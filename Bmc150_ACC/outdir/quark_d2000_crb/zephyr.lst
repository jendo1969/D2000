
zephyr.elf:     ファイル形式 elf32-iamcu


セクション text の逆アセンブル:

00180000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  180000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  180003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  180008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  18000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  18000c:	0f 01 1d 4c 00 18 00 	lidtl  0x18004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  180013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  180016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  180019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
  18001c:	bc e0 02 28 00       	mov    $0x2802e0,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  180021:	81 c4 00 01 00 00    	add    $0x100,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
  180027:	bf 00 00 28 00       	mov    $0x280000,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
  18002c:	be 48 51 18 00       	mov    $0x185148,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
  180031:	b9 29 00 00 00       	mov    $0x29,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
  180036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  180038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  18003a:	bf c0 00 28 00       	mov    $0x2800c0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  18003f:	b9 88 00 00 00       	mov    $0x88,%ecx
	cld
  180044:	fc                   	cld    
	rep
  180045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  180047:	e9 08 2f 00 00       	jmp    182f54 <_Cstart>

0018004c <_Idt>:
  18004c:	ff 01 48 4f 18 00 66 90 66 90 66 90 66 90 66 90     ..HO..f.f.f.f.f.
  18005c:	66 90 66 90                                         f.f.

00180060 <_thread_entry_wrapper>:
  180060:	58                   	pop    %eax
  180061:	5a                   	pop    %edx
  180062:	59                   	pop    %ecx
  180063:	6a 00                	push   $0x0
  180065:	e9 5d 3b 00 00       	jmp    183bc7 <_thread_entry>

0018006a <write_register>:
	}
	return 0;
}

static int write_register(uint16_t addr, uint8_t reg, uint8_t data)
{
  18006a:	56                   	push   %esi
  18006b:	53                   	push   %ebx
  18006c:	83 ec 10             	sub    $0x10,%esp
  18006f:	89 c3                	mov    %eax,%ebx
	int8_t data1[2];

	data1[0] = reg;
  180071:	88 54 24 0e          	mov    %dl,0xe(%esp)
	data1[1] = data;
  180075:	88 4c 24 0f          	mov    %cl,0xf(%esp)
	if (i2c_write(i2c_dev, &data1, sizeof(data1), addr) != 0)
  180079:	a1 68 02 28 00       	mov    0x280268,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  18007e:	8b 70 04             	mov    0x4(%eax),%esi
	struct i2c_msg msg;

	msg.buf = buf;
  180081:	8d 54 24 0e          	lea    0xe(%esp),%edx
  180085:	89 14 24             	mov    %edx,(%esp)
	msg.len = num_bytes;
  180088:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  18008f:	00 
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  180090:	c6 44 24 08 02       	movb   $0x2,0x8(%esp)

	return api->transfer(dev, &msg, 1, addr);
  180095:	0f b7 db             	movzwl %bx,%ebx
  180098:	53                   	push   %ebx
  180099:	b9 01 00 00 00       	mov    $0x1,%ecx
  18009e:	8d 54 24 04          	lea    0x4(%esp),%edx
  1800a2:	ff 56 04             	call   *0x4(%esi)
  1800a5:	83 c4 04             	add    $0x4,%esp
  1800a8:	85 c0                	test   %eax,%eax
  1800aa:	74 12                	je     1800be <write_register+0x54>
	{
		printk("Error on i2c_write()\n");
  1800ac:	68 40 47 18 00       	push   $0x184740
  1800b1:	e8 29 1c 00 00       	call   181cdf <printk>
  1800b6:	83 c4 04             	add    $0x4,%esp
		return 1;
  1800b9:	b8 01 00 00 00       	mov    $0x1,%eax
	}
	return 0;
}
  1800be:	83 c4 10             	add    $0x10,%esp
  1800c1:	5b                   	pop    %ebx
  1800c2:	5e                   	pop    %esi
  1800c3:	c3                   	ret    

001800c4 <write_Acc_range>:
	temp_val = ((float)data) / 2 + 23;
}

static void write_Acc_range(uint8_t data)
{
	if (write_register(BMC150_I2C_ADDR, ACCELEROMTER_RANGE, data) != 0)
  1800c4:	0f b6 c8             	movzbl %al,%ecx
  1800c7:	ba 0f 00 00 00       	mov    $0xf,%edx
  1800cc:	b8 10 00 00 00       	mov    $0x10,%eax
  1800d1:	e8 94 ff ff ff       	call   18006a <write_register>
  1800d6:	85 c0                	test   %eax,%eax
  1800d8:	74 0d                	je     1800e7 <write_Acc_range+0x23>
	{
		printk("Error on i2c_write()\n");
  1800da:	68 40 47 18 00       	push   $0x184740
  1800df:	e8 fb 1b 00 00       	call   181cdf <printk>
  1800e4:	83 c4 04             	add    $0x4,%esp
  1800e7:	c3                   	ret    

001800e8 <write_Acc_bandwidth>:
}


static void write_Acc_bandwidth(uint8_t data)
{
	if (write_register(BMC150_I2C_ADDR, ACCELEROMTER_BANDWIDTH, data) != 0)
  1800e8:	0f b6 c8             	movzbl %al,%ecx
  1800eb:	ba 10 00 00 00       	mov    $0x10,%edx
  1800f0:	b8 10 00 00 00       	mov    $0x10,%eax
  1800f5:	e8 70 ff ff ff       	call   18006a <write_register>
  1800fa:	85 c0                	test   %eax,%eax
  1800fc:	74 0d                	je     18010b <write_Acc_bandwidth+0x23>
	{
		printk("Error on i2c_write()\n");
  1800fe:	68 40 47 18 00       	push   $0x184740
  180103:	e8 d7 1b 00 00       	call   181cdf <printk>
  180108:	83 c4 04             	add    $0x4,%esp
  18010b:	c3                   	ret    

0018010c <read_register>:

	return 0;
}

static int read_register(uint16_t addr, uint8_t reg, uint8_t *const data, uint32_t len)
{
  18010c:	55                   	push   %ebp
  18010d:	57                   	push   %edi
  18010e:	56                   	push   %esi
  18010f:	53                   	push   %ebx
  180110:	83 ec 10             	sub    $0x10,%esp
  180113:	89 cf                	mov    %ecx,%edi
  180115:	88 14 24             	mov    %dl,(%esp)
	if (i2c_write(i2c_dev, &reg, 1, addr) != 0) {
  180118:	8b 35 68 02 28 00    	mov    0x280268,%esi
 * @retval -EIO General input / output error.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  18011e:	8b 6e 04             	mov    0x4(%esi),%ebp
	struct i2c_msg msg;

	msg.buf = buf;
  180121:	89 64 24 04          	mov    %esp,0x4(%esp)
	msg.len = num_bytes;
  180125:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  18012c:	00 
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  18012d:	c6 44 24 0c 02       	movb   $0x2,0xc(%esp)

	return api->transfer(dev, &msg, 1, addr);
  180132:	0f b7 d8             	movzwl %ax,%ebx
  180135:	53                   	push   %ebx
  180136:	b9 01 00 00 00       	mov    $0x1,%ecx
  18013b:	8d 54 24 08          	lea    0x8(%esp),%edx
  18013f:	89 f0                	mov    %esi,%eax
  180141:	ff 55 04             	call   *0x4(%ebp)
  180144:	83 c4 04             	add    $0x4,%esp
  180147:	85 c0                	test   %eax,%eax
  180149:	74 14                	je     18015f <read_register+0x53>
		printk("Error on i2c_write()\n");
  18014b:	68 40 47 18 00       	push   $0x184740
  180150:	e8 8a 1b 00 00       	call   181cdf <printk>
  180155:	83 c4 04             	add    $0x4,%esp
		return 1;
  180158:	b8 01 00 00 00       	mov    $0x1,%eax
  18015d:	eb 3f                	jmp    18019e <read_register+0x92>
	}

	if (i2c_read(i2c_dev, data, len, addr) != 0) {
  18015f:	a1 68 02 28 00       	mov    0x280268,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_read(struct device *dev, uint8_t *buf,
			   uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  180164:	8b 70 04             	mov    0x4(%eax),%esi
	struct i2c_msg msg;

	msg.buf = buf;
  180167:	89 7c 24 04          	mov    %edi,0x4(%esp)
	msg.len = num_bytes;
  18016b:	8b 54 24 24          	mov    0x24(%esp),%edx
  18016f:	89 54 24 08          	mov    %edx,0x8(%esp)
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
  180173:	c6 44 24 0c 03       	movb   $0x3,0xc(%esp)

	return api->transfer(dev, &msg, 1, addr);
  180178:	53                   	push   %ebx
  180179:	b9 01 00 00 00       	mov    $0x1,%ecx
  18017e:	8d 54 24 08          	lea    0x8(%esp),%edx
  180182:	ff 56 04             	call   *0x4(%esi)
  180185:	83 c4 04             	add    $0x4,%esp
  180188:	85 c0                	test   %eax,%eax
  18018a:	74 12                	je     18019e <read_register+0x92>
		printk("Error on i2c_read()\n");
  18018c:	68 56 47 18 00       	push   $0x184756
  180191:	e8 49 1b 00 00       	call   181cdf <printk>
  180196:	83 c4 04             	add    $0x4,%esp
		return 1;
  180199:	b8 01 00 00 00       	mov    $0x1,%eax
	}
	return 0;
}
  18019e:	83 c4 10             	add    $0x10,%esp
  1801a1:	5b                   	pop    %ebx
  1801a2:	5e                   	pop    %esi
  1801a3:	5f                   	pop    %edi
  1801a4:	5d                   	pop    %ebp
  1801a5:	c3                   	ret    

001801a6 <read_Temperature>:
	return 0;
}


static void read_Temperature()
{
  1801a6:	83 ec 04             	sub    $0x4,%esp
	int8_t data;

	if (read_register(BMC150_I2C_ADDR, ACCD_TEMP_REG, &data, 1)!= 0)
  1801a9:	6a 01                	push   $0x1
  1801ab:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  1801af:	ba 08 00 00 00       	mov    $0x8,%edx
  1801b4:	b8 10 00 00 00       	mov    $0x10,%eax
  1801b9:	e8 4e ff ff ff       	call   18010c <read_register>
  1801be:	83 c4 04             	add    $0x4,%esp
  1801c1:	85 c0                	test   %eax,%eax
  1801c3:	74 0c                	je     1801d1 <read_Temperature+0x2b>
	{
		temp_val = 999;
  1801c5:	c7 05 d4 00 28 00 00 	movl   $0x4479c000,0x2800d4
  1801cc:	c0 79 44 
  1801cf:	eb 23                	jmp    1801f4 <read_Temperature+0x4e>
		return;
	}
	temp_val = ((float)data) / 2 + 23;
  1801d1:	0f be 44 24 03       	movsbl 0x3(%esp),%eax
  1801d6:	e8 b1 42 00 00       	call   18448c <__floatsisf>
  1801db:	ba 00 00 00 3f       	mov    $0x3f000000,%edx
  1801e0:	e8 5e 40 00 00       	call   184243 <__mulsf3>
  1801e5:	ba 00 00 b8 41       	mov    $0x41b80000,%edx
  1801ea:	e8 43 3c 00 00       	call   183e32 <__addsf3>
  1801ef:	a3 d4 00 28 00       	mov    %eax,0x2800d4
}
  1801f4:	83 c4 04             	add    $0x4,%esp
  1801f7:	c3                   	ret    

001801f8 <read_Accelerometer>:
		printk("Error on i2c_write()\n");
		return;
	}
}
static void read_Accelerometer()
{
  1801f8:	53                   	push   %ebx
  1801f9:	83 ec 14             	sub    $0x14,%esp
	int8_t reg;
	int8_t data[6];
	int16_t lsb, msb;

	reg = DATA_ACC_X_LSB;
  1801fc:	c6 44 24 13 02       	movb   $0x2,0x13(%esp)
	if (i2c_write(i2c_dev, &reg, 1, BMC150_I2C_ADDR) != 0) {
  180201:	a1 68 02 28 00       	mov    0x280268,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  180206:	8b 58 04             	mov    0x4(%eax),%ebx
	struct i2c_msg msg;

	msg.buf = buf;
  180209:	8d 54 24 13          	lea    0x13(%esp),%edx
  18020d:	89 14 24             	mov    %edx,(%esp)
	msg.len = num_bytes;
  180210:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  180217:	00 
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  180218:	c6 44 24 08 02       	movb   $0x2,0x8(%esp)

	return api->transfer(dev, &msg, 1, addr);
  18021d:	6a 10                	push   $0x10
  18021f:	b9 01 00 00 00       	mov    $0x1,%ecx
  180224:	8d 54 24 04          	lea    0x4(%esp),%edx
  180228:	ff 53 04             	call   *0x4(%ebx)
  18022b:	83 c4 04             	add    $0x4,%esp
  18022e:	85 c0                	test   %eax,%eax
  180230:	74 12                	je     180244 <read_Accelerometer+0x4c>
		printk("Error on i2c_write()\n");
  180232:	68 40 47 18 00       	push   $0x184740
  180237:	e8 a3 1a 00 00       	call   181cdf <printk>
  18023c:	83 c4 04             	add    $0x4,%esp
		return;
  18023f:	e9 e5 00 00 00       	jmp    180329 <read_Accelerometer+0x131>
	}

	if (i2c_read(i2c_dev, data, 6, BMC150_I2C_ADDR) != 0) {
  180244:	a1 68 02 28 00       	mov    0x280268,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_read(struct device *dev, uint8_t *buf,
			   uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  180249:	8b 58 04             	mov    0x4(%eax),%ebx
	struct i2c_msg msg;

	msg.buf = buf;
  18024c:	8d 54 24 0d          	lea    0xd(%esp),%edx
  180250:	89 14 24             	mov    %edx,(%esp)
	msg.len = num_bytes;
  180253:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)
  18025a:	00 
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
  18025b:	c6 44 24 08 03       	movb   $0x3,0x8(%esp)

	return api->transfer(dev, &msg, 1, addr);
  180260:	6a 10                	push   $0x10
  180262:	b9 01 00 00 00       	mov    $0x1,%ecx
  180267:	8d 54 24 04          	lea    0x4(%esp),%edx
  18026b:	ff 53 04             	call   *0x4(%ebx)
  18026e:	83 c4 04             	add    $0x4,%esp
  180271:	85 c0                	test   %eax,%eax
  180273:	74 12                	je     180287 <read_Accelerometer+0x8f>
		printk("Error on i2c_read()\n");
  180275:	68 56 47 18 00       	push   $0x184756
  18027a:	e8 60 1a 00 00       	call   181cdf <printk>
  18027f:	83 c4 04             	add    $0x4,%esp
		return;
  180282:	e9 a2 00 00 00       	jmp    180329 <read_Accelerometer+0x131>
	}

	lsb = data[0];
  180287:	66 0f be 54 24 0d    	movsbw 0xd(%esp),%dx
	msb = data[1];
	msb <<= 8;
  18028d:	0f be 44 24 0e       	movsbl 0xe(%esp),%eax
  180292:	c1 e0 08             	shl    $0x8,%eax
	acc_x = (msb | lsb) >> 4;
  180295:	09 d0                	or     %edx,%eax
  180297:	66 c1 f8 04          	sar    $0x4,%ax
  18029b:	66 a3 c4 00 28 00    	mov    %ax,0x2800c4
	acc_x_val = ((float)acc_x) * 2 / 4096;
  1802a1:	98                   	cwtl   
  1802a2:	e8 e5 41 00 00       	call   18448c <__floatsisf>
  1802a7:	89 c2                	mov    %eax,%edx
  1802a9:	e8 84 3b 00 00       	call   183e32 <__addsf3>
  1802ae:	ba 00 00 80 39       	mov    $0x39800000,%edx
  1802b3:	e8 8b 3f 00 00       	call   184243 <__mulsf3>
  1802b8:	a3 d0 00 28 00       	mov    %eax,0x2800d0

	lsb = data[2];
  1802bd:	66 0f be 54 24 0f    	movsbw 0xf(%esp),%dx
	msb = data[3];
	msb <<= 8;
  1802c3:	0f be 44 24 10       	movsbl 0x10(%esp),%eax
  1802c8:	c1 e0 08             	shl    $0x8,%eax
	acc_y = (msb | lsb) >> 4;
  1802cb:	09 d0                	or     %edx,%eax
  1802cd:	66 c1 f8 04          	sar    $0x4,%ax
  1802d1:	66 a3 c2 00 28 00    	mov    %ax,0x2800c2
	acc_y_val = ((float)acc_y) * 2 / 4096;
  1802d7:	98                   	cwtl   
  1802d8:	e8 af 41 00 00       	call   18448c <__floatsisf>
  1802dd:	89 c2                	mov    %eax,%edx
  1802df:	e8 4e 3b 00 00       	call   183e32 <__addsf3>
  1802e4:	ba 00 00 80 39       	mov    $0x39800000,%edx
  1802e9:	e8 55 3f 00 00       	call   184243 <__mulsf3>
  1802ee:	a3 cc 00 28 00       	mov    %eax,0x2800cc

	lsb = data[4];
  1802f3:	66 0f be 54 24 11    	movsbw 0x11(%esp),%dx
	msb = data[5];
	msb <<= 8;
  1802f9:	0f be 44 24 12       	movsbl 0x12(%esp),%eax
  1802fe:	c1 e0 08             	shl    $0x8,%eax
	acc_z = (msb | lsb) >> 4;
  180301:	09 d0                	or     %edx,%eax
  180303:	66 c1 f8 04          	sar    $0x4,%ax
  180307:	66 a3 c0 00 28 00    	mov    %ax,0x2800c0
	acc_z_val = ((float)acc_z) * 2 / 4096;
  18030d:	98                   	cwtl   
  18030e:	e8 79 41 00 00       	call   18448c <__floatsisf>
  180313:	89 c2                	mov    %eax,%edx
  180315:	e8 18 3b 00 00       	call   183e32 <__addsf3>
  18031a:	ba 00 00 80 39       	mov    $0x39800000,%edx
  18031f:	e8 1f 3f 00 00       	call   184243 <__mulsf3>
  180324:	a3 c8 00 28 00       	mov    %eax,0x2800c8
}
  180329:	83 c4 14             	add    $0x14,%esp
  18032c:	5b                   	pop    %ebx
  18032d:	c3                   	ret    

0018032e <i2c_init>:
	cfg.raw = 0;
	cfg.bits.use_10_bit_addr = 0;
	cfg.bits.speed = I2C_SPEED_STANDARD;
	cfg.bits.is_master_device = 1;

	i2c_dev = device_get_binding("I2C_0");
  18032e:	b8 6b 47 18 00       	mov    $0x18476b,%eax
  180333:	e8 aa 2a 00 00       	call   182de2 <device_get_binding>
  180338:	a3 68 02 28 00       	mov    %eax,0x280268
	if (!i2c_dev) {
  18033d:	85 c0                	test   %eax,%eax
  18033f:	75 13                	jne    180354 <i2c_init+0x26>
		printk("I2C0: Device not found.\n");
  180341:	68 71 47 18 00       	push   $0x184771
  180346:	e8 94 19 00 00       	call   181cdf <printk>
  18034b:	83 c4 04             	add    $0x4,%esp
		return -1;
  18034e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  180353:	c3                   	ret    
 * @retval 0 If successful.
 * @retval -EIO General input / output error, failed to configure device.
 */
static inline int i2c_configure(struct device *dev, uint32_t dev_config)
{
	const struct i2c_driver_api *api = dev->driver_api;
  180354:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->configure(dev, dev_config);
  180357:	ba 12 00 00 00       	mov    $0x12,%edx
  18035c:	ff 11                	call   *(%ecx)
	}

	if (i2c_configure(i2c_dev, cfg.raw) != 0) {
  18035e:	85 c0                	test   %eax,%eax
  180360:	74 12                	je     180374 <i2c_init+0x46>
		printk("Error on i2c_configure()\n");
  180362:	68 8a 47 18 00       	push   $0x18478a
  180367:	e8 73 19 00 00       	call   181cdf <printk>
  18036c:	83 c4 04             	add    $0x4,%esp
		return -1;
  18036f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return 0;
}
  180374:	c3                   	ret    

00180375 <main>:
	acc_z = (msb | lsb) >> 4;
	acc_z_val = ((float)acc_z) * 2 / 4096;
}

void main(void)
{
  180375:	53                   	push   %ebx
  180376:	83 ec 40             	sub    $0x40,%esp
	uint8_t buf[64];

	printk("Start I2C BMC150 sample\n");
  180379:	68 a4 47 18 00       	push   $0x1847a4
  18037e:	e8 5c 19 00 00       	call   181cdf <printk>
  180383:	83 c4 04             	add    $0x4,%esp

	i2c_init();
  180386:	e8 a3 ff ff ff       	call   18032e <i2c_init>


	write_Acc_range(ACCELEROMETER_RANGE_2G);
  18038b:	b8 03 00 00 00       	mov    $0x3,%eax
  180390:	e8 2f fd ff ff       	call   1800c4 <write_Acc_range>
	write_Acc_bandwidth(ACCELEROMTER_BANDWIDTH_64MS);
  180395:	b8 08 00 00 00       	mov    $0x8,%eax
  18039a:	e8 49 fd ff ff       	call   1800e8 <write_Acc_bandwidth>

	while (1) {
		read_Temperature();
  18039f:	e8 02 fe ff ff       	call   1801a6 <read_Temperature>
		read_Accelerometer();
  1803a4:	e8 4f fe ff ff       	call   1801f8 <read_Accelerometer>
		sprintf(buf, "(t,x,y,z)=(%4.1f,%+04d,%+04d,%+04d)\n", temp_val, acc_x, acc_y, acc_z);
  1803a9:	0f bf 05 c0 00 28 00 	movswl 0x2800c0,%eax
  1803b0:	50                   	push   %eax
  1803b1:	0f bf 05 c2 00 28 00 	movswl 0x2800c2,%eax
  1803b8:	50                   	push   %eax
  1803b9:	0f bf 05 c4 00 28 00 	movswl 0x2800c4,%eax
  1803c0:	50                   	push   %eax
  1803c1:	a1 d4 00 28 00       	mov    0x2800d4,%eax
  1803c6:	e8 78 41 00 00       	call   184543 <__extendsfdf2>
  1803cb:	52                   	push   %edx
  1803cc:	50                   	push   %eax
  1803cd:	68 c0 47 18 00       	push   $0x1847c0
  1803d2:	8d 5c 24 18          	lea    0x18(%esp),%ebx
  1803d6:	53                   	push   %ebx
  1803d7:	e8 d3 14 00 00       	call   1818af <sprintf>
  1803dc:	83 c4 1c             	add    $0x1c,%esp
		printk(buf);
  1803df:	53                   	push   %ebx
  1803e0:	e8 fa 18 00 00       	call   181cdf <printk>
  1803e5:	83 c4 04             	add    $0x4,%esp

		k_sleep(500);
  1803e8:	b8 f4 01 00 00       	mov    $0x1f4,%eax
  1803ed:	e8 0a 2f 00 00       	call   1832fc <k_sleep>
  1803f2:	eb ab                	jmp    18039f <main+0x2a>

001803f4 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1803f4:	53                   	push   %ebx
  1803f5:	89 c3                	mov    %eax,%ebx
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  1803f7:	83 f8 0a             	cmp    $0xa,%eax
  1803fa:	75 10                	jne    18040c <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
  1803fc:	a1 d8 00 28 00       	mov    0x2800d8,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  180401:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  180404:	ba 0d 00 00 00       	mov    $0xd,%edx
  180409:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
  18040c:	a1 d8 00 28 00       	mov    0x2800d8,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  180411:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  180414:	0f b6 d3             	movzbl %bl,%edx
  180417:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
  18041a:	89 d8                	mov    %ebx,%eax
  18041c:	5b                   	pop    %ebx
  18041d:	c3                   	ret    

0018041e <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
  18041e:	b8 f4 03 18 00       	mov    $0x1803f4,%eax
  180423:	e8 c4 16 00 00       	call   181aec <__printk_hook_install>
  180428:	c3                   	ret    

00180429 <uart_console_init>:
static int uart_console_init(struct device *arg)
{

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  180429:	b8 e5 47 18 00       	mov    $0x1847e5,%eax
  18042e:	e8 af 29 00 00       	call   182de2 <device_get_binding>
  180433:	a3 d8 00 28 00       	mov    %eax,0x2800d8
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  180438:	e8 e1 ff ff ff       	call   18041e <uart_console_hook_install>

	return 0;
}
  18043d:	b8 00 00 00 00       	mov    $0x0,%eax
  180442:	c3                   	ret    

00180443 <is_tx_fifo_full>:
}

#if CONFIG_UART_INTERRUPT_DRIVEN
static bool is_tx_fifo_full(qm_uart_t instance)
{
	return !!(QM_UART[instance]->lsr & QM_UART_LSR_THRE);
  180443:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
  18044a:	8b 40 14             	mov    0x14(%eax),%eax
  18044d:	a8 20                	test   $0x20,%al
  18044f:	0f 95 c0             	setne  %al
}
  180452:	c3                   	ret    

00180453 <is_data_ready>:
	return i;
}

static bool is_data_ready(qm_uart_t instance)
{
	return QM_UART[instance]->lsr & QM_UART_LSR_DR;
  180453:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
  18045a:	8b 40 14             	mov    0x14(%eax),%eax
  18045d:	83 e0 01             	and    $0x1,%eax
}
  180460:	c3                   	ret    

00180461 <uart_qmsi_irq_tx_enable>:
	return i;
}

static void uart_qmsi_irq_tx_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180461:	8b 00                	mov    (%eax),%eax
  180463:	8b 40 08             	mov    0x8(%eax),%eax
  180466:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ETBEI;
  180468:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  18046f:	8b 42 04             	mov    0x4(%edx),%eax
  180472:	83 c8 02             	or     $0x2,%eax
  180475:	89 42 04             	mov    %eax,0x4(%edx)
  180478:	c3                   	ret    

00180479 <uart_qmsi_irq_tx_disable>:
}

static void uart_qmsi_irq_tx_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180479:	8b 00                	mov    (%eax),%eax
  18047b:	8b 40 08             	mov    0x8(%eax),%eax
  18047e:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ETBEI;
  180480:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  180487:	8b 42 04             	mov    0x4(%edx),%eax
  18048a:	83 e0 fd             	and    $0xfffffffd,%eax
  18048d:	89 42 04             	mov    %eax,0x4(%edx)
  180490:	c3                   	ret    

00180491 <uart_qmsi_irq_tx_ready>:
}

static int uart_qmsi_irq_tx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180491:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  180494:	8a 40 04             	mov    0x4(%eax),%al

	return id == QM_UART_IIR_THR_EMPTY;
  180497:	83 e0 0f             	and    $0xf,%eax
  18049a:	3c 02                	cmp    $0x2,%al
  18049c:	0f 94 c0             	sete   %al
  18049f:	0f b6 c0             	movzbl %al,%eax
}
  1804a2:	c3                   	ret    

001804a3 <uart_qmsi_irq_tx_empty>:

static int uart_qmsi_irq_tx_empty(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1804a3:	8b 00                	mov    (%eax),%eax
  1804a5:	8b 40 08             	mov    0x8(%eax),%eax
  1804a8:	8b 00                	mov    (%eax),%eax
	const uint32_t mask = (QM_UART_LSR_TEMT | QM_UART_LSR_THRE);

	return (QM_UART[instance]->lsr & mask) == mask;
  1804aa:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
  1804b1:	8b 40 14             	mov    0x14(%eax),%eax
  1804b4:	83 e0 60             	and    $0x60,%eax
  1804b7:	83 f8 60             	cmp    $0x60,%eax
  1804ba:	0f 94 c0             	sete   %al
  1804bd:	0f b6 c0             	movzbl %al,%eax
}
  1804c0:	c3                   	ret    

001804c1 <uart_qmsi_irq_rx_enable>:

static void uart_qmsi_irq_rx_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1804c1:	8b 00                	mov    (%eax),%eax
  1804c3:	8b 40 08             	mov    0x8(%eax),%eax
  1804c6:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ERBFI;
  1804c8:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  1804cf:	8b 42 04             	mov    0x4(%edx),%eax
  1804d2:	83 c8 01             	or     $0x1,%eax
  1804d5:	89 42 04             	mov    %eax,0x4(%edx)
  1804d8:	c3                   	ret    

001804d9 <uart_qmsi_irq_rx_disable>:
}

static void uart_qmsi_irq_rx_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1804d9:	8b 00                	mov    (%eax),%eax
  1804db:	8b 40 08             	mov    0x8(%eax),%eax
  1804de:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ERBFI;
  1804e0:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  1804e7:	8b 42 04             	mov    0x4(%edx),%eax
  1804ea:	83 e0 fe             	and    $0xfffffffe,%eax
  1804ed:	89 42 04             	mov    %eax,0x4(%edx)
  1804f0:	c3                   	ret    

001804f1 <uart_qmsi_irq_rx_ready>:
}

static int uart_qmsi_irq_rx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  1804f1:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  1804f4:	8a 50 04             	mov    0x4(%eax),%dl
  1804f7:	83 e2 0f             	and    $0xf,%edx

	return (id == QM_UART_IIR_RECV_DATA_AVAIL) ||
  1804fa:	83 fa 04             	cmp    $0x4,%edx
  1804fd:	0f 94 c1             	sete   %cl
	       (id == QM_UART_IIR_CHAR_TIMEOUT);
  180500:	83 fa 0c             	cmp    $0xc,%edx
  180503:	0f 94 c0             	sete   %al
static int uart_qmsi_irq_rx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);

	return (id == QM_UART_IIR_RECV_DATA_AVAIL) ||
  180506:	09 c8                	or     %ecx,%eax
  180508:	0f b6 c0             	movzbl %al,%eax
	       (id == QM_UART_IIR_CHAR_TIMEOUT);
}
  18050b:	c3                   	ret    

0018050c <uart_qmsi_irq_err_enable>:

static void uart_qmsi_irq_err_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18050c:	8b 00                	mov    (%eax),%eax
  18050e:	8b 40 08             	mov    0x8(%eax),%eax
  180511:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ELSI;
  180513:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  18051a:	8b 42 04             	mov    0x4(%edx),%eax
  18051d:	83 c8 04             	or     $0x4,%eax
  180520:	89 42 04             	mov    %eax,0x4(%edx)
  180523:	c3                   	ret    

00180524 <uart_qmsi_irq_err_disable>:
}

static void uart_qmsi_irq_err_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180524:	8b 00                	mov    (%eax),%eax
  180526:	8b 40 08             	mov    0x8(%eax),%eax
  180529:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ELSI;
  18052b:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  180532:	8b 42 04             	mov    0x4(%edx),%eax
  180535:	83 e0 fb             	and    $0xfffffffb,%eax
  180538:	89 42 04             	mov    %eax,0x4(%edx)
  18053b:	c3                   	ret    

0018053c <uart_qmsi_irq_is_pending>:
}

static int uart_qmsi_irq_is_pending(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  18053c:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  18053f:	8a 40 04             	mov    0x4(%eax),%al

	return !(id == IIR_IID_NO_INTERRUPT_PENDING);
  180542:	83 e0 0f             	and    $0xf,%eax
  180545:	3c 01                	cmp    $0x1,%al
  180547:	0f 95 c0             	setne  %al
  18054a:	0f b6 c0             	movzbl %al,%eax
}
  18054d:	c3                   	ret    

0018054e <uart_qmsi_irq_update>:

static int uart_qmsi_irq_update(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18054e:	8b 10                	mov    (%eax),%edx
  180550:	8b 52 08             	mov    0x8(%edx),%edx
  180553:	8b 12                	mov    (%edx),%edx
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180555:	8b 40 08             	mov    0x8(%eax),%eax

	drv_data->iir_cache = QM_UART[instance]->iir_fcr;
  180558:	8b 14 95 1c 00 28 00 	mov    0x28001c(,%edx,4),%edx
  18055f:	8b 52 08             	mov    0x8(%edx),%edx
  180562:	88 50 04             	mov    %dl,0x4(%eax)
	return 1;
}
  180565:	b8 01 00 00 00       	mov    $0x1,%eax
  18056a:	c3                   	ret    

0018056b <uart_qmsi_irq_callback_set>:

static void uart_qmsi_irq_callback_set(struct device *dev,
				       uart_irq_callback_t cb)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  18056b:	8b 40 08             	mov    0x8(%eax),%eax

	drv_data->user_cb = cb;
  18056e:	89 10                	mov    %edx,(%eax)
  180570:	c3                   	ret    

00180571 <uart_qmsi_isr>:
}

static void uart_qmsi_isr(void *arg)
{
  180571:	53                   	push   %ebx
  180572:	89 c3                	mov    %eax,%ebx
	struct device *dev = arg;
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180574:	8b 40 08             	mov    0x8(%eax),%eax

	if (drv_data->user_cb)
  180577:	8b 10                	mov    (%eax),%edx
  180579:	85 d2                	test   %edx,%edx
  18057b:	74 04                	je     180581 <uart_qmsi_isr+0x10>
		drv_data->user_cb(dev);
  18057d:	89 d8                	mov    %ebx,%eax
  18057f:	ff d2                	call   *%edx

	device_busy_clear(dev);
  180581:	89 d8                	mov    %ebx,%eax
  180583:	e8 92 28 00 00       	call   182e1a <device_busy_clear>
}
  180588:	5b                   	pop    %ebx
  180589:	c3                   	ret    

0018058a <irq_config_func_0>:
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  18058a:	b9 00 80 00 00       	mov    $0x8000,%ecx
  18058f:	ba 08 00 00 00       	mov    $0x8,%edx
  180594:	b8 28 00 00 00       	mov    $0x28,%eax
  180599:	e8 b1 02 00 00       	call   18084f <__irq_controller_irq_config>
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT),
		    CONFIG_UART_QMSI_0_IRQ_PRI, uart_qmsi_isr,
		    DEVICE_GET(uart_0), UART_IRQ_FLAGS);
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT));
  18059e:	b8 08 00 00 00       	mov    $0x8,%eax
  1805a3:	e8 82 02 00 00       	call   18082a <_arch_irq_enable>
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->uart_0_int_mask);
  1805a8:	a1 60 04 80 b0       	mov    0xb0800460,%eax
  1805ad:	83 e0 fe             	and    $0xfffffffe,%eax
  1805b0:	a3 60 04 80 b0       	mov    %eax,0xb0800460
  1805b5:	c3                   	ret    

001805b6 <uart_qmsi_isr_irq8_stub>:
#ifdef CONFIG_UART_QMSI_0
static void irq_config_func_0(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT),
  1805b6:	68 5c 00 28 00       	push   $0x28005c
  1805bb:	68 71 05 18 00       	push   $0x180571
  1805c0:	e9 a1 24 00 00       	jmp    182a66 <_interrupt_enter>

001805c5 <uart_qmsi_isr_irq6_stub>:
#ifdef CONFIG_UART_QMSI_1
static void irq_config_func_1(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_1_INT),
  1805c5:	68 50 00 28 00       	push   $0x280050
  1805ca:	68 71 05 18 00       	push   $0x180571
  1805cf:	e9 92 24 00 00       	jmp    182a66 <_interrupt_enter>

001805d4 <_timer_int_handler_irq10_stub>:
  1805d4:	6a 00                	push   $0x0
  1805d6:	68 4e 07 18 00       	push   $0x18074e
  1805db:	e9 86 24 00 00       	jmp    182a66 <_interrupt_enter>

001805e0 <qm_i2c_0_irq_isr_irq4_stub>:
  1805e0:	6a 00                	push   $0x0
  1805e2:	68 ba 24 18 00       	push   $0x1824ba
  1805e7:	e9 7a 24 00 00       	jmp    182a66 <_interrupt_enter>

001805ec <irq_config_func_1>:
  1805ec:	b9 00 80 00 00       	mov    $0x8000,%ecx
  1805f1:	ba 06 00 00 00       	mov    $0x6,%edx
  1805f6:	b8 26 00 00 00       	mov    $0x26,%eax
  1805fb:	e8 4f 02 00 00       	call   18084f <__irq_controller_irq_config>
		    CONFIG_UART_QMSI_1_IRQ_PRI, uart_qmsi_isr,
		    DEVICE_GET(uart_1), UART_IRQ_FLAGS);
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_UART_1_INT));
  180600:	b8 06 00 00 00       	mov    $0x6,%eax
  180605:	e8 20 02 00 00       	call   18082a <_arch_irq_enable>
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->uart_1_int_mask);
  18060a:	a1 64 04 80 b0       	mov    0xb0800464,%eax
  18060f:	83 e0 fe             	and    $0xfffffffe,%eax
  180612:	a3 64 04 80 b0       	mov    %eax,0xb0800464
  180617:	c3                   	ret    

00180618 <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
  180618:	56                   	push   %esi
  180619:	53                   	push   %ebx
  18061a:	83 ec 0c             	sub    $0xc,%esp
  18061d:	89 c6                	mov    %eax,%esi
	const struct uart_qmsi_config_info *config = dev->config->config_info;
  18061f:	8b 00                	mov    (%eax),%eax
  180621:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
  180624:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
	cfg.baud_divisor = config->baud_divisor;
  18062b:	8b 43 08             	mov    0x8(%ebx),%eax
  18062e:	89 44 24 04          	mov    %eax,0x4(%esp)
	cfg.hw_fc = config->hw_fc;
  180632:	8a 43 0c             	mov    0xc(%ebx),%al
  180635:	88 44 24 08          	mov    %al,0x8(%esp)

	clk_periph_enable(config->clock_gate);
  180639:	8b 43 04             	mov    0x4(%ebx),%eax
  18063c:	e8 13 17 00 00       	call   181d54 <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
  180641:	89 e2                	mov    %esp,%edx
  180643:	8b 03                	mov    (%ebx),%eax
  180645:	e8 de 20 00 00       	call   182728 <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
  18064a:	89 f0                	mov    %esi,%eax
  18064c:	ff 53 10             	call   *0x10(%ebx)
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
  18064f:	c7 46 04 20 48 18 00 	movl   $0x184820,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  180656:	b8 00 00 00 00       	mov    $0x0,%eax
  18065b:	83 c4 0c             	add    $0xc,%esp
  18065e:	5b                   	pop    %ebx
  18065f:	5e                   	pop    %esi
  180660:	c3                   	ret    

00180661 <uart_qmsi_fifo_read>:
	return QM_UART[instance]->lsr & QM_UART_LSR_DR;
}

static int uart_qmsi_fifo_read(struct device *dev, uint8_t *rx_data,
				  const int size)
{
  180661:	55                   	push   %ebp
  180662:	57                   	push   %edi
  180663:	56                   	push   %esi
  180664:	53                   	push   %ebx
  180665:	89 d5                	mov    %edx,%ebp
  180667:	89 cf                	mov    %ecx,%edi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180669:	8b 10                	mov    (%eax),%edx
  18066b:	8b 52 08             	mov    0x8(%edx),%edx
  18066e:	8b 32                	mov    (%edx),%esi
	int i;

	device_busy_set(dev);
  180670:	e8 a4 27 00 00       	call   182e19 <device_busy_set>

	for (i = 0; i < size && is_data_ready(instance); i++) {
  180675:	bb 00 00 00 00       	mov    $0x0,%ebx
  18067a:	eb 0e                	jmp    18068a <uart_qmsi_fifo_read+0x29>
		rx_data[i] = QM_UART[instance]->rbr_thr_dll;
  18067c:	8b 04 b5 1c 00 28 00 	mov    0x28001c(,%esi,4),%eax
  180683:	8b 00                	mov    (%eax),%eax
  180685:	88 44 1d 00          	mov    %al,0x0(%ebp,%ebx,1)
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
	int i;

	device_busy_set(dev);

	for (i = 0; i < size && is_data_ready(instance); i++) {
  180689:	43                   	inc    %ebx
  18068a:	39 fb                	cmp    %edi,%ebx
  18068c:	7d 0b                	jge    180699 <uart_qmsi_fifo_read+0x38>
  18068e:	89 f0                	mov    %esi,%eax
  180690:	e8 be fd ff ff       	call   180453 <is_data_ready>
  180695:	84 c0                	test   %al,%al
  180697:	75 e3                	jne    18067c <uart_qmsi_fifo_read+0x1b>
		rx_data[i] = QM_UART[instance]->rbr_thr_dll;
	}

	return i;
}
  180699:	89 d8                	mov    %ebx,%eax
  18069b:	5b                   	pop    %ebx
  18069c:	5e                   	pop    %esi
  18069d:	5f                   	pop    %edi
  18069e:	5d                   	pop    %ebp
  18069f:	c3                   	ret    

001806a0 <uart_qmsi_fifo_fill>:
	return !!(QM_UART[instance]->lsr & QM_UART_LSR_THRE);
}

static int uart_qmsi_fifo_fill(struct device *dev, const uint8_t *tx_data,
				  int size)
{
  1806a0:	55                   	push   %ebp
  1806a1:	57                   	push   %edi
  1806a2:	56                   	push   %esi
  1806a3:	53                   	push   %ebx
  1806a4:	89 d5                	mov    %edx,%ebp
  1806a6:	89 cf                	mov    %ecx,%edi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1806a8:	8b 10                	mov    (%eax),%edx
  1806aa:	8b 52 08             	mov    0x8(%edx),%edx
  1806ad:	8b 32                	mov    (%edx),%esi
	int i;

	device_busy_set(dev);
  1806af:	e8 65 27 00 00       	call   182e19 <device_busy_set>

	for (i = 0; i < size && !is_tx_fifo_full(instance); i++) {
  1806b4:	bb 00 00 00 00       	mov    $0x0,%ebx
  1806b9:	eb 0f                	jmp    1806ca <uart_qmsi_fifo_fill+0x2a>
		QM_UART[instance]->rbr_thr_dll = tx_data[i];
  1806bb:	8b 04 b5 1c 00 28 00 	mov    0x28001c(,%esi,4),%eax
  1806c2:	0f b6 54 1d 00       	movzbl 0x0(%ebp,%ebx,1),%edx
  1806c7:	89 10                	mov    %edx,(%eax)
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
	int i;

	device_busy_set(dev);

	for (i = 0; i < size && !is_tx_fifo_full(instance); i++) {
  1806c9:	43                   	inc    %ebx
  1806ca:	39 fb                	cmp    %edi,%ebx
  1806cc:	7d 0b                	jge    1806d9 <uart_qmsi_fifo_fill+0x39>
  1806ce:	89 f0                	mov    %esi,%eax
  1806d0:	e8 6e fd ff ff       	call   180443 <is_tx_fifo_full>
  1806d5:	84 c0                	test   %al,%al
  1806d7:	74 e2                	je     1806bb <uart_qmsi_fifo_fill+0x1b>
		QM_UART[instance]->rbr_thr_dll = tx_data[i];
	}

	return i;
}
  1806d9:	89 d8                	mov    %ebx,%eax
  1806db:	5b                   	pop    %ebx
  1806dc:	5e                   	pop    %esi
  1806dd:	5f                   	pop    %edi
  1806de:	5d                   	pop    %ebp
  1806df:	c3                   	ret    

001806e0 <uart_qmsi_err_check>:
	qm_uart_write(instance, data);
	return data;
}

static int uart_qmsi_err_check(struct device *dev)
{
  1806e0:	83 ec 04             	sub    $0x4,%esp
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1806e3:	8b 00                	mov    (%eax),%eax
  1806e5:	8b 40 08             	mov    0x8(%eax),%eax
  1806e8:	8b 00                	mov    (%eax),%eax

	/* QMSI and Zephyr use the same bits to represent UART errors
	 * so we don't need to translate each error bit from QMSI API
	 * to Zephyr API.
	 */
	qm_uart_get_status(instance, &status);
  1806ea:	89 e2                	mov    %esp,%edx
  1806ec:	e8 aa 20 00 00       	call   18279b <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
  1806f1:	8b 04 24             	mov    (%esp),%eax
  1806f4:	83 e0 1e             	and    $0x1e,%eax
}
  1806f7:	83 c4 04             	add    $0x4,%esp
  1806fa:	c3                   	ret    

001806fb <uart_qmsi_poll_out>:
	return 0;
}

static unsigned char uart_qmsi_poll_out(struct device *dev,
					unsigned char data)
{
  1806fb:	53                   	push   %ebx
  1806fc:	89 d3                	mov    %edx,%ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1806fe:	8b 00                	mov    (%eax),%eax
  180700:	8b 40 08             	mov    0x8(%eax),%eax
  180703:	8b 00                	mov    (%eax),%eax

	qm_uart_write(instance, data);
  180705:	0f b6 d2             	movzbl %dl,%edx
  180708:	e8 d1 20 00 00       	call   1827de <qm_uart_write>
	return data;
}
  18070d:	88 d8                	mov    %bl,%al
  18070f:	5b                   	pop    %ebx
  180710:	c3                   	ret    

00180711 <uart_qmsi_poll_in>:
	      uart_qmsi_device_ctrl, &drv_data_1, &config_info_1, PRE_KERNEL_1,
	      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL);
#endif /* CONFIG_UART_QMSI_1 */

static int uart_qmsi_poll_in(struct device *dev, unsigned char *data)
{
  180711:	56                   	push   %esi
  180712:	53                   	push   %ebx
  180713:	83 ec 04             	sub    $0x4,%esp
  180716:	89 d6                	mov    %edx,%esi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180718:	8b 00                	mov    (%eax),%eax
  18071a:	8b 40 08             	mov    0x8(%eax),%eax
  18071d:	8b 18                	mov    (%eax),%ebx
	qm_uart_status_t status;

	qm_uart_get_status(instance, &status);
  18071f:	89 e2                	mov    %esp,%edx
  180721:	89 d8                	mov    %ebx,%eax
  180723:	e8 73 20 00 00       	call   18279b <qm_uart_get_status>
	/* In order to check if there is any data to read from UART
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
  180728:	f6 04 24 40          	testb  $0x40,(%esp)
  18072c:	74 15                	je     180743 <uart_qmsi_poll_in+0x32>
		return -1;

	qm_uart_read(instance, data, NULL);
  18072e:	b9 00 00 00 00       	mov    $0x0,%ecx
  180733:	89 f2                	mov    %esi,%edx
  180735:	89 d8                	mov    %ebx,%eax
  180737:	e8 c4 20 00 00       	call   182800 <qm_uart_read>
	return 0;
  18073c:	b8 00 00 00 00       	mov    $0x0,%eax
  180741:	eb 05                	jmp    180748 <uart_qmsi_poll_in+0x37>
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
		return -1;
  180743:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	qm_uart_read(instance, data, NULL);
	return 0;
}
  180748:	83 c4 04             	add    $0x4,%esp
  18074b:	5b                   	pop    %ebx
  18074c:	5e                   	pop    %esi
  18074d:	c3                   	ret    

0018074e <_timer_int_handler>:
		timer_mode = TIMER_MODE_PERIODIC;
	}

	_sys_clock_final_tick_announce();
#else
	_sys_clock_tick_announce();
  18074e:	a1 24 00 28 00       	mov    0x280024,%eax
  180753:	e8 ac 30 00 00       	call   183804 <_nano_sys_clock_tick_announce>
  180758:	c3                   	ret    

00180759 <_sys_clock_driver_init>:
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
  180759:	a1 28 00 28 00       	mov    0x280028,%eax
  18075e:	48                   	dec    %eax
 * @param count Count from which timer is to count down
 * @return N/A
 */
static inline void initial_count_register_set(uint32_t count)
{
	*_REG_TIMER_ICR = count;
  18075f:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
 *
 * @return N/A
 */
static inline void periodic_mode_set(void)
{
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
  180764:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
  180769:	0d 00 00 02 00       	or     $0x20000,%eax
  18076e:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180773:	b9 00 00 00 00       	mov    $0x0,%ecx
  180778:	ba 0a 00 00 00       	mov    $0xa,%edx
  18077d:	b8 2a 00 00 00       	mov    $0x2a,%eax
  180782:	e8 c8 00 00 00       	call   18084f <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
  180787:	b8 0a 00 00 00       	mov    $0xa,%eax
  18078c:	e8 99 00 00 00       	call   18082a <_arch_irq_enable>

	return 0;
}
  180791:	b8 00 00 00 00       	mov    $0x0,%eax
  180796:	c3                   	ret    

00180797 <_mvic_rte_set>:
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  180797:	89 c1                	mov    %eax,%ecx
  180799:	83 e1 07             	and    $0x7,%ecx
  18079c:	01 c9                	add    %ecx,%ecx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  18079e:	83 e0 18             	and    $0x18,%eax
  1807a1:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  1807a4:	09 c8                	or     %ecx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1807a6:	9c                   	pushf  
  1807a7:	fa                   	cli    
  1807a8:	59                   	pop    %ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1807a9:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
  1807ae:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  1807b4:	f6 c5 02             	test   $0x2,%ch
  1807b7:	74 01                	je     1807ba <_mvic_rte_set+0x23>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1807b9:	fb                   	sti    
  1807ba:	c3                   	ret    

001807bb <_mvic_rte_update>:
 * @param mask of bits to be modified
 *
 * @returns N/A
 */
static void _mvic_rte_update(unsigned int irq, uint32_t value, uint32_t mask)
{
  1807bb:	53                   	push   %ebx
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  1807bc:	89 c3                	mov    %eax,%ebx
  1807be:	83 e3 07             	and    $0x7,%ebx
  1807c1:	01 db                	add    %ebx,%ebx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  1807c3:	83 e0 18             	and    $0x18,%eax
  1807c6:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  1807c9:	09 d8                	or     %ebx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1807cb:	9c                   	pushf  
  1807cc:	fa                   	cli    
  1807cd:	5b                   	pop    %ebx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1807ce:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1807d3:	a1 10 00 c0 fe       	mov    0xfec00010,%eax
	key = irq_lock();

	sys_write32(regsel, MVIC_IOREGSEL);

	old_value = sys_read32(MVIC_IOWIN);
	updated_value = (old_value & ~mask) | (value & mask);
  1807d8:	31 c2                	xor    %eax,%edx
  1807da:	21 d1                	and    %edx,%ecx
  1807dc:	31 c8                	xor    %ecx,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1807de:	a3 10 00 c0 fe       	mov    %eax,0xfec00010
  1807e3:	f6 c7 02             	test   $0x2,%bh
  1807e6:	74 01                	je     1807e9 <_mvic_rte_update+0x2e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1807e8:	fb                   	sti    
	sys_write32(updated_value, MVIC_IOWIN);

	irq_unlock(key);
}
  1807e9:	5b                   	pop    %ebx
  1807ea:	c3                   	ret    

001807eb <_mvic_init>:
 * This routine replaces the standard Local APIC / IO APIC init routines.
 *
 * @returns: N/A
 */
static int _mvic_init(struct device *unused)
{
  1807eb:	53                   	push   %ebx
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  1807ec:	bb 00 00 00 00       	mov    $0x0,%ebx
  1807f1:	eb 0d                	jmp    180800 <_mvic_init+0x15>
		_mvic_rte_set(i, MVIC_IOWIN_MASK);
  1807f3:	ba 00 00 01 00       	mov    $0x10000,%edx
  1807f8:	89 d8                	mov    %ebx,%eax
  1807fa:	e8 98 ff ff ff       	call   180797 <_mvic_rte_set>
{
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  1807ff:	43                   	inc    %ebx
  180800:	83 fb 1f             	cmp    $0x1f,%ebx
  180803:	7e ee                	jle    1807f3 <_mvic_init+0x8>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180805:	b8 00 00 00 00       	mov    $0x0,%eax
  18080a:	a3 80 00 e0 fe       	mov    %eax,0xfee00080
  18080f:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
  180814:	b8 0a 00 01 00       	mov    $0x1000a,%eax
  180819:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  18081e:	b8 00 00 00 00       	mov    $0x0,%eax
  180823:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	/* discard a pending interrupt if any */
	sys_write32(0, MVIC_EOI);

	return 0;

}
  180828:	5b                   	pop    %ebx
  180829:	c3                   	ret    

0018082a <_arch_irq_enable>:
SYS_INIT(_mvic_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


void _arch_irq_enable(unsigned int irq)
{
	if (irq == CONFIG_MVIC_TIMER_IRQ) {
  18082a:	83 f8 0a             	cmp    $0xa,%eax
  18082d:	75 10                	jne    18083f <_arch_irq_enable+0x15>
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  18082f:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
		sys_write32(sys_read32(MVIC_LVTTIMER) & ~MVIC_LVTTIMER_MASK,
  180834:	25 ff ff fe ff       	and    $0xfffeffff,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180839:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  18083e:	c3                   	ret    
			    MVIC_LVTTIMER);
	} else {
		_mvic_rte_update(irq, 0, MVIC_IOWIN_MASK);
  18083f:	b9 00 00 01 00       	mov    $0x10000,%ecx
  180844:	ba 00 00 00 00       	mov    $0x0,%edx
  180849:	e8 6d ff ff ff       	call   1807bb <_mvic_rte_update>
  18084e:	c3                   	ret    

0018084f <__irq_controller_irq_config>:

	/* Vector argument always ignored. There are no triggering options
	 * for the timer, so nothing to do at all for that case. Other I/O
	 * interrupts need their triggering set
	 */
	if (irq != CONFIG_MVIC_TIMER_IRQ) {
  18084f:	83 fa 0a             	cmp    $0xa,%edx
  180852:	74 0f                	je     180863 <__irq_controller_irq_config+0x14>
  180854:	89 d0                	mov    %edx,%eax
		_mvic_rte_set(irq, MVIC_IOWIN_MASK | flags);
  180856:	81 c9 00 00 01 00    	or     $0x10000,%ecx
  18085c:	89 ca                	mov    %ecx,%edx
  18085e:	e8 34 ff ff ff       	call   180797 <_mvic_rte_set>
  180863:	c3                   	ret    

00180864 <__irq_controller_isr_vector_get>:
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180864:	a1 10 01 e0 fe       	mov    0xfee00110,%eax
{
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
  180869:	85 c0                	test   %eax,%eax
  18086b:	74 0e                	je     18087b <__irq_controller_isr_vector_get+0x17>

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  18086d:	0f bd c0             	bsr    %eax,%eax
  180870:	75 05                	jne    180877 <__irq_controller_isr_vector_get+0x13>
  180872:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		return -1;
	}
	return 32 + (find_msb_set(isr) - 1);
  180877:	83 c0 20             	add    $0x20,%eax
  18087a:	c3                   	ret    
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
		return -1;
  18087b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
	return 32 + (find_msb_set(isr) - 1);
}
  180880:	c3                   	ret    

00180881 <transfer_complete>:
			 uint32_t len)
{
	struct device *dev = (struct device *) data;
	struct i2c_qmsi_driver_data *driver_data;

	driver_data = GET_DRIVER_DATA(dev);
  180881:	8b 40 08             	mov    0x8(%eax),%eax
	driver_data->transfer_status = rc;
  180884:	89 50 14             	mov    %edx,0x14(%eax)
	k_sem_give(&driver_data->device_sync_sem);
  180887:	e8 b6 2e 00 00       	call   183742 <k_sem_give>
  18088c:	c3                   	ret    

0018088d <i2c_qmsi_transfer>:
}

static int i2c_qmsi_transfer(struct device *dev, struct i2c_msg *msgs,
			     uint8_t num_msgs, uint16_t addr)
{
  18088d:	55                   	push   %ebp
  18088e:	57                   	push   %edi
  18088f:	56                   	push   %esi
  180890:	53                   	push   %ebx
  180891:	83 ec 2c             	sub    $0x2c,%esp
  180894:	88 4c 24 05          	mov    %cl,0x5(%esp)
  180898:	8b 7c 24 40          	mov    0x40(%esp),%edi
  18089c:	66 89 7c 24 06       	mov    %di,0x6(%esp)
	struct i2c_qmsi_driver_data *driver_data = GET_DRIVER_DATA(dev);
  1808a1:	8b 70 08             	mov    0x8(%eax),%esi
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
  1808a4:	8b 18                	mov    (%eax),%ebx
  1808a6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  1808a9:	8b 1b                	mov    (%ebx),%ebx
  1808ab:	89 1c 24             	mov    %ebx,(%esp)
	int rc;

	__ASSERT_NO_MSG(msgs);
	if (!num_msgs) {
  1808ae:	84 c9                	test   %cl,%cl
  1808b0:	0f 84 f5 00 00 00    	je     1809ab <i2c_qmsi_transfer+0x11e>
  1808b6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1808ba:	89 44 24 08          	mov    %eax,0x8(%esp)
		return 0;
	}

	device_busy_set(dev);
  1808be:	e8 56 25 00 00       	call   182e19 <device_busy_set>

	for (int i = 0; i < num_msgs; i++) {
  1808c3:	bb 00 00 00 00       	mov    $0x0,%ebx
  1808c8:	89 f5                	mov    %esi,%ebp
  1808ca:	e9 bf 00 00 00       	jmp    18098e <i2c_qmsi_transfer+0x101>
		uint8_t op =  msgs[i].flags & I2C_MSG_RW_MASK;
  1808cf:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
  1808d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  1808d9:	03 54 24 0c          	add    0xc(%esp),%edx
		bool stop = (msgs[i].flags & I2C_MSG_STOP) == I2C_MSG_STOP;
  1808dd:	8a 42 08             	mov    0x8(%edx),%al
  1808e0:	d0 e8                	shr    %al
  1808e2:	83 e0 01             	and    $0x1,%eax
  1808e5:	89 c6                	mov    %eax,%esi
		qm_i2c_transfer_t xfer = { 0 };
  1808e7:	8d 7c 24 10          	lea    0x10(%esp),%edi
  1808eb:	b9 07 00 00 00       	mov    $0x7,%ecx
  1808f0:	b8 00 00 00 00       	mov    $0x0,%eax
  1808f5:	f3 ab                	rep stos %eax,%es:(%edi)
		if (op == I2C_MSG_WRITE) {
  1808f7:	f6 42 08 01          	testb  $0x1,0x8(%edx)
  1808fb:	75 0f                	jne    18090c <i2c_qmsi_transfer+0x7f>
			xfer.tx = msgs[i].buf;
  1808fd:	8b 02                	mov    (%edx),%eax
  1808ff:	89 44 24 10          	mov    %eax,0x10(%esp)
			xfer.tx_len = msgs[i].len;
  180903:	8b 42 04             	mov    0x4(%edx),%eax
  180906:	89 44 24 14          	mov    %eax,0x14(%esp)
  18090a:	eb 0d                	jmp    180919 <i2c_qmsi_transfer+0x8c>
		} else {
			xfer.rx = msgs[i].buf;
  18090c:	8b 02                	mov    (%edx),%eax
  18090e:	89 44 24 18          	mov    %eax,0x18(%esp)
			xfer.rx_len = msgs[i].len;
  180912:	8b 42 04             	mov    0x4(%edx),%eax
  180915:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		}

		xfer.callback = transfer_complete;
  180919:	c7 44 24 24 81 08 18 	movl   $0x180881,0x24(%esp)
  180920:	00 
		xfer.callback_data = dev;
  180921:	8b 44 24 08          	mov    0x8(%esp),%eax
  180925:	89 44 24 28          	mov    %eax,0x28(%esp)
		xfer.stop = stop;
  180929:	89 f0                	mov    %esi,%eax
  18092b:	88 44 24 20          	mov    %al,0x20(%esp)

		k_sem_take(&driver_data->sem, K_FOREVER);
  18092f:	8d 75 18             	lea    0x18(%ebp),%esi
  180932:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  180937:	89 f0                	mov    %esi,%eax
  180939:	e8 22 2e 00 00       	call   183760 <k_sem_take>
		rc = qm_i2c_master_irq_transfer(instance, &xfer, addr);
  18093e:	0f b7 4c 24 06       	movzwl 0x6(%esp),%ecx
  180943:	8d 54 24 10          	lea    0x10(%esp),%edx
  180947:	8b 04 24             	mov    (%esp),%eax
  18094a:	e8 47 1d 00 00       	call   182696 <qm_i2c_master_irq_transfer>
  18094f:	89 c7                	mov    %eax,%edi
		k_sem_give(&driver_data->sem);
  180951:	89 f0                	mov    %esi,%eax
  180953:	e8 ea 2d 00 00       	call   183742 <k_sem_give>

		if (rc != 0) {
  180958:	85 ff                	test   %edi,%edi
  18095a:	74 0b                	je     180967 <i2c_qmsi_transfer+0xda>
			device_busy_clear(dev);
  18095c:	8b 44 24 08          	mov    0x8(%esp),%eax
  180960:	e8 b5 24 00 00       	call   182e1a <device_busy_clear>
			return -EIO;
  180965:	eb 20                	jmp    180987 <i2c_qmsi_transfer+0xfa>
		}

		/* Block current thread until the I2C transfer completes. */
		k_sem_take(&driver_data->device_sync_sem, K_FOREVER);
  180967:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  18096c:	89 e8                	mov    %ebp,%eax
  18096e:	e8 ed 2d 00 00       	call   183760 <k_sem_take>

		if (driver_data->transfer_status != 0) {
  180973:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  180977:	74 0b                	je     180984 <i2c_qmsi_transfer+0xf7>
			device_busy_clear(dev);
  180979:	8b 44 24 08          	mov    0x8(%esp),%eax
  18097d:	e8 98 24 00 00       	call   182e1a <device_busy_clear>
			return -EIO;
  180982:	eb 03                	jmp    180987 <i2c_qmsi_transfer+0xfa>
		return 0;
	}

	device_busy_set(dev);

	for (int i = 0; i < num_msgs; i++) {
  180984:	43                   	inc    %ebx
  180985:	eb 07                	jmp    18098e <i2c_qmsi_transfer+0x101>
		rc = qm_i2c_master_irq_transfer(instance, &xfer, addr);
		k_sem_give(&driver_data->sem);

		if (rc != 0) {
			device_busy_clear(dev);
			return -EIO;
  180987:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  18098c:	eb 22                	jmp    1809b0 <i2c_qmsi_transfer+0x123>
		return 0;
	}

	device_busy_set(dev);

	for (int i = 0; i < num_msgs; i++) {
  18098e:	0f b6 44 24 05       	movzbl 0x5(%esp),%eax
  180993:	39 c3                	cmp    %eax,%ebx
  180995:	0f 8c 34 ff ff ff    	jl     1808cf <i2c_qmsi_transfer+0x42>
			device_busy_clear(dev);
			return -EIO;
		}
	}

	device_busy_clear(dev);
  18099b:	8b 44 24 08          	mov    0x8(%esp),%eax
  18099f:	e8 76 24 00 00       	call   182e1a <device_busy_clear>

	return 0;
  1809a4:	b8 00 00 00 00       	mov    $0x0,%eax
  1809a9:	eb 05                	jmp    1809b0 <i2c_qmsi_transfer+0x123>
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
	int rc;

	__ASSERT_NO_MSG(msgs);
	if (!num_msgs) {
		return 0;
  1809ab:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	device_busy_clear(dev);

	return 0;
}
  1809b0:	83 c4 2c             	add    $0x2c,%esp
  1809b3:	5b                   	pop    %ebx
  1809b4:	5e                   	pop    %esi
  1809b5:	5f                   	pop    %edi
  1809b6:	5d                   	pop    %ebp
  1809b7:	c3                   	ret    

001809b8 <i2c_qmsi_configure>:
	      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL);

#endif /* CONFIG_I2C_1 */

static int i2c_qmsi_configure(struct device *dev, uint32_t config)
{
  1809b8:	57                   	push   %edi
  1809b9:	56                   	push   %esi
  1809ba:	53                   	push   %ebx
  1809bb:	83 ec 14             	sub    $0x14,%esp
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
  1809be:	8b 08                	mov    (%eax),%ecx
  1809c0:	8b 49 08             	mov    0x8(%ecx),%ecx
  1809c3:	8b 19                	mov    (%ecx),%ebx
	struct i2c_qmsi_driver_data *driver_data = GET_DRIVER_DATA(dev);
  1809c5:	8b 78 08             	mov    0x8(%eax),%edi
	qm_i2c_reg_t *const controller = QM_I2C[instance];
  1809c8:	8b 34 9d 18 00 28 00 	mov    0x280018(,%ebx,4),%esi
	qm_i2c_config_t qm_cfg;

	cfg.raw = config;

	/* This driver only supports master mode. */
	if (!cfg.bits.is_master_device)
  1809cf:	f6 c2 10             	test   $0x10,%dl
  1809d2:	74 74                	je     180a48 <i2c_qmsi_configure+0x90>
		return -EINVAL;

	qm_cfg.mode = QM_I2C_MASTER;
  1809d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1809db:	00 
	qm_cfg.address_mode = (cfg.bits.use_10_bit_addr) ? QM_I2C_10_BIT :
  1809dc:	89 d0                	mov    %edx,%eax
  1809de:	83 e0 01             	and    $0x1,%eax
  1809e1:	89 44 24 04          	mov    %eax,0x4(%esp)
							   QM_I2C_7_BIT;

	switch (cfg.bits.speed) {
  1809e5:	d1 ea                	shr    %edx
  1809e7:	83 e2 07             	and    $0x7,%edx
  1809ea:	80 fa 02             	cmp    $0x2,%dl
  1809ed:	74 13                	je     180a02 <i2c_qmsi_configure+0x4a>
  1809ef:	80 fa 03             	cmp    $0x3,%dl
  1809f2:	74 17                	je     180a0b <i2c_qmsi_configure+0x53>
  1809f4:	80 fa 01             	cmp    $0x1,%dl
  1809f7:	75 56                	jne    180a4f <i2c_qmsi_configure+0x97>
	case I2C_SPEED_STANDARD:
		qm_cfg.speed = QM_I2C_SPEED_STD;
  1809f9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
		break;
  180a00:	eb 10                	jmp    180a12 <i2c_qmsi_configure+0x5a>
	case I2C_SPEED_FAST:
		qm_cfg.speed = QM_I2C_SPEED_FAST;
  180a02:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
		break;
  180a09:	eb 07                	jmp    180a12 <i2c_qmsi_configure+0x5a>
	case I2C_SPEED_FAST_PLUS:
		qm_cfg.speed = QM_I2C_SPEED_FAST_PLUS;
  180a0b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
		break;
	default:
		return -EINVAL;
	}

	k_sem_take(&driver_data->sem, K_FOREVER);
  180a12:	83 c7 18             	add    $0x18,%edi
  180a15:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  180a1a:	89 f8                	mov    %edi,%eax
  180a1c:	e8 3f 2d 00 00       	call   183760 <k_sem_take>
	rc = qm_i2c_set_config(instance, &qm_cfg);
  180a21:	89 e2                	mov    %esp,%edx
  180a23:	89 d8                	mov    %ebx,%eax
  180a25:	e8 9b 1a 00 00       	call   1824c5 <qm_i2c_set_config>
  180a2a:	89 c3                	mov    %eax,%ebx
	k_sem_give(&driver_data->sem);
  180a2c:	89 f8                	mov    %edi,%eax
  180a2e:	e8 0f 2d 00 00       	call   183742 <k_sem_give>

	controller->ic_sda_hold = (CONFIG_I2C_SDA_RX_HOLD << 16) +
  180a33:	c7 46 7c 10 00 18 00 	movl   $0x180010,0x7c(%esi)
				   CONFIG_I2C_SDA_TX_HOLD;

	controller->ic_sda_setup = CONFIG_I2C_SDA_SETUP;
  180a3a:	c7 86 94 00 00 00 02 	movl   $0x2,0x94(%esi)
  180a41:	00 00 00 

	return rc;
  180a44:	89 d8                	mov    %ebx,%eax
  180a46:	eb 0c                	jmp    180a54 <i2c_qmsi_configure+0x9c>

	cfg.raw = config;

	/* This driver only supports master mode. */
	if (!cfg.bits.is_master_device)
		return -EINVAL;
  180a48:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  180a4d:	eb 05                	jmp    180a54 <i2c_qmsi_configure+0x9c>
		break;
	case I2C_SPEED_FAST_PLUS:
		qm_cfg.speed = QM_I2C_SPEED_FAST_PLUS;
		break;
	default:
		return -EINVAL;
  180a4f:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
				   CONFIG_I2C_SDA_TX_HOLD;

	controller->ic_sda_setup = CONFIG_I2C_SDA_SETUP;

	return rc;
}
  180a54:	83 c4 14             	add    $0x14,%esp
  180a57:	5b                   	pop    %ebx
  180a58:	5e                   	pop    %esi
  180a59:	5f                   	pop    %edi
  180a5a:	c3                   	ret    

00180a5b <i2c_qmsi_init>:
	.configure = i2c_qmsi_configure,
	.transfer = i2c_qmsi_transfer,
};

static int i2c_qmsi_init(struct device *dev)
{
  180a5b:	55                   	push   %ebp
  180a5c:	57                   	push   %edi
  180a5d:	56                   	push   %esi
  180a5e:	53                   	push   %ebx
  180a5f:	89 c6                	mov    %eax,%esi
	struct i2c_qmsi_driver_data *driver_data = GET_DRIVER_DATA(dev);
  180a61:	8b 58 08             	mov    0x8(%eax),%ebx
	const struct i2c_qmsi_config_info *config = dev->config->config_info;
  180a64:	8b 00                	mov    (%eax),%eax
  180a66:	8b 78 08             	mov    0x8(%eax),%edi
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
  180a69:	8b 2f                	mov    (%edi),%ebp
	int err;

	k_sem_init(&driver_data->device_sync_sem, 0, UINT_MAX);
  180a6b:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  180a70:	ba 00 00 00 00       	mov    $0x0,%edx
  180a75:	89 d8                	mov    %ebx,%eax
  180a77:	e8 a3 2c 00 00       	call   18371f <k_sem_init>
	k_sem_init(&driver_data->sem, 0, UINT_MAX);
  180a7c:	83 c3 18             	add    $0x18,%ebx
  180a7f:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  180a84:	ba 00 00 00 00       	mov    $0x0,%edx
  180a89:	89 d8                	mov    %ebx,%eax
  180a8b:	e8 8f 2c 00 00       	call   18371f <k_sem_init>
	k_sem_give(&driver_data->sem);
  180a90:	89 d8                	mov    %ebx,%eax
  180a92:	e8 ab 2c 00 00       	call   183742 <k_sem_give>

	switch (instance) {
  180a97:	85 ed                	test   %ebp,%ebp
  180a99:	75 4f                	jne    180aea <i2c_qmsi_init+0x8f>
  180a9b:	b9 00 80 00 00       	mov    $0x8000,%ecx
  180aa0:	ba 04 00 00 00       	mov    $0x4,%edx
  180aa5:	b8 24 00 00 00       	mov    $0x24,%eax
  180aaa:	e8 a0 fd ff ff       	call   18084f <__irq_controller_irq_config>
		 * to Lakemont core.
		 */
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_I2C_0_INT),
			    CONFIG_I2C_0_IRQ_PRI, qm_i2c_0_irq_isr, NULL,
			    (IOAPIC_LEVEL | IOAPIC_HIGH));
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_I2C_0_INT));
  180aaf:	b8 04 00 00 00       	mov    $0x4,%eax
  180ab4:	e8 71 fd ff ff       	call   18082a <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(
  180ab9:	a1 48 04 80 b0       	mov    0xb0800448,%eax
  180abe:	83 e0 fe             	and    $0xfffffffe,%eax
  180ac1:	a3 48 04 80 b0       	mov    %eax,0xb0800448

	default:
		return -EIO;
	}

	clk_periph_enable(config->clock_gate);
  180ac6:	8b 47 08             	mov    0x8(%edi),%eax
  180ac9:	e8 86 12 00 00       	call   181d54 <clk_periph_enable>

	err = i2c_qmsi_configure(dev, config->default_cfg.raw);
  180ace:	8b 57 04             	mov    0x4(%edi),%edx
  180ad1:	89 f0                	mov    %esi,%eax
  180ad3:	e8 e0 fe ff ff       	call   1809b8 <i2c_qmsi_configure>
	if (err < 0) {
  180ad8:	85 c0                	test   %eax,%eax
  180ada:	78 13                	js     180aef <i2c_qmsi_init+0x94>
		return err;
	}

	dev->driver_api = &api;
  180adc:	c7 46 04 64 48 18 00 	movl   $0x184864,0x4(%esi)

	i2c_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
  180ae3:	b8 00 00 00 00       	mov    $0x0,%eax
  180ae8:	eb 05                	jmp    180aef <i2c_qmsi_init+0x94>
				QM_INTERRUPT_ROUTER->i2c_master_1_int_mask);
		break;
#endif /* CONFIG_I2C_1 */

	default:
		return -EIO;
  180aea:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	dev->driver_api = &api;

	i2c_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  180aef:	5b                   	pop    %ebx
  180af0:	5e                   	pop    %esi
  180af1:	5f                   	pop    %edi
  180af2:	5d                   	pop    %ebp
  180af3:	c3                   	ret    

00180af4 <pinmux_get>:
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_get(struct device *dev, uint32_t pin,
			  uint32_t *func)
{
  180af4:	56                   	push   %esi
  180af5:	53                   	push   %ebx
  180af6:	89 cb                	mov    %ecx,%ebx
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
  180af8:	89 d6                	mov    %edx,%esi
  180afa:	c1 ee 04             	shr    $0x4,%esi

	/* The pin offset within the register */
	uint32_t pin_no = pin % 16;
  180afd:	83 e2 0f             	and    $0xf,%edx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
  180b00:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  180b03:	b8 03 00 00 00       	mov    $0x3,%eax
  180b08:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
  180b0a:	8b 14 b5 30 09 80 b0 	mov    -0x4f7ff6d0(,%esi,4),%edx
  180b11:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
  180b13:	d3 e8                	shr    %cl,%eax

	*func = mode;
  180b15:	89 03                	mov    %eax,(%ebx)

	return 0;
}
  180b17:	b8 00 00 00 00       	mov    $0x0,%eax
  180b1c:	5b                   	pop    %ebx
  180b1d:	5e                   	pop    %esi
  180b1e:	c3                   	ret    

00180b1f <pinmux_initialize>:
};

static int pinmux_initialize(struct device *port)
{
	return 0;
}
  180b1f:	b8 00 00 00 00       	mov    $0x0,%eax
  180b24:	c3                   	ret    

00180b25 <pinmux_input>:
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_input(struct device *dev, uint32_t pin,
			    uint8_t func)
{
  180b25:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
  180b27:	84 c9                	test   %cl,%cl
  180b29:	0f 95 c2             	setne  %dl
  180b2c:	0f b6 d2             	movzbl %dl,%edx
  180b2f:	e8 a1 1d 00 00       	call   1828d5 <qm_pmux_input_en>
  180b34:	85 c0                	test   %eax,%eax
  180b36:	74 05                	je     180b3d <pinmux_input+0x18>
  180b38:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180b3d:	c3                   	ret    

00180b3e <pinmux_pullup>:
	return 0;
}

static int pinmux_pullup(struct device *dev, uint32_t pin,
			     uint8_t func)
{
  180b3e:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
  180b40:	84 c9                	test   %cl,%cl
  180b42:	0f 95 c2             	setne  %dl
  180b45:	0f b6 d2             	movzbl %dl,%edx
  180b48:	e8 e9 1d 00 00       	call   182936 <qm_pmux_pullup_en>
  180b4d:	85 c0                	test   %eax,%eax
  180b4f:	74 05                	je     180b56 <pinmux_pullup+0x18>
  180b51:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180b56:	c3                   	ret    

00180b57 <pinmux_set>:

#define MASK_2_BITS	0x3

static int pinmux_set(struct device *dev, uint32_t pin,
			  uint32_t func)
{
  180b57:	89 d0                	mov    %edx,%eax
  180b59:	89 ca                	mov    %ecx,%edx
	ARG_UNUSED(dev);

	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
  180b5b:	e8 1d 1d 00 00       	call   18287d <qm_pmux_select>
  180b60:	85 c0                	test   %eax,%eax
  180b62:	74 05                	je     180b69 <pinmux_set+0x12>
  180b64:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180b69:	c3                   	ret    

00180b6a <_uc>:
#define EOF  -1
#endif

static void _uc(char *buf)
{
	for (/**/; *buf; buf++) {
  180b6a:	eb 0e                	jmp    180b7a <_uc+0x10>
		if (*buf >= 'a' && *buf <= 'z') {
  180b6c:	8d 4a 9f             	lea    -0x61(%edx),%ecx
  180b6f:	80 f9 19             	cmp    $0x19,%cl
  180b72:	77 05                	ja     180b79 <_uc+0xf>
			*buf += 'A' - 'a';
  180b74:	83 ea 20             	sub    $0x20,%edx
  180b77:	88 10                	mov    %dl,(%eax)
#define EOF  -1
#endif

static void _uc(char *buf)
{
	for (/**/; *buf; buf++) {
  180b79:	40                   	inc    %eax
  180b7a:	8a 10                	mov    (%eax),%dl
  180b7c:	84 d2                	test   %dl,%dl
  180b7e:	75 ec                	jne    180b6c <_uc+0x2>
		if (*buf >= 'a' && *buf <= 'z') {
			*buf += 'A' - 'a';
		}
	}
}
  180b80:	c3                   	ret    

00180b81 <_reverse_and_pad>:

/* Convention note: "end" as passed in is the standard "byte after
 * last character" style, but...
 */
static int _reverse_and_pad(char *start, char *end, int minlen)
{
  180b81:	56                   	push   %esi
  180b82:	53                   	push   %ebx
	int len;

	while (end - start < minlen) {
  180b83:	eb 06                	jmp    180b8b <_reverse_and_pad+0xa>
		*end++ = '0';
  180b85:	c6 02 30             	movb   $0x30,(%edx)
  180b88:	8d 52 01             	lea    0x1(%edx),%edx
 */
static int _reverse_and_pad(char *start, char *end, int minlen)
{
	int len;

	while (end - start < minlen) {
  180b8b:	89 d3                	mov    %edx,%ebx
  180b8d:	29 c3                	sub    %eax,%ebx
  180b8f:	39 cb                	cmp    %ecx,%ebx
  180b91:	7c f2                	jl     180b85 <_reverse_and_pad+0x4>
		*end++ = '0';
	}

	*end = 0;
  180b93:	c6 02 00             	movb   $0x0,(%edx)
	len = end - start;
	for (end--; end > start; end--, start++) {
  180b96:	4a                   	dec    %edx
  180b97:	eb 0d                	jmp    180ba6 <_reverse_and_pad+0x25>
		char tmp = *end;
  180b99:	0f b6 32             	movzbl (%edx),%esi
		*end = *start;
  180b9c:	8a 08                	mov    (%eax),%cl
  180b9e:	88 0a                	mov    %cl,(%edx)
		*start = tmp;
  180ba0:	89 f1                	mov    %esi,%ecx
  180ba2:	88 08                	mov    %cl,(%eax)
		*end++ = '0';
	}

	*end = 0;
	len = end - start;
	for (end--; end > start; end--, start++) {
  180ba4:	4a                   	dec    %edx
  180ba5:	40                   	inc    %eax
  180ba6:	39 d0                	cmp    %edx,%eax
  180ba8:	72 ef                	jb     180b99 <_reverse_and_pad+0x18>
		char tmp = *end;
		*end = *start;
		*start = tmp;
	}
	return len;
}
  180baa:	89 d8                	mov    %ebx,%eax
  180bac:	5b                   	pop    %ebx
  180bad:	5e                   	pop    %esi
  180bae:	c3                   	ret    

00180baf <_to_x>:
/* Writes the specified number into the buffer in the given base,
 * using the digit characters 0-9a-z (i.e. base>36 will start writing
 * odd bytes), padding with leading zeros up to the minimum length.
 */
static int _to_x(char *buf, uint32_t n, int base, int minlen)
{
  180baf:	55                   	push   %ebp
  180bb0:	57                   	push   %edi
  180bb1:	56                   	push   %esi
  180bb2:	53                   	push   %ebx
  180bb3:	83 ec 04             	sub    $0x4,%esp
  180bb6:	89 04 24             	mov    %eax,(%esp)
  180bb9:	89 d6                	mov    %edx,%esi
  180bbb:	89 c3                	mov    %eax,%ebx
	char *buf0 = buf;

	do {
		int d = n % base;
  180bbd:	89 f0                	mov    %esi,%eax
  180bbf:	ba 00 00 00 00       	mov    $0x0,%edx
  180bc4:	f7 f1                	div    %ecx

		n /= base;
  180bc6:	89 c6                	mov    %eax,%esi
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
  180bc8:	8d 7b 01             	lea    0x1(%ebx),%edi
  180bcb:	83 fa 09             	cmp    $0x9,%edx
  180bce:	7e 07                	jle    180bd7 <_to_x+0x28>
  180bd0:	bd 27 00 00 00       	mov    $0x27,%ebp
  180bd5:	eb 05                	jmp    180bdc <_to_x+0x2d>
  180bd7:	bd 00 00 00 00       	mov    $0x0,%ebp
  180bdc:	8d 54 15 30          	lea    0x30(%ebp,%edx,1),%edx
  180be0:	88 13                	mov    %dl,(%ebx)
  180be2:	89 fb                	mov    %edi,%ebx
	} while (n);
  180be4:	85 c0                	test   %eax,%eax
  180be6:	75 d5                	jne    180bbd <_to_x+0xe>
	return _reverse_and_pad(buf0, buf, minlen);
  180be8:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  180bec:	89 fa                	mov    %edi,%edx
  180bee:	8b 04 24             	mov    (%esp),%eax
  180bf1:	e8 8b ff ff ff       	call   180b81 <_reverse_and_pad>
}
  180bf6:	83 c4 04             	add    $0x4,%esp
  180bf9:	5b                   	pop    %ebx
  180bfa:	5e                   	pop    %esi
  180bfb:	5f                   	pop    %edi
  180bfc:	5d                   	pop    %ebp
  180bfd:	c3                   	ret    

00180bfe <_to_hex>:

static int _to_hex(char *buf, uint32_t value,
		   int alt_form, int precision, int prefix)
{
  180bfe:	57                   	push   %edi
  180bff:	56                   	push   %esi
  180c00:	53                   	push   %ebx
  180c01:	89 c6                	mov    %eax,%esi
	int len;
	char *buf0 = buf;

	if (alt_form) {
  180c03:	85 c9                	test   %ecx,%ecx
  180c05:	74 0c                	je     180c13 <_to_hex+0x15>
		*buf++ = '0';
  180c07:	c6 00 30             	movb   $0x30,(%eax)
		*buf++ = 'x';
  180c0a:	8d 58 02             	lea    0x2(%eax),%ebx
  180c0d:	c6 40 01 78          	movb   $0x78,0x1(%eax)
  180c11:	eb 02                	jmp    180c15 <_to_hex+0x17>
  180c13:	89 c3                	mov    %eax,%ebx
	}

	len = _to_x(buf, value, 16, precision);
  180c15:	ff 74 24 10          	pushl  0x10(%esp)
  180c19:	b9 10 00 00 00       	mov    $0x10,%ecx
  180c1e:	89 d8                	mov    %ebx,%eax
  180c20:	e8 8a ff ff ff       	call   180baf <_to_x>
  180c25:	83 c4 04             	add    $0x4,%esp
  180c28:	89 c7                	mov    %eax,%edi
	if (prefix == 'X') {
  180c2a:	83 7c 24 14 58       	cmpl   $0x58,0x14(%esp)
  180c2f:	75 07                	jne    180c38 <_to_hex+0x3a>
		_uc(buf0);
  180c31:	89 f0                	mov    %esi,%eax
  180c33:	e8 32 ff ff ff       	call   180b6a <_uc>
	}

	return len + (buf - buf0);
  180c38:	29 f3                	sub    %esi,%ebx
  180c3a:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
}
  180c3d:	5b                   	pop    %ebx
  180c3e:	5e                   	pop    %esi
  180c3f:	5f                   	pop    %edi
  180c40:	c3                   	ret    

00180c41 <_to_octal>:

static int _to_octal(char *buf, uint32_t value, int alt_form, int precision)
{
  180c41:	53                   	push   %ebx
  180c42:	89 c3                	mov    %eax,%ebx
	char *buf0 = buf;

	if (alt_form) {
  180c44:	85 c9                	test   %ecx,%ecx
  180c46:	74 15                	je     180c5d <_to_octal+0x1c>
		*buf++ = '0';
  180c48:	8d 40 01             	lea    0x1(%eax),%eax
  180c4b:	c6 03 30             	movb   $0x30,(%ebx)
		if (!value) {
  180c4e:	85 d2                	test   %edx,%edx
  180c50:	75 0b                	jne    180c5d <_to_octal+0x1c>
			/* So we don't return "00" for a value == 0. */
			*buf++ = 0;
  180c52:	c6 43 01 00          	movb   $0x0,0x1(%ebx)
			return 1;
  180c56:	b8 01 00 00 00       	mov    $0x1,%eax
  180c5b:	eb 19                	jmp    180c76 <_to_octal+0x35>
		}
	}
	return (buf - buf0) + _to_x(buf, value, 8, precision);
  180c5d:	89 c1                	mov    %eax,%ecx
  180c5f:	29 d9                	sub    %ebx,%ecx
  180c61:	89 cb                	mov    %ecx,%ebx
  180c63:	ff 74 24 08          	pushl  0x8(%esp)
  180c67:	b9 08 00 00 00       	mov    $0x8,%ecx
  180c6c:	e8 3e ff ff ff       	call   180baf <_to_x>
  180c71:	83 c4 04             	add    $0x4,%esp
  180c74:	01 d8                	add    %ebx,%eax
}
  180c76:	5b                   	pop    %ebx
  180c77:	c3                   	ret    

00180c78 <_to_udec>:

static int _to_udec(char *buf, uint32_t value, int precision)
{
	return _to_x(buf, value, 10, precision);
  180c78:	51                   	push   %ecx
  180c79:	b9 0a 00 00 00       	mov    $0xa,%ecx
  180c7e:	e8 2c ff ff ff       	call   180baf <_to_x>
  180c83:	83 c4 04             	add    $0x4,%esp
}
  180c86:	c3                   	ret    

00180c87 <_to_dec>:

static int _to_dec(char *buf, int32_t value, int fplus, int fspace, int precision)
{
  180c87:	56                   	push   %esi
  180c88:	53                   	push   %ebx
  180c89:	89 c3                	mov    %eax,%ebx

#if (MAXFLD < 10)
  #error buffer size MAXFLD is too small
#endif

	if (value < 0) {
  180c8b:	85 d2                	test   %edx,%edx
  180c8d:	79 12                	jns    180ca1 <_to_dec+0x1a>
		*buf++ = '-';
  180c8f:	8d 70 01             	lea    0x1(%eax),%esi
  180c92:	c6 00 2d             	movb   $0x2d,(%eax)
		if (value != 0x80000000)
  180c95:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
  180c9b:	74 21                	je     180cbe <_to_dec+0x37>
			value = -value;
  180c9d:	f7 da                	neg    %edx
  180c9f:	eb 1d                	jmp    180cbe <_to_dec+0x37>
	} else if (fplus)
  180ca1:	85 c9                	test   %ecx,%ecx
  180ca3:	74 08                	je     180cad <_to_dec+0x26>
		*buf++ = '+';
  180ca5:	8d 70 01             	lea    0x1(%eax),%esi
  180ca8:	c6 00 2b             	movb   $0x2b,(%eax)
  180cab:	eb 11                	jmp    180cbe <_to_dec+0x37>
	else if (fspace)
  180cad:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  180cb2:	74 08                	je     180cbc <_to_dec+0x35>
		*buf++ = ' ';
  180cb4:	8d 70 01             	lea    0x1(%eax),%esi
  180cb7:	c6 00 20             	movb   $0x20,(%eax)
  180cba:	eb 02                	jmp    180cbe <_to_dec+0x37>
  180cbc:	89 c6                	mov    %eax,%esi

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
  180cbe:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  180cc2:	89 f0                	mov    %esi,%eax
  180cc4:	e8 af ff ff ff       	call   180c78 <_to_udec>
  180cc9:	01 f0                	add    %esi,%eax
  180ccb:	29 d8                	sub    %ebx,%eax
}
  180ccd:	5b                   	pop    %ebx
  180cce:	5e                   	pop    %esi
  180ccf:	c3                   	ret    

00180cd0 <_rlrshift>:

static	void _rlrshift(uint64_t *v)
{
  180cd0:	57                   	push   %edi
  180cd1:	56                   	push   %esi
  180cd2:	53                   	push   %ebx
	*v = (*v & 1) + (*v >> 1);
  180cd3:	8b 08                	mov    (%eax),%ecx
  180cd5:	8b 58 04             	mov    0x4(%eax),%ebx
  180cd8:	89 ca                	mov    %ecx,%edx
  180cda:	83 e2 01             	and    $0x1,%edx
  180cdd:	bf 00 00 00 00       	mov    $0x0,%edi
  180ce2:	0f ac d9 01          	shrd   $0x1,%ebx,%ecx
  180ce6:	d1 eb                	shr    %ebx
  180ce8:	01 d1                	add    %edx,%ecx
  180cea:	11 fb                	adc    %edi,%ebx
  180cec:	89 08                	mov    %ecx,(%eax)
  180cee:	89 58 04             	mov    %ebx,0x4(%eax)
}
  180cf1:	5b                   	pop    %ebx
  180cf2:	5e                   	pop    %esi
  180cf3:	5f                   	pop    %edi
  180cf4:	c3                   	ret    

00180cf5 <_ldiv5>:
 * six.  This was tested exhaustively through the first ~10B values in
 * the input space, and for ~2e12 (4 hours runtime) random inputs
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
  180cf5:	55                   	push   %ebp
  180cf6:	57                   	push   %edi
  180cf7:	56                   	push   %esi
  180cf8:	53                   	push   %ebx
  180cf9:	83 ec 10             	sub    $0x10,%esp
  180cfc:	89 c5                	mov    %eax,%ebp
	static const char shifts[] = { 32, 3, 0 };

	/* Usage in this file wants rounded behavior, not truncation.  So add
	 * two to get the threshold right.
	 */
	rem += 2;
  180cfe:	8b 00                	mov    (%eax),%eax
  180d00:	8b 55 04             	mov    0x4(%ebp),%edx
  180d03:	83 c0 02             	add    $0x2,%eax
  180d06:	83 d2 00             	adc    $0x0,%edx
  180d09:	89 04 24             	mov    %eax,(%esp)
  180d0c:	89 54 24 04          	mov    %edx,0x4(%esp)
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
	uint32_t i, hi;
	uint64_t rem = *v, quot = 0, q;
  180d10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180d17:	00 
  180d18:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  180d1f:	00 
	/* Usage in this file wants rounded behavior, not truncation.  So add
	 * two to get the threshold right.
	 */
	rem += 2;

	for (i = 0; i < 3; i++) {
  180d20:	bb 00 00 00 00       	mov    $0x0,%ebx
  180d25:	eb 5d                	jmp    180d84 <_ldiv5+0x8f>
		hi = rem >> shifts[i];
  180d27:	8b 04 24             	mov    (%esp),%eax
  180d2a:	8b 54 24 04          	mov    0x4(%esp),%edx
  180d2e:	8a 8b 54 4b 18 00    	mov    0x184b54(%ebx),%cl
  180d34:	0f ad d0             	shrd   %cl,%edx,%eax
  180d37:	d3 ea                	shr    %cl,%edx
  180d39:	f6 c1 20             	test   $0x20,%cl
  180d3c:	74 02                	je     180d40 <_ldiv5+0x4b>
  180d3e:	89 d0                	mov    %edx,%eax
		q = (uint64_t)(hi / 5) << shifts[i];
  180d40:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  180d45:	f7 e1                	mul    %ecx
  180d47:	c1 ea 02             	shr    $0x2,%edx
  180d4a:	89 d0                	mov    %edx,%eax
  180d4c:	ba 00 00 00 00       	mov    $0x0,%edx
  180d51:	8a 8b 54 4b 18 00    	mov    0x184b54(%ebx),%cl
  180d57:	0f a5 c2             	shld   %cl,%eax,%edx
  180d5a:	d3 e0                	shl    %cl,%eax
  180d5c:	f6 c1 20             	test   $0x20,%cl
  180d5f:	74 04                	je     180d65 <_ldiv5+0x70>
  180d61:	89 c2                	mov    %eax,%edx
  180d63:	31 c0                	xor    %eax,%eax
		rem -= q * 5;
  180d65:	89 c6                	mov    %eax,%esi
  180d67:	89 d7                	mov    %edx,%edi
  180d69:	0f a4 c7 02          	shld   $0x2,%eax,%edi
  180d6d:	c1 e6 02             	shl    $0x2,%esi
  180d70:	01 c6                	add    %eax,%esi
  180d72:	11 d7                	adc    %edx,%edi
  180d74:	29 34 24             	sub    %esi,(%esp)
  180d77:	19 7c 24 04          	sbb    %edi,0x4(%esp)
		quot += q;
  180d7b:	01 44 24 08          	add    %eax,0x8(%esp)
  180d7f:	11 54 24 0c          	adc    %edx,0xc(%esp)
	/* Usage in this file wants rounded behavior, not truncation.  So add
	 * two to get the threshold right.
	 */
	rem += 2;

	for (i = 0; i < 3; i++) {
  180d83:	43                   	inc    %ebx
  180d84:	83 fb 02             	cmp    $0x2,%ebx
  180d87:	76 9e                	jbe    180d27 <_ldiv5+0x32>
		q = (uint64_t)(hi / 5) << shifts[i];
		rem -= q * 5;
		quot += q;
	}

	*v = quot;
  180d89:	8b 44 24 08          	mov    0x8(%esp),%eax
  180d8d:	8b 54 24 0c          	mov    0xc(%esp),%edx
  180d91:	89 45 00             	mov    %eax,0x0(%ebp)
  180d94:	89 55 04             	mov    %edx,0x4(%ebp)
}
  180d97:	83 c4 10             	add    $0x10,%esp
  180d9a:	5b                   	pop    %ebx
  180d9b:	5e                   	pop    %esi
  180d9c:	5f                   	pop    %edi
  180d9d:	5d                   	pop    %ebp
  180d9e:	c3                   	ret    

00180d9f <_get_digit>:

static	char _get_digit(uint64_t *fr, int *digit_count)
{
	int		rval;

	if (*digit_count > 0) {
  180d9f:	8b 0a                	mov    (%edx),%ecx
  180da1:	85 c9                	test   %ecx,%ecx
  180da3:	7e 39                	jle    180dde <_get_digit+0x3f>

	*v = quot;
}

static	char _get_digit(uint64_t *fr, int *digit_count)
{
  180da5:	57                   	push   %edi
  180da6:	56                   	push   %esi
  180da7:	53                   	push   %ebx
	int		rval;

	if (*digit_count > 0) {
		*digit_count -= 1;
  180da8:	49                   	dec    %ecx
  180da9:	89 0a                	mov    %ecx,(%edx)
		*fr = *fr * 10;
  180dab:	8b 30                	mov    (%eax),%esi
  180dad:	8b 78 04             	mov    0x4(%eax),%edi
  180db0:	89 f1                	mov    %esi,%ecx
  180db2:	89 fb                	mov    %edi,%ebx
  180db4:	0f a4 f3 01          	shld   $0x1,%esi,%ebx
  180db8:	01 f1                	add    %esi,%ecx
  180dba:	0f a4 f7 03          	shld   $0x3,%esi,%edi
  180dbe:	c1 e6 03             	shl    $0x3,%esi
  180dc1:	01 f1                	add    %esi,%ecx
  180dc3:	11 fb                	adc    %edi,%ebx
  180dc5:	89 ce                	mov    %ecx,%esi
  180dc7:	89 da                	mov    %ebx,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
  180dc9:	89 d9                	mov    %ebx,%ecx
  180dcb:	c1 e9 1c             	shr    $0x1c,%ecx
  180dce:	83 c1 30             	add    $0x30,%ecx
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  180dd1:	89 30                	mov    %esi,(%eax)
  180dd3:	81 e2 ff ff ff 0f    	and    $0xfffffff,%edx
  180dd9:	89 50 04             	mov    %edx,0x4(%eax)
  180ddc:	eb 08                	jmp    180de6 <_get_digit+0x47>
	} else
		rval = '0';
  180dde:	b9 30 00 00 00       	mov    $0x30,%ecx
	return (char) (rval);
}
  180de3:	88 c8                	mov    %cl,%al
  180de5:	c3                   	ret    
  180de6:	88 c8                	mov    %cl,%al
  180de8:	5b                   	pop    %ebx
  180de9:	5e                   	pop    %esi
  180dea:	5f                   	pop    %edi
  180deb:	c3                   	ret    

00180dec <_to_float>:
#define	MAXFP1	0xFFFFFFFF	/* Largest # if first fp format */
#define HIGHBIT64 (1ull<<63)

static int _to_float(char *buf, uint64_t double_temp, int c,
					 int falt, int fplus, int fspace, int precision)
{
  180dec:	55                   	push   %ebp
  180ded:	57                   	push   %edi
  180dee:	56                   	push   %esi
  180def:	53                   	push   %ebx
  180df0:	83 ec 24             	sub    $0x24,%esp
  180df3:	89 c6                	mov    %eax,%esi
	uint64_t        fract;
	uint64_t        ltemp;
	int             prune_zero;
	char           *start = buf;

	exp = double_temp >> 52 & 0x7ff;
  180df5:	89 cb                	mov    %ecx,%ebx
  180df7:	c1 eb 14             	shr    $0x14,%ebx
  180dfa:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
	fract = (double_temp << 11) & ~HIGHBIT64;
  180e00:	89 d7                	mov    %edx,%edi
  180e02:	89 cd                	mov    %ecx,%ebp
  180e04:	0f a4 d5 0b          	shld   $0xb,%edx,%ebp
  180e08:	c1 e7 0b             	shl    $0xb,%edi
  180e0b:	89 f8                	mov    %edi,%eax
  180e0d:	89 ea                	mov    %ebp,%edx
  180e0f:	89 fd                	mov    %edi,%ebp
  180e11:	89 d7                	mov    %edx,%edi
  180e13:	81 e7 ff ff ff 7f    	and    $0x7fffffff,%edi
  180e19:	89 44 24 18          	mov    %eax,0x18(%esp)
  180e1d:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
	sign = !!(double_temp & HIGHBIT64);
  180e21:	89 c8                	mov    %ecx,%eax
  180e23:	c1 e9 1f             	shr    $0x1f,%ecx


	if (exp == 0x7ff) {
  180e26:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  180e2c:	75 39                	jne    180e67 <_to_float+0x7b>
		if (!fract) {
  180e2e:	09 ef                	or     %ebp,%edi
  180e30:	75 1d                	jne    180e4f <_to_float+0x63>
			*buf++ = sign ? '-' : '+';
  180e32:	85 c0                	test   %eax,%eax
  180e34:	79 04                	jns    180e3a <_to_float+0x4e>
  180e36:	b0 2d                	mov    $0x2d,%al
  180e38:	eb 02                	jmp    180e3c <_to_float+0x50>
  180e3a:	b0 2b                	mov    $0x2b,%al
  180e3c:	88 06                	mov    %al,(%esi)
			*buf++ = 'I';
  180e3e:	c6 46 01 49          	movb   $0x49,0x1(%esi)
			*buf++ = 'N';
  180e42:	c6 46 02 4e          	movb   $0x4e,0x2(%esi)
			*buf++ = 'F';
  180e46:	8d 46 04             	lea    0x4(%esi),%eax
  180e49:	c6 46 03 46          	movb   $0x46,0x3(%esi)
  180e4d:	eb 0e                	jmp    180e5d <_to_float+0x71>
		} else {
			*buf++ = 'N';
  180e4f:	c6 06 4e             	movb   $0x4e,(%esi)
			*buf++ = 'a';
  180e52:	c6 46 01 61          	movb   $0x61,0x1(%esi)
			*buf++ = 'N';
  180e56:	8d 46 03             	lea    0x3(%esi),%eax
  180e59:	c6 46 02 4e          	movb   $0x4e,0x2(%esi)
		}
		*buf = 0;
  180e5d:	c6 00 00             	movb   $0x0,(%eax)
		return buf - start;
  180e60:	29 f0                	sub    %esi,%eax
  180e62:	e9 ce 03 00 00       	jmp    181235 <_to_float+0x449>
	}

	if ((exp | fract) != 0) {
  180e67:	89 da                	mov    %ebx,%edx
  180e69:	c1 fa 1f             	sar    $0x1f,%edx
  180e6c:	89 1c 24             	mov    %ebx,(%esp)
  180e6f:	89 54 24 04          	mov    %edx,0x4(%esp)
  180e73:	89 d8                	mov    %ebx,%eax
  180e75:	09 e8                	or     %ebp,%eax
  180e77:	8b 54 24 04          	mov    0x4(%esp),%edx
  180e7b:	09 fa                	or     %edi,%edx
  180e7d:	09 c2                	or     %eax,%edx
  180e7f:	74 1b                	je     180e9c <_to_float+0xb0>
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
  180e81:	81 eb fe 03 00 00    	sub    $0x3fe,%ebx
		fract |= HIGHBIT64;
  180e87:	89 6c 24 18          	mov    %ebp,0x18(%esp)
  180e8b:	81 cf 00 00 00 80    	or     $0x80000000,%edi
  180e91:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
		decexp = true;		/* Wasn't zero */
  180e95:	b8 01 00 00 00       	mov    $0x1,%eax
  180e9a:	eb 05                	jmp    180ea1 <_to_float+0xb5>
	} else
		decexp = false;		/* It was zero */
  180e9c:	b8 00 00 00 00       	mov    $0x0,%eax

	if (decexp && sign) {
  180ea1:	84 c8                	test   %cl,%al
  180ea3:	74 0b                	je     180eb0 <_to_float+0xc4>
		*buf++ = '-';
  180ea5:	8d 46 01             	lea    0x1(%esi),%eax
  180ea8:	89 04 24             	mov    %eax,(%esp)
  180eab:	c6 06 2d             	movb   $0x2d,(%esi)
  180eae:	eb 27                	jmp    180ed7 <_to_float+0xeb>
	} else if (fplus) {
  180eb0:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
  180eb5:	74 0b                	je     180ec2 <_to_float+0xd6>
		*buf++ = '+';
  180eb7:	8d 46 01             	lea    0x1(%esi),%eax
  180eba:	89 04 24             	mov    %eax,(%esp)
  180ebd:	c6 06 2b             	movb   $0x2b,(%esi)
  180ec0:	eb 15                	jmp    180ed7 <_to_float+0xeb>
	} else if (fspace) {
  180ec2:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  180ec7:	74 0b                	je     180ed4 <_to_float+0xe8>
		*buf++ = ' ';
  180ec9:	8d 46 01             	lea    0x1(%esi),%eax
  180ecc:	89 04 24             	mov    %eax,(%esp)
  180ecf:	c6 06 20             	movb   $0x20,(%esi)
  180ed2:	eb 03                	jmp    180ed7 <_to_float+0xeb>
  180ed4:	89 34 24             	mov    %esi,(%esp)
  180ed7:	89 74 24 0c          	mov    %esi,0xc(%esp)
	}

	decexp = 0;
  180edb:	bd 00 00 00 00       	mov    $0x0,%ebp
	while (exp <= -3) {
  180ee0:	eb 54                	jmp    180f36 <_to_float+0x14a>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
			_rlrshift(&fract);
  180ee2:	8d 44 24 18          	lea    0x18(%esp),%eax
  180ee6:	e8 e5 fd ff ff       	call   180cd0 <_rlrshift>
			exp++;
  180eeb:	43                   	inc    %ebx
		*buf++ = ' ';
	}

	decexp = 0;
	while (exp <= -3) {
		while ((fract >> 32) >= (MAXFP1 / 5)) {
  180eec:	8b 44 24 18          	mov    0x18(%esp),%eax
  180ef0:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  180ef4:	81 fa 32 33 33 33    	cmp    $0x33333332,%edx
  180efa:	77 e6                	ja     180ee2 <_to_float+0xf6>
			_rlrshift(&fract);
			exp++;
		}
		fract *= 5;
  180efc:	89 c6                	mov    %eax,%esi
  180efe:	89 d7                	mov    %edx,%edi
  180f00:	0f a4 c7 02          	shld   $0x2,%eax,%edi
  180f04:	c1 e6 02             	shl    $0x2,%esi
  180f07:	01 f0                	add    %esi,%eax
  180f09:	11 fa                	adc    %edi,%edx
  180f0b:	89 44 24 18          	mov    %eax,0x18(%esp)
  180f0f:	89 54 24 1c          	mov    %edx,0x1c(%esp)
		exp++;
  180f13:	43                   	inc    %ebx
		decexp--;
  180f14:	4d                   	dec    %ebp

		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180f15:	eb 0f                	jmp    180f26 <_to_float+0x13a>
			fract <<= 1;
  180f17:	0f a4 c2 01          	shld   $0x1,%eax,%edx
  180f1b:	01 c0                	add    %eax,%eax
  180f1d:	89 44 24 18          	mov    %eax,0x18(%esp)
  180f21:	89 54 24 1c          	mov    %edx,0x1c(%esp)
			exp--;
  180f25:	4b                   	dec    %ebx
		}
		fract *= 5;
		exp++;
		decexp--;

		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180f26:	8b 44 24 18          	mov    0x18(%esp),%eax
  180f2a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  180f2e:	81 fa ff ff ff 7f    	cmp    $0x7fffffff,%edx
  180f34:	76 e1                	jbe    180f17 <_to_float+0x12b>
	} else if (fspace) {
		*buf++ = ' ';
	}

	decexp = 0;
	while (exp <= -3) {
  180f36:	83 fb fe             	cmp    $0xfffffffe,%ebx
  180f39:	7c b1                	jl     180eec <_to_float+0x100>
  180f3b:	eb 2c                	jmp    180f69 <_to_float+0x17d>
			exp--;
		}
	}

	while (exp > 0) {
		_ldiv5(&fract);
  180f3d:	8d 44 24 18          	lea    0x18(%esp),%eax
  180f41:	e8 af fd ff ff       	call   180cf5 <_ldiv5>
		exp--;
  180f46:	4b                   	dec    %ebx
		decexp++;
  180f47:	45                   	inc    %ebp
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180f48:	eb 0f                	jmp    180f59 <_to_float+0x16d>
			fract <<= 1;
  180f4a:	0f a4 c2 01          	shld   $0x1,%eax,%edx
  180f4e:	01 c0                	add    %eax,%eax
  180f50:	89 44 24 18          	mov    %eax,0x18(%esp)
  180f54:	89 54 24 1c          	mov    %edx,0x1c(%esp)
			exp--;
  180f58:	4b                   	dec    %ebx

	while (exp > 0) {
		_ldiv5(&fract);
		exp--;
		decexp++;
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180f59:	8b 44 24 18          	mov    0x18(%esp),%eax
  180f5d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  180f61:	81 fa ff ff ff 7f    	cmp    $0x7fffffff,%edx
  180f67:	76 e1                	jbe    180f4a <_to_float+0x15e>
			fract <<= 1;
			exp--;
		}
	}

	while (exp > 0) {
  180f69:	85 db                	test   %ebx,%ebx
  180f6b:	7f d0                	jg     180f3d <_to_float+0x151>
  180f6d:	eb 0a                	jmp    180f79 <_to_float+0x18d>
			exp--;
		}
	}

	while (exp < (0 + 4)) {
		_rlrshift(&fract);
  180f6f:	8d 44 24 18          	lea    0x18(%esp),%eax
  180f73:	e8 58 fd ff ff       	call   180cd0 <_rlrshift>
		exp++;
  180f78:	43                   	inc    %ebx
			fract <<= 1;
			exp--;
		}
	}

	while (exp < (0 + 4)) {
  180f79:	83 fb 03             	cmp    $0x3,%ebx
  180f7c:	7e f1                	jle    180f6f <_to_float+0x183>
		_rlrshift(&fract);
		exp++;
	}

	if (precision < 0)
  180f7e:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  180f83:	79 08                	jns    180f8d <_to_float+0x1a1>
		precision = 6;		/* Default precision if none given */
  180f85:	c7 44 24 48 06 00 00 	movl   $0x6,0x48(%esp)
  180f8c:	00 
	prune_zero = false;		/* Assume trailing 0's allowed     */
	if ((c == 'g') || (c == 'G')) {
  180f8d:	83 7c 24 38 67       	cmpl   $0x67,0x38(%esp)
  180f92:	0f 94 c2             	sete   %dl
  180f95:	83 7c 24 38 47       	cmpl   $0x47,0x38(%esp)
  180f9a:	0f 94 c0             	sete   %al
  180f9d:	08 c2                	or     %al,%dl
  180f9f:	74 45                	je     180fe6 <_to_float+0x1fa>
		if (!falt && (precision > 0))
  180fa1:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  180fa6:	0f 94 c2             	sete   %dl
  180fa9:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  180fae:	0f 9f c0             	setg   %al
  180fb1:	84 c2                	test   %al,%dl
  180fb3:	75 0a                	jne    180fbf <_to_float+0x1d3>
		exp++;
	}

	if (precision < 0)
		precision = 6;		/* Default precision if none given */
	prune_zero = false;		/* Assume trailing 0's allowed     */
  180fb5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180fbc:	00 
  180fbd:	eb 08                	jmp    180fc7 <_to_float+0x1db>
	if ((c == 'g') || (c == 'G')) {
		if (!falt && (precision > 0))
			prune_zero = true;
  180fbf:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  180fc6:	00 
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
  180fc7:	83 fd fd             	cmp    $0xfffffffd,%ebp
  180fca:	7c 09                	jl     180fd5 <_to_float+0x1e9>
  180fcc:	8b 44 24 48          	mov    0x48(%esp),%eax
  180fd0:	40                   	inc    %eax
  180fd1:	39 c5                	cmp    %eax,%ebp
  180fd3:	7e 1b                	jle    180ff0 <_to_float+0x204>
			if (c == 'g')
  180fd5:	83 7c 24 38 67       	cmpl   $0x67,0x38(%esp)
  180fda:	75 1e                	jne    180ffa <_to_float+0x20e>
				c = 'e';
  180fdc:	c7 44 24 38 65 00 00 	movl   $0x65,0x38(%esp)
  180fe3:	00 
  180fe4:	eb 1c                	jmp    181002 <_to_float+0x216>
		exp++;
	}

	if (precision < 0)
		precision = 6;		/* Default precision if none given */
	prune_zero = false;		/* Assume trailing 0's allowed     */
  180fe6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180fed:	00 
  180fee:	eb 12                	jmp    181002 <_to_float+0x216>
			if (c == 'g')
				c = 'e';
			else
				c = 'E';
		} else
			c = 'f';
  180ff0:	c7 44 24 38 66 00 00 	movl   $0x66,0x38(%esp)
  180ff7:	00 
  180ff8:	eb 08                	jmp    181002 <_to_float+0x216>
			prune_zero = true;
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
			if (c == 'g')
				c = 'e';
			else
				c = 'E';
  180ffa:	c7 44 24 38 45 00 00 	movl   $0x45,0x38(%esp)
  181001:	00 
		} else
			c = 'f';
	}

	if (c == 'f') {
  181002:	83 7c 24 38 66       	cmpl   $0x66,0x38(%esp)
  181007:	75 0a                	jne    181013 <_to_float+0x227>
		exp = precision + decexp;
		if (exp < 0)
  181009:	89 e8                	mov    %ebp,%eax
  18100b:	03 44 24 48          	add    0x48(%esp),%eax
  18100f:	79 0e                	jns    18101f <_to_float+0x233>
  181011:	eb 07                	jmp    18101a <_to_float+0x22e>
			exp = 0;
	} else
		exp = precision + 1;
  181013:	8b 44 24 48          	mov    0x48(%esp),%eax
  181017:	40                   	inc    %eax
  181018:	eb 05                	jmp    18101f <_to_float+0x233>
	}

	if (c == 'f') {
		exp = precision + decexp;
		if (exp < 0)
			exp = 0;
  18101a:	b8 00 00 00 00       	mov    $0x0,%eax
	} else
		exp = precision + 1;
	digit_count = 16;
  18101f:	c7 44 24 20 10 00 00 	movl   $0x10,0x20(%esp)
  181026:	00 
	if (exp > 16)
  181027:	83 f8 10             	cmp    $0x10,%eax
  18102a:	7e 05                	jle    181031 <_to_float+0x245>
		exp = 16;
  18102c:	b8 10 00 00 00       	mov    $0x10,%eax

	ltemp = 0x0800000000000000;
  181031:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  181038:	00 
  181039:	c7 44 24 14 00 00 00 	movl   $0x8000000,0x14(%esp)
  181040:	08 
	while (exp--) {
  181041:	eb 14                	jmp    181057 <_to_float+0x26b>
		_ldiv5(&ltemp);
  181043:	8d 44 24 10          	lea    0x10(%esp),%eax
  181047:	e8 a9 fc ff ff       	call   180cf5 <_ldiv5>
		_rlrshift(&ltemp);
  18104c:	8d 44 24 10          	lea    0x10(%esp),%eax
  181050:	e8 7b fc ff ff       	call   180cd0 <_rlrshift>
	digit_count = 16;
	if (exp > 16)
		exp = 16;

	ltemp = 0x0800000000000000;
	while (exp--) {
  181055:	89 d8                	mov    %ebx,%eax
  181057:	8d 58 ff             	lea    -0x1(%eax),%ebx
  18105a:	85 c0                	test   %eax,%eax
  18105c:	75 e5                	jne    181043 <_to_float+0x257>
		_ldiv5(&ltemp);
		_rlrshift(&ltemp);
	}

	fract += ltemp;
  18105e:	8b 44 24 10          	mov    0x10(%esp),%eax
  181062:	8b 54 24 14          	mov    0x14(%esp),%edx
  181066:	03 44 24 18          	add    0x18(%esp),%eax
  18106a:	13 54 24 1c          	adc    0x1c(%esp),%edx
  18106e:	89 44 24 18          	mov    %eax,0x18(%esp)
  181072:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	if ((fract >> 32) & 0xF0000000) {
  181076:	89 d0                	mov    %edx,%eax
  181078:	a9 00 00 00 f0       	test   $0xf0000000,%eax
  18107d:	74 13                	je     181092 <_to_float+0x2a6>
		_ldiv5(&fract);
  18107f:	8d 44 24 18          	lea    0x18(%esp),%eax
  181083:	e8 6d fc ff ff       	call   180cf5 <_ldiv5>
		_rlrshift(&fract);
  181088:	8d 44 24 18          	lea    0x18(%esp),%eax
  18108c:	e8 3f fc ff ff       	call   180cd0 <_rlrshift>
		decexp++;
  181091:	45                   	inc    %ebp
	}

	if (c == 'f') {
  181092:	83 7c 24 38 66       	cmpl   $0x66,0x38(%esp)
  181097:	0f 85 8a 00 00 00    	jne    181127 <_to_float+0x33b>
		if (decexp > 0) {
  18109d:	85 ed                	test   %ebp,%ebp
  18109f:	7f 19                	jg     1810ba <_to_float+0x2ce>
  1810a1:	eb 23                	jmp    1810c6 <_to_float+0x2da>
			while (decexp > 0) {
				*buf++ = _get_digit(&fract, &digit_count);
  1810a3:	8d 73 01             	lea    0x1(%ebx),%esi
  1810a6:	8d 54 24 20          	lea    0x20(%esp),%edx
  1810aa:	8d 44 24 18          	lea    0x18(%esp),%eax
  1810ae:	e8 ec fc ff ff       	call   180d9f <_get_digit>
  1810b3:	88 03                	mov    %al,(%ebx)
				decexp--;
  1810b5:	4d                   	dec    %ebp
	}

	if (c == 'f') {
		if (decexp > 0) {
			while (decexp > 0) {
				*buf++ = _get_digit(&fract, &digit_count);
  1810b6:	89 f3                	mov    %esi,%ebx
  1810b8:	eb 03                	jmp    1810bd <_to_float+0x2d1>
  1810ba:	8b 1c 24             	mov    (%esp),%ebx
		decexp++;
	}

	if (c == 'f') {
		if (decexp > 0) {
			while (decexp > 0) {
  1810bd:	85 ed                	test   %ebp,%ebp
  1810bf:	7f e2                	jg     1810a3 <_to_float+0x2b7>
  1810c1:	89 1c 24             	mov    %ebx,(%esp)
  1810c4:	eb 0c                	jmp    1810d2 <_to_float+0x2e6>
				*buf++ = _get_digit(&fract, &digit_count);
				decexp--;
			}
		} else
			*buf++ = '0';
  1810c6:	8b 04 24             	mov    (%esp),%eax
  1810c9:	c6 00 30             	movb   $0x30,(%eax)
  1810cc:	8d 40 01             	lea    0x1(%eax),%eax
  1810cf:	89 04 24             	mov    %eax,(%esp)
		if (falt || (precision > 0))
  1810d2:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  1810d7:	0f 95 c2             	setne  %dl
  1810da:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  1810df:	0f 9f c0             	setg   %al
  1810e2:	08 c2                	or     %al,%dl
  1810e4:	74 0c                	je     1810f2 <_to_float+0x306>
			*buf++ = '.';
  1810e6:	8b 04 24             	mov    (%esp),%eax
  1810e9:	c6 00 2e             	movb   $0x2e,(%eax)
  1810ec:	8d 40 01             	lea    0x1(%eax),%eax
  1810ef:	89 04 24             	mov    %eax,(%esp)
		while (precision-- > 0) {
			if (decexp < 0) {
				*buf++ = '0';
  1810f2:	8b 1c 24             	mov    (%esp),%ebx
  1810f5:	8b 44 24 48          	mov    0x48(%esp),%eax
  1810f9:	eb 23                	jmp    18111e <_to_float+0x332>
		} else
			*buf++ = '0';
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0) {
			if (decexp < 0) {
  1810fb:	85 ed                	test   %ebp,%ebp
  1810fd:	79 09                	jns    181108 <_to_float+0x31c>
				*buf++ = '0';
  1810ff:	c6 03 30             	movb   $0x30,(%ebx)
				decexp++;
  181102:	45                   	inc    %ebp
			*buf++ = '0';
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0) {
			if (decexp < 0) {
				*buf++ = '0';
  181103:	8d 5b 01             	lea    0x1(%ebx),%ebx
  181106:	eb 14                	jmp    18111c <_to_float+0x330>
				decexp++;
			} else
				*buf++ = _get_digit(&fract, &digit_count);
  181108:	8d 7b 01             	lea    0x1(%ebx),%edi
  18110b:	8d 54 24 20          	lea    0x20(%esp),%edx
  18110f:	8d 44 24 18          	lea    0x18(%esp),%eax
  181113:	e8 87 fc ff ff       	call   180d9f <_get_digit>
  181118:	88 03                	mov    %al,(%ebx)
  18111a:	89 fb                	mov    %edi,%ebx
  18111c:	89 f0                	mov    %esi,%eax
			}
		} else
			*buf++ = '0';
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0) {
  18111e:	8d 70 ff             	lea    -0x1(%eax),%esi
  181121:	85 c0                	test   %eax,%eax
  181123:	7f d6                	jg     1810fb <_to_float+0x30f>
  181125:	eb 61                	jmp    181188 <_to_float+0x39c>
				decexp++;
			} else
				*buf++ = _get_digit(&fract, &digit_count);
		}
	} else {
		*buf = _get_digit(&fract, &digit_count);
  181127:	8d 54 24 20          	lea    0x20(%esp),%edx
  18112b:	8d 44 24 18          	lea    0x18(%esp),%eax
  18112f:	e8 6b fc ff ff       	call   180d9f <_get_digit>
  181134:	8b 3c 24             	mov    (%esp),%edi
  181137:	88 07                	mov    %al,(%edi)
		if (*buf++ != '0')
  181139:	8d 5f 01             	lea    0x1(%edi),%ebx
  18113c:	3c 30                	cmp    $0x30,%al
  18113e:	74 01                	je     181141 <_to_float+0x355>
			decexp--;
  181140:	4d                   	dec    %ebp
		if (falt || (precision > 0))
  181141:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  181146:	0f 95 c2             	setne  %dl
  181149:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  18114e:	0f 9f c0             	setg   %al
  181151:	08 c2                	or     %al,%dl
  181153:	74 28                	je     18117d <_to_float+0x391>
			*buf++ = '.';
  181155:	8b 04 24             	mov    (%esp),%eax
  181158:	8d 58 02             	lea    0x2(%eax),%ebx
  18115b:	c6 40 01 2e          	movb   $0x2e,0x1(%eax)
  18115f:	8b 44 24 48          	mov    0x48(%esp),%eax
  181163:	eb 1c                	jmp    181181 <_to_float+0x395>
		while (precision-- > 0)
			*buf++ = _get_digit(&fract, &digit_count);
  181165:	8d 7b 01             	lea    0x1(%ebx),%edi
  181168:	8d 54 24 20          	lea    0x20(%esp),%edx
  18116c:	8d 44 24 18          	lea    0x18(%esp),%eax
  181170:	e8 2a fc ff ff       	call   180d9f <_get_digit>
  181175:	88 03                	mov    %al,(%ebx)
		*buf = _get_digit(&fract, &digit_count);
		if (*buf++ != '0')
			decexp--;
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0)
  181177:	89 f0                	mov    %esi,%eax
			*buf++ = _get_digit(&fract, &digit_count);
  181179:	89 fb                	mov    %edi,%ebx
  18117b:	eb 04                	jmp    181181 <_to_float+0x395>
  18117d:	8b 44 24 48          	mov    0x48(%esp),%eax
		*buf = _get_digit(&fract, &digit_count);
		if (*buf++ != '0')
			decexp--;
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0)
  181181:	8d 70 ff             	lea    -0x1(%eax),%esi
  181184:	85 c0                	test   %eax,%eax
  181186:	7f dd                	jg     181165 <_to_float+0x379>
			*buf++ = _get_digit(&fract, &digit_count);
	}

	if (prune_zero) {
  181188:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  18118d:	74 14                	je     1811a3 <_to_float+0x3b7>
  18118f:	eb 02                	jmp    181193 <_to_float+0x3a7>
		while (*--buf == '0')
  181191:	89 d3                	mov    %edx,%ebx
  181193:	8d 53 ff             	lea    -0x1(%ebx),%edx
  181196:	8a 43 ff             	mov    -0x1(%ebx),%al
  181199:	3c 30                	cmp    $0x30,%al
  18119b:	74 f4                	je     181191 <_to_float+0x3a5>
			;
		if (*buf != '.')
  18119d:	3c 2e                	cmp    $0x2e,%al
  18119f:	75 02                	jne    1811a3 <_to_float+0x3b7>
		while (precision-- > 0)
			*buf++ = _get_digit(&fract, &digit_count);
	}

	if (prune_zero) {
		while (*--buf == '0')
  1811a1:	89 d3                	mov    %edx,%ebx
			;
		if (*buf != '.')
			buf++;
	}

	if ((c == 'e') || (c == 'E')) {
  1811a3:	83 7c 24 38 65       	cmpl   $0x65,0x38(%esp)
  1811a8:	0f 94 c2             	sete   %dl
  1811ab:	83 7c 24 38 45       	cmpl   $0x45,0x38(%esp)
  1811b0:	0f 94 c0             	sete   %al
  1811b3:	08 c2                	or     %al,%dl
  1811b5:	74 75                	je     18122c <_to_float+0x440>
		*buf++ = (char) c;
  1811b7:	8a 44 24 38          	mov    0x38(%esp),%al
  1811bb:	88 03                	mov    %al,(%ebx)
		if (decexp < 0) {
  1811bd:	85 ed                	test   %ebp,%ebp
  1811bf:	79 0b                	jns    1811cc <_to_float+0x3e0>
			decexp = -decexp;
  1811c1:	f7 dd                	neg    %ebp
			*buf++ = '-';
  1811c3:	8d 4b 02             	lea    0x2(%ebx),%ecx
  1811c6:	c6 43 01 2d          	movb   $0x2d,0x1(%ebx)
  1811ca:	eb 07                	jmp    1811d3 <_to_float+0x3e7>
		} else
			*buf++ = '+';
  1811cc:	8d 4b 02             	lea    0x2(%ebx),%ecx
  1811cf:	c6 43 01 2b          	movb   $0x2b,0x1(%ebx)
		*buf++ = (char) ((decexp / 100) + '0');
  1811d3:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  1811d8:	89 e8                	mov    %ebp,%eax
  1811da:	f7 ea                	imul   %edx
  1811dc:	89 d0                	mov    %edx,%eax
  1811de:	c1 f8 05             	sar    $0x5,%eax
  1811e1:	89 ea                	mov    %ebp,%edx
  1811e3:	c1 fa 1f             	sar    $0x1f,%edx
  1811e6:	29 d0                	sub    %edx,%eax
  1811e8:	8d 50 30             	lea    0x30(%eax),%edx
  1811eb:	88 11                	mov    %dl,(%ecx)
		decexp %= 100;
  1811ed:	8d 04 80             	lea    (%eax,%eax,4),%eax
  1811f0:	8d 14 80             	lea    (%eax,%eax,4),%edx
  1811f3:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
  1811fa:	89 eb                	mov    %ebp,%ebx
  1811fc:	29 c3                	sub    %eax,%ebx
		*buf++ = (char) ((decexp / 10) + '0');
  1811fe:	ba 67 66 66 66       	mov    $0x66666667,%edx
  181203:	89 d8                	mov    %ebx,%eax
  181205:	f7 ea                	imul   %edx
  181207:	89 d0                	mov    %edx,%eax
  181209:	c1 f8 02             	sar    $0x2,%eax
  18120c:	89 da                	mov    %ebx,%edx
  18120e:	c1 fa 1f             	sar    $0x1f,%edx
  181211:	29 d0                	sub    %edx,%eax
  181213:	8d 50 30             	lea    0x30(%eax),%edx
  181216:	88 51 01             	mov    %dl,0x1(%ecx)
		decexp %= 10;
  181219:	8d 14 80             	lea    (%eax,%eax,4),%edx
  18121c:	8d 04 12             	lea    (%edx,%edx,1),%eax
  18121f:	89 da                	mov    %ebx,%edx
  181221:	29 c2                	sub    %eax,%edx
		*buf++ = (char) (decexp + '0');
  181223:	8d 59 03             	lea    0x3(%ecx),%ebx
  181226:	83 c2 30             	add    $0x30,%edx
  181229:	88 51 02             	mov    %dl,0x2(%ecx)
	}
	*buf = 0;
  18122c:	c6 03 00             	movb   $0x0,(%ebx)

	return buf - start;
  18122f:	89 d8                	mov    %ebx,%eax
  181231:	2b 44 24 0c          	sub    0xc(%esp),%eax
}
  181235:	83 c4 24             	add    $0x24,%esp
  181238:	5b                   	pop    %ebx
  181239:	5e                   	pop    %esi
  18123a:	5f                   	pop    %edi
  18123b:	5d                   	pop    %ebp
  18123c:	c3                   	ret    

0018123d <_atoi>:

static int _atoi(char **sptr)
{
  18123d:	56                   	push   %esi
  18123e:	53                   	push   %ebx
	register char *p;
	register int   i;

	i = 0;
	p = *sptr;
	p--;
  18123f:	8b 18                	mov    (%eax),%ebx
  181241:	4b                   	dec    %ebx
static int _atoi(char **sptr)
{
	register char *p;
	register int   i;

	i = 0;
  181242:	be 00 00 00 00       	mov    $0x0,%esi
	p = *sptr;
	p--;
	while (isdigit(((int) *p)))
  181247:	eb 0e                	jmp    181257 <_atoi+0x1a>
		i = 10 * i + *p++ - '0';
  181249:	8d 34 b6             	lea    (%esi,%esi,4),%esi
  18124c:	8d 0c 36             	lea    (%esi,%esi,1),%ecx
  18124f:	43                   	inc    %ebx
  181250:	0f be d2             	movsbl %dl,%edx
  181253:	8d 74 11 d0          	lea    -0x30(%ecx,%edx,1),%esi
	register int   i;

	i = 0;
	p = *sptr;
	p--;
	while (isdigit(((int) *p)))
  181257:	8a 13                	mov    (%ebx),%dl
	return ((((unsigned)c) >= ' ') && (((unsigned)c) <= '~'));
}

static inline int isdigit(int a)
{
	return (((unsigned)(a)-'0') < 10);
  181259:	0f be ca             	movsbl %dl,%ecx
  18125c:	83 e9 30             	sub    $0x30,%ecx
  18125f:	83 f9 09             	cmp    $0x9,%ecx
  181262:	76 e5                	jbe    181249 <_atoi+0xc>
		i = 10 * i + *p++ - '0';
	*sptr = p;
  181264:	89 18                	mov    %ebx,(%eax)
	return i;
}
  181266:	89 f0                	mov    %esi,%eax
  181268:	5b                   	pop    %ebx
  181269:	5e                   	pop    %esi
  18126a:	c3                   	ret    

0018126b <_prf>:

int _prf(int (*func)(), void *dest, char *format, va_list vargs)
{
  18126b:	55                   	push   %ebp
  18126c:	57                   	push   %edi
  18126d:	56                   	push   %esi
  18126e:	53                   	push   %ebx
  18126f:	81 ec f0 00 00 00    	sub    $0xf0,%esp
  181275:	89 c5                	mov    %eax,%ebp
  181277:	89 14 24             	mov    %edx,(%esp)
  18127a:	89 4c 24 20          	mov    %ecx,0x20(%esp)
	int32_t			*int32ptr_temp;
	int32_t			int32_temp;
	uint32_t			uint32_temp;
	uint64_t			double_temp;

	count = 0;
  18127e:	bf 00 00 00 00       	mov    $0x0,%edi

	while ((c = *format++)) {
  181283:	e9 e0 05 00 00       	jmp    181868 <_prf+0x5fd>
		if (c != '%') {
  181288:	83 f8 25             	cmp    $0x25,%eax
  18128b:	74 52                	je     1812df <_prf+0x74>
			if ((*func) (c, dest) == EOF) {
  18128d:	8b 14 24             	mov    (%esp),%edx
  181290:	ff d5                	call   *%ebp
  181292:	83 f8 ff             	cmp    $0xffffffff,%eax
  181295:	0f 84 f4 05 00 00    	je     18188f <_prf+0x624>
				return EOF;
			}

			count++;
  18129b:	47                   	inc    %edi
  18129c:	e9 c7 05 00 00       	jmp    181868 <_prf+0x5fd>
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
  1812a1:	80 fb 30             	cmp    $0x30,%bl
  1812a4:	77 5e                	ja     181304 <_prf+0x99>
  1812a6:	0f b6 db             	movzbl %bl,%ebx
  1812a9:	ff 24 9d ac 48 18 00 	jmp    *0x1848ac(,%ebx,4)
				case '-':
					fminus = true;
					break;

				case '+':
					fplus = true;
  1812b0:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1812b7:	00 
					break;
  1812b8:	eb 4a                	jmp    181304 <_prf+0x99>

				case ' ':
					fspace = true;
  1812ba:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  1812c1:	00 
					break;
  1812c2:	eb 40                	jmp    181304 <_prf+0x99>

				case '#':
					falt = true;
  1812c4:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  1812cb:	00 
					break;
  1812cc:	eb 36                	jmp    181304 <_prf+0x99>

				case '0':
					pad = '0';
  1812ce:	c6 44 24 0b 30       	movb   $0x30,0xb(%esp)
					break;
  1812d3:	eb 2f                	jmp    181304 <_prf+0x99>
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
				case '-':
					fminus = true;
  1812d5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1812dc:	00 
  1812dd:	eb 25                	jmp    181304 <_prf+0x99>
  1812df:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
  1812e4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  1812eb:	00 
  1812ec:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1812f3:	00 
  1812f4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1812fb:	00 
  1812fc:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  181303:	00 
		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
  181304:	8b 44 24 20          	mov    0x20(%esp),%eax
  181308:	8d 50 01             	lea    0x1(%eax),%edx
  18130b:	89 54 24 20          	mov    %edx,0x20(%esp)
  18130f:	8a 18                	mov    (%eax),%bl
  181311:	0f be f3             	movsbl %bl,%esi
  181314:	89 f2                	mov    %esi,%edx
  181316:	b8 a0 48 18 00       	mov    $0x1848a0,%eax
  18131b:	e8 c3 05 00 00       	call   1818e3 <strchr>
  181320:	85 c0                	test   %eax,%eax
  181322:	0f 85 79 ff ff ff    	jne    1812a1 <_prf+0x36>
				case '\0':
					return count;
				}
			}

			if (c == '*') {
  181328:	83 fe 2a             	cmp    $0x2a,%esi
  18132b:	75 37                	jne    181364 <_prf+0xf9>
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
  18132d:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181334:	8d 50 04             	lea    0x4(%eax),%edx
  181337:	8b 00                	mov    (%eax),%eax
  181339:	89 44 24 18          	mov    %eax,0x18(%esp)
				if (width < 0) {
  18133d:	85 c0                	test   %eax,%eax
  18133f:	79 0c                	jns    18134d <_prf+0xe2>
					fminus = true;
					width = -width;
  181341:	f7 5c 24 18          	negl   0x18(%esp)

			if (c == '*') {
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
				if (width < 0) {
					fminus = true;
  181345:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  18134c:	00 
					width = -width;
				}
				c = *format++;
  18134d:	8b 44 24 20          	mov    0x20(%esp),%eax
  181351:	8d 48 01             	lea    0x1(%eax),%ecx
  181354:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  181358:	0f be 30             	movsbl (%eax),%esi
				}
			}

			if (c == '*') {
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
  18135b:	89 94 24 04 01 00 00 	mov    %edx,0x104(%esp)
  181362:	eb 30                	jmp    181394 <_prf+0x129>
  181364:	0f be db             	movsbl %bl,%ebx
  181367:	83 eb 30             	sub    $0x30,%ebx
				if (width < 0) {
					fminus = true;
					width = -width;
				}
				c = *format++;
			} else if (!isdigit(c))
  18136a:	83 fb 09             	cmp    $0x9,%ebx
  18136d:	77 1d                	ja     18138c <_prf+0x121>
				width = 0;
			else {
				width = _atoi(&format);	/* Find width */
  18136f:	8d 44 24 20          	lea    0x20(%esp),%eax
  181373:	e8 c5 fe ff ff       	call   18123d <_atoi>
  181378:	89 44 24 18          	mov    %eax,0x18(%esp)
				c = *format++;
  18137c:	8b 44 24 20          	mov    0x20(%esp),%eax
  181380:	8d 50 01             	lea    0x1(%eax),%edx
  181383:	89 54 24 20          	mov    %edx,0x20(%esp)
  181387:	0f be 30             	movsbl (%eax),%esi
  18138a:	eb 08                	jmp    181394 <_prf+0x129>
					fminus = true;
					width = -width;
				}
				c = *format++;
			} else if (!isdigit(c))
				width = 0;
  18138c:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  181393:	00 
			 * If <width> is INT_MIN, then its absolute value can
			 * not be expressed as a positive number using 32-bit
			 * two's complement.  To cover that case, cast it to
			 * an unsigned before comparing it against MAXFLD.
			 */
			if ((unsigned) width > MAXFLD) {
  181394:	81 7c 24 18 c8 00 00 	cmpl   $0xc8,0x18(%esp)
  18139b:	00 
  18139c:	76 08                	jbe    1813a6 <_prf+0x13b>
				width = MAXFLD;
  18139e:	c7 44 24 18 c8 00 00 	movl   $0xc8,0x18(%esp)
  1813a5:	00 
			}

			if (c == '.') {
  1813a6:	83 fe 2e             	cmp    $0x2e,%esi
  1813a9:	75 5f                	jne    18140a <_prf+0x19f>
				c = *format++;
  1813ab:	8b 44 24 20          	mov    0x20(%esp),%eax
  1813af:	8d 50 01             	lea    0x1(%eax),%edx
  1813b2:	89 54 24 20          	mov    %edx,0x20(%esp)
				if (c == '*') {
  1813b6:	80 38 2a             	cmpb   $0x2a,(%eax)
  1813b9:	75 20                	jne    1813db <_prf+0x170>
					precision = (int32_t)
  1813bb:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1813c2:	8b 00                	mov    (%eax),%eax
  1813c4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1813c8:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1813cf:	8d 40 04             	lea    0x4(%eax),%eax
  1813d2:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
  1813d9:	eb 0d                	jmp    1813e8 <_prf+0x17d>
					va_arg(vargs, int32_t);
				} else
					precision = _atoi(&format);
  1813db:	8d 44 24 20          	lea    0x20(%esp),%eax
  1813df:	e8 59 fe ff ff       	call   18123d <_atoi>
  1813e4:	89 44 24 1c          	mov    %eax,0x1c(%esp)

				if (precision > MAXFLD)
  1813e8:	81 7c 24 1c c8 00 00 	cmpl   $0xc8,0x1c(%esp)
  1813ef:	00 
  1813f0:	7e 08                	jle    1813fa <_prf+0x18f>
					precision = -1;
  1813f2:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp)
  1813f9:	ff 
				c = *format++;
  1813fa:	8b 44 24 20          	mov    0x20(%esp),%eax
  1813fe:	8d 50 01             	lea    0x1(%eax),%edx
  181401:	89 54 24 20          	mov    %edx,0x20(%esp)
  181405:	0f be 30             	movsbl (%eax),%esi
  181408:	eb 08                	jmp    181412 <_prf+0x1a7>
			count++;

		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */
  18140a:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp)
  181411:	ff 
			 *    L: long double
			 *    z: size_t or ssize_t
			 * No further special processing is done for them.
			 */

			if (strchr("hlLz", c) != NULL) {
  181412:	89 f2                	mov    %esi,%edx
  181414:	b8 a6 48 18 00       	mov    $0x1848a6,%eax
  181419:	e8 c5 04 00 00       	call   1818e3 <strchr>
  18141e:	85 c0                	test   %eax,%eax
  181420:	74 0e                	je     181430 <_prf+0x1c5>
				i = c;
				c = *format++;
  181422:	8b 44 24 20          	mov    0x20(%esp),%eax
  181426:	8d 50 01             	lea    0x1(%eax),%edx
  181429:	89 54 24 20          	mov    %edx,0x20(%esp)
  18142d:	0f be 30             	movsbl (%eax),%esi
				 */
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
  181430:	83 fe 78             	cmp    $0x78,%esi
  181433:	0f 87 e3 02 00 00    	ja     18171c <_prf+0x4b1>
  181439:	ff 24 b5 70 49 18 00 	jmp    *0x184970(,%esi,4)
			case 'c':
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
  181440:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181447:	8b 00                	mov    (%eax),%eax
  181449:	88 44 24 27          	mov    %al,0x27(%esp)
				buf[1] = '\0';
  18144d:	c6 44 24 28 00       	movb   $0x0,0x28(%esp)

			need_justifying = false;
			prefix = 0;
			switch (c) {
			case 'c':
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
  181452:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181459:	8d 40 04             	lea    0x4(%eax),%eax
  18145c:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181463:	bb 00 00 00 00       	mov    $0x0,%ebx
			switch (c) {
			case 'c':
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
				buf[1] = '\0';
				need_justifying = true;
  181468:	b8 01 00 00 00       	mov    $0x1,%eax
				c = 1;
  18146d:	be 01 00 00 00       	mov    $0x1,%esi
				break;
  181472:	e9 67 03 00 00       	jmp    1817de <_prf+0x573>

			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
  181477:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18147e:	83 c0 04             	add    $0x4,%eax
  181481:	89 44 24 14          	mov    %eax,0x14(%esp)
  181485:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18148c:	8b 18                	mov    (%eax),%ebx
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
  18148e:	ff 74 24 1c          	pushl  0x1c(%esp)
  181492:	ff 74 24 14          	pushl  0x14(%esp)
  181496:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  18149a:	89 da                	mov    %ebx,%edx
  18149c:	8d 44 24 2f          	lea    0x2f(%esp),%eax
  1814a0:	e8 e2 f7 ff ff       	call   180c87 <_to_dec>
  1814a5:	83 c4 08             	add    $0x8,%esp
  1814a8:	89 c6                	mov    %eax,%esi
				if (fplus || fspace || (int32_temp < 0))
  1814aa:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1814ae:	0b 44 24 10          	or     0x10(%esp),%eax
  1814b2:	75 0b                	jne    1814bf <_prf+0x254>
  1814b4:	85 db                	test   %ebx,%ebx
  1814b6:	78 0e                	js     1814c6 <_prf+0x25b>
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1814b8:	bb 00 00 00 00       	mov    $0x0,%ebx
  1814bd:	eb 0c                	jmp    1814cb <_prf+0x260>
			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
  1814bf:	bb 01 00 00 00       	mov    $0x1,%ebx
  1814c4:	eb 05                	jmp    1814cb <_prf+0x260>
  1814c6:	bb 01 00 00 00       	mov    $0x1,%ebx
				need_justifying = true;
				if (precision != -1)
  1814cb:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1814d0:	0f 85 55 02 00 00    	jne    18172b <_prf+0x4c0>
				c = 1;
				break;

			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
  1814d6:	8b 44 24 14          	mov    0x14(%esp),%eax
  1814da:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
				need_justifying = true;
  1814e1:	b8 01 00 00 00       	mov    $0x1,%eax
  1814e6:	e9 f3 02 00 00       	jmp    1817de <_prf+0x573>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  1814eb:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1814f2:	8d 58 08             	lea    0x8(%eax),%ebx
  1814f5:	8b 10                	mov    (%eax),%edx
  1814f7:	8b 48 04             	mov    0x4(%eax),%ecx
				double_temp = u.i;
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
  1814fa:	ff 74 24 1c          	pushl  0x1c(%esp)
  1814fe:	ff 74 24 14          	pushl  0x14(%esp)
  181502:	ff 74 24 14          	pushl  0x14(%esp)
  181506:	ff 74 24 20          	pushl  0x20(%esp)
  18150a:	56                   	push   %esi
  18150b:	8d 44 24 3b          	lea    0x3b(%esp),%eax
  18150f:	e8 d8 f8 ff ff       	call   180dec <_to_float>
  181514:	83 c4 14             	add    $0x14,%esp
  181517:	89 c6                	mov    %eax,%esi
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
  181519:	8b 44 24 0c          	mov    0xc(%esp),%eax
  18151d:	0b 44 24 10          	or     0x10(%esp),%eax
  181521:	0f 85 1e 02 00 00    	jne    181745 <_prf+0x4da>
  181527:	80 7c 24 27 2d       	cmpb   $0x2d,0x27(%esp)
  18152c:	0f 84 29 02 00 00    	je     18175b <_prf+0x4f0>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  181532:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181539:	bb 00 00 00 00       	mov    $0x0,%ebx

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
					prefix = 1;
				need_justifying = true;
  18153e:	b8 01 00 00 00       	mov    $0x1,%eax
  181543:	e9 96 02 00 00       	jmp    1817de <_prf+0x573>
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
  181548:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18154f:	8b 00                	mov    (%eax),%eax
				*int32ptr_temp = count;
  181551:	89 38                	mov    %edi,(%eax)
					prefix = 1;
				need_justifying = true;
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
  181553:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18155a:	8d 40 04             	lea    0x4(%eax),%eax
  18155d:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181564:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  181569:	b8 00 00 00 00       	mov    $0x0,%eax
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;
  18156e:	e9 6b 02 00 00       	jmp    1817de <_prf+0x573>

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181573:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18157a:	8d 58 04             	lea    0x4(%eax),%ebx
  18157d:	8b 10                	mov    (%eax),%edx
				c = _to_octal(buf, uint32_temp, falt, precision);
  18157f:	ff 74 24 1c          	pushl  0x1c(%esp)
  181583:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  181587:	8d 44 24 2b          	lea    0x2b(%esp),%eax
  18158b:	e8 b1 f6 ff ff       	call   180c41 <_to_octal>
  181590:	83 c4 04             	add    $0x4,%esp
  181593:	89 c6                	mov    %eax,%esi
				need_justifying = true;
				if (precision != -1)
  181595:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  18159a:	0f 85 ce 01 00 00    	jne    18176e <_prf+0x503>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1815a0:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1815a7:	bb 00 00 00 00       	mov    $0x0,%ebx
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_octal(buf, uint32_temp, falt, precision);
				need_justifying = true;
  1815ac:	b8 01 00 00 00       	mov    $0x1,%eax
  1815b1:	e9 28 02 00 00       	jmp    1817de <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1815b6:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1815bd:	8d 58 04             	lea    0x4(%eax),%ebx
  1815c0:	8b 10                	mov    (%eax),%edx
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
  1815c2:	6a 78                	push   $0x78
  1815c4:	6a 08                	push   $0x8
  1815c6:	b9 01 00 00 00       	mov    $0x1,%ecx
  1815cb:	8d 44 24 2f          	lea    0x2f(%esp),%eax
  1815cf:	e8 2a f6 ff ff       	call   180bfe <_to_hex>
  1815d4:	83 c4 08             	add    $0x8,%esp
  1815d7:	89 c6                	mov    %eax,%esi
				need_justifying = true;
				if (precision != -1)
  1815d9:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1815de:	0f 85 a2 01 00 00    	jne    181786 <_prf+0x51b>
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1815e4:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1815eb:	bb 00 00 00 00       	mov    $0x0,%ebx
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
				need_justifying = true;
  1815f0:	b8 01 00 00 00       	mov    $0x1,%eax
  1815f5:	e9 e4 01 00 00       	jmp    1817de <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
  1815fa:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181601:	8d 58 04             	lea    0x4(%eax),%ebx
  181604:	8b 10                	mov    (%eax),%edx
				/* Get the string length */
				for (c = 0; c < MAXFLD; c++) {
  181606:	be 00 00 00 00       	mov    $0x0,%esi
  18160b:	eb 07                	jmp    181614 <_prf+0x3a9>
					if (cptr_temp[c] == '\0') {
  18160d:	80 3c 32 00          	cmpb   $0x0,(%edx,%esi,1)
  181611:	74 09                	je     18161c <_prf+0x3b1>
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
				/* Get the string length */
				for (c = 0; c < MAXFLD; c++) {
  181613:	46                   	inc    %esi
  181614:	81 fe c7 00 00 00    	cmp    $0xc7,%esi
  18161a:	7e f1                	jle    18160d <_prf+0x3a2>
					if (cptr_temp[c] == '\0') {
						break;
					}
				}
				if ((precision >= 0) && (precision < c))
  18161c:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  181620:	89 c8                	mov    %ecx,%eax
  181622:	f7 d0                	not    %eax
  181624:	c1 e8 1f             	shr    $0x1f,%eax
  181627:	39 ce                	cmp    %ecx,%esi
  181629:	0f 9f c1             	setg   %cl
  18162c:	84 c1                	test   %al,%cl
  18162e:	74 04                	je     181634 <_prf+0x3c9>
					c = precision;
  181630:	8b 74 24 1c          	mov    0x1c(%esp),%esi
				if (c > 0) {
  181634:	85 f6                	test   %esi,%esi
  181636:	0f 8e 62 01 00 00    	jle    18179e <_prf+0x533>
					memcpy(buf, cptr_temp, (size_t) c);
  18163c:	89 f1                	mov    %esi,%ecx
  18163e:	8d 44 24 27          	lea    0x27(%esp),%eax
  181642:	e8 ff 02 00 00       	call   181946 <memcpy>
				if (precision != -1)
					pad = ' ';
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
  181647:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18164e:	bb 00 00 00 00       	mov    $0x0,%ebx
				}
				if ((precision >= 0) && (precision < c))
					c = precision;
				if (c > 0) {
					memcpy(buf, cptr_temp, (size_t) c);
					need_justifying = true;
  181653:	b8 01 00 00 00       	mov    $0x1,%eax
  181658:	e9 81 01 00 00       	jmp    1817de <_prf+0x573>
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  18165d:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181664:	8d 58 04             	lea    0x4(%eax),%ebx
  181667:	8b 10                	mov    (%eax),%edx
				c = _to_udec(buf, uint32_temp, precision);
  181669:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  18166d:	8d 44 24 27          	lea    0x27(%esp),%eax
  181671:	e8 02 f6 ff ff       	call   180c78 <_to_udec>
  181676:	89 c6                	mov    %eax,%esi
				need_justifying = true;
				if (precision != -1)
  181678:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  18167d:	0f 85 2e 01 00 00    	jne    1817b1 <_prf+0x546>
					need_justifying = true;
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181683:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18168a:	bb 00 00 00 00       	mov    $0x0,%ebx
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_udec(buf, uint32_temp, precision);
				need_justifying = true;
  18168f:	b8 01 00 00 00       	mov    $0x1,%eax
  181694:	e9 45 01 00 00       	jmp    1817de <_prf+0x573>
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181699:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1816a0:	83 c0 04             	add    $0x4,%eax
  1816a3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1816a7:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1816ae:	8b 10                	mov    (%eax),%edx
				c = _to_hex(buf, uint32_temp, falt, precision, c);
  1816b0:	56                   	push   %esi
  1816b1:	ff 74 24 20          	pushl  0x20(%esp)
  1816b5:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  1816b9:	89 d9                	mov    %ebx,%ecx
  1816bb:	8d 44 24 2f          	lea    0x2f(%esp),%eax
  1816bf:	e8 3a f5 ff ff       	call   180bfe <_to_hex>
  1816c4:	83 c4 08             	add    $0x8,%esp
  1816c7:	89 c6                	mov    %eax,%esi
				if (falt)
  1816c9:	85 db                	test   %ebx,%ebx
  1816cb:	75 07                	jne    1816d4 <_prf+0x469>
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1816cd:	bb 00 00 00 00       	mov    $0x0,%ebx
  1816d2:	eb 05                	jmp    1816d9 <_prf+0x46e>
			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
  1816d4:	bb 02 00 00 00       	mov    $0x2,%ebx
				need_justifying = true;
				if (precision != -1)
  1816d9:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1816de:	0f 85 e5 00 00 00    	jne    1817c9 <_prf+0x55e>
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1816e4:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1816e8:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
				need_justifying = true;
  1816ef:	b8 01 00 00 00       	mov    $0x1,%eax
  1816f4:	e9 e5 00 00 00       	jmp    1817de <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case '%':
				if ((*func)('%', dest) == EOF) {
  1816f9:	8b 14 24             	mov    (%esp),%edx
  1816fc:	b8 25 00 00 00       	mov    $0x25,%eax
  181701:	ff d5                	call   *%ebp
  181703:	83 f8 ff             	cmp    $0xffffffff,%eax
  181706:	0f 84 83 01 00 00    	je     18188f <_prf+0x624>
					return EOF;
				}

				count++;
  18170c:	47                   	inc    %edi
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18170d:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  181712:	b8 00 00 00 00       	mov    $0x0,%eax
				if ((*func)('%', dest) == EOF) {
					return EOF;
				}

				count++;
				break;
  181717:	e9 c2 00 00 00       	jmp    1817de <_prf+0x573>
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18171c:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  181721:	b8 00 00 00 00       	mov    $0x0,%eax
  181726:	e9 b3 00 00 00       	jmp    1817de <_prf+0x573>
				c = 1;
				break;

			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
  18172b:	8b 44 24 14          	mov    0x14(%esp),%eax
  18172f:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  181736:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
				need_justifying = true;
  18173b:	b8 01 00 00 00       	mov    $0x1,%eax
  181740:	e9 99 00 00 00       	jmp    1817de <_prf+0x573>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  181745:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
					prefix = 1;
  18174c:	bb 01 00 00 00       	mov    $0x1,%ebx
				need_justifying = true;
  181751:	b8 01 00 00 00       	mov    $0x1,%eax
  181756:	e9 83 00 00 00       	jmp    1817de <_prf+0x573>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  18175b:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
					prefix = 1;
  181762:	bb 01 00 00 00       	mov    $0x1,%ebx
				need_justifying = true;
  181767:	b8 01 00 00 00       	mov    $0x1,%eax
  18176c:	eb 70                	jmp    1817de <_prf+0x573>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  18176e:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181775:	bb 00 00 00 00       	mov    $0x0,%ebx
			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_octal(buf, uint32_temp, falt, precision);
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  18177a:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_octal(buf, uint32_temp, falt, precision);
				need_justifying = true;
  18177f:	b8 01 00 00 00       	mov    $0x1,%eax
  181784:	eb 58                	jmp    1817de <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181786:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18178d:	bb 00 00 00 00       	mov    $0x0,%ebx
			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  181792:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
				need_justifying = true;
  181797:	b8 01 00 00 00       	mov    $0x1,%eax
  18179c:	eb 40                	jmp    1817de <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
  18179e:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1817a5:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  1817aa:	b8 00 00 00 00       	mov    $0x0,%eax
  1817af:	eb 2d                	jmp    1817de <_prf+0x573>
					need_justifying = true;
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1817b1:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1817b8:	bb 00 00 00 00       	mov    $0x0,%ebx
			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_udec(buf, uint32_temp, precision);
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  1817bd:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_udec(buf, uint32_temp, precision);
				need_justifying = true;
  1817c2:	b8 01 00 00 00       	mov    $0x1,%eax
  1817c7:	eb 15                	jmp    1817de <_prf+0x573>
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1817c9:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1817cd:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  1817d4:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
				need_justifying = true;
  1817d9:	b8 01 00 00 00       	mov    $0x1,%eax

			case 0:
				return count;
			}

			if (c >= MAXFLD + 1)
  1817de:	81 fe c8 00 00 00    	cmp    $0xc8,%esi
  1817e4:	0f 8f a0 00 00 00    	jg     18188a <_prf+0x61f>
				return EOF;

			if (need_justifying) {
  1817ea:	85 c0                	test   %eax,%eax
  1817ec:	74 7a                	je     181868 <_prf+0x5fd>
				if (c < width) {
  1817ee:	3b 74 24 18          	cmp    0x18(%esp),%esi
  1817f2:	7d 5a                	jge    18184e <_prf+0x5e3>
					if (fminus)	{
  1817f4:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  1817f9:	75 0a                	jne    181805 <_prf+0x59a>
  1817fb:	eb 16                	jmp    181813 <_prf+0x5a8>
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
  1817fd:	c6 44 34 27 20       	movb   $0x20,0x27(%esp,%esi,1)

			if (need_justifying) {
				if (c < width) {
					if (fminus)	{
						/* Left justify? */
						for (i = c; i < width; i++)
  181802:	46                   	inc    %esi
  181803:	eb 04                	jmp    181809 <_prf+0x59e>
  181805:	8b 44 24 18          	mov    0x18(%esp),%eax
  181809:	39 c6                	cmp    %eax,%esi
  18180b:	7c f0                	jl     1817fd <_prf+0x592>
							prefix = 0;
						c = width - c + prefix;
						for (i = prefix; i < c; i++)
							buf[i] = pad;
					}
					c = width;
  18180d:	8b 74 24 18          	mov    0x18(%esp),%esi
  181811:	eb 3b                	jmp    18184e <_prf+0x5e3>
						for (i = c; i < width; i++)
							buf[i] = ' ';
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
  181813:	8d 4e 01             	lea    0x1(%esi),%ecx
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
  181816:	8b 44 24 18          	mov    0x18(%esp),%eax
  18181a:	29 f0                	sub    %esi,%eax
  18181c:	89 c6                	mov    %eax,%esi
  18181e:	8d 44 24 27          	lea    0x27(%esp),%eax
  181822:	01 f0                	add    %esi,%eax
  181824:	8d 54 24 27          	lea    0x27(%esp),%edx
  181828:	e8 ec 00 00 00       	call   181919 <memmove>
										+ 1));
						if (pad == ' ')
  18182d:	80 7c 24 0b 20       	cmpb   $0x20,0xb(%esp)
  181832:	75 05                	jne    181839 <_prf+0x5ce>
							prefix = 0;
  181834:	bb 00 00 00 00       	mov    $0x0,%ebx
						c = width - c + prefix;
  181839:	01 de                	add    %ebx,%esi
  18183b:	8a 44 24 0b          	mov    0xb(%esp),%al
						for (i = prefix; i < c; i++)
  18183f:	eb 05                	jmp    181846 <_prf+0x5db>
							buf[i] = pad;
  181841:	88 44 1c 27          	mov    %al,0x27(%esp,%ebx,1)
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
						if (pad == ' ')
							prefix = 0;
						c = width - c + prefix;
						for (i = prefix; i < c; i++)
  181845:	43                   	inc    %ebx
  181846:	39 f3                	cmp    %esi,%ebx
  181848:	7c f7                	jl     181841 <_prf+0x5d6>
							buf[i] = pad;
					}
					c = width;
  18184a:	8b 74 24 18          	mov    0x18(%esp),%esi
  18184e:	8d 5c 24 27          	lea    0x27(%esp),%ebx
  181852:	eb 10                	jmp    181864 <_prf+0x5f9>
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
					if ((*func)(*cptr, dest) == EOF)
  181854:	0f be 03             	movsbl (%ebx),%eax
  181857:	8b 14 24             	mov    (%esp),%edx
  18185a:	ff d5                	call   *%ebp
  18185c:	83 f8 ff             	cmp    $0xffffffff,%eax
  18185f:	74 2e                	je     18188f <_prf+0x624>
							buf[i] = pad;
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
  181861:	4e                   	dec    %esi
  181862:	43                   	inc    %ebx
  181863:	47                   	inc    %edi
  181864:	85 f6                	test   %esi,%esi
  181866:	7f ec                	jg     181854 <_prf+0x5e9>
	uint32_t			uint32_temp;
	uint64_t			double_temp;

	count = 0;

	while ((c = *format++)) {
  181868:	8b 44 24 20          	mov    0x20(%esp),%eax
  18186c:	8d 50 01             	lea    0x1(%eax),%edx
  18186f:	89 54 24 20          	mov    %edx,0x20(%esp)
  181873:	0f be 00             	movsbl (%eax),%eax
  181876:	85 c0                	test   %eax,%eax
  181878:	0f 85 0a fa ff ff    	jne    181288 <_prf+0x1d>
						return EOF;
				}
			}
		}
	}
	return count;
  18187e:	89 f8                	mov    %edi,%eax
  181880:	eb 0d                	jmp    18188f <_prf+0x624>
				case '0':
					pad = '0';
					break;

				case '\0':
					return count;
  181882:	89 f8                	mov    %edi,%eax
  181884:	eb 09                	jmp    18188f <_prf+0x624>

				count++;
				break;

			case 0:
				return count;
  181886:	89 f8                	mov    %edi,%eax
  181888:	eb 05                	jmp    18188f <_prf+0x624>
			}

			if (c >= MAXFLD + 1)
				return EOF;
  18188a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
				}
			}
		}
	}
	return count;
}
  18188f:	81 c4 f0 00 00 00    	add    $0xf0,%esp
  181895:	5b                   	pop    %ebx
  181896:	5e                   	pop    %esi
  181897:	5f                   	pop    %edi
  181898:	5d                   	pop    %ebp
  181899:	c3                   	ret    

0018189a <sprintf_out>:
	int len;
};

static int sprintf_out(int c, struct emitter *p)
{
	if (p->len > 1) { /* need to reserve a byte for EOS */
  18189a:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)
  18189e:	7e 09                	jle    1818a9 <sprintf_out+0xf>
		*(p->ptr) = c;
  1818a0:	8b 0a                	mov    (%edx),%ecx
  1818a2:	88 01                	mov    %al,(%ecx)
		p->ptr += 1;
  1818a4:	ff 02                	incl   (%edx)
		p->len -= 1;
  1818a6:	ff 4a 04             	decl   0x4(%edx)
	}
	return 0; /* indicate keep going so we get the total count */
}
  1818a9:	b8 00 00 00 00       	mov    $0x0,%eax
  1818ae:	c3                   	ret    

001818af <sprintf>:
	*(p.ptr) = 0;
	return r;
}

int sprintf(char *_MLIBC_RESTRICT s, const char *_MLIBC_RESTRICT format, ...)
{
  1818af:	83 ec 08             	sub    $0x8,%esp
	va_list vargs;

	struct emitter p;
	int     r;

	p.ptr = s;
  1818b2:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1818b6:	89 04 24             	mov    %eax,(%esp)
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
  1818b9:	c7 44 24 04 ff ff ff 	movl   $0x7fffffff,0x4(%esp)
  1818c0:	7f 

	va_start(vargs, format);
  1818c1:	8d 44 24 14          	lea    0x14(%esp),%eax
	r = _prf(sprintf_out, (void *) (&p), format, vargs);
  1818c5:	50                   	push   %eax
  1818c6:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  1818ca:	8d 54 24 04          	lea    0x4(%esp),%edx
  1818ce:	b8 9a 18 18 00       	mov    $0x18189a,%eax
  1818d3:	e8 93 f9 ff ff       	call   18126b <_prf>
	va_end(vargs);

	*(p.ptr) = 0;
  1818d8:	8b 54 24 04          	mov    0x4(%esp),%edx
  1818dc:	c6 02 00             	movb   $0x0,(%edx)
	return r;
}
  1818df:	83 c4 0c             	add    $0xc,%esp
  1818e2:	c3                   	ret    

001818e3 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
  1818e3:	53                   	push   %ebx
	char tmp = (char) c;
  1818e4:	88 d3                	mov    %dl,%bl

	while ((*s != tmp) && (*s != '\0'))
  1818e6:	eb 01                	jmp    1818e9 <strchr+0x6>
		s++;
  1818e8:	40                   	inc    %eax

char *strchr(const char *s, int c)
{
	char tmp = (char) c;

	while ((*s != tmp) && (*s != '\0'))
  1818e9:	8a 08                	mov    (%eax),%cl
  1818eb:	38 cb                	cmp    %cl,%bl
  1818ed:	74 04                	je     1818f3 <strchr+0x10>
  1818ef:	84 c9                	test   %cl,%cl
  1818f1:	75 f5                	jne    1818e8 <strchr+0x5>
		s++;

	return (*s == tmp) ? (char *) s : NULL;
  1818f3:	38 ca                	cmp    %cl,%dl
  1818f5:	74 05                	je     1818fc <strchr+0x19>
  1818f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1818fc:	5b                   	pop    %ebx
  1818fd:	c3                   	ret    

001818fe <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  1818fe:	53                   	push   %ebx
	while ((*s1 == *s2) && (*s1 != '\0')) {
  1818ff:	eb 02                	jmp    181903 <strcmp+0x5>
		s1++;
  181901:	40                   	inc    %eax
		s2++;
  181902:	42                   	inc    %edx
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
  181903:	8a 08                	mov    (%eax),%cl
  181905:	8a 1a                	mov    (%edx),%bl
  181907:	38 d9                	cmp    %bl,%cl
  181909:	75 04                	jne    18190f <strcmp+0x11>
  18190b:	84 c9                	test   %cl,%cl
  18190d:	75 f2                	jne    181901 <strcmp+0x3>
		s1++;
		s2++;
	}

	return *s1 - *s2;
  18190f:	0f be c1             	movsbl %cl,%eax
  181912:	0f be db             	movsbl %bl,%ebx
  181915:	29 d8                	sub    %ebx,%eax
}
  181917:	5b                   	pop    %ebx
  181918:	c3                   	ret    

00181919 <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
  181919:	56                   	push   %esi
  18191a:	53                   	push   %ebx
  18191b:	89 c6                	mov    %eax,%esi
	char *dest = d;
	const char *src  = s;

	if ((size_t) (d - s) < n) {
  18191d:	89 c3                	mov    %eax,%ebx
  18191f:	29 d3                	sub    %edx,%ebx
  181921:	39 cb                	cmp    %ecx,%ebx
  181923:	72 0b                	jb     181930 <memmove+0x17>
  181925:	89 c3                	mov    %eax,%ebx
  181927:	eb 14                	jmp    18193d <memmove+0x24>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
  181929:	49                   	dec    %ecx
			dest[n] = src[n];
  18192a:	8a 1c 0a             	mov    (%edx,%ecx,1),%bl
  18192d:	88 1c 0e             	mov    %bl,(%esi,%ecx,1)
		/*
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
  181930:	85 c9                	test   %ecx,%ecx
  181932:	75 f5                	jne    181929 <memmove+0x10>
  181934:	eb 0b                	jmp    181941 <memmove+0x28>
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
			*dest = *src;
  181936:	8a 02                	mov    (%edx),%al
  181938:	88 03                	mov    %al,(%ebx)
			dest++;
  18193a:	43                   	inc    %ebx
			src++;
  18193b:	42                   	inc    %edx
			n--;
  18193c:	49                   	dec    %ecx
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
  18193d:	85 c9                	test   %ecx,%ecx
  18193f:	75 f5                	jne    181936 <memmove+0x1d>
			n--;
		}
	}

	return d;
}
  181941:	89 f0                	mov    %esi,%eax
  181943:	5b                   	pop    %ebx
  181944:	5e                   	pop    %esi
  181945:	c3                   	ret    

00181946 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
  181946:	56                   	push   %esi
  181947:	53                   	push   %ebx
  181948:	89 c6                	mov    %eax,%esi
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
  18194a:	89 c3                	mov    %eax,%ebx
  18194c:	31 d3                	xor    %edx,%ebx
  18194e:	f6 c3 03             	test   $0x3,%bl
  181951:	74 15                	je     181968 <memcpy+0x22>

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
  181953:	89 c3                	mov    %eax,%ebx
  181955:	eb 39                	jmp    181990 <memcpy+0x4a>
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
			if (n == 0) {
  181957:	85 c9                	test   %ecx,%ecx
  181959:	74 39                	je     181994 <memcpy+0x4e>
				return d;
			}
			*(d_byte++) = *(s_byte++);
  18195b:	8a 02                	mov    (%edx),%al
  18195d:	88 03                	mov    %al,(%ebx)
			n--;
  18195f:	49                   	dec    %ecx

		while (((unsigned int)d_byte) & 0x3) {
			if (n == 0) {
				return d;
			}
			*(d_byte++) = *(s_byte++);
  181960:	8d 52 01             	lea    0x1(%edx),%edx
  181963:	8d 5b 01             	lea    0x1(%ebx),%ebx
  181966:	eb 02                	jmp    18196a <memcpy+0x24>
  181968:	89 c3                	mov    %eax,%ebx

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
  18196a:	f6 c3 03             	test   $0x3,%bl
  18196d:	75 e8                	jne    181957 <memcpy+0x11>
  18196f:	eb 0d                	jmp    18197e <memcpy+0x38>

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
			*(d_word++) = *(s_word++);
  181971:	8b 02                	mov    (%edx),%eax
  181973:	89 03                	mov    %eax,(%ebx)
			n -= sizeof(unsigned int);
  181975:	83 e9 04             	sub    $0x4,%ecx

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
			*(d_word++) = *(s_word++);
  181978:	8d 52 04             	lea    0x4(%edx),%edx
  18197b:	8d 5b 04             	lea    0x4(%ebx),%ebx
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
  18197e:	83 f9 03             	cmp    $0x3,%ecx
  181981:	77 ee                	ja     181971 <memcpy+0x2b>
  181983:	eb 0b                	jmp    181990 <memcpy+0x4a>
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
  181985:	8a 02                	mov    (%edx),%al
  181987:	88 03                	mov    %al,(%ebx)
		n--;
  181989:	49                   	dec    %ecx
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
  18198a:	8d 52 01             	lea    0x1(%edx),%edx
  18198d:	8d 5b 01             	lea    0x1(%ebx),%ebx
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
  181990:	85 c9                	test   %ecx,%ecx
  181992:	75 f1                	jne    181985 <memcpy+0x3f>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
  181994:	89 f0                	mov    %esi,%eax
  181996:	5b                   	pop    %ebx
  181997:	5e                   	pop    %esi
  181998:	c3                   	ret    

00181999 <_nop_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  181999:	b8 00 00 00 00       	mov    $0x0,%eax
  18199e:	c3                   	ret    

0018199f <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
  18199f:	8b 0a                	mov    (%edx),%ecx
  1819a1:	41                   	inc    %ecx
  1819a2:	89 0a                	mov    %ecx,(%edx)
	return _char_out(c);
  1819a4:	ff 15 10 00 28 00    	call   *0x280010
}
  1819aa:	c3                   	ret    

001819ab <_printk_hex_ulong>:
 * @return N/A
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  1819ab:	55                   	push   %ebp
  1819ac:	57                   	push   %edi
  1819ad:	56                   	push   %esi
  1819ae:	53                   	push   %ebx
  1819af:	83 ec 08             	sub    $0x8,%esp
  1819b2:	89 c5                	mov    %eax,%ebp
  1819b4:	89 14 24             	mov    %edx,(%esp)
  1819b7:	89 cf                	mov    %ecx,%edi
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
  1819b9:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  1819c0:	00 
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
  1819c1:	bb 00 00 00 00       	mov    $0x0,%ebx
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
  1819c6:	ba 08 00 00 00       	mov    $0x8,%edx
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  1819cb:	eb 65                	jmp    181a32 <_printk_hex_ulong+0x87>
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  1819cd:	8d 72 ff             	lea    -0x1(%edx),%esi
  1819d0:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  1819d7:	89 f8                	mov    %edi,%eax
  1819d9:	d3 e8                	shr    %cl,%eax

		if (nibble || found_largest_digit || size == 1) {
  1819db:	83 e0 0f             	and    $0xf,%eax
  1819de:	0f 95 c1             	setne  %cl
  1819e1:	08 d9                	or     %bl,%cl
  1819e3:	75 05                	jne    1819ea <_printk_hex_ulong+0x3f>
  1819e5:	83 fa 01             	cmp    $0x1,%edx
  1819e8:	75 1b                	jne    181a05 <_printk_hex_ulong+0x5a>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
  1819ea:	3c 09                	cmp    $0x9,%al
  1819ec:	7e 04                	jle    1819f2 <_printk_hex_ulong+0x47>
  1819ee:	b2 57                	mov    $0x57,%dl
  1819f0:	eb 02                	jmp    1819f4 <_printk_hex_ulong+0x49>
  1819f2:	b2 30                	mov    $0x30,%dl
  1819f4:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
  1819f6:	0f be c0             	movsbl %al,%eax
  1819f9:	8b 14 24             	mov    (%esp),%edx
  1819fc:	ff d5                	call   *%ebp

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  1819fe:	bb 01 00 00 00       	mov    $0x1,%ebx
			nibble += nibble > 9 ? 87 : 48;
			out((int)nibble, ctx);
			continue;
  181a03:	eb 2b                	jmp    181a30 <_printk_hex_ulong+0x85>
		}

		if (remaining-- <= min_width) {
  181a05:	8b 44 24 04          	mov    0x4(%esp),%eax
  181a09:	8d 48 ff             	lea    -0x1(%eax),%ecx
  181a0c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  181a10:	3b 44 24 20          	cmp    0x20(%esp),%eax
  181a14:	7f 1a                	jg     181a30 <_printk_hex_ulong+0x85>
			out((int)(pad_zero ? '0' : ' '), ctx);
  181a16:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  181a1b:	74 07                	je     181a24 <_printk_hex_ulong+0x79>
  181a1d:	b8 30 00 00 00       	mov    $0x30,%eax
  181a22:	eb 05                	jmp    181a29 <_printk_hex_ulong+0x7e>
  181a24:	b8 20 00 00 00       	mov    $0x20,%eax
  181a29:	8b 14 24             	mov    (%esp),%edx
  181a2c:	ff d5                	call   *%ebp
  181a2e:	eb 00                	jmp    181a30 <_printk_hex_ulong+0x85>

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  181a30:	89 f2                	mov    %esi,%edx
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  181a32:	85 d2                	test   %edx,%edx
  181a34:	75 97                	jne    1819cd <_printk_hex_ulong+0x22>

		if (remaining-- <= min_width) {
			out((int)(pad_zero ? '0' : ' '), ctx);
		}
	}
}
  181a36:	83 c4 08             	add    $0x8,%esp
  181a39:	5b                   	pop    %ebx
  181a3a:	5e                   	pop    %esi
  181a3b:	5f                   	pop    %edi
  181a3c:	5d                   	pop    %ebp
  181a3d:	c3                   	ret    

00181a3e <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  181a3e:	55                   	push   %ebp
  181a3f:	57                   	push   %edi
  181a40:	56                   	push   %esi
  181a41:	53                   	push   %ebx
  181a42:	83 ec 08             	sub    $0x8,%esp
  181a45:	89 c5                	mov    %eax,%ebp
  181a47:	89 54 24 04          	mov    %edx,0x4(%esp)
	unsigned long remainder = num;
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  181a4b:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  181a50:	7f 08                	jg     181a5a <_printk_dec_ulong+0x1c>
		min_width = 1;
  181a52:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  181a59:	00 
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  181a5a:	89 0c 24             	mov    %ecx,(%esp)
  181a5d:	bf 0a 00 00 00       	mov    $0xa,%edi
  181a62:	bb 00 00 00 00       	mov    $0x0,%ebx
  181a67:	be ff c9 9a 3b       	mov    $0x3b9ac9ff,%esi
  181a6c:	eb 65                	jmp    181ad3 <_printk_dec_ulong+0x95>
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  181a6e:	3b 34 24             	cmp    (%esp),%esi
  181a71:	0f 92 c0             	setb   %al
  181a74:	08 d8                	or     %bl,%al
  181a76:	74 1d                	je     181a95 <_printk_dec_ulong+0x57>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
  181a78:	8d 4e 01             	lea    0x1(%esi),%ecx
  181a7b:	8b 04 24             	mov    (%esp),%eax
  181a7e:	ba 00 00 00 00       	mov    $0x0,%edx
  181a83:	f7 f1                	div    %ecx
  181a85:	83 c0 30             	add    $0x30,%eax
  181a88:	8b 54 24 04          	mov    0x4(%esp),%edx
  181a8c:	ff d5                	call   *%ebp
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  181a8e:	bb 01 00 00 00       	mov    $0x1,%ebx
  181a93:	eb 1f                	jmp    181ab4 <_printk_dec_ulong+0x76>
			out((int)((remainder / (pos + 1)) + 48), ctx);
		} else if (remaining <= min_width) {
  181a95:	3b 7c 24 20          	cmp    0x20(%esp),%edi
  181a99:	7f 19                	jg     181ab4 <_printk_dec_ulong+0x76>
			out((int)(pad_zero ? '0' : ' '), ctx);
  181a9b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  181aa0:	74 07                	je     181aa9 <_printk_dec_ulong+0x6b>
  181aa2:	b8 30 00 00 00       	mov    $0x30,%eax
  181aa7:	eb 05                	jmp    181aae <_printk_dec_ulong+0x70>
  181aa9:	b8 20 00 00 00       	mov    $0x20,%eax
  181aae:	8b 54 24 04          	mov    0x4(%esp),%edx
  181ab2:	ff d5                	call   *%ebp
		}
		remaining--;
  181ab4:	4f                   	dec    %edi
		remainder %= (pos + 1);
  181ab5:	8d 4e 01             	lea    0x1(%esi),%ecx
  181ab8:	8b 04 24             	mov    (%esp),%eax
  181abb:	ba 00 00 00 00       	mov    $0x0,%edx
  181ac0:	f7 f1                	div    %ecx
  181ac2:	89 14 24             	mov    %edx,(%esp)
		pos /= 10;
  181ac5:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  181aca:	89 f0                	mov    %esi,%eax
  181acc:	f7 e2                	mul    %edx
  181ace:	89 d6                	mov    %edx,%esi
  181ad0:	c1 ee 03             	shr    $0x3,%esi
	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
  181ad3:	83 fe 08             	cmp    $0x8,%esi
  181ad6:	77 96                	ja     181a6e <_printk_dec_ulong+0x30>
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
	}
	out((int)(remainder + 48), ctx);
  181ad8:	8b 04 24             	mov    (%esp),%eax
  181adb:	83 c0 30             	add    $0x30,%eax
  181ade:	8b 54 24 04          	mov    0x4(%esp),%edx
  181ae2:	ff d5                	call   *%ebp
}
  181ae4:	83 c4 08             	add    $0x8,%esp
  181ae7:	5b                   	pop    %ebx
  181ae8:	5e                   	pop    %esi
  181ae9:	5f                   	pop    %edi
  181aea:	5d                   	pop    %ebp
  181aeb:	c3                   	ret    

00181aec <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  181aec:	a3 10 00 28 00       	mov    %eax,0x280010
  181af1:	c3                   	ret    

00181af2 <_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
  181af2:	55                   	push   %ebp
  181af3:	57                   	push   %edi
  181af4:	56                   	push   %esi
  181af5:	53                   	push   %ebx
  181af6:	83 ec 10             	sub    $0x10,%esp
  181af9:	89 c7                	mov    %eax,%edi
  181afb:	89 54 24 04          	mov    %edx,0x4(%esp)
  181aff:	89 cb                	mov    %ecx,%ebx
  181b01:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
	int min_width = -1;
  181b05:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
  181b0c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  181b13:	00 
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  181b14:	be 00 00 00 00       	mov    $0x0,%esi
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  181b19:	e9 af 01 00 00       	jmp    181ccd <_vprintk+0x1db>
		if (!might_format) {
  181b1e:	85 f6                	test   %esi,%esi
  181b20:	75 16                	jne    181b38 <_vprintk+0x46>
			if (*fmt != '%') {
  181b22:	3c 25                	cmp    $0x25,%al
  181b24:	0f 84 84 01 00 00    	je     181cae <_vprintk+0x1bc>
				out((int)*fmt, ctx);
  181b2a:	0f be c0             	movsbl %al,%eax
  181b2d:	8b 54 24 04          	mov    0x4(%esp),%edx
  181b31:	ff d7                	call   *%edi
  181b33:	e9 94 01 00 00       	jmp    181ccc <_vprintk+0x1da>
				might_format = 1;
				min_width = -1;
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
  181b38:	8d 50 db             	lea    -0x25(%eax),%edx
  181b3b:	80 fa 55             	cmp    $0x55,%dl
  181b3e:	0f 87 4f 01 00 00    	ja     181c93 <_vprintk+0x1a1>
  181b44:	0f b6 d2             	movzbl %dl,%edx
  181b47:	ff 24 95 58 4b 18 00 	jmp    *0x184b58(,%edx,4)
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  181b4e:	8b 14 24             	mov    (%esp),%edx
  181b51:	c1 ea 1f             	shr    $0x1f,%edx
  181b54:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  181b59:	0f 94 c1             	sete   %cl
  181b5c:	84 d1                	test   %dl,%cl
  181b5e:	0f 85 60 01 00 00    	jne    181cc4 <_vprintk+0x1d2>
					pad_zero = 1;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
  181b64:	83 3c 24 00          	cmpl   $0x0,(%esp)
  181b68:	79 0e                	jns    181b78 <_vprintk+0x86>
					min_width = *fmt - '0';
  181b6a:	0f be c0             	movsbl %al,%eax
  181b6d:	83 e8 30             	sub    $0x30,%eax
  181b70:	89 04 24             	mov    %eax,(%esp)
  181b73:	e9 54 01 00 00       	jmp    181ccc <_vprintk+0x1da>
				} else {
					min_width = 10 * min_width + *fmt - '0';
  181b78:	8b 0c 24             	mov    (%esp),%ecx
  181b7b:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  181b7e:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  181b81:	0f be c0             	movsbl %al,%eax
  181b84:	8d 44 02 d0          	lea    -0x30(%edx,%eax,1),%eax
  181b88:	89 04 24             	mov    %eax,(%esp)
  181b8b:	e9 3c 01 00 00       	jmp    181ccc <_vprintk+0x1da>
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  181b90:	8d 75 04             	lea    0x4(%ebp),%esi
  181b93:	8b 6d 00             	mov    0x0(%ebp),%ebp

				if (d < 0) {
  181b96:	85 ed                	test   %ebp,%ebp
  181b98:	79 10                	jns    181baa <_vprintk+0xb8>
					out((int)'-', ctx);
  181b9a:	8b 54 24 04          	mov    0x4(%esp),%edx
  181b9e:	b8 2d 00 00 00       	mov    $0x2d,%eax
  181ba3:	ff d7                	call   *%edi
					d = -d;
  181ba5:	f7 dd                	neg    %ebp
					min_width--;
  181ba7:	ff 0c 24             	decl   (%esp)
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
  181baa:	ff 34 24             	pushl  (%esp)
  181bad:	ff 74 24 0c          	pushl  0xc(%esp)
  181bb1:	89 e9                	mov    %ebp,%ecx
  181bb3:	8b 54 24 0c          	mov    0xc(%esp),%edx
  181bb7:	89 f8                	mov    %edi,%eax
  181bb9:	e8 80 fe ff ff       	call   181a3e <_printk_dec_ulong>
  181bbe:	83 c4 08             	add    $0x8,%esp
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  181bc1:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181bc3:	be 00 00 00 00       	mov    $0x0,%esi
					d = -d;
					min_width--;
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
  181bc8:	e9 ff 00 00 00       	jmp    181ccc <_vprintk+0x1da>
			}
			case 'u': {
				unsigned long u = va_arg(
  181bcd:	8d 75 04             	lea    0x4(%ebp),%esi
  181bd0:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
  181bd3:	ff 34 24             	pushl  (%esp)
  181bd6:	ff 74 24 0c          	pushl  0xc(%esp)
  181bda:	8b 54 24 0c          	mov    0xc(%esp),%edx
  181bde:	89 f8                	mov    %edi,%eax
  181be0:	e8 59 fe ff ff       	call   181a3e <_printk_dec_ulong>
  181be5:	83 c4 08             	add    $0x8,%esp
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  181be8:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181bea:	be 00 00 00 00       	mov    $0x0,%esi
			case 'u': {
				unsigned long u = va_arg(
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
						  min_width);
				break;
  181bef:	e9 d8 00 00 00       	jmp    181ccc <_vprintk+0x1da>
			}
			case 'p':
				  out('0', ctx);
  181bf4:	8b 74 24 04          	mov    0x4(%esp),%esi
  181bf8:	89 f2                	mov    %esi,%edx
  181bfa:	b8 30 00 00 00       	mov    $0x30,%eax
  181bff:	ff d7                	call   *%edi
				  out('x', ctx);
  181c01:	89 f2                	mov    %esi,%edx
  181c03:	b8 78 00 00 00       	mov    $0x78,%eax
  181c08:	ff d7                	call   *%edi
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
				  min_width = 8;
  181c0a:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
			}
			case 'p':
				  out('0', ctx);
				  out('x', ctx);
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
  181c11:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  181c18:	00 
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  181c19:	8d 75 04             	lea    0x4(%ebp),%esi
  181c1c:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
  181c1f:	ff 34 24             	pushl  (%esp)
  181c22:	ff 74 24 0c          	pushl  0xc(%esp)
  181c26:	8b 54 24 0c          	mov    0xc(%esp),%edx
  181c2a:	89 f8                	mov    %edi,%eax
  181c2c:	e8 7a fd ff ff       	call   1819ab <_printk_hex_ulong>
  181c31:	83 c4 08             	add    $0x8,%esp
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  181c34:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181c36:	be 00 00 00 00       	mov    $0x0,%esi
			case 'X': {
				unsigned long x = va_arg(
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
  181c3b:	e9 8c 00 00 00       	jmp    181ccc <_vprintk+0x1da>
			}
			case 's': {
				char *s = va_arg(ap, char *);
  181c40:	8d 75 04             	lea    0x4(%ebp),%esi
  181c43:	8b 6d 00             	mov    0x0(%ebp),%ebp
  181c46:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  181c4a:	8b 5c 24 04          	mov    0x4(%esp),%ebx

				while (*s)
  181c4e:	eb 08                	jmp    181c58 <_vprintk+0x166>
					out((int)(*s++), ctx);
  181c50:	45                   	inc    %ebp
  181c51:	0f be c0             	movsbl %al,%eax
  181c54:	89 da                	mov    %ebx,%edx
  181c56:	ff d7                	call   *%edi
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);

				while (*s)
  181c58:	8a 45 00             	mov    0x0(%ebp),%al
  181c5b:	84 c0                	test   %al,%al
  181c5d:	75 f1                	jne    181c50 <_vprintk+0x15e>
  181c5f:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  181c63:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181c65:	be 00 00 00 00       	mov    $0x0,%esi
  181c6a:	eb 60                	jmp    181ccc <_vprintk+0x1da>
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  181c6c:	8d 75 04             	lea    0x4(%ebp),%esi
  181c6f:	8b 45 00             	mov    0x0(%ebp),%eax

				out(c, ctx);
  181c72:	8b 54 24 04          	mov    0x4(%esp),%edx
  181c76:	ff d7                	call   *%edi
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  181c78:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181c7a:	be 00 00 00 00       	mov    $0x0,%esi
			}
			case 'c': {
				int c = va_arg(ap, int);

				out(c, ctx);
				break;
  181c7f:	eb 4b                	jmp    181ccc <_vprintk+0x1da>
			}
			case '%': {
				out((int)'%', ctx);
  181c81:	8b 54 24 04          	mov    0x4(%esp),%edx
  181c85:	b8 25 00 00 00       	mov    $0x25,%eax
  181c8a:	ff d7                	call   *%edi
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181c8c:	be 00 00 00 00       	mov    $0x0,%esi
				out(c, ctx);
				break;
			}
			case '%': {
				out((int)'%', ctx);
				break;
  181c91:	eb 39                	jmp    181ccc <_vprintk+0x1da>
			}
			default:
				out((int)'%', ctx);
  181c93:	8b 74 24 04          	mov    0x4(%esp),%esi
  181c97:	89 f2                	mov    %esi,%edx
  181c99:	b8 25 00 00 00       	mov    $0x25,%eax
  181c9e:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
  181ca0:	0f be 03             	movsbl (%ebx),%eax
  181ca3:	89 f2                	mov    %esi,%edx
  181ca5:	ff d7                	call   *%edi
				break;
			}
			might_format = 0;
  181ca7:	be 00 00 00 00       	mov    $0x0,%esi
				break;
			}
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
  181cac:	eb 1e                	jmp    181ccc <_vprintk+0x1da>
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
  181cae:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
				pad_zero = 0;
  181cb5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  181cbc:	00 
	while (*fmt) {
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
  181cbd:	be 01 00 00 00       	mov    $0x1,%esi
  181cc2:	eb 08                	jmp    181ccc <_vprintk+0x1da>
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
					pad_zero = 1;
  181cc4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  181ccb:	00 
				break;
			}
			might_format = 0;
		}
still_might_format:
		++fmt;
  181ccc:	43                   	inc    %ebx
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  181ccd:	8a 03                	mov    (%ebx),%al
  181ccf:	84 c0                	test   %al,%al
  181cd1:	0f 85 47 fe ff ff    	jne    181b1e <_vprintk+0x2c>
			might_format = 0;
		}
still_might_format:
		++fmt;
	}
}
  181cd7:	83 c4 10             	add    $0x10,%esp
  181cda:	5b                   	pop    %ebx
  181cdb:	5e                   	pop    %esi
  181cdc:	5f                   	pop    %edi
  181cdd:	5d                   	pop    %ebp
  181cde:	c3                   	ret    

00181cdf <printk>:
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
  181cdf:	83 ec 04             	sub    $0x4,%esp
	struct out_context ctx = { 0 };
  181ce2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	va_list ap;

	va_start(ap, fmt);
  181ce9:	8d 44 24 0c          	lea    0xc(%esp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
  181ced:	50                   	push   %eax
  181cee:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  181cf2:	8d 54 24 04          	lea    0x4(%esp),%edx
  181cf6:	b8 9f 19 18 00       	mov    $0x18199f,%eax
  181cfb:	e8 f2 fd ff ff       	call   181af2 <_vprintk>
	va_end(ap);

	return ctx.count;
}
  181d00:	8b 44 24 04          	mov    0x4(%esp),%eax
  181d04:	83 c4 08             	add    $0x8,%esp
  181d07:	c3                   	ret    

00181d08 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_SOC, 1);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
  181d08:	c3                   	ret    

00181d09 <_pinmux_defaults>:
/******** End PINMUX mapping **************************/

#define PINMUX_MAX_REGISTERS 2

static void _pinmux_defaults(uint32_t base)
{
  181d09:	53                   	push   %ebx
  181d0a:	83 ec 08             	sub    $0x8,%esp
	PIN_CONFIG(mux_config,  6, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config,  7, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 12, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 13, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 14, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
  181d0d:	c7 04 24 42 a1 00 aa 	movl   $0xaa00a142,(%esp)
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);
  181d14:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  181d1b:	00 

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  181d1c:	ba 00 00 00 00       	mov    $0x0,%edx
  181d21:	eb 0a                	jmp    181d2d <_pinmux_defaults+0x24>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
  181d23:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
  181d26:	8b 0c 94             	mov    (%esp,%edx,4),%ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  181d29:	89 4b 30             	mov    %ecx,0x30(%ebx)
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  181d2c:	42                   	inc    %edx
  181d2d:	83 fa 01             	cmp    $0x1,%edx
  181d30:	7e f1                	jle    181d23 <_pinmux_defaults+0x1a>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}
  181d32:	83 c4 08             	add    $0x8,%esp
  181d35:	5b                   	pop    %ebx
  181d36:	c3                   	ret    

00181d37 <pinmux_initialize>:

static int pinmux_initialize(struct device *port)
{
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);
  181d37:	b8 00 09 80 b0       	mov    $0xb0800900,%eax
  181d3c:	e8 c8 ff ff ff       	call   181d09 <_pinmux_defaults>

	/*
	 * MAGIC NUMBER: 0x1 is used as the pullup is a single bit in a
	 * 32-bit register.
	 */
	(*(mux_register)) = ((*(mux_register)) & ~(0x1 << pin_offset)) |
  181d41:	a1 20 09 80 b0       	mov    0xb0800920,%eax
  181d46:	83 c8 20             	or     $0x20,%eax
  181d49:	a3 20 09 80 b0       	mov    %eax,0xb0800920

	/* Enable the UART RX pin to receive input */
	_quark_mcu_set_mux(PINMUX_BASE_ADDR + PINMUX_INPUT_OFFSET, 5, 0x1);

	return 0;
}
  181d4e:	b8 00 00 00 00       	mov    $0x0,%eax
  181d53:	c3                   	ret    

00181d54 <clk_periph_enable>:

int clk_periph_enable(const clk_periph_t clocks)
{
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
  181d54:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
  181d5a:	09 d0                	or     %edx,%eax
  181d5c:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
  181d61:	b8 00 00 00 00       	mov    $0x0,%eax
  181d66:	c3                   	ret    

00181d67 <clk_sys_get_ticks_per_us>:
}

uint32_t clk_sys_get_ticks_per_us(void)
{
	return ticks_per_us;
}
  181d67:	a1 14 00 28 00       	mov    0x280014,%eax
  181d6c:	c3                   	ret    

00181d6d <clk_sys_udelay>:

void clk_sys_udelay(uint32_t microseconds)
{
  181d6d:	56                   	push   %esi
  181d6e:	53                   	push   %ebx
	uint32_t timeout = ticks_per_us * microseconds;
  181d6f:	0f af 05 14 00 28 00 	imul   0x280014,%eax
  181d76:	89 c6                	mov    %eax,%esi
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
  181d78:	0f 31                	rdtsc  
  181d7a:	89 c1                	mov    %eax,%ecx
  181d7c:	89 d3                	mov    %edx,%ebx
  181d7e:	0f 31                	rdtsc  
	unsigned long long tsc_start;
	tsc_start = get_ticks();
	/* We need to wait until timeout system clock ticks has occurred. */
	while (get_ticks() - tsc_start < timeout) {
  181d80:	29 c8                	sub    %ecx,%eax
  181d82:	19 da                	sbb    %ebx,%edx
  181d84:	83 fa 00             	cmp    $0x0,%edx
  181d87:	77 04                	ja     181d8d <clk_sys_udelay+0x20>
  181d89:	39 f0                	cmp    %esi,%eax
  181d8b:	72 f1                	jb     181d7e <clk_sys_udelay+0x11>
	}
}
  181d8d:	5b                   	pop    %ebx
  181d8e:	5e                   	pop    %esi
  181d8f:	c3                   	ret    

00181d90 <get_i2c_clk_freq_in_mhz>:
 *
 * @return [uint32_t] I2C freq_in_mhz.
 */
uint32_t get_i2c_clk_freq_in_mhz(void)
{
	return clk_sys_get_ticks_per_us() >>
  181d90:	e8 d2 ff ff ff       	call   181d67 <clk_sys_get_ticks_per_us>
	       ((QM_SCSS_CCU->ccu_periph_clk_div_ctl0 &
  181d95:	8b 0d 1c 00 80 b0    	mov    0xb080001c,%ecx
  181d9b:	83 e1 f9             	and    $0xfffffff9,%ecx
		 CLK_PERIPH_DIV_DEF_MASK) >>
  181d9e:	d1 e9                	shr    %ecx
 *
 * @return [uint32_t] I2C freq_in_mhz.
 */
uint32_t get_i2c_clk_freq_in_mhz(void)
{
	return clk_sys_get_ticks_per_us() >>
  181da0:	d3 e8                	shr    %cl,%eax
	       ((QM_SCSS_CCU->ccu_periph_clk_div_ctl0 &
		 CLK_PERIPH_DIV_DEF_MASK) >>
		QM_CCU_PERIPH_PCLK_DIV_OFFSET);
}
  181da2:	c3                   	ret    

00181da3 <empty_rx_fifo>:
 * received data.
 */
static void empty_rx_fifo(const qm_i2c_t i2c,
			  const volatile qm_i2c_transfer_t *const transfer,
			  qm_i2c_reg_t *const controller)
{
  181da3:	55                   	push   %ebp
  181da4:	57                   	push   %edi
  181da5:	56                   	push   %esi
  181da6:	53                   	push   %ebx
  181da7:	89 c7                	mov    %eax,%edi
  181da9:	89 d6                	mov    %edx,%esi
  181dab:	89 cb                	mov    %ecx,%ebx
	while (controller->ic_status & QM_I2C_IC_STATUS_RFNE) {
  181dad:	eb 6b                	jmp    181e1a <empty_rx_fifo+0x77>
		if (!transfer_ongoing) {
  181daf:	a0 2e 01 28 00       	mov    0x28012e,%al
  181db4:	84 c0                	test   %al,%al
  181db6:	75 05                	jne    181dbd <empty_rx_fifo+0x1a>
			/* Dummy read. */
			controller->ic_data_cmd;
  181db8:	8b 43 10             	mov    0x10(%ebx),%eax
  181dbb:	eb 5d                	jmp    181e1a <empty_rx_fifo+0x77>
		} else {
			if (transfer->rx_len > i2c_read_pos[i2c]) {
  181dbd:	8b 56 0c             	mov    0xc(%esi),%edx
  181dc0:	8b 04 bd 34 01 28 00 	mov    0x280134(,%edi,4),%eax
  181dc7:	39 c2                	cmp    %eax,%edx
  181dc9:	76 1a                	jbe    181de5 <empty_rx_fifo+0x42>
				transfer->rx[i2c_read_pos[i2c]++] =
  181dcb:	8b 56 08             	mov    0x8(%esi),%edx
  181dce:	8b 04 bd 34 01 28 00 	mov    0x280134(,%edi,4),%eax
  181dd5:	8d 48 01             	lea    0x1(%eax),%ecx
  181dd8:	89 0c bd 34 01 28 00 	mov    %ecx,0x280134(,%edi,4)
				    controller->ic_data_cmd & 0xFF;
  181ddf:	8b 4b 10             	mov    0x10(%ebx),%ecx
		if (!transfer_ongoing) {
			/* Dummy read. */
			controller->ic_data_cmd;
		} else {
			if (transfer->rx_len > i2c_read_pos[i2c]) {
				transfer->rx[i2c_read_pos[i2c]++] =
  181de2:	88 0c 02             	mov    %cl,(%edx,%eax,1)
				    controller->ic_data_cmd & 0xFF;
			}

			if (transfer->rx_len == i2c_read_pos[i2c]) {
  181de5:	8b 56 0c             	mov    0xc(%esi),%edx
  181de8:	8b 04 bd 34 01 28 00 	mov    0x280134(,%edi,4),%eax
  181def:	39 c2                	cmp    %eax,%edx
  181df1:	75 27                	jne    181e1a <empty_rx_fifo+0x77>
				/*
				 * End user transfer if user does not update
				 * buffers.
				 */
				transfer_ongoing = false;
  181df3:	c6 05 2e 01 28 00 00 	movb   $0x0,0x28012e

				if (transfer->callback) {
  181dfa:	8b 46 14             	mov    0x14(%esi),%eax
  181dfd:	85 c0                	test   %eax,%eax
  181dff:	74 19                	je     181e1a <empty_rx_fifo+0x77>
					transfer->callback(
  181e01:	8b 6e 14             	mov    0x14(%esi),%ebp
  181e04:	8b 56 0c             	mov    0xc(%esi),%edx
  181e07:	8b 46 18             	mov    0x18(%esi),%eax
  181e0a:	52                   	push   %edx
  181e0b:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  181e10:	ba 00 00 00 00       	mov    $0x0,%edx
  181e15:	ff d5                	call   *%ebp
  181e17:	83 c4 04             	add    $0x4,%esp
 */
static void empty_rx_fifo(const qm_i2c_t i2c,
			  const volatile qm_i2c_transfer_t *const transfer,
			  qm_i2c_reg_t *const controller)
{
	while (controller->ic_status & QM_I2C_IC_STATUS_RFNE) {
  181e1a:	8b 43 70             	mov    0x70(%ebx),%eax
  181e1d:	a8 08                	test   $0x8,%al
  181e1f:	75 8e                	jne    181daf <empty_rx_fifo+0xc>
					    QM_I2C_RX_FULL, transfer->rx_len);
				}
			}
		}
	}
}
  181e21:	5b                   	pop    %ebx
  181e22:	5e                   	pop    %esi
  181e23:	5f                   	pop    %edi
  181e24:	5d                   	pop    %ebp
  181e25:	c3                   	ret    

00181e26 <slave_fill_tx_fifo>:
 * data.
 */
static void slave_fill_tx_fifo(const qm_i2c_t i2c,
			       const volatile qm_i2c_transfer_t *const transfer,
			       qm_i2c_reg_t *const controller)
{
  181e26:	55                   	push   %ebp
  181e27:	57                   	push   %edi
  181e28:	56                   	push   %esi
  181e29:	53                   	push   %ebx
  181e2a:	89 c7                	mov    %eax,%edi
  181e2c:	89 d6                	mov    %edx,%esi
  181e2e:	89 cb                	mov    %ecx,%ebx
	while ((controller->ic_status & QM_I2C_IC_STATUS_TNF) &&
  181e30:	eb 6f                	jmp    181ea1 <slave_fill_tx_fifo+0x7b>
	       (!(controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_ABRT))) {
		if (!transfer_ongoing) {
  181e32:	a0 2e 01 28 00       	mov    0x28012e,%al
  181e37:	84 c0                	test   %al,%al
  181e39:	75 09                	jne    181e44 <slave_fill_tx_fifo+0x1e>
			/* Dummy write. */
			controller->ic_data_cmd = 0;
  181e3b:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  181e42:	eb 5d                	jmp    181ea1 <slave_fill_tx_fifo+0x7b>

		} else {
			if (transfer->tx_len > i2c_write_pos[i2c]) {
  181e44:	8b 56 04             	mov    0x4(%esi),%edx
  181e47:	8b 04 bd 38 01 28 00 	mov    0x280138(,%edi,4),%eax
  181e4e:	39 c2                	cmp    %eax,%edx
  181e50:	76 1a                	jbe    181e6c <slave_fill_tx_fifo+0x46>
				controller->ic_data_cmd =
				    transfer->tx[i2c_write_pos[i2c]++];
  181e52:	8b 16                	mov    (%esi),%edx
  181e54:	8b 04 bd 38 01 28 00 	mov    0x280138(,%edi,4),%eax
  181e5b:	8d 48 01             	lea    0x1(%eax),%ecx
  181e5e:	89 0c bd 38 01 28 00 	mov    %ecx,0x280138(,%edi,4)
			/* Dummy write. */
			controller->ic_data_cmd = 0;

		} else {
			if (transfer->tx_len > i2c_write_pos[i2c]) {
				controller->ic_data_cmd =
  181e65:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
  181e69:	89 43 10             	mov    %eax,0x10(%ebx)
				    transfer->tx[i2c_write_pos[i2c]++];
			}

			if (transfer->tx_len == i2c_write_pos[i2c]) {
  181e6c:	8b 56 04             	mov    0x4(%esi),%edx
  181e6f:	8b 04 bd 38 01 28 00 	mov    0x280138(,%edi,4),%eax
  181e76:	39 c2                	cmp    %eax,%edx
  181e78:	75 27                	jne    181ea1 <slave_fill_tx_fifo+0x7b>
				/*
				 * End user transfer if user does not update
				 * buffers.
				 */
				transfer_ongoing = false;
  181e7a:	c6 05 2e 01 28 00 00 	movb   $0x0,0x28012e

				if (transfer->callback) {
  181e81:	8b 46 14             	mov    0x14(%esi),%eax
  181e84:	85 c0                	test   %eax,%eax
  181e86:	74 19                	je     181ea1 <slave_fill_tx_fifo+0x7b>
					transfer->callback(
  181e88:	8b 6e 14             	mov    0x14(%esi),%ebp
  181e8b:	8b 56 04             	mov    0x4(%esi),%edx
  181e8e:	8b 46 18             	mov    0x18(%esi),%eax
  181e91:	52                   	push   %edx
  181e92:	b9 00 00 80 00       	mov    $0x800000,%ecx
  181e97:	ba 00 00 00 00       	mov    $0x0,%edx
  181e9c:	ff d5                	call   *%ebp
  181e9e:	83 c4 04             	add    $0x4,%esp
 */
static void slave_fill_tx_fifo(const qm_i2c_t i2c,
			       const volatile qm_i2c_transfer_t *const transfer,
			       qm_i2c_reg_t *const controller)
{
	while ((controller->ic_status & QM_I2C_IC_STATUS_TNF) &&
  181ea1:	8b 43 70             	mov    0x70(%ebx),%eax
  181ea4:	a8 02                	test   $0x2,%al
  181ea6:	74 07                	je     181eaf <slave_fill_tx_fifo+0x89>
	       (!(controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_ABRT))) {
  181ea8:	8b 43 2c             	mov    0x2c(%ebx),%eax
 */
static void slave_fill_tx_fifo(const qm_i2c_t i2c,
			       const volatile qm_i2c_transfer_t *const transfer,
			       qm_i2c_reg_t *const controller)
{
	while ((controller->ic_status & QM_I2C_IC_STATUS_TNF) &&
  181eab:	a8 40                	test   $0x40,%al
  181ead:	74 83                	je     181e32 <slave_fill_tx_fifo+0xc>
					    QM_I2C_TX_EMPTY, transfer->tx_len);
				}
			}
		}
	}
}
  181eaf:	5b                   	pop    %ebx
  181eb0:	5e                   	pop    %esi
  181eb1:	5f                   	pop    %edi
  181eb2:	5d                   	pop    %ebp
  181eb3:	c3                   	ret    

00181eb4 <master_fill_tx_fifo>:

static uint32_t
master_fill_tx_fifo(const qm_i2c_t i2c,
		    const volatile qm_i2c_transfer_t *const transfer,
		    qm_i2c_reg_t *const controller)
{
  181eb4:	55                   	push   %ebp
  181eb5:	57                   	push   %edi
  181eb6:	56                   	push   %esi
  181eb7:	53                   	push   %ebx
  181eb8:	83 ec 04             	sub    $0x4,%esp
  181ebb:	89 d7                	mov    %edx,%edi
  181ebd:	89 cd                	mov    %ecx,%ebp
	uint32_t ic_data_cmd, count_tx = (QM_I2C_FIFO_SIZE - TX_TL);
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
  181ebf:	8b 5a 04             	mov    0x4(%edx),%ebx
  181ec2:	8b 14 85 38 01 28 00 	mov    0x280138(,%eax,4),%edx
  181ec9:	29 d3                	sub    %edx,%ebx
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];
  181ecb:	8b 4f 0c             	mov    0xc(%edi),%ecx
  181ece:	8b 14 85 34 01 28 00 	mov    0x280134(,%eax,4),%edx
  181ed5:	29 d1                	sub    %edx,%ecx
  181ed7:	89 0c 24             	mov    %ecx,(%esp)
static uint32_t
master_fill_tx_fifo(const qm_i2c_t i2c,
		    const volatile qm_i2c_transfer_t *const transfer,
		    qm_i2c_reg_t *const controller)
{
	uint32_t ic_data_cmd, count_tx = (QM_I2C_FIFO_SIZE - TX_TL);
  181eda:	be 0e 00 00 00       	mov    $0xe,%esi
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];

	while ((count_tx) && write_buffer_remaining) {
  181edf:	eb 32                	jmp    181f13 <master_fill_tx_fifo+0x5f>
		count_tx--;
  181ee1:	4e                   	dec    %esi
		write_buffer_remaining--;
  181ee2:	4b                   	dec    %ebx

		/*
		 * Write command -IC_DATA_CMD[8] = 0.
		 * Fill IC_DATA_CMD[7:0] with the data.
		 */
		ic_data_cmd = transfer->tx[i2c_write_pos[i2c]];
  181ee3:	8b 0f                	mov    (%edi),%ecx
  181ee5:	8b 14 85 38 01 28 00 	mov    0x280138(,%eax,4),%edx
  181eec:	0f b6 14 11          	movzbl (%ecx,%edx,1),%edx

		/*
		 * If transfer is a combined transfer, only send stop at
		 * end of the transfer sequence.
		 */
		if (transfer->stop && (write_buffer_remaining == 0) &&
  181ef0:	8a 4f 10             	mov    0x10(%edi),%cl
  181ef3:	84 c9                	test   %cl,%cl
  181ef5:	74 0a                	je     181f01 <master_fill_tx_fifo+0x4d>
  181ef7:	8b 0c 24             	mov    (%esp),%ecx
  181efa:	09 d9                	or     %ebx,%ecx
  181efc:	75 03                	jne    181f01 <master_fill_tx_fifo+0x4d>
		    (read_buffer_remaining == 0)) {

			ic_data_cmd |= QM_I2C_IC_DATA_CMD_STOP_BIT_CTRL;
  181efe:	80 ce 02             	or     $0x2,%dh
		}

		/* Write data. */
		controller->ic_data_cmd = ic_data_cmd;
  181f01:	89 55 10             	mov    %edx,0x10(%ebp)
		i2c_write_pos[i2c]++;
  181f04:	8b 14 85 38 01 28 00 	mov    0x280138(,%eax,4),%edx
  181f0b:	42                   	inc    %edx
  181f0c:	89 14 85 38 01 28 00 	mov    %edx,0x280138(,%eax,4)
{
	uint32_t ic_data_cmd, count_tx = (QM_I2C_FIFO_SIZE - TX_TL);
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];

	while ((count_tx) && write_buffer_remaining) {
  181f13:	85 f6                	test   %esi,%esi
  181f15:	0f 95 c2             	setne  %dl
  181f18:	85 db                	test   %ebx,%ebx
  181f1a:	0f 95 c1             	setne  %cl
  181f1d:	84 d1                	test   %dl,%cl
  181f1f:	75 c0                	jne    181ee1 <master_fill_tx_fifo+0x2d>
		 * goes above the threshold.
		 */
	}

	return write_buffer_remaining;
}
  181f21:	89 d8                	mov    %ebx,%eax
  181f23:	83 c4 04             	add    $0x4,%esp
  181f26:	5b                   	pop    %ebx
  181f27:	5e                   	pop    %esi
  181f28:	5f                   	pop    %edi
  181f29:	5d                   	pop    %ebp
  181f2a:	c3                   	ret    

00181f2b <controller_enable>:
	return 0;
}

static void controller_enable(const qm_i2c_t i2c)
{
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  181f2b:	8b 14 85 18 00 28 00 	mov    0x280018(,%eax,4),%edx

	if (!(controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN)) {
  181f32:	8b 82 9c 00 00 00    	mov    0x9c(%edx),%eax
  181f38:	a8 01                	test   $0x1,%al
  181f3a:	75 13                	jne    181f4f <controller_enable+0x24>
		/* Enable controller. */
		controller->ic_enable |= QM_I2C_IC_ENABLE_CONTROLLER_EN;
  181f3c:	8b 42 6c             	mov    0x6c(%edx),%eax
  181f3f:	83 c8 01             	or     $0x1,%eax
  181f42:	89 42 6c             	mov    %eax,0x6c(%edx)

		/* Wait until controller is enabled. */
		while (!(controller->ic_enable_status &
  181f45:	8b 82 9c 00 00 00    	mov    0x9c(%edx),%eax
  181f4b:	a8 01                	test   $0x1,%al
  181f4d:	74 f6                	je     181f45 <controller_enable+0x1a>
			 QM_I2C_IC_ENABLE_STATUS_IC_EN))
			;
	}

	/* Be sure that all interrupts flag are cleared. */
	controller->ic_clr_intr;
  181f4f:	8b 42 40             	mov    0x40(%edx),%eax
  181f52:	c3                   	ret    

00181f53 <controller_disable>:
}

static int controller_disable(const qm_i2c_t i2c)
{
  181f53:	56                   	push   %esi
  181f54:	53                   	push   %ebx
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  181f55:	8b 34 85 18 00 28 00 	mov    0x280018(,%eax,4),%esi
	int poll_count = I2C_POLL_COUNT;

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;
  181f5c:	8b 46 6c             	mov    0x6c(%esi),%eax
  181f5f:	83 e0 fe             	and    $0xfffffffe,%eax
  181f62:	89 46 6c             	mov    %eax,0x6c(%esi)
}

static int controller_disable(const qm_i2c_t i2c)
{
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
	int poll_count = I2C_POLL_COUNT;
  181f65:	b8 40 42 0f 00       	mov    $0xf4240,%eax

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
  181f6a:	eb 0c                	jmp    181f78 <controller_disable+0x25>
	       poll_count--) {
		clk_sys_udelay(I2C_POLL_MICROSECOND);
  181f6c:	b8 01 00 00 00       	mov    $0x1,%eax
  181f71:	e8 f7 fd ff ff       	call   181d6d <clk_sys_udelay>
	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
	       poll_count--) {
  181f76:	89 d8                	mov    %ebx,%eax

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
  181f78:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
  181f7e:	f6 c2 01             	test   $0x1,%dl
  181f81:	74 07                	je     181f8a <controller_disable+0x37>
	       poll_count--) {
  181f83:	8d 58 ff             	lea    -0x1(%eax),%ebx

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
  181f86:	85 c0                	test   %eax,%eax
  181f88:	75 e2                	jne    181f6c <controller_disable+0x19>
	       poll_count--) {
		clk_sys_udelay(I2C_POLL_MICROSECOND);
	}

	/* Returns 0 if ok, meaning controller is disabled. */
	return (controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN);
  181f8a:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
  181f90:	83 e0 01             	and    $0x1,%eax
}
  181f93:	5b                   	pop    %ebx
  181f94:	5e                   	pop    %esi
  181f95:	c3                   	ret    

00181f96 <i2c_isr_irq_handler>:
		}
	}
}

static void i2c_isr_irq_handler(const qm_i2c_t i2c)
{
  181f96:	55                   	push   %ebp
  181f97:	57                   	push   %edi
  181f98:	56                   	push   %esi
  181f99:	53                   	push   %ebx
  181f9a:	83 ec 08             	sub    $0x8,%esp
  181f9d:	89 c3                	mov    %eax,%ebx
	const volatile qm_i2c_transfer_t *const transfer = i2c_transfer[i2c];
  181f9f:	8b 3c 85 3c 01 28 00 	mov    0x28013c(,%eax,4),%edi
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  181fa6:	8b 34 85 18 00 28 00 	mov    0x280018(,%eax,4),%esi

	/* Check TX_OVER error. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_OVER) {
  181fad:	8b 46 2c             	mov    0x2c(%esi),%eax
  181fb0:	a8 08                	test   $0x8,%al
  181fb2:	74 35                	je     181fe9 <i2c_isr_irq_handler+0x53>
		/* Clear interrupt. */
		controller->ic_clr_tx_over;
  181fb4:	8b 46 4c             	mov    0x4c(%esi),%eax

		/* Mask interrupts. */
		controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  181fb7:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

		controller_disable(i2c);
  181fbe:	89 d8                	mov    %ebx,%eax
  181fc0:	e8 8e ff ff ff       	call   181f53 <controller_disable>
		if (transfer->callback) {
  181fc5:	8b 47 14             	mov    0x14(%edi),%eax
  181fc8:	85 c0                	test   %eax,%eax
  181fca:	74 1d                	je     181fe9 <i2c_isr_irq_handler+0x53>
			transfer->callback(transfer->callback_data, -EIO,
  181fcc:	8b 6f 14             	mov    0x14(%edi),%ebp
  181fcf:	8b 14 9d 38 01 28 00 	mov    0x280138(,%ebx,4),%edx
  181fd6:	8b 47 18             	mov    0x18(%edi),%eax
  181fd9:	52                   	push   %edx
  181fda:	b9 00 00 08 00       	mov    $0x80000,%ecx
  181fdf:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
  181fe4:	ff d5                	call   *%ebp
  181fe6:	83 c4 04             	add    $0x4,%esp
					   QM_I2C_TX_OVER, i2c_write_pos[i2c]);
		}
	}

	/* Check for RX_UNDER error. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_UNDER) {
  181fe9:	8b 46 2c             	mov    0x2c(%esi),%eax
  181fec:	a8 01                	test   $0x1,%al
  181fee:	74 35                	je     182025 <i2c_isr_irq_handler+0x8f>
		/* Clear interrupt. */
		controller->ic_clr_rx_under;
  181ff0:	8b 46 44             	mov    0x44(%esi),%eax

		/* Mask interrupts. */
		controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  181ff3:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

		controller_disable(i2c);
  181ffa:	89 d8                	mov    %ebx,%eax
  181ffc:	e8 52 ff ff ff       	call   181f53 <controller_disable>
		if (transfer->callback) {
  182001:	8b 47 14             	mov    0x14(%edi),%eax
  182004:	85 c0                	test   %eax,%eax
  182006:	74 1d                	je     182025 <i2c_isr_irq_handler+0x8f>
			transfer->callback(transfer->callback_data, -EIO,
  182008:	8b 6f 14             	mov    0x14(%edi),%ebp
  18200b:	8b 14 9d 38 01 28 00 	mov    0x280138(,%ebx,4),%edx
  182012:	8b 47 18             	mov    0x18(%edi),%eax
  182015:	52                   	push   %edx
  182016:	b9 00 00 20 00       	mov    $0x200000,%ecx
  18201b:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
  182020:	ff d5                	call   *%ebp
  182022:	83 c4 04             	add    $0x4,%esp
	/*
	 * TX ABORT interrupt.
	 * Avoid spurious interrupts by checking RX DONE interrupt: RX_DONE
	 * interrupt also trigger a TX_ABORT interrupt when flushing FIFO.
	 */
	if ((controller->ic_intr_stat &
  182025:	8b 46 2c             	mov    0x2c(%esi),%eax
  182028:	25 c0 00 00 00       	and    $0xc0,%eax
  18202d:	83 f8 40             	cmp    $0x40,%eax
  182030:	75 63                	jne    182095 <i2c_isr_irq_handler+0xff>

	*status = QM_I2C_TX_ABORT;

	/* Get source of TX_ABRT interrupt. */
	*status |=
	    (controller->ic_tx_abrt_source & QM_I2C_IC_TX_ABRT_SOURCE_ALL_MASK);
  182032:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
  182038:	89 c2                	mov    %eax,%edx
  18203a:	81 e2 ff ff 01 00    	and    $0x1ffff,%edx
		    QM_I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT));

	*status = QM_I2C_TX_ABORT;

	/* Get source of TX_ABRT interrupt. */
	*status |=
  182040:	81 ca 00 00 04 00    	or     $0x40000,%edx
  182046:	89 14 24             	mov    %edx,(%esp)
	    (controller->ic_tx_abrt_source & QM_I2C_IC_TX_ABRT_SOURCE_ALL_MASK);

	/* Clear TX ABORT interrupt. */
	controller->ic_clr_tx_abrt;
  182049:	8b 56 54             	mov    0x54(%esi),%edx

	/* Mask interrupts. */
	controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  18204c:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

	return rc = (*status & QM_I2C_TX_ABRT_USER_ABRT) ? -ECANCELED : -EIO;
  182053:	a9 00 00 01 00       	test   $0x10000,%eax
  182058:	74 0a                	je     182064 <i2c_isr_irq_handler+0xce>
  18205a:	c7 44 24 04 b8 ff ff 	movl   $0xffffffb8,0x4(%esp)
  182061:	ff 
  182062:	eb 08                	jmp    18206c <i2c_isr_irq_handler+0xd6>
  182064:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  18206b:	ff 
	qm_i2c_status_t status = 0;
	int rc = 0;

	rc = handle_tx_abrt_common(controller, &status);

	controller_disable(i2c);
  18206c:	89 d8                	mov    %ebx,%eax
  18206e:	e8 e0 fe ff ff       	call   181f53 <controller_disable>
	if (transfer->callback) {
  182073:	8b 47 14             	mov    0x14(%edi),%eax
  182076:	85 c0                	test   %eax,%eax
  182078:	74 1b                	je     182095 <i2c_isr_irq_handler+0xff>
		transfer->callback(transfer->callback_data, rc, status,
  18207a:	8b 6f 14             	mov    0x14(%edi),%ebp
  18207d:	8b 14 9d 38 01 28 00 	mov    0x280138(,%ebx,4),%edx
  182084:	8b 47 18             	mov    0x18(%edi),%eax
  182087:	52                   	push   %edx
  182088:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  18208c:	8b 54 24 08          	mov    0x8(%esp),%edx
  182090:	ff d5                	call   *%ebp
  182092:	83 c4 04             	add    $0x4,%esp
	    QM_I2C_IC_INTR_STAT_TX_ABRT) {
		handle_irq_tx_abrt(i2c, transfer, controller);
	}

	/* Master mode. */
	if (controller->ic_con & QM_I2C_IC_CON_MASTER_MODE) {
  182095:	8b 06                	mov    (%esi),%eax
  182097:	a8 01                	test   $0x1,%al
  182099:	0f 84 d4 01 00 00    	je     182273 <i2c_isr_irq_handler+0x2dd>
		/* Check for RX_OVER error. */
		if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_OVER) {
  18209f:	8b 46 2c             	mov    0x2c(%esi),%eax
  1820a2:	a8 02                	test   $0x2,%al
  1820a4:	74 35                	je     1820db <i2c_isr_irq_handler+0x145>
			/* Clear interrupt. */
			controller->ic_clr_rx_over;
  1820a6:	8b 46 48             	mov    0x48(%esi),%eax

			/* Mask interrupts. */
			controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  1820a9:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

			controller_disable(i2c);
  1820b0:	89 d8                	mov    %ebx,%eax
  1820b2:	e8 9c fe ff ff       	call   181f53 <controller_disable>
			if (transfer->callback) {
  1820b7:	8b 47 14             	mov    0x14(%edi),%eax
  1820ba:	85 c0                	test   %eax,%eax
  1820bc:	74 1d                	je     1820db <i2c_isr_irq_handler+0x145>
				transfer->callback(transfer->callback_data,
  1820be:	8b 6f 14             	mov    0x14(%edi),%ebp
  1820c1:	8b 14 9d 38 01 28 00 	mov    0x280138(,%ebx,4),%edx
  1820c8:	8b 47 18             	mov    0x18(%edi),%eax
  1820cb:	52                   	push   %edx
  1820cc:	b9 00 00 10 00       	mov    $0x100000,%ecx
  1820d1:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
  1820d6:	ff d5                	call   *%ebp
  1820d8:	83 c4 04             	add    $0x4,%esp
i2c_isr_master_handler(const qm_i2c_t i2c,
		       const volatile qm_i2c_transfer_t *const transfer,
		       qm_i2c_reg_t *const controller)
{
	uint32_t count_tx;
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];
  1820db:	8b 57 0c             	mov    0xc(%edi),%edx
  1820de:	8b 04 9d 34 01 28 00 	mov    0x280134(,%ebx,4),%eax
  1820e5:	29 c2                	sub    %eax,%edx
  1820e7:	89 14 24             	mov    %edx,(%esp)
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
  1820ea:	8b 57 04             	mov    0x4(%edi),%edx
  1820ed:	8b 04 9d 38 01 28 00 	mov    0x280138(,%ebx,4),%eax
  1820f4:	29 c2                	sub    %eax,%edx
  1820f6:	89 d5                	mov    %edx,%ebp
	uint32_t missing_bytes;

	/* RX read from buffer. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {
  1820f8:	8b 46 2c             	mov    0x2c(%esi),%eax
  1820fb:	a8 04                	test   $0x4,%al
  1820fd:	75 68                	jne    182167 <i2c_isr_irq_handler+0x1d1>
  1820ff:	e9 84 00 00 00       	jmp    182188 <i2c_isr_irq_handler+0x1f2>

		while (read_buffer_remaining && controller->ic_rxflr) {
			transfer->rx[i2c_read_pos[i2c]] =
  182104:	8b 57 08             	mov    0x8(%edi),%edx
  182107:	8b 04 9d 34 01 28 00 	mov    0x280134(,%ebx,4),%eax
			    controller->ic_data_cmd;
  18210e:	8b 4e 10             	mov    0x10(%esi),%ecx

	/* RX read from buffer. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {

		while (read_buffer_remaining && controller->ic_rxflr) {
			transfer->rx[i2c_read_pos[i2c]] =
  182111:	88 0c 02             	mov    %cl,(%edx,%eax,1)
			    controller->ic_data_cmd;
			read_buffer_remaining--;
			i2c_read_pos[i2c]++;
  182114:	8b 04 9d 34 01 28 00 	mov    0x280134(,%ebx,4),%eax
  18211b:	40                   	inc    %eax
  18211c:	89 04 9d 34 01 28 00 	mov    %eax,0x280134(,%ebx,4)

			if (read_buffer_remaining == 0) {
  182123:	ff 0c 24             	decl   (%esp)
  182126:	75 43                	jne    18216b <i2c_isr_irq_handler+0x1d5>
				/*
				 * Mask RX full interrupt if transfer
				 * complete.
				 */
				controller->ic_intr_mask &=
  182128:	8b 46 30             	mov    0x30(%esi),%eax
  18212b:	83 e0 eb             	and    $0xffffffeb,%eax
  18212e:	89 46 30             	mov    %eax,0x30(%esi)
				    ~(QM_I2C_IC_INTR_MASK_RX_FULL |
				      QM_I2C_IC_INTR_MASK_TX_EMPTY);

				if (transfer->stop) {
  182131:	8a 47 10             	mov    0x10(%edi),%al
  182134:	84 c0                	test   %al,%al
  182136:	74 07                	je     18213f <i2c_isr_irq_handler+0x1a9>
					controller_disable(i2c);
  182138:	89 d8                	mov    %ebx,%eax
  18213a:	e8 14 fe ff ff       	call   181f53 <controller_disable>
				}

				if (transfer->callback) {
  18213f:	8b 47 14             	mov    0x14(%edi),%eax
  182142:	85 c0                	test   %eax,%eax
  182144:	74 25                	je     18216b <i2c_isr_irq_handler+0x1d5>
					transfer->callback(
  182146:	8b 47 14             	mov    0x14(%edi),%eax
  182149:	89 c5                	mov    %eax,%ebp
  18214b:	8b 14 9d 34 01 28 00 	mov    0x280134(,%ebx,4),%edx
  182152:	8b 47 18             	mov    0x18(%edi),%eax
  182155:	52                   	push   %edx
  182156:	b9 00 00 00 00       	mov    $0x0,%ecx
  18215b:	ba 00 00 00 00       	mov    $0x0,%edx
  182160:	ff d5                	call   *%ebp
  182162:	83 c4 04             	add    $0x4,%esp
  182165:	eb 04                	jmp    18216b <i2c_isr_irq_handler+0x1d5>
  182167:	89 54 24 04          	mov    %edx,0x4(%esp)
	uint32_t missing_bytes;

	/* RX read from buffer. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {

		while (read_buffer_remaining && controller->ic_rxflr) {
  18216b:	83 3c 24 00          	cmpl   $0x0,(%esp)
  18216f:	74 07                	je     182178 <i2c_isr_irq_handler+0x1e2>
  182171:	8b 46 78             	mov    0x78(%esi),%eax
  182174:	85 c0                	test   %eax,%eax
  182176:	75 8c                	jne    182104 <i2c_isr_irq_handler+0x16e>
  182178:	8b 6c 24 04          	mov    0x4(%esp),%ebp
					    QM_I2C_IDLE, i2c_read_pos[i2c]);
				}
			}
		}

		if (read_buffer_remaining > 0 &&
  18217c:	8b 04 24             	mov    (%esp),%eax
  18217f:	48                   	dec    %eax
  182180:	83 f8 04             	cmp    $0x4,%eax
  182183:	77 03                	ja     182188 <i2c_isr_irq_handler+0x1f2>
			/*
			 * Adjust the RX threshold so the next 'RX_FULL'
			 * interrupt is generated when all the remaining
			 * data are received.
			 */
			controller->ic_rx_tl = read_buffer_remaining - 1;
  182185:	89 46 38             	mov    %eax,0x38(%esi)
		 * RX_FULL INTR is autocleared when the buffer levels goes below
		 * the threshold.
		 */
	}

	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_EMPTY) {
  182188:	8b 46 2c             	mov    0x2c(%esi),%eax
  18218b:	a8 10                	test   $0x10,%al
  18218d:	0f 84 d4 02 00 00    	je     182467 <i2c_isr_irq_handler+0x4d1>

		if ((controller->ic_status & QM_I2C_IC_STATUS_TFE) &&
  182193:	8b 46 70             	mov    0x70(%esi),%eax
  182196:	a8 04                	test   $0x4,%al
  182198:	74 46                	je     1821e0 <i2c_isr_irq_handler+0x24a>
		    (transfer->tx != NULL) && (write_buffer_remaining == 0) &&
  18219a:	8b 07                	mov    (%edi),%eax
		 */
	}

	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_EMPTY) {

		if ((controller->ic_status & QM_I2C_IC_STATUS_TFE) &&
  18219c:	85 c0                	test   %eax,%eax
  18219e:	74 40                	je     1821e0 <i2c_isr_irq_handler+0x24a>
		    (transfer->tx != NULL) && (write_buffer_remaining == 0) &&
  1821a0:	0b 2c 24             	or     (%esp),%ebp
  1821a3:	75 3b                	jne    1821e0 <i2c_isr_irq_handler+0x24a>
		    (read_buffer_remaining == 0)) {

			controller->ic_intr_mask &=
  1821a5:	8b 46 30             	mov    0x30(%esi),%eax
  1821a8:	83 e0 ef             	and    $0xffffffef,%eax
  1821ab:	89 46 30             	mov    %eax,0x30(%esi)

			/*
			 * If this is not a combined transaction, disable the
			 * controller now.
			 */
			if (transfer->stop) {
  1821ae:	8a 47 10             	mov    0x10(%edi),%al
  1821b1:	84 c0                	test   %al,%al
  1821b3:	74 07                	je     1821bc <i2c_isr_irq_handler+0x226>
				controller_disable(i2c);
  1821b5:	89 d8                	mov    %ebx,%eax
  1821b7:	e8 97 fd ff ff       	call   181f53 <controller_disable>
			}

			/* Callback. */
			if (transfer->callback) {
  1821bc:	8b 47 14             	mov    0x14(%edi),%eax
  1821bf:	85 c0                	test   %eax,%eax
  1821c1:	74 1d                	je     1821e0 <i2c_isr_irq_handler+0x24a>
				transfer->callback(transfer->callback_data, 0,
  1821c3:	8b 6f 14             	mov    0x14(%edi),%ebp
  1821c6:	8b 14 9d 38 01 28 00 	mov    0x280138(,%ebx,4),%edx
  1821cd:	8b 47 18             	mov    0x18(%edi),%eax
  1821d0:	52                   	push   %edx
  1821d1:	b9 00 00 00 00       	mov    $0x0,%ecx
  1821d6:	ba 00 00 00 00       	mov    $0x0,%edx
  1821db:	ff d5                	call   *%ebp
  1821dd:	83 c4 04             	add    $0x4,%esp
						   QM_I2C_IDLE,
						   i2c_write_pos[i2c]);
			}
		}

		write_buffer_remaining =
  1821e0:	89 f1                	mov    %esi,%ecx
  1821e2:	89 fa                	mov    %edi,%edx
  1821e4:	89 d8                	mov    %ebx,%eax
  1821e6:	e8 c9 fc ff ff       	call   181eb4 <master_fill_tx_fifo>
		 * waiting for some bytes after sending read request on the
		 * previous interruption. We have to take into account this
		 * value in order to not send too much request so we won't fall
		 * into rx overflow.
		 */
		missing_bytes = read_buffer_remaining - i2c_read_cmd_send[i2c];
  1821eb:	8b 14 9d 30 01 28 00 	mov    0x280130(,%ebx,4),%edx
  1821f2:	8b 0c 24             	mov    (%esp),%ecx
  1821f5:	29 d1                	sub    %edx,%ecx
  1821f7:	89 ca                	mov    %ecx,%edx
		 * cannot be more than the number of expected bytes.
		 */
		QM_ASSERT(controller->ic_rxflr <= missing_bytes);

		/* Count_tx is the remaining size in the FIFO. */
		count_tx = QM_I2C_FIFO_SIZE - controller->ic_txflr;
  1821f9:	8b 4e 74             	mov    0x74(%esi),%ecx
  1821fc:	bd 10 00 00 00       	mov    $0x10,%ebp
  182201:	29 cd                	sub    %ecx,%ebp

		if (count_tx > missing_bytes) {
  182203:	39 ea                	cmp    %ebp,%edx
  182205:	73 04                	jae    18220b <i2c_isr_irq_handler+0x275>
			count_tx -= missing_bytes;
  182207:	29 d5                	sub    %edx,%ebp
  182209:	eb 39                	jmp    182244 <i2c_isr_irq_handler+0x2ae>
		} else {
			count_tx = 0;
  18220b:	bd 00 00 00 00       	mov    $0x0,%ebp
  182210:	eb 32                	jmp    182244 <i2c_isr_irq_handler+0x2ae>
		}

		while (i2c_read_cmd_send[i2c] &&
		       (write_buffer_remaining == 0) && count_tx) {
			count_tx--;
  182212:	4d                   	dec    %ebp
			i2c_read_cmd_send[i2c]--;
  182213:	8b 14 9d 30 01 28 00 	mov    0x280130(,%ebx,4),%edx
  18221a:	4a                   	dec    %edx
  18221b:	89 14 9d 30 01 28 00 	mov    %edx,0x280130(,%ebx,4)

			/*
			 * If transfer is a combined transfer, only send stop at
			 * end of the transfer sequence.
			 */
			if (transfer->stop && (i2c_read_cmd_send[i2c] == 0)) {
  182222:	8a 57 10             	mov    0x10(%edi),%dl
  182225:	84 d2                	test   %dl,%dl
  182227:	74 14                	je     18223d <i2c_isr_irq_handler+0x2a7>
  182229:	8b 14 9d 30 01 28 00 	mov    0x280130(,%ebx,4),%edx
  182230:	85 d2                	test   %edx,%edx
  182232:	75 09                	jne    18223d <i2c_isr_irq_handler+0x2a7>
				controller->ic_data_cmd =
  182234:	c7 46 10 00 03 00 00 	movl   $0x300,0x10(%esi)
  18223b:	eb 07                	jmp    182244 <i2c_isr_irq_handler+0x2ae>
				    QM_I2C_IC_DATA_CMD_READ |
				    QM_I2C_IC_DATA_CMD_STOP_BIT_CTRL;
			} else {
				controller->ic_data_cmd =
  18223d:	c7 46 10 00 01 00 00 	movl   $0x100,0x10(%esi)
			count_tx -= missing_bytes;
		} else {
			count_tx = 0;
		}

		while (i2c_read_cmd_send[i2c] &&
  182244:	8b 14 9d 30 01 28 00 	mov    0x280130(,%ebx,4),%edx
  18224b:	85 d2                	test   %edx,%edx
  18224d:	74 0d                	je     18225c <i2c_isr_irq_handler+0x2c6>
		       (write_buffer_remaining == 0) && count_tx) {
  18224f:	85 c0                	test   %eax,%eax
  182251:	0f 94 c2             	sete   %dl
  182254:	85 ed                	test   %ebp,%ebp
  182256:	74 04                	je     18225c <i2c_isr_irq_handler+0x2c6>
  182258:	84 d2                	test   %dl,%dl
  18225a:	75 b6                	jne    182212 <i2c_isr_irq_handler+0x27c>
				    QM_I2C_IC_DATA_CMD_READ;
			}
		}

		/* Generate a tx_empty interrupt when TX FIFO is fully empty. */
		if ((write_buffer_remaining == 0) &&
  18225c:	8b 0c 24             	mov    (%esp),%ecx
  18225f:	09 c1                	or     %eax,%ecx
  182261:	0f 85 00 02 00 00    	jne    182467 <i2c_isr_irq_handler+0x4d1>
		    (read_buffer_remaining == 0)) {
			controller->ic_tx_tl = 0;
  182267:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  18226e:	e9 f4 01 00 00       	jmp    182467 <i2c_isr_irq_handler+0x4d1>
i2c_isr_slave_handler(const qm_i2c_t i2c,
		      const volatile qm_i2c_transfer_t *const transfer,
		      qm_i2c_reg_t *const controller)
{
	/* Save register to speed up process in interrupt. */
	uint32_t ic_intr_stat = controller->ic_intr_stat;
  182273:	8b 46 2c             	mov    0x2c(%esi),%eax
  182276:	89 04 24             	mov    %eax,(%esp)
	 * - General call (will only appear after few SCL clock cycles after
	 *   start interrupt).
	 */

	/* Stop condition detected. */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_STOP_DETECTED) {
  182279:	f6 c4 02             	test   $0x2,%ah
  18227c:	0f 84 97 00 00 00    	je     182319 <i2c_isr_irq_handler+0x383>
		/* Empty RX FIFO. */
		empty_rx_fifo(i2c, transfer, controller);
  182282:	89 f1                	mov    %esi,%ecx
  182284:	89 fa                	mov    %edi,%edx
  182286:	89 d8                	mov    %ebx,%eax
  182288:	e8 16 fb ff ff       	call   181da3 <empty_rx_fifo>
		 * been addressed.
		 * Driver only knows it has been addressed if:
		 * - It already triggered an interrupt on TX_EMPTY or RX_FULL
		 * - Data was read from RX FIFO.
		 */
		if ((transfer->stop == true) &&
  18228d:	8a 47 10             	mov    0x10(%edi),%al
  182290:	84 c0                	test   %al,%al
  182292:	74 1b                	je     1822af <i2c_isr_irq_handler+0x319>
		    (is_addressed || (i2c_read_pos[i2c] != 0))) {
  182294:	a0 2c 01 28 00       	mov    0x28012c,%al
		 * been addressed.
		 * Driver only knows it has been addressed if:
		 * - It already triggered an interrupt on TX_EMPTY or RX_FULL
		 * - Data was read from RX FIFO.
		 */
		if ((transfer->stop == true) &&
  182299:	84 c0                	test   %al,%al
  18229b:	75 0b                	jne    1822a8 <i2c_isr_irq_handler+0x312>
		    (is_addressed || (i2c_read_pos[i2c] != 0))) {
  18229d:	8b 04 9d 34 01 28 00 	mov    0x280134(,%ebx,4),%eax
  1822a4:	85 c0                	test   %eax,%eax
  1822a6:	74 07                	je     1822af <i2c_isr_irq_handler+0x319>
			controller_disable(i2c);
  1822a8:	89 d8                	mov    %ebx,%eax
  1822aa:	e8 a4 fc ff ff       	call   181f53 <controller_disable>
		}

		if (transfer->callback) {
  1822af:	8b 47 14             	mov    0x14(%edi),%eax
  1822b2:	85 c0                	test   %eax,%eax
  1822b4:	74 2d                	je     1822e3 <i2c_isr_irq_handler+0x34d>
			transfer->callback(
  1822b6:	8b 6f 14             	mov    0x14(%edi),%ebp
			    transfer->callback_data, 0, QM_I2C_STOP_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
  1822b9:	a0 2e 01 28 00       	mov    0x28012e,%al
		    (is_addressed || (i2c_read_pos[i2c] != 0))) {
			controller_disable(i2c);
		}

		if (transfer->callback) {
			transfer->callback(
  1822be:	84 c0                	test   %al,%al
  1822c0:	74 09                	je     1822cb <i2c_isr_irq_handler+0x335>
  1822c2:	8b 14 9d 34 01 28 00 	mov    0x280134(,%ebx,4),%edx
  1822c9:	eb 05                	jmp    1822d0 <i2c_isr_irq_handler+0x33a>
  1822cb:	ba 00 00 00 00       	mov    $0x0,%edx
  1822d0:	8b 47 18             	mov    0x18(%edi),%eax
  1822d3:	52                   	push   %edx
  1822d4:	b9 00 00 00 02       	mov    $0x2000000,%ecx
  1822d9:	ba 00 00 00 00       	mov    $0x0,%edx
  1822de:	ff d5                	call   *%ebp
  1822e0:	83 c4 04             	add    $0x4,%esp
			    transfer->callback_data, 0, QM_I2C_STOP_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
		}
		i2c_write_pos[i2c] = 0;
  1822e3:	c7 04 9d 38 01 28 00 	movl   $0x0,0x280138(,%ebx,4)
  1822ea:	00 00 00 00 
		i2c_read_pos[i2c] = 0;
  1822ee:	c7 04 9d 34 01 28 00 	movl   $0x0,0x280134(,%ebx,4)
  1822f5:	00 00 00 00 

		controller->ic_intr_mask &= ~QM_I2C_IC_INTR_MASK_TX_EMPTY;
  1822f9:	8b 46 30             	mov    0x30(%esi),%eax
  1822fc:	83 e0 ef             	and    $0xffffffef,%eax
  1822ff:	89 46 30             	mov    %eax,0x30(%esi)

		is_addressed = false;
  182302:	c6 05 2c 01 28 00 00 	movb   $0x0,0x28012c

		/* Clear stop interrupt. */
		controller->ic_clr_stop_det;
  182309:	8b 46 60             	mov    0x60(%esi),%eax

		/*
		 * Read again the interrupt status in case of a start interrupt
		 * has been triggered in the meantime.
		 */
		ic_intr_stat = controller->ic_intr_stat;
  18230c:	8b 46 2c             	mov    0x2c(%esi),%eax
  18230f:	89 04 24             	mov    %eax,(%esp)
		first_start = true;
  182312:	c6 05 2d 01 28 00 01 	movb   $0x1,0x28012d
	/*
	 * START or RESTART condition detected.
	 * The RESTART_DETECTED interrupt is not used as it is redundant with
	 * the START_DETECTED interrupt.
	 */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_START_DETECTED) {
  182319:	f7 04 24 00 04 00 00 	testl  $0x400,(%esp)
  182320:	74 71                	je     182393 <i2c_isr_irq_handler+0x3fd>
		if (!first_start) {
  182322:	a0 2d 01 28 00       	mov    0x28012d,%al
  182327:	84 c0                	test   %al,%al
  182329:	75 0b                	jne    182336 <i2c_isr_irq_handler+0x3a0>
			empty_rx_fifo(i2c, transfer, controller);
  18232b:	89 f1                	mov    %esi,%ecx
  18232d:	89 fa                	mov    %edi,%edx
  18232f:	89 d8                	mov    %ebx,%eax
  182331:	e8 6d fa ff ff       	call   181da3 <empty_rx_fifo>
		}
		if (transfer->callback) {
  182336:	8b 47 14             	mov    0x14(%edi),%eax
  182339:	85 c0                	test   %eax,%eax
  18233b:	74 2f                	je     18236c <i2c_isr_irq_handler+0x3d6>
			transfer->callback(
  18233d:	8b 47 14             	mov    0x14(%edi),%eax
  182340:	89 c5                	mov    %eax,%ebp
			    transfer->callback_data, 0, QM_I2C_START_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
  182342:	a0 2e 01 28 00       	mov    0x28012e,%al
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_START_DETECTED) {
		if (!first_start) {
			empty_rx_fifo(i2c, transfer, controller);
		}
		if (transfer->callback) {
			transfer->callback(
  182347:	84 c0                	test   %al,%al
  182349:	74 09                	je     182354 <i2c_isr_irq_handler+0x3be>
  18234b:	8b 14 9d 34 01 28 00 	mov    0x280134(,%ebx,4),%edx
  182352:	eb 05                	jmp    182359 <i2c_isr_irq_handler+0x3c3>
  182354:	ba 00 00 00 00       	mov    $0x0,%edx
  182359:	8b 47 18             	mov    0x18(%edi),%eax
  18235c:	52                   	push   %edx
  18235d:	b9 00 00 40 00       	mov    $0x400000,%ecx
  182362:	ba 00 00 00 00       	mov    $0x0,%edx
  182367:	ff d5                	call   *%ebp
  182369:	83 c4 04             	add    $0x4,%esp
			    transfer->callback_data, 0, QM_I2C_START_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
		}
		transfer_ongoing = true;
  18236c:	c6 05 2e 01 28 00 01 	movb   $0x1,0x28012e
		i2c_write_pos[i2c] = 0;
  182373:	c7 04 9d 38 01 28 00 	movl   $0x0,0x280138(,%ebx,4)
  18237a:	00 00 00 00 
		i2c_read_pos[i2c] = 0;
  18237e:	c7 04 9d 34 01 28 00 	movl   $0x0,0x280134(,%ebx,4)
  182385:	00 00 00 00 

		/* Clear Start detected interrupt. */
		controller->ic_clr_start_det;
  182389:	8b 46 64             	mov    0x64(%esi),%eax
		first_start = false;
  18238c:	c6 05 2d 01 28 00 00 	movb   $0x0,0x28012d
	 *
	 * RX FIFO overflow must always be checked though, in case of an
	 * overflow happens during RX_FULL interrupt handling.
	 */
	/* RX FIFO Overflow. */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_OVER) {
  182393:	f6 04 24 02          	testb  $0x2,(%esp)
  182397:	74 23                	je     1823bc <i2c_isr_irq_handler+0x426>
		controller->ic_clr_rx_over;
  182399:	8b 46 48             	mov    0x48(%esi),%eax
		if (transfer->callback) {
  18239c:	8b 47 14             	mov    0x14(%edi),%eax
  18239f:	85 c0                	test   %eax,%eax
  1823a1:	74 19                	je     1823bc <i2c_isr_irq_handler+0x426>
			transfer->callback(transfer->callback_data, 0,
  1823a3:	8b 47 14             	mov    0x14(%edi),%eax
  1823a6:	89 c5                	mov    %eax,%ebp
  1823a8:	8b 47 18             	mov    0x18(%edi),%eax
  1823ab:	6a 00                	push   $0x0
  1823ad:	b9 00 00 10 00       	mov    $0x100000,%ecx
  1823b2:	ba 00 00 00 00       	mov    $0x0,%edx
  1823b7:	ff d5                	call   *%ebp
  1823b9:	83 c4 04             	add    $0x4,%esp
					   QM_I2C_RX_OVER, 0);
		}
	}

	/* RX FIFO FULL. */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {
  1823bc:	f6 04 24 04          	testb  $0x4,(%esp)
  1823c0:	74 17                	je     1823d9 <i2c_isr_irq_handler+0x443>
		/* Empty RX FIFO. */
		empty_rx_fifo(i2c, transfer, controller);
  1823c2:	89 f1                	mov    %esi,%ecx
  1823c4:	89 fa                	mov    %edi,%edx
  1823c6:	89 d8                	mov    %ebx,%eax
  1823c8:	e8 d6 f9 ff ff       	call   181da3 <empty_rx_fifo>

		/* Track activity of controller when addressed. */
		is_addressed = true;
  1823cd:	c6 05 2c 01 28 00 01 	movb   $0x1,0x28012c
  1823d4:	e9 8e 00 00 00       	jmp    182467 <i2c_isr_irq_handler+0x4d1>
	 * TX FIFO empty interrupt must be handled after RX DONE interrupt: when
	 * RX DONE is triggered, TX FIFO is flushed (thus emptied) creating a
	 * TX_ABORT interrupt and a TX_EMPTY condition. TX_ABORT shall be
	 * cleared and TX_EMPTY interrupt disabled.
	 */
	else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RD_REQ) {
  1823d9:	f6 04 24 20          	testb  $0x20,(%esp)
  1823dd:	74 20                	je     1823ff <i2c_isr_irq_handler+0x469>
		/* Clear read request interrupt. */
		controller->ic_clr_rd_req;
  1823df:	8b 46 50             	mov    0x50(%esi),%eax

		/* Track activity of controller when addressed. */
		is_addressed = true;
  1823e2:	c6 05 2c 01 28 00 01 	movb   $0x1,0x28012c

		slave_fill_tx_fifo(i2c, transfer, controller);
  1823e9:	89 f1                	mov    %esi,%ecx
  1823eb:	89 fa                	mov    %edi,%edx
  1823ed:	89 d8                	mov    %ebx,%eax
  1823ef:	e8 32 fa ff ff       	call   181e26 <slave_fill_tx_fifo>

		/* Enable TX EMPTY interrupts. */
		controller->ic_intr_mask |= QM_I2C_IC_INTR_MASK_TX_EMPTY;
  1823f4:	8b 46 30             	mov    0x30(%esi),%eax
  1823f7:	83 c8 10             	or     $0x10,%eax
  1823fa:	89 46 30             	mov    %eax,0x30(%esi)
  1823fd:	eb 68                	jmp    182467 <i2c_isr_irq_handler+0x4d1>
	} else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_DONE) {
  1823ff:	f6 04 24 80          	testb  $0x80,(%esp)
  182403:	74 14                	je     182419 <i2c_isr_irq_handler+0x483>
		controller->ic_clr_rx_done;
  182405:	8b 46 58             	mov    0x58(%esi),%eax
		/* Clear TX ABORT as it is triggered when FIFO is flushed. */
		controller->ic_clr_tx_abrt;
  182408:	8b 46 54             	mov    0x54(%esi),%eax

		/* Disable TX EMPTY interrupt. */
		controller->ic_intr_mask &= ~QM_I2C_IC_INTR_MASK_TX_EMPTY;
  18240b:	8b 46 30             	mov    0x30(%esi),%eax
  18240e:	83 e0 ef             	and    $0xffffffef,%eax
  182411:	89 46 30             	mov    %eax,0x30(%esi)

		/*
		 * Read again the interrupt status in case of a stop or a start
		 * interrupt has been triggered in the meantime.
		 */
		ic_intr_stat = controller->ic_intr_stat;
  182414:	8b 46 2c             	mov    0x2c(%esi),%eax
  182417:	eb 4e                	jmp    182467 <i2c_isr_irq_handler+0x4d1>

	} else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_EMPTY) {
  182419:	f6 04 24 10          	testb  $0x10,(%esp)
  18241d:	74 0d                	je     18242c <i2c_isr_irq_handler+0x496>
		slave_fill_tx_fifo(i2c, transfer, controller);
  18241f:	89 f1                	mov    %esi,%ecx
  182421:	89 fa                	mov    %edi,%edx
  182423:	89 d8                	mov    %ebx,%eax
  182425:	e8 fc f9 ff ff       	call   181e26 <slave_fill_tx_fifo>
  18242a:	eb 3b                	jmp    182467 <i2c_isr_irq_handler+0x4d1>
	}

	/* General call detected. */
	else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_GEN_CALL_DETECTED) {
  18242c:	f7 04 24 00 08 00 00 	testl  $0x800,(%esp)
  182433:	74 32                	je     182467 <i2c_isr_irq_handler+0x4d1>
		if (transfer->callback) {
  182435:	8b 47 14             	mov    0x14(%edi),%eax
  182438:	85 c0                	test   %eax,%eax
  18243a:	74 1c                	je     182458 <i2c_isr_irq_handler+0x4c2>
			transfer->callback(transfer->callback_data, 0,
  18243c:	8b 5f 14             	mov    0x14(%edi),%ebx
  18243f:	8b 47 18             	mov    0x18(%edi),%eax
  182442:	6a 00                	push   $0x0
  182444:	b9 00 00 00 04       	mov    $0x4000000,%ecx
  182449:	ba 00 00 00 00       	mov    $0x0,%edx
  18244e:	ff d3                	call   *%ebx
  182450:	83 c4 04             	add    $0x4,%esp
  182453:	eb 03                	jmp    182458 <i2c_isr_irq_handler+0x4c2>
		 * read too early.
		 */
		while (controller->ic_intr_stat &
		       QM_I2C_IC_INTR_STAT_GEN_CALL_DETECTED) {
			/* Clear General call interrupt. */
			controller->ic_clr_gen_call;
  182455:	8b 46 68             	mov    0x68(%esi),%eax
		/*
		 * Workaround.
		 * The interrupt may not actually be cleared when register is
		 * read too early.
		 */
		while (controller->ic_intr_stat &
  182458:	8b 46 2c             	mov    0x2c(%esi),%eax
  18245b:	f6 c4 08             	test   $0x8,%ah
  18245e:	75 f5                	jne    182455 <i2c_isr_irq_handler+0x4bf>
#else
		controller->ic_clr_gen_call;
#endif

		/* Track activity of controller when addressed. */
		is_addressed = true;
  182460:	c6 05 2c 01 28 00 01 	movb   $0x1,0x28012c
	}
	/* Slave mode. */
	else {
		i2c_isr_slave_handler(i2c, transfer, controller);
	}
}
  182467:	83 c4 08             	add    $0x8,%esp
  18246a:	5b                   	pop    %ebx
  18246b:	5e                   	pop    %esi
  18246c:	5f                   	pop    %edi
  18246d:	5d                   	pop    %ebp
  18246e:	c3                   	ret    

0018246f <get_lo_cnt>:
	QM_ISR_EOI(QM_IRQ_I2C_1_INT_VECTOR);
}
#endif

static uint32_t get_lo_cnt(uint32_t lo_time_ns)
{
  18246f:	53                   	push   %ebx
  182470:	89 c3                	mov    %eax,%ebx
	return (((get_i2c_clk_freq_in_mhz() * lo_time_ns) / 1000) - 1);
  182472:	e8 19 f9 ff ff       	call   181d90 <get_i2c_clk_freq_in_mhz>
  182477:	0f af d8             	imul   %eax,%ebx
  18247a:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  18247f:	89 d8                	mov    %ebx,%eax
  182481:	f7 e1                	mul    %ecx
  182483:	c1 ea 06             	shr    $0x6,%edx
  182486:	8d 42 ff             	lea    -0x1(%edx),%eax
}
  182489:	5b                   	pop    %ebx
  18248a:	c3                   	ret    

0018248b <get_hi_cnt>:

static uint32_t get_hi_cnt(qm_i2c_t i2c, uint32_t hi_time_ns)
{
  18248b:	56                   	push   %esi
  18248c:	53                   	push   %ebx
  18248d:	89 c3                	mov    %eax,%ebx
  18248f:	89 d6                	mov    %edx,%esi
	return ((((get_i2c_clk_freq_in_mhz() * hi_time_ns) / 1000) - 7 -
  182491:	e8 fa f8 ff ff       	call   181d90 <get_i2c_clk_freq_in_mhz>
  182496:	0f af f0             	imul   %eax,%esi
  182499:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  18249e:	89 f0                	mov    %esi,%eax
  1824a0:	f7 e1                	mul    %ecx
  1824a2:	c1 ea 06             	shr    $0x6,%edx
		 QM_I2C[i2c]->ic_fs_spklen) +
  1824a5:	8b 04 9d 18 00 28 00 	mov    0x280018(,%ebx,4),%eax
  1824ac:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
	return (((get_i2c_clk_freq_in_mhz() * lo_time_ns) / 1000) - 1);
}

static uint32_t get_hi_cnt(qm_i2c_t i2c, uint32_t hi_time_ns)
{
	return ((((get_i2c_clk_freq_in_mhz() * hi_time_ns) / 1000) - 7 -
  1824b2:	29 c2                	sub    %eax,%edx
  1824b4:	8d 42 fa             	lea    -0x6(%edx),%eax
		 QM_I2C[i2c]->ic_fs_spklen) +
		1);
}
  1824b7:	5b                   	pop    %ebx
  1824b8:	5e                   	pop    %esi
  1824b9:	c3                   	ret    

001824ba <qm_i2c_0_irq_isr>:
	}
}

QM_ISR_DECLARE(qm_i2c_0_irq_isr)
{
	i2c_isr_irq_handler(QM_I2C_0);
  1824ba:	b8 00 00 00 00       	mov    $0x0,%eax
  1824bf:	e8 d2 fa ff ff       	call   181f96 <i2c_isr_irq_handler>
  1824c4:	c3                   	ret    

001824c5 <qm_i2c_set_config>:
		 QM_I2C[i2c]->ic_fs_spklen) +
		1);
}

int qm_i2c_set_config(const qm_i2c_t i2c, const qm_i2c_config_t *const cfg)
{
  1824c5:	55                   	push   %ebp
  1824c6:	57                   	push   %edi
  1824c7:	56                   	push   %esi
  1824c8:	53                   	push   %ebx
  1824c9:	83 ec 0c             	sub    $0xc,%esp
  1824cc:	89 c3                	mov    %eax,%ebx
  1824ce:	89 d7                	mov    %edx,%edi
	uint32_t lcnt = 0, hcnt = 0, min_lcnt = 0, lcnt_diff = 0, ic_con = 0;
	QM_CHECK(i2c < QM_I2C_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  1824d0:	8b 34 85 18 00 28 00 	mov    0x280018(,%eax,4),%esi

	i2c_dma_context[i2c].ongoing_dma_rx_operation = false;
  1824d7:	c1 e0 06             	shl    $0x6,%eax
  1824da:	c6 80 b5 02 28 00 00 	movb   $0x0,0x2802b5(%eax)
	i2c_dma_context[i2c].ongoing_dma_tx_operation = false;
  1824e1:	c6 80 b4 02 28 00 00 	movb   $0x0,0x2802b4(%eax)
	/* Mask all interrupts. */
	controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  1824e8:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

	/* Disable controller. */
	if (controller_disable(i2c)) {
  1824ef:	89 d8                	mov    %ebx,%eax
  1824f1:	e8 5d fa ff ff       	call   181f53 <controller_disable>
  1824f6:	85 c0                	test   %eax,%eax
  1824f8:	0f 85 7b 01 00 00    	jne    182679 <qm_i2c_set_config+0x1b4>
  1824fe:	89 c5                	mov    %eax,%ebp
		return -EBUSY;
	}

	switch (cfg->mode) {
  182500:	8b 47 08             	mov    0x8(%edi),%eax
  182503:	85 c0                	test   %eax,%eax
  182505:	74 0e                	je     182515 <qm_i2c_set_config+0x50>
  182507:	83 f8 01             	cmp    $0x1,%eax
  18250a:	0f 84 3c 01 00 00    	je     18264c <qm_i2c_set_config+0x187>
  182510:	e9 56 01 00 00       	jmp    18266b <qm_i2c_set_config+0x1a6>
		/* Set mode. */
		ic_con = QM_I2C_IC_CON_MASTER_MODE | QM_I2C_IC_CON_RESTART_EN |
			 QM_I2C_IC_CON_SLAVE_DISABLE |
			 /* Set 7/10 bit address mode. */
			 (cfg->address_mode
			  << QM_I2C_IC_CON_10BITADDR_MASTER_OFFSET);
  182515:	8b 47 04             	mov    0x4(%edi),%eax
  182518:	c1 e0 04             	shl    $0x4,%eax
	}

	switch (cfg->mode) {
	case QM_I2C_MASTER:
		/* Set mode. */
		ic_con = QM_I2C_IC_CON_MASTER_MODE | QM_I2C_IC_CON_RESTART_EN |
  18251b:	89 c1                	mov    %eax,%ecx
  18251d:	83 c9 61             	or     $0x61,%ecx
  182520:	89 0c 24             	mov    %ecx,(%esp)
		 *    at 50% duty cycle
		 * 2. adjust the hi/lo count to ensure that minimum hi/lo
		 *    timings are guaranteed as per spec.
		 */

		switch (cfg->speed) {
  182523:	8b 17                	mov    (%edi),%edx
  182525:	83 fa 02             	cmp    $0x2,%edx
  182528:	74 4f                	je     182579 <qm_i2c_set_config+0xb4>
  18252a:	83 fa 03             	cmp    $0x3,%edx
  18252d:	0f 84 80 00 00 00    	je     1825b3 <qm_i2c_set_config+0xee>
  182533:	83 fa 01             	cmp    $0x1,%edx
  182536:	0f 85 b1 00 00 00    	jne    1825ed <qm_i2c_set_config+0x128>
		case QM_I2C_SPEED_STD:

			ic_con |= QM_I2C_IC_CON_SPEED_SS;
  18253c:	83 c8 63             	or     $0x63,%eax
  18253f:	89 04 24             	mov    %eax,(%esp)

			controller->ic_fs_spklen = SPK_LEN_SS;
  182542:	c7 86 a0 00 00 00 01 	movl   $0x1,0xa0(%esi)
  182549:	00 00 00 

			min_lcnt = get_lo_cnt(QM_I2C_MIN_SS_NS);
  18254c:	b8 5c 12 00 00       	mov    $0x125c,%eax
  182551:	e8 19 ff ff ff       	call   18246f <get_lo_cnt>
  182556:	89 44 24 08          	mov    %eax,0x8(%esp)
			lcnt = get_lo_cnt(QM_I2C_SS_50_DC_NS);
  18255a:	b8 88 13 00 00       	mov    $0x1388,%eax
  18255f:	e8 0b ff ff ff       	call   18246f <get_lo_cnt>
  182564:	89 44 24 04          	mov    %eax,0x4(%esp)
			hcnt = get_hi_cnt(i2c, QM_I2C_SS_50_DC_NS);
  182568:	ba 88 13 00 00       	mov    $0x1388,%edx
  18256d:	89 d8                	mov    %ebx,%eax
  18256f:	e8 17 ff ff ff       	call   18248b <get_hi_cnt>
			break;
  182574:	e9 89 00 00 00       	jmp    182602 <qm_i2c_set_config+0x13d>

		case QM_I2C_SPEED_FAST:
			ic_con |= QM_I2C_IC_CON_SPEED_FS_FSP;
  182579:	83 c8 65             	or     $0x65,%eax
  18257c:	89 04 24             	mov    %eax,(%esp)

			controller->ic_fs_spklen = SPK_LEN_FS_FSP;
  18257f:	c7 86 a0 00 00 00 02 	movl   $0x2,0xa0(%esi)
  182586:	00 00 00 

			min_lcnt = get_lo_cnt(QM_I2C_MIN_FS_NS);
  182589:	b8 14 05 00 00       	mov    $0x514,%eax
  18258e:	e8 dc fe ff ff       	call   18246f <get_lo_cnt>
  182593:	89 44 24 08          	mov    %eax,0x8(%esp)
			lcnt = get_lo_cnt(QM_I2C_FS_50_DC_NS);
  182597:	b8 e2 04 00 00       	mov    $0x4e2,%eax
  18259c:	e8 ce fe ff ff       	call   18246f <get_lo_cnt>
  1825a1:	89 44 24 04          	mov    %eax,0x4(%esp)
			hcnt = get_hi_cnt(i2c, QM_I2C_FS_50_DC_NS);
  1825a5:	ba e2 04 00 00       	mov    $0x4e2,%edx
  1825aa:	89 d8                	mov    %ebx,%eax
  1825ac:	e8 da fe ff ff       	call   18248b <get_hi_cnt>
			break;
  1825b1:	eb 4f                	jmp    182602 <qm_i2c_set_config+0x13d>

		case QM_I2C_SPEED_FAST_PLUS:
			ic_con |= QM_I2C_IC_CON_SPEED_FS_FSP;
  1825b3:	83 c8 65             	or     $0x65,%eax
  1825b6:	89 04 24             	mov    %eax,(%esp)

			controller->ic_fs_spklen = SPK_LEN_FS_FSP;
  1825b9:	c7 86 a0 00 00 00 02 	movl   $0x2,0xa0(%esi)
  1825c0:	00 00 00 

			min_lcnt = get_lo_cnt(QM_I2C_MIN_FSP_NS);
  1825c3:	b8 f4 01 00 00       	mov    $0x1f4,%eax
  1825c8:	e8 a2 fe ff ff       	call   18246f <get_lo_cnt>
  1825cd:	89 44 24 08          	mov    %eax,0x8(%esp)
			lcnt = get_lo_cnt(QM_I2C_FSP_50_DC_NS);
  1825d1:	b8 f4 01 00 00       	mov    $0x1f4,%eax
  1825d6:	e8 94 fe ff ff       	call   18246f <get_lo_cnt>
  1825db:	89 44 24 04          	mov    %eax,0x4(%esp)
			hcnt = get_hi_cnt(i2c, QM_I2C_FSP_50_DC_NS);
  1825df:	ba f4 01 00 00       	mov    $0x1f4,%edx
  1825e4:	89 d8                	mov    %ebx,%eax
  1825e6:	e8 a0 fe ff ff       	call   18248b <get_hi_cnt>
			break;
  1825eb:	eb 15                	jmp    182602 <qm_i2c_set_config+0x13d>
		1);
}

int qm_i2c_set_config(const qm_i2c_t i2c, const qm_i2c_config_t *const cfg)
{
	uint32_t lcnt = 0, hcnt = 0, min_lcnt = 0, lcnt_diff = 0, ic_con = 0;
  1825ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1825f4:	00 
  1825f5:	b8 00 00 00 00       	mov    $0x0,%eax
  1825fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  182601:	00 
			lcnt = get_lo_cnt(QM_I2C_FSP_50_DC_NS);
			hcnt = get_hi_cnt(i2c, QM_I2C_FSP_50_DC_NS);
			break;
		}

		if (hcnt > QM_I2C_IC_HCNT_MAX || hcnt < QM_I2C_IC_HCNT_MIN) {
  182602:	8d 50 fa             	lea    -0x6(%eax),%edx
  182605:	81 fa ef ff 00 00    	cmp    $0xffef,%edx
  18260b:	77 73                	ja     182680 <qm_i2c_set_config+0x1bb>
			return -EINVAL;
		}

		if (lcnt > QM_I2C_IC_LCNT_MAX || lcnt < QM_I2C_IC_LCNT_MIN) {
  18260d:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  182611:	8d 53 f8             	lea    -0x8(%ebx),%edx
  182614:	81 fa ed ff 00 00    	cmp    $0xffed,%edx
  18261a:	77 6b                	ja     182687 <qm_i2c_set_config+0x1c2>
			return -EINVAL;
		}

		/* Increment minimum low count to account for rounding down. */
		min_lcnt++;
  18261c:	8b 54 24 08          	mov    0x8(%esp),%edx
  182620:	42                   	inc    %edx
		if (lcnt < min_lcnt) {
  182621:	39 d3                	cmp    %edx,%ebx
  182623:	73 0a                	jae    18262f <qm_i2c_set_config+0x16a>
			lcnt_diff = (min_lcnt - lcnt);
  182625:	89 d1                	mov    %edx,%ecx
  182627:	29 d9                	sub    %ebx,%ecx
			lcnt += (lcnt_diff);
			hcnt -= (lcnt_diff);
  182629:	29 c8                	sub    %ecx,%eax

		/* Increment minimum low count to account for rounding down. */
		min_lcnt++;
		if (lcnt < min_lcnt) {
			lcnt_diff = (min_lcnt - lcnt);
			lcnt += (lcnt_diff);
  18262b:	89 54 24 04          	mov    %edx,0x4(%esp)
			hcnt -= (lcnt_diff);
		}
		if (QM_I2C_SPEED_STD == cfg->speed) {
  18262f:	83 3f 01             	cmpl   $0x1,(%edi)
  182632:	75 0c                	jne    182640 <qm_i2c_set_config+0x17b>
			controller->ic_ss_scl_lcnt = lcnt;
  182634:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  182638:	89 4e 18             	mov    %ecx,0x18(%esi)
			controller->ic_ss_scl_hcnt = hcnt;
  18263b:	89 46 14             	mov    %eax,0x14(%esi)
  18263e:	eb 32                	jmp    182672 <qm_i2c_set_config+0x1ad>
		} else {
			controller->ic_fs_scl_hcnt = hcnt;
  182640:	89 46 1c             	mov    %eax,0x1c(%esi)
			controller->ic_fs_scl_lcnt = lcnt;
  182643:	8b 44 24 04          	mov    0x4(%esp),%eax
  182647:	89 46 20             	mov    %eax,0x20(%esi)
  18264a:	eb 26                	jmp    182672 <qm_i2c_set_config+0x1ad>
		 * QM_I2C_IC_CON_MASTER_MODE and QM_I2C_IC_CON_SLAVE_DISABLE are
		 * deasserted.
		 */

		/* Set 7/10 bit address mode. */
		ic_con = cfg->address_mode
  18264c:	8b 47 04             	mov    0x4(%edi),%eax
  18264f:	c1 e0 03             	shl    $0x3,%eax
  182652:	89 04 24             	mov    %eax,(%esp)
			 << QM_I2C_IC_CON_10BITADDR_SLAVE_OFFSET;

		if (cfg->stop_detect_behaviour ==
  182655:	83 7f 10 01          	cmpl   $0x1,0x10(%edi)
  182659:	75 07                	jne    182662 <qm_i2c_set_config+0x19d>
		    QM_I2C_SLAVE_INTERRUPT_WHEN_ADDRESSED) {
			/* Set stop interrupt only when addressed. */
			ic_con |= QM_I2C_IC_CON_STOP_DET_IFADDRESSED;
  18265b:	81 0c 24 80 00 00 00 	orl    $0x80,(%esp)
		}

		/* Set slave address. */
		controller->ic_sar = cfg->slave_addr;
  182662:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  182666:	89 46 08             	mov    %eax,0x8(%esi)
		break;
  182669:	eb 07                	jmp    182672 <qm_i2c_set_config+0x1ad>
		1);
}

int qm_i2c_set_config(const qm_i2c_t i2c, const qm_i2c_config_t *const cfg)
{
	uint32_t lcnt = 0, hcnt = 0, min_lcnt = 0, lcnt_diff = 0, ic_con = 0;
  18266b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
		/* Set slave address. */
		controller->ic_sar = cfg->slave_addr;
		break;
	}

	controller->ic_con = ic_con;
  182672:	8b 04 24             	mov    (%esp),%eax
  182675:	89 06                	mov    %eax,(%esi)
	return 0;
  182677:	eb 13                	jmp    18268c <qm_i2c_set_config+0x1c7>
	/* Mask all interrupts. */
	controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;

	/* Disable controller. */
	if (controller_disable(i2c)) {
		return -EBUSY;
  182679:	bd f0 ff ff ff       	mov    $0xfffffff0,%ebp
  18267e:	eb 0c                	jmp    18268c <qm_i2c_set_config+0x1c7>
			hcnt = get_hi_cnt(i2c, QM_I2C_FSP_50_DC_NS);
			break;
		}

		if (hcnt > QM_I2C_IC_HCNT_MAX || hcnt < QM_I2C_IC_HCNT_MIN) {
			return -EINVAL;
  182680:	bd ea ff ff ff       	mov    $0xffffffea,%ebp
  182685:	eb 05                	jmp    18268c <qm_i2c_set_config+0x1c7>
		}

		if (lcnt > QM_I2C_IC_LCNT_MAX || lcnt < QM_I2C_IC_LCNT_MIN) {
			return -EINVAL;
  182687:	bd ea ff ff ff       	mov    $0xffffffea,%ebp
		break;
	}

	controller->ic_con = ic_con;
	return 0;
}
  18268c:	89 e8                	mov    %ebp,%eax
  18268e:	83 c4 0c             	add    $0xc,%esp
  182691:	5b                   	pop    %ebx
  182692:	5e                   	pop    %esi
  182693:	5f                   	pop    %edi
  182694:	5d                   	pop    %ebp
  182695:	c3                   	ret    

00182696 <qm_i2c_master_irq_transfer>:
}

int qm_i2c_master_irq_transfer(const qm_i2c_t i2c,
			       const qm_i2c_transfer_t *const xfer,
			       const uint16_t slave_addr)
{
  182696:	57                   	push   %edi
  182697:	56                   	push   %esi
  182698:	53                   	push   %ebx
  182699:	89 c6                	mov    %eax,%esi
  18269b:	89 d7                	mov    %edx,%edi
	QM_CHECK(i2c < QM_I2C_NUM, -EINVAL);
	QM_CHECK(NULL != xfer, -EINVAL);
	QM_CHECK(slave_addr <= QM_I2C_IC_TAR_MASK, -EINVAL);

	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  18269d:	8b 1c 85 18 00 28 00 	mov    0x280018(,%eax,4),%ebx

	/* Write slave address to TAR. */
	controller->ic_tar &= ~QM_I2C_IC_TAR_MASK;
  1826a4:	8b 43 04             	mov    0x4(%ebx),%eax
  1826a7:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  1826ac:	89 43 04             	mov    %eax,0x4(%ebx)
	controller->ic_tar |= slave_addr;
  1826af:	8b 43 04             	mov    0x4(%ebx),%eax
  1826b2:	0f b7 c9             	movzwl %cx,%ecx
  1826b5:	09 c1                	or     %eax,%ecx
  1826b7:	89 4b 04             	mov    %ecx,0x4(%ebx)

	i2c_write_pos[i2c] = 0;
  1826ba:	c7 04 b5 38 01 28 00 	movl   $0x0,0x280138(,%esi,4)
  1826c1:	00 00 00 00 
	i2c_read_pos[i2c] = 0;
  1826c5:	c7 04 b5 34 01 28 00 	movl   $0x0,0x280134(,%esi,4)
  1826cc:	00 00 00 00 
	i2c_read_cmd_send[i2c] = xfer->rx_len;
  1826d0:	8b 42 0c             	mov    0xc(%edx),%eax
  1826d3:	89 04 b5 30 01 28 00 	mov    %eax,0x280130(,%esi,4)
	i2c_transfer[i2c] = xfer;
  1826da:	89 14 b5 3c 01 28 00 	mov    %edx,0x28013c(,%esi,4)

	/* Set threshold. */
	controller->ic_tx_tl = TX_TL;
  1826e1:	c7 43 3c 02 00 00 00 	movl   $0x2,0x3c(%ebx)
	if (xfer->rx_len > 0 && xfer->rx_len < (RX_TL + 1)) {
  1826e8:	8b 42 0c             	mov    0xc(%edx),%eax
  1826eb:	48                   	dec    %eax
  1826ec:	83 f8 04             	cmp    $0x4,%eax
  1826ef:	77 05                	ja     1826f6 <qm_i2c_master_irq_transfer+0x60>
		/*
		 * If 'rx_len' is less than the default threshold, we have to
		 * change the threshold value so the 'RX FULL' interrupt is
		 * generated once all data from the transfer is received.
		 */
		controller->ic_rx_tl = xfer->rx_len - 1;
  1826f1:	89 43 38             	mov    %eax,0x38(%ebx)
  1826f4:	eb 07                	jmp    1826fd <qm_i2c_master_irq_transfer+0x67>
	} else {
		controller->ic_rx_tl = RX_TL;
  1826f6:	c7 43 38 05 00 00 00 	movl   $0x5,0x38(%ebx)
	}

	/* Mask interrupts. */
	QM_I2C[i2c]->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  1826fd:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)

	/* Enable controller. */
	controller_enable(i2c);
  182704:	89 f0                	mov    %esi,%eax
  182706:	e8 20 f8 ff ff       	call   181f2b <controller_enable>

	/* Start filling tx fifo. */
	master_fill_tx_fifo(i2c, xfer, controller);
  18270b:	89 d9                	mov    %ebx,%ecx
  18270d:	89 fa                	mov    %edi,%edx
  18270f:	89 f0                	mov    %esi,%eax
  182711:	e8 9e f7 ff ff       	call   181eb4 <master_fill_tx_fifo>

	/* Unmask interrupts. */
	controller->ic_intr_mask |=
  182716:	8b 43 30             	mov    0x30(%ebx),%eax
  182719:	83 c8 5f             	or     $0x5f,%eax
  18271c:	89 43 30             	mov    %eax,0x30(%ebx)
	    QM_I2C_IC_INTR_MASK_RX_UNDER | QM_I2C_IC_INTR_MASK_RX_OVER |
	    QM_I2C_IC_INTR_MASK_RX_FULL | QM_I2C_IC_INTR_MASK_TX_OVER |
	    QM_I2C_IC_INTR_MASK_TX_EMPTY | QM_I2C_IC_INTR_MASK_TX_ABORT;

	return 0;
}
  18271f:	b8 00 00 00 00       	mov    $0x0,%eax
  182724:	5b                   	pop    %ebx
  182725:	5e                   	pop    %esi
  182726:	5f                   	pop    %edi
  182727:	c3                   	ret    

00182728 <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
  182728:	83 ec 04             	sub    $0x4,%esp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  18272b:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
	volatile uint32_t unused_lsr __attribute__((unused));

	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;
  182732:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
  182739:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
  182740:	8b 4a 04             	mov    0x4(%edx),%ecx
  182743:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  182749:	c1 e9 10             	shr    $0x10,%ecx
  18274c:	89 48 04             	mov    %ecx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
  18274f:	8b 4a 04             	mov    0x4(%edx),%ecx
  182752:	0f b6 cd             	movzbl %ch,%ecx
  182755:	89 08                	mov    %ecx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
  182757:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  18275b:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
  182761:	8b 0a                	mov    (%edx),%ecx
  182763:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
  182766:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
  18276d:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  182771:	74 09                	je     18277c <qm_uart_set_config+0x54>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
  182773:	8b 50 10             	mov    0x10(%eax),%edx
  182776:	83 ca 22             	or     $0x22,%edx
  182779:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
  18277c:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
  182783:	8b 50 04             	mov    0x4(%eax),%edx
  182786:	80 ca 80             	or     $0x80,%dl
  182789:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
  18278c:	8b 40 14             	mov    0x14(%eax),%eax
  18278f:	89 04 24             	mov    %eax,(%esp)

	return 0;
}
  182792:	b8 00 00 00 00       	mov    $0x0,%eax
  182797:	83 c4 04             	add    $0x4,%esp
  18279a:	c3                   	ret    

0018279b <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
  18279b:	56                   	push   %esi
  18279c:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
  18279d:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
	uint32_t lsr = regs->lsr;
  1827a4:	8b 48 14             	mov    0x14(%eax),%ecx

	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
  1827a7:	89 cb                	mov    %ecx,%ebx
  1827a9:	83 e3 1e             	and    $0x1e,%ebx
  1827ac:	89 1a                	mov    %ebx,(%edx)

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
  1827ae:	8b 70 1c             	mov    0x1c(%eax),%esi
  1827b1:	f7 c6 01 00 00 00    	test   $0x1,%esi
  1827b7:	74 0b                	je     1827c4 <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
  1827b9:	8b 58 1c             	mov    0x1c(%eax),%ebx
  1827bc:	83 e3 fe             	and    $0xfffffffe,%ebx
  1827bf:	89 58 1c             	mov    %ebx,0x1c(%eax)
  1827c2:	eb 0a                	jmp    1827ce <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
  1827c4:	f6 c1 40             	test   $0x40,%cl
  1827c7:	75 05                	jne    1827ce <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
  1827c9:	83 cb 20             	or     $0x20,%ebx
  1827cc:	89 1a                	mov    %ebx,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
  1827ce:	f6 c1 01             	test   $0x1,%cl
  1827d1:	74 03                	je     1827d6 <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
  1827d3:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
  1827d6:	b8 00 00 00 00       	mov    $0x0,%eax
  1827db:	5b                   	pop    %ebx
  1827dc:	5e                   	pop    %esi
  1827dd:	c3                   	ret    

001827de <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  1827de:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax

	while (regs->lsr & QM_UART_LSR_THRE) {
  1827e5:	8b 48 14             	mov    0x14(%eax),%ecx
  1827e8:	f6 c1 20             	test   $0x20,%cl
  1827eb:	75 f8                	jne    1827e5 <qm_uart_write+0x7>
	}
	regs->rbr_thr_dll = data;
  1827ed:	0f b6 d2             	movzbl %dl,%edx
  1827f0:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
  1827f2:	8b 50 14             	mov    0x14(%eax),%edx
  1827f5:	f6 c2 40             	test   $0x40,%dl
  1827f8:	74 f8                	je     1827f2 <qm_uart_write+0x14>
	}

	return 0;
}
  1827fa:	b8 00 00 00 00       	mov    $0x0,%eax
  1827ff:	c3                   	ret    

00182800 <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
  182800:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  182801:	8b 1c 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%ebx

	uint32_t lsr = regs->lsr;
  182808:	8b 43 14             	mov    0x14(%ebx),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
  18280b:	eb 03                	jmp    182810 <qm_uart_read+0x10>
		lsr = regs->lsr;
  18280d:	8b 43 14             	mov    0x14(%ebx),%eax
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
  182810:	a8 01                	test   $0x1,%al
  182812:	74 f9                	je     18280d <qm_uart_read+0xd>
		lsr = regs->lsr;
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
  182814:	83 e0 1e             	and    $0x1e,%eax
  182817:	74 0d                	je     182826 <qm_uart_read+0x26>
		if (status) {
  182819:	85 c9                	test   %ecx,%ecx
  18281b:	74 14                	je     182831 <qm_uart_read+0x31>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
  18281d:	89 01                	mov    %eax,(%ecx)
		}
		return -EIO;
  18281f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  182824:	eb 10                	jmp    182836 <qm_uart_read+0x36>
	}
	*data = regs->rbr_thr_dll;
  182826:	8b 03                	mov    (%ebx),%eax
  182828:	88 02                	mov    %al,(%edx)

	return 0;
  18282a:	b8 00 00 00 00       	mov    $0x0,%eax
  18282f:	eb 05                	jmp    182836 <qm_uart_read+0x36>
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
  182831:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}
	*data = regs->rbr_thr_dll;

	return 0;
}
  182836:	5b                   	pop    %ebx
  182837:	c3                   	ret    

00182838 <pin_to_register>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The register index of the given pin.
 */
static uint32_t pin_to_register(uint32_t pin, uint32_t width)
{
  182838:	56                   	push   %esi
  182839:	53                   	push   %ebx
  18283a:	89 c3                	mov    %eax,%ebx
  18283c:	89 d6                	mov    %edx,%esi
	return (pin / (32 / width));
  18283e:	b8 20 00 00 00       	mov    $0x20,%eax
  182843:	ba 00 00 00 00       	mov    $0x0,%edx
  182848:	f7 f6                	div    %esi
  18284a:	89 c1                	mov    %eax,%ecx
  18284c:	89 d8                	mov    %ebx,%eax
  18284e:	ba 00 00 00 00       	mov    $0x0,%edx
  182853:	f7 f1                	div    %ecx
}
  182855:	5b                   	pop    %ebx
  182856:	5e                   	pop    %esi
  182857:	c3                   	ret    

00182858 <pin_to_offset>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
  182858:	56                   	push   %esi
  182859:	53                   	push   %ebx
  18285a:	89 c6                	mov    %eax,%esi
  18285c:	89 d3                	mov    %edx,%ebx
	return ((pin % (32 / width)) * width);
  18285e:	b8 20 00 00 00       	mov    $0x20,%eax
  182863:	ba 00 00 00 00       	mov    $0x0,%edx
  182868:	f7 f3                	div    %ebx
  18286a:	89 c1                	mov    %eax,%ecx
  18286c:	89 f0                	mov    %esi,%eax
  18286e:	ba 00 00 00 00       	mov    $0x0,%edx
  182873:	f7 f1                	div    %ecx
  182875:	89 d8                	mov    %ebx,%eax
  182877:	0f af c2             	imul   %edx,%eax
}
  18287a:	5b                   	pop    %ebx
  18287b:	5e                   	pop    %esi
  18287c:	c3                   	ret    

0018287d <qm_pmux_select>:

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
  18287d:	57                   	push   %edi
  18287e:	56                   	push   %esi
  18287f:	53                   	push   %ebx
  182880:	89 c7                	mov    %eax,%edi
  182882:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
  182884:	ba 02 00 00 00       	mov    $0x2,%edx
  182889:	e8 aa ff ff ff       	call   182838 <pin_to_register>
  18288e:	89 c3                	mov    %eax,%ebx
	uint32_t offs = pin_to_offset(pin, 2);
  182890:	ba 02 00 00 00       	mov    $0x2,%edx
  182895:	89 f8                	mov    %edi,%eax
  182897:	e8 bc ff ff ff       	call   182858 <pin_to_offset>
  18289c:	89 c1                	mov    %eax,%ecx

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
  18289e:	83 c3 0c             	add    $0xc,%ebx
  1828a1:	8b 3c 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edi
  1828a8:	ba 03 00 00 00       	mov    $0x3,%edx
  1828ad:	d3 e2                	shl    %cl,%edx
  1828af:	f7 d2                	not    %edx
  1828b1:	21 fa                	and    %edi,%edx
  1828b3:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
  1828ba:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  1828c1:	d3 e6                	shl    %cl,%esi
  1828c3:	09 c6                	or     %eax,%esi
  1828c5:	89 34 9d 00 09 80 b0 	mov    %esi,-0x4f7ff700(,%ebx,4)

	return 0;
}
  1828cc:	b8 00 00 00 00       	mov    $0x0,%eax
  1828d1:	5b                   	pop    %ebx
  1828d2:	5e                   	pop    %esi
  1828d3:	5f                   	pop    %edi
  1828d4:	c3                   	ret    

001828d5 <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
  1828d5:	57                   	push   %edi
  1828d6:	56                   	push   %esi
  1828d7:	53                   	push   %ebx
  1828d8:	89 c7                	mov    %eax,%edi
  1828da:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  1828dc:	ba 01 00 00 00       	mov    $0x1,%edx
  1828e1:	e8 52 ff ff ff       	call   182838 <pin_to_register>
  1828e6:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  1828e8:	ba 01 00 00 00       	mov    $0x1,%edx
  1828ed:	89 f8                	mov    %edi,%eax
  1828ef:	e8 64 ff ff ff       	call   182858 <pin_to_offset>
  1828f4:	ba 01 00 00 00       	mov    $0x1,%edx
  1828f9:	88 c1                	mov    %al,%cl
  1828fb:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  1828fd:	89 f0                	mov    %esi,%eax
  1828ff:	84 c0                	test   %al,%al
  182901:	75 17                	jne    18291a <qm_pmux_input_en+0x45>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
  182903:	83 c3 08             	add    $0x8,%ebx
  182906:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  18290d:	f7 d2                	not    %edx
  18290f:	21 c2                	and    %eax,%edx
  182911:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  182918:	eb 13                	jmp    18292d <qm_pmux_input_en+0x58>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
  18291a:	83 c3 08             	add    $0x8,%ebx
  18291d:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  182924:	09 c2                	or     %eax,%edx
  182926:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  18292d:	b8 00 00 00 00       	mov    $0x0,%eax
  182932:	5b                   	pop    %ebx
  182933:	5e                   	pop    %esi
  182934:	5f                   	pop    %edi
  182935:	c3                   	ret    

00182936 <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
  182936:	57                   	push   %edi
  182937:	56                   	push   %esi
  182938:	53                   	push   %ebx
  182939:	89 c7                	mov    %eax,%edi
  18293b:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  18293d:	ba 01 00 00 00       	mov    $0x1,%edx
  182942:	e8 f1 fe ff ff       	call   182838 <pin_to_register>
  182947:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  182949:	ba 01 00 00 00       	mov    $0x1,%edx
  18294e:	89 f8                	mov    %edi,%eax
  182950:	e8 03 ff ff ff       	call   182858 <pin_to_offset>
  182955:	ba 01 00 00 00       	mov    $0x1,%edx
  18295a:	88 c1                	mov    %al,%cl
  18295c:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  18295e:	89 f0                	mov    %esi,%eax
  182960:	84 c0                	test   %al,%al
  182962:	75 14                	jne    182978 <qm_pmux_pullup_en+0x42>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
  182964:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  18296b:	f7 d2                	not    %edx
  18296d:	21 c2                	and    %eax,%edx
  18296f:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  182976:	eb 10                	jmp    182988 <qm_pmux_pullup_en+0x52>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
  182978:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  18297f:	09 c2                	or     %eax,%edx
  182981:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  182988:	b8 00 00 00 00       	mov    $0x0,%eax
  18298d:	5b                   	pop    %ebx
  18298e:	5e                   	pop    %esi
  18298f:	5f                   	pop    %edi
  182990:	c3                   	ret    

00182991 <k_cpu_idle>:
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  182991:	fb                   	sti    
  182992:	f4                   	hlt    
  182993:	c3                   	ret    

00182994 <_SysFatalErrorHandler>:
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
  182994:	e8 e5 11 00 00       	call   183b7e <k_is_in_isr>
  182999:	85 c0                	test   %eax,%eax
  18299b:	75 09                	jne    1829a6 <_SysFatalErrorHandler+0x12>
  18299d:	e8 ea 11 00 00       	call   183b8c <_is_thread_essential>
  1829a2:	85 c0                	test   %eax,%eax
  1829a4:	74 25                	je     1829cb <_SysFatalErrorHandler+0x37>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  1829a6:	e8 d3 11 00 00       	call   183b7e <k_is_in_isr>
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  1829ab:	85 c0                	test   %eax,%eax
  1829ad:	74 07                	je     1829b6 <_SysFatalErrorHandler+0x22>
  1829af:	b8 b0 4c 18 00       	mov    $0x184cb0,%eax
  1829b4:	eb 05                	jmp    1829bb <_SysFatalErrorHandler+0x27>
  1829b6:	b8 b4 4c 18 00       	mov    $0x184cb4,%eax
  1829bb:	50                   	push   %eax
  1829bc:	68 04 4d 18 00       	push   $0x184d04
  1829c1:	e8 19 f3 ff ff       	call   181cdf <printk>
  1829c6:	83 c4 08             	add    $0x8,%esp
  1829c9:	eb fe                	jmp    1829c9 <_SysFatalErrorHandler+0x35>
		       k_is_in_isr() ? "ISR" : "essential thread");
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  1829cb:	ff 35 48 01 28 00    	pushl  0x280148
  1829d1:	68 24 4d 18 00       	push   $0x184d24
  1829d6:	e8 04 f3 ff ff       	call   181cdf <printk>
  1829db:	83 c4 08             	add    $0x8,%esp
	k_thread_abort(_current);
  1829de:	a1 48 01 28 00       	mov    0x280148,%eax
  1829e3:	e8 ee 13 00 00       	call   183dd6 <k_thread_abort>

001829e8 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  1829e8:	53                   	push   %ebx
	movl $1, %eax
  1829e9:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  1829ee:	0f a2                	cpuid  
	movl %ebx, %eax
  1829f0:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  1829f2:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  1829f7:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  1829fa:	5b                   	pop    %ebx
	ret
  1829fb:	c3                   	ret    

001829fc <init_cache_line_size>:

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  1829fc:	e8 e7 ff ff ff       	call   1829e8 <_cache_line_size_get>
  182a01:	a3 c4 02 28 00       	mov    %eax,0x2802c4
  182a06:	c3                   	ret    

00182a07 <init_cache>:
static int init_cache(struct device *unused)
{
	ARG_UNUSED(unused);

	init_cache_flush();
	init_cache_line_size();
  182a07:	e8 f0 ff ff ff       	call   1829fc <init_cache_line_size>

	return 0;
}
  182a0c:	b8 00 00 00 00       	mov    $0x0,%eax
  182a11:	c3                   	ret    

00182a12 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  182a12:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  182a13:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  182a16:	50                   	push   %eax
	pushl	%edx
  182a17:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  182a18:	57                   	push   %edi
	pushl	%esi
  182a19:	56                   	push   %esi
	pushl	%ebx
  182a1a:	53                   	push   %ebx
	pushl	%ebp
  182a1b:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  182a1c:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  182a20:	50                   	push   %eax

	/* ESP is pointing to the ESF at this point */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %edx
  182a21:	8b 15 48 01 28 00    	mov    0x280148,%edx

	/* inc exception nest count */
	incl	_thread_offset_to_excNestCount(%edx)
  182a27:	ff 42 44             	incl   0x44(%edx)
     * the current execution context if this is the outermost exception.
     * The ESF pointer is used by debug tools to locate the volatile
     * registers and the stack of the preempted thread.
     */

	testb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  182a2a:	f6 42 09 40          	testb  $0x40,0x9(%edx)
	jne	alreadyInException
  182a2e:	75 03                	jne    182a33 <alreadyInException>
	movl	%esp, _thread_offset_to_esf(%edx)
  182a30:	89 62 40             	mov    %esp,0x40(%edx)

00182a33 <alreadyInException>:
	 * (where needed) if the exception handler causes a context switch.
	 * It also indicates to debug tools that an exception is being
	 * handled in the event of a context switch.
	 */

	orb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  182a33:	80 4a 09 40          	orb    $0x40,0x9(%edx)
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  182a37:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  182a3e:	00 
	je	allDone
  182a3f:	74 01                	je     182a42 <allDone>
	sti
  182a41:	fb                   	sti    

00182a42 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
  182a42:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
  182a44:	ff d1                	call   *%ecx
	addl	$0x4, %esp
#endif

#if defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %ecx
  182a46:	8b 0d 48 01 28 00    	mov    0x280148,%ecx
	 * Must lock interrupts to prevent outside interference.
	 * (Using "lock" prefix would be nicer, but this won't work
	 * on platforms that don't respect the CPU's bus lock signal.)
	 */

	cli
  182a4c:	fa                   	cli    

	/*
	 * Determine whether exiting from a nested interrupt.
	 */

	decl	_thread_offset_to_excNestCount(%ecx)
  182a4d:	ff 49 44             	decl   0x44(%ecx)

	cmpl	$0, _thread_offset_to_excNestCount(%ecx)
  182a50:	83 79 44 00          	cmpl   $0x0,0x44(%ecx)
	jne	nestedException
  182a54:	75 04                	jne    182a5a <nestedException>
	 * Clear the _EXC_ACTIVE bit in the k_thread of the current execution
	 * context if we are not in a nested exception (ie, when we exit the
	 * outermost exception).
	 */

	andb	$~_EXC_ACTIVE, _thread_offset_to_thread_state(%ecx)
  182a56:	80 61 09 bf          	andb   $0xbf,0x9(%ecx)

00182a5a <nestedException>:
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  182a5a:	5d                   	pop    %ebp
	popl	%ebp
  182a5b:	5d                   	pop    %ebp
	popl	%ebx
  182a5c:	5b                   	pop    %ebx
	popl	%esi
  182a5d:	5e                   	pop    %esi
	popl	%edi
  182a5e:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  182a5f:	5a                   	pop    %edx
	popl	%eax
  182a60:	58                   	pop    %eax
	popl	%ecx
  182a61:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  182a62:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  182a65:	cf                   	iret   

00182a66 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  182a66:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  182a67:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  182a6b:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  182a6e:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  182a6f:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  182a70:	b9 40 01 28 00       	mov    $0x280140,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  182a75:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  182a77:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  182a7a:	75 06                	jne    182a82 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  182a7c:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  182a7e:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  182a81:	57                   	push   %edi

00182a82 <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  182a82:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  182a83:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  182a85:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
  182a86:	31 c0                	xor    %eax,%eax
  182a88:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  182a8d:	b9 40 01 28 00       	mov    $0x280140,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  182a92:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  182a94:	75 2b                	jne    182ac1 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  182a96:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
  182a99:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
  182a9f:	73 1f                	jae    182ac0 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  182aa1:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
  182aa4:	74 1a                	je     182ac0 <noReschedule>
	 * preserved using the lazy save/restore algorithm, or to indicate to
	 * debug tools that a preemptive context switch has occurred.
	 */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)
	orb	$_INT_ACTIVE, _thread_offset_to_thread_state(%edx)
  182aa6:	80 4a 09 80          	orb    $0x80,0x9(%edx)
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  182aaa:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  182aab:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
  182aac:	58                   	pop    %eax
#endif
	call	_Swap
  182aad:	e8 30 00 00 00       	call   182ae2 <_Swap>
	 * _Swap() has restored the floating point registers, if needed.
	 * Clear the _INT_ACTIVE bit in the interrupted thread's state
	 * since it has served its purpose.
	 */

	movl	_kernel + _kernel_offset_to_current, %eax
  182ab2:	a1 48 01 28 00       	mov    0x280148,%eax
	andb	$~_INT_ACTIVE, _thread_offset_to_thread_state(%eax)
  182ab7:	80 60 09 7f          	andb   $0x7f,0x9(%eax)

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  182abb:	5f                   	pop    %edi
	popl	%ecx
  182abc:	59                   	pop    %ecx
	popl	%edx
  182abd:	5a                   	pop    %edx
	popl	%eax
  182abe:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  182abf:	cf                   	iret   

00182ac0 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  182ac0:	5c                   	pop    %esp

00182ac1 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  182ac1:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  182ac2:	59                   	pop    %ecx
	popl	%edx
  182ac3:	5a                   	pop    %edx
	popl	%eax
  182ac4:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  182ac5:	cf                   	iret   

00182ac6 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  182ac6:	6a 00                	push   $0x0

00182ac8 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  182ac8:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  182ac9:	50                   	push   %eax
	pushl %ecx
  182aca:	51                   	push   %ecx
	pushl %edx
  182acb:	52                   	push   %edx
	pushl %edi
  182acc:	57                   	push   %edi
	pushl %esi
  182acd:	56                   	push   %esi
	pushl %ebx
  182ace:	53                   	push   %ebx
	pushl %ebp
  182acf:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  182ad0:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  182ad4:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
  182ad5:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
  182ad7:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
  182ad8:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  182add:	e8 d5 00 00 00       	call   182bb7 <_NanoFatalErrorHandler>

00182ae2 <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
  182ae2:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
  182ae5:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  182ae9:	57                   	push   %edi

	movl	$_kernel, %edi
  182aea:	bf 40 01 28 00       	mov    $0x280140,%edi

	pushl	%esi
  182aef:	56                   	push   %esi
	pushl	%ebx
  182af0:	53                   	push   %ebx
	pushl	%ebp
  182af1:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
  182af2:	ff 35 04 4f 18 00    	pushl  0x184f04


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  182af8:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  182afb:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  182afe:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  182b01:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  182b04:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
  182b07:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  182b08:	5d                   	pop    %ebp
	popl	%ebx
  182b09:	5b                   	pop    %ebx
	popl	%esi
  182b0a:	5e                   	pop    %esi
	popl	%edi
  182b0b:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  182b0c:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  182b10:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
  182b11:	5a                   	pop    %edx
	movl	%edx, (%esp)
  182b12:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
  182b15:	c3                   	ret    

00182b16 <_new_thread_internal>:
 * @return N/A
 */
static void _new_thread_internal(char *pStackMem, unsigned stackSize,
				 int priority,
				 unsigned options)
{
  182b16:	56                   	push   %esi
  182b17:	53                   	push   %ebx
  182b18:	89 c3                	mov    %eax,%ebx
  182b1a:	89 d6                	mov    %edx,%esi
  182b1c:	89 ca                	mov    %ecx,%edx
	unsigned long *pInitialCtx;
	/* ptr to the new task's k_thread */
	struct k_thread *thread = (struct k_thread *)pStackMem;

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
  182b1e:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
  182b25:	ff 74 24 0c          	pushl  0xc(%esp)
  182b29:	b9 04 00 00 00       	mov    $0x4,%ecx
  182b2e:	e8 73 12 00 00       	call   183da6 <_init_thread_base>
  182b33:	83 c4 04             	add    $0x4,%esp

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  182b36:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	thread->fn_abort = NULL;
  182b3d:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
	 * the base address of the stack which is past the initial stack frame.
	 * Therefore some of the calculations done in the other routines that
	 * initialize the stack frame need to be repeated.
	 */

	pInitialCtx = (unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  182b44:	8d 14 33             	lea    (%ebx,%esi,1),%edx
  182b47:	83 e2 fc             	and    $0xfffffffc,%edx
#ifdef CONFIG_THREAD_MONITOR
	/*
	 * In debug mode thread->entry give direct access to the thread entry
	 * and the corresponding parameters.
	 */
	thread->entry = (struct __thread_entry *)(pInitialCtx -
  182b4a:	8d 42 c0             	lea    -0x40(%edx),%eax
  182b4d:	89 43 34             	mov    %eax,0x34(%ebx)
	 *  - 4 thread entry routine parameters
	 *  - eflags
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;
  182b50:	83 ea 2c             	sub    $0x2c,%edx

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  182b53:	89 53 28             	mov    %edx,0x28(%ebx)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182b56:	9c                   	pushf  
  182b57:	fa                   	cli    
  182b58:	58                   	pop    %eax
static ALWAYS_INLINE void thread_monitor_init(struct k_thread *thread)
{
	unsigned int key;

	key = irq_lock();
	thread->next_thread = _kernel.threads;
  182b59:	8b 15 5c 02 28 00    	mov    0x28025c,%edx
  182b5f:	89 53 38             	mov    %edx,0x38(%ebx)
	_kernel.threads = thread;
  182b62:	89 1d 5c 02 28 00    	mov    %ebx,0x28025c
  182b68:	f6 c4 02             	test   $0x2,%ah
  182b6b:	74 01                	je     182b6e <_new_thread_internal+0x58>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182b6d:	fb                   	sti    
	PRINTK("\nInitial context ESP = 0x%x\n", thread->coopReg.esp);

	PRINTK("\nstruct thread * = 0x%x", thread);

	thread_monitor_init(thread);
}
  182b6e:	5b                   	pop    %ebx
  182b6f:	5e                   	pop    %esi
  182b70:	c3                   	ret    

00182b71 <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  182b71:	56                   	push   %esi
  182b72:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  182b73:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  182b76:	83 e3 fc             	and    $0xfffffffc,%ebx
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  182b79:	8b 74 24 14          	mov    0x14(%esp),%esi
  182b7d:	89 73 fc             	mov    %esi,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  182b80:	8b 74 24 10          	mov    0x10(%esp),%esi
  182b84:	89 73 f8             	mov    %esi,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  182b87:	8b 74 24 0c          	mov    0xc(%esp),%esi
  182b8b:	89 73 f4             	mov    %esi,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  182b8e:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  182b91:	9c                   	pushf  
  182b92:	59                   	pop    %ecx

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  182b93:	80 e5 cd             	and    $0xcd,%ch
  182b96:	80 cd 02             	or     $0x2,%ch
  182b99:	89 4b ec             	mov    %ecx,-0x14(%ebx)
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
  182b9c:	c7 43 e8 60 00 18 00 	movl   $0x180060,-0x18(%ebx)
	/*
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
  182ba3:	ff 74 24 1c          	pushl  0x1c(%esp)
  182ba7:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  182bab:	e8 66 ff ff ff       	call   182b16 <_new_thread_internal>
  182bb0:	83 c4 04             	add    $0x4,%esp
}
  182bb3:	5b                   	pop    %ebx
  182bb4:	5e                   	pop    %esi
  182bb5:	c3                   	ret    

00182bb6 <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  182bb6:	c3                   	ret    

00182bb7 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  182bb7:	55                   	push   %ebp
  182bb8:	57                   	push   %edi
  182bb9:	56                   	push   %esi
  182bba:	53                   	push   %ebx
  182bbb:	83 ec 24             	sub    $0x24,%esp
  182bbe:	89 c6                	mov    %eax,%esi
  182bc0:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
  182bc2:	89 d0                	mov    %edx,%eax
  182bc4:	e8 ed ff ff ff       	call   182bb6 <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  182bc9:	83 fe 03             	cmp    $0x3,%esi
  182bcc:	74 4c                	je     182c1a <_NanoFatalErrorHandler+0x63>
  182bce:	83 fe 03             	cmp    $0x3,%esi
  182bd1:	77 06                	ja     182bd9 <_NanoFatalErrorHandler+0x22>
  182bd3:	85 f6                	test   %esi,%esi
  182bd5:	74 0e                	je     182be5 <_NanoFatalErrorHandler+0x2e>
  182bd7:	eb 5f                	jmp    182c38 <_NanoFatalErrorHandler+0x81>
  182bd9:	83 fe 05             	cmp    $0x5,%esi
  182bdc:	74 4b                	je     182c29 <_NanoFatalErrorHandler+0x72>
  182bde:	83 fe 06             	cmp    $0x6,%esi
  182be1:	74 63                	je     182c46 <_NanoFatalErrorHandler+0x8f>
  182be3:	eb 53                	jmp    182c38 <_NanoFatalErrorHandler+0x81>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  182be5:	e8 7a dc ff ff       	call   180864 <__irq_controller_isr_vector_get>
  182bea:	89 c3                	mov    %eax,%ebx
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  182bec:	68 4c 4d 18 00       	push   $0x184d4c
  182bf1:	e8 e9 f0 ff ff       	call   181cdf <printk>
  182bf6:	83 c4 04             	add    $0x4,%esp
		if (vector >= 0) {
  182bf9:	85 db                	test   %ebx,%ebx
  182bfb:	78 0e                	js     182c0b <_NanoFatalErrorHandler+0x54>
			printk("%d ", vector);
  182bfd:	53                   	push   %ebx
  182bfe:	68 c5 4c 18 00       	push   $0x184cc5
  182c03:	e8 d7 f0 ff ff       	call   181cdf <printk>
  182c08:	83 c4 08             	add    $0x8,%esp
		}
		printk("*****\n");
  182c0b:	68 c9 4c 18 00       	push   $0x184cc9
  182c10:	e8 ca f0 ff ff       	call   181cdf <printk>
  182c15:	83 c4 04             	add    $0x4,%esp
		break;
  182c18:	eb 2c                	jmp    182c46 <_NanoFatalErrorHandler+0x8f>
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  182c1a:	68 70 4d 18 00       	push   $0x184d70
  182c1f:	e8 bb f0 ff ff       	call   181cdf <printk>
  182c24:	83 c4 04             	add    $0x4,%esp
		break;
  182c27:	eb 1d                	jmp    182c46 <_NanoFatalErrorHandler+0x8f>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  182c29:	68 9c 4d 18 00       	push   $0x184d9c
  182c2e:	e8 ac f0 ff ff       	call   181cdf <printk>
  182c33:	83 c4 04             	add    $0x4,%esp
		break;
  182c36:	eb 0e                	jmp    182c46 <_NanoFatalErrorHandler+0x8f>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  182c38:	56                   	push   %esi
  182c39:	68 c4 4d 18 00       	push   $0x184dc4
  182c3e:	e8 9c f0 ff ff       	call   181cdf <printk>
  182c43:	83 c4 08             	add    $0x8,%esp
		break;
	}

	printk("Current thread ID = %p\n"
  182c46:	8b 6f 2c             	mov    0x2c(%edi),%ebp
  182c49:	8b 07                	mov    (%edi),%eax
  182c4b:	89 04 24             	mov    %eax,(%esp)
  182c4e:	8b 4f 04             	mov    0x4(%edi),%ecx
  182c51:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  182c55:	8b 5f 10             	mov    0x10(%edi),%ebx
  182c58:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  182c5c:	8b 57 0c             	mov    0xc(%edi),%edx
  182c5f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  182c63:	8b 47 14             	mov    0x14(%edi),%eax
  182c66:	89 44 24 10          	mov    %eax,0x10(%esp)
  182c6a:	8b 4f 1c             	mov    0x1c(%edi),%ecx
  182c6d:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  182c71:	8b 5f 08             	mov    0x8(%edi),%ebx
  182c74:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  182c78:	8b 57 18             	mov    0x18(%edi),%edx
  182c7b:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  182c7f:	8b 47 24             	mov    0x24(%edi),%eax
  182c82:	89 44 24 20          	mov    %eax,0x20(%esp)
	       "Faulting segment:address = 0x%x:0x%x\n"
	       "eax: 0x%x, ebx: 0x%x, ecx: 0x%x, edx: 0x%x\n"
	       "esi: 0x%x, edi: 0x%x, ebp: 0%x, esp: 0x%x\n"
	       "eflags: 0x%x\n",
	       k_current_get(),
	       pEsf->cs & 0xFFFF, pEsf->eip,
  182c86:	8b 5f 28             	mov    0x28(%edi),%ebx
	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}

	printk("Current thread ID = %p\n"
  182c89:	e8 ae 07 00 00       	call   18343c <k_current_get>
  182c8e:	55                   	push   %ebp
  182c8f:	ff 74 24 04          	pushl  0x4(%esp)
  182c93:	ff 74 24 0c          	pushl  0xc(%esp)
  182c97:	ff 74 24 14          	pushl  0x14(%esp)
  182c9b:	ff 74 24 1c          	pushl  0x1c(%esp)
  182c9f:	ff 74 24 24          	pushl  0x24(%esp)
  182ca3:	ff 74 24 2c          	pushl  0x2c(%esp)
  182ca7:	ff 74 24 34          	pushl  0x34(%esp)
  182cab:	ff 74 24 3c          	pushl  0x3c(%esp)
  182caf:	ff 74 24 44          	pushl  0x44(%esp)
  182cb3:	0f b7 d3             	movzwl %bx,%edx
  182cb6:	52                   	push   %edx
  182cb7:	50                   	push   %eax
  182cb8:	68 e8 4d 18 00       	push   $0x184de8
  182cbd:	e8 1d f0 ff ff       	call   181cdf <printk>
  182cc2:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  182cc5:	89 fa                	mov    %edi,%edx
  182cc7:	89 f0                	mov    %esi,%eax
  182cc9:	e8 c6 fc ff ff       	call   182994 <_SysFatalErrorHandler>

00182cce <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  182cce:	56                   	push   %esi
  182ccf:	53                   	push   %ebx
  182cd0:	89 c3                	mov    %eax,%ebx
  182cd2:	89 d6                	mov    %edx,%esi
	printk("***** CPU exception %d\n", vector);
  182cd4:	50                   	push   %eax
  182cd5:	68 d0 4c 18 00       	push   $0x184cd0
  182cda:	e8 00 f0 ff ff       	call   181cdf <printk>
  182cdf:	83 c4 08             	add    $0x8,%esp
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  182ce2:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  182ce7:	88 d9                	mov    %bl,%cl
  182ce9:	d3 f8                	sar    %cl,%eax
  182ceb:	a8 01                	test   $0x1,%al
  182ced:	74 10                	je     182cff <generic_exc_handle+0x31>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  182cef:	ff 76 20             	pushl  0x20(%esi)
  182cf2:	68 e8 4c 18 00       	push   $0x184ce8
  182cf7:	e8 e3 ef ff ff       	call   181cdf <printk>
  182cfc:	83 c4 08             	add    $0x8,%esp
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  182cff:	89 f2                	mov    %esi,%edx
  182d01:	b8 06 00 00 00       	mov    $0x6,%eax
  182d06:	e8 ac fe ff ff       	call   182bb7 <_NanoFatalErrorHandler>

00182d0b <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  182d0b:	89 c2                	mov    %eax,%edx
  182d0d:	b8 00 00 00 00       	mov    $0x0,%eax
  182d12:	e8 b7 ff ff ff       	call   182cce <generic_exc_handle>

00182d17 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  182d17:	89 c2                	mov    %eax,%edx
  182d19:	b8 02 00 00 00       	mov    $0x2,%eax
  182d1e:	e8 ab ff ff ff       	call   182cce <generic_exc_handle>

00182d23 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  182d23:	89 c2                	mov    %eax,%edx
  182d25:	b8 04 00 00 00       	mov    $0x4,%eax
  182d2a:	e8 9f ff ff ff       	call   182cce <generic_exc_handle>

00182d2f <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  182d2f:	89 c2                	mov    %eax,%edx
  182d31:	b8 05 00 00 00       	mov    $0x5,%eax
  182d36:	e8 93 ff ff ff       	call   182cce <generic_exc_handle>

00182d3b <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  182d3b:	89 c2                	mov    %eax,%edx
  182d3d:	b8 06 00 00 00       	mov    $0x6,%eax
  182d42:	e8 87 ff ff ff       	call   182cce <generic_exc_handle>

00182d47 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  182d47:	89 c2                	mov    %eax,%edx
  182d49:	b8 07 00 00 00       	mov    $0x7,%eax
  182d4e:	e8 7b ff ff ff       	call   182cce <generic_exc_handle>

00182d53 <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  182d53:	89 c2                	mov    %eax,%edx
  182d55:	b8 08 00 00 00       	mov    $0x8,%eax
  182d5a:	e8 6f ff ff ff       	call   182cce <generic_exc_handle>

00182d5f <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  182d5f:	89 c2                	mov    %eax,%edx
  182d61:	b8 0a 00 00 00       	mov    $0xa,%eax
  182d66:	e8 63 ff ff ff       	call   182cce <generic_exc_handle>

00182d6b <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  182d6b:	89 c2                	mov    %eax,%edx
  182d6d:	b8 0b 00 00 00       	mov    $0xb,%eax
  182d72:	e8 57 ff ff ff       	call   182cce <generic_exc_handle>

00182d77 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  182d77:	89 c2                	mov    %eax,%edx
  182d79:	b8 0c 00 00 00       	mov    $0xc,%eax
  182d7e:	e8 4b ff ff ff       	call   182cce <generic_exc_handle>

00182d83 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  182d83:	89 c2                	mov    %eax,%edx
  182d85:	b8 0d 00 00 00       	mov    $0xd,%eax
  182d8a:	e8 3f ff ff ff       	call   182cce <generic_exc_handle>

00182d8f <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  182d8f:	89 c2                	mov    %eax,%edx
  182d91:	b8 0e 00 00 00       	mov    $0xe,%eax
  182d96:	e8 33 ff ff ff       	call   182cce <generic_exc_handle>

00182d9b <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  182d9b:	89 c2                	mov    %eax,%edx
  182d9d:	b8 10 00 00 00       	mov    $0x10,%eax
  182da2:	e8 27 ff ff ff       	call   182cce <generic_exc_handle>

00182da7 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  182da7:	89 c2                	mov    %eax,%edx
  182da9:	b8 11 00 00 00       	mov    $0x11,%eax
  182dae:	e8 1b ff ff ff       	call   182cce <generic_exc_handle>

00182db3 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  182db3:	89 c2                	mov    %eax,%edx
  182db5:	b8 12 00 00 00       	mov    $0x12,%eax
  182dba:	e8 0f ff ff ff       	call   182cce <generic_exc_handle>

00182dbf <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  182dbf:	56                   	push   %esi
  182dc0:	53                   	push   %ebx
  182dc1:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  182dc3:	8b 1c 85 e0 4e 18 00 	mov    0x184ee0(,%eax,4),%ebx
  182dca:	eb 0a                	jmp    182dd6 <_sys_device_do_config_level+0x17>
		struct device_config *device = info->config;
  182dcc:	8b 13                	mov    (%ebx),%edx

		device->init(info);
  182dce:	89 d8                	mov    %ebx,%eax
  182dd0:	ff 52 04             	call   *0x4(%edx)
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  182dd3:	83 c3 0c             	add    $0xc,%ebx
  182dd6:	3b 1c b5 e4 4e 18 00 	cmp    0x184ee4(,%esi,4),%ebx
  182ddd:	72 ed                	jb     182dcc <_sys_device_do_config_level+0xd>
		struct device_config *device = info->config;

		device->init(info);
	}
}
  182ddf:	5b                   	pop    %ebx
  182de0:	5e                   	pop    %esi
  182de1:	c3                   	ret    

00182de2 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  182de2:	56                   	push   %esi
  182de3:	53                   	push   %ebx
  182de4:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  182de6:	bb 2c 00 28 00       	mov    $0x28002c,%ebx
  182deb:	eb 18                	jmp    182e05 <device_get_binding+0x23>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  182ded:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  182df1:	74 0f                	je     182e02 <device_get_binding+0x20>
  182df3:	8b 03                	mov    (%ebx),%eax
  182df5:	8b 10                	mov    (%eax),%edx
  182df7:	89 f0                	mov    %esi,%eax
  182df9:	e8 00 eb ff ff       	call   1818fe <strcmp>
  182dfe:	85 c0                	test   %eax,%eax
  182e00:	74 12                	je     182e14 <device_get_binding+0x32>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  182e02:	83 c3 0c             	add    $0xc,%ebx
  182e05:	81 fb a4 00 28 00    	cmp    $0x2800a4,%ebx
  182e0b:	75 e0                	jne    182ded <device_get_binding+0xb>
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
  182e0d:	b8 00 00 00 00       	mov    $0x0,%eax
  182e12:	eb 02                	jmp    182e16 <device_get_binding+0x34>
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
  182e14:	89 d8                	mov    %ebx,%eax
		}
	}

	return NULL;
}
  182e16:	5b                   	pop    %ebx
  182e17:	5e                   	pop    %esi
  182e18:	c3                   	ret    

00182e19 <device_busy_set>:
}

#endif

void device_busy_set(struct device *busy_dev)
{
  182e19:	c3                   	ret    

00182e1a <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
  182e1a:	c3                   	ret    

00182e1b <prepare_multithreading>:
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  182e1b:	a3 48 01 28 00       	mov    %eax,0x280148

	dummy_thread->base.user_options = K_ESSENTIAL;
  182e20:	c6 40 08 01          	movb   $0x1,0x8(%eax)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  182e24:	b8 00 00 00 00       	mov    $0x0,%eax
  182e29:	eb 1a                	jmp    182e45 <prepare_multithreading+0x2a>
		sys_dlist_init(&_ready_q.q[ii]);
  182e2b:	8d 50 01             	lea    0x1(%eax),%edx
  182e2e:	8d 0c d5 54 01 28 00 	lea    0x280154(,%edx,8),%ecx
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  182e35:	89 0c d5 54 01 28 00 	mov    %ecx,0x280154(,%edx,8)
	list->tail = (sys_dnode_t *)list;
  182e3c:	89 0c c5 60 01 28 00 	mov    %ecx,0x280160(,%eax,8)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  182e43:	89 d0                	mov    %edx,%eax
  182e45:	83 f8 1f             	cmp    $0x1f,%eax
  182e48:	7e e1                	jle    182e2b <prepare_multithreading+0x10>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
  182e4a:	c7 05 54 01 28 00 e0 	movl   $0x2804e0,0x280154
  182e51:	04 28 00 

	_new_thread(_main_stack, MAIN_STACK_SIZE,
  182e54:	6a 01                	push   $0x1
  182e56:	6a 00                	push   $0x0
  182e58:	6a 00                	push   $0x0
  182e5a:	6a 00                	push   $0x0
  182e5c:	6a 00                	push   $0x0
  182e5e:	b9 0a 2f 18 00       	mov    $0x182f0a,%ecx
  182e63:	ba 00 02 00 00       	mov    $0x200,%edx
  182e68:	b8 e0 04 28 00       	mov    $0x2804e0,%eax
  182e6d:	e8 ff fc ff ff       	call   182b71 <_new_thread>
  182e72:	83 c4 14             	add    $0x14,%esp
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182e75:	a0 e9 04 28 00       	mov    0x2804e9,%al
  182e7a:	83 e0 fb             	and    $0xfffffffb,%eax
  182e7d:	a2 e9 04 28 00       	mov    %al,0x2804e9
		    _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
  182e82:	b8 e0 04 28 00       	mov    $0x2804e0,%eax
  182e87:	e8 3b 01 00 00       	call   182fc7 <_add_thread_to_ready_q>

#ifdef CONFIG_MULTITHREADING
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  182e8c:	6a 01                	push   $0x1
  182e8e:	6a 0f                	push   $0xf
  182e90:	6a 00                	push   $0x0
  182e92:	6a 00                	push   $0x0
  182e94:	6a 00                	push   $0x0
  182e96:	b9 08 3e 18 00       	mov    $0x183e08,%ecx
  182e9b:	ba 00 01 00 00       	mov    $0x100,%edx
  182ea0:	b8 e0 03 28 00       	mov    $0x2803e0,%eax
  182ea5:	e8 c7 fc ff ff       	call   182b71 <_new_thread>
  182eaa:	83 c4 14             	add    $0x14,%esp
  182ead:	a0 e9 03 28 00       	mov    0x2803e9,%al
  182eb2:	83 e0 fb             	and    $0xfffffffb,%eax
  182eb5:	a2 e9 03 28 00       	mov    %al,0x2803e9
		    idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
  182eba:	b8 e0 03 28 00       	mov    $0x2803e0,%eax
  182ebf:	e8 03 01 00 00       	call   182fc7 <_add_thread_to_ready_q>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  182ec4:	c7 05 4c 01 28 00 4c 	movl   $0x28014c,0x28014c
  182ecb:	01 28 00 
	list->tail = (sys_dnode_t *)list;
  182ece:	c7 05 50 01 28 00 4c 	movl   $0x28014c,0x280150
  182ed5:	01 28 00 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
  182ed8:	c7 05 40 01 28 00 00 	movl   $0x0,0x280140
  182edf:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  182ee2:	c7 05 44 01 28 00 e0 	movl   $0x2803e0,0x280144
  182ee9:	03 28 00 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  182eec:	c7 05 c8 02 28 00 00 	movl   $0x200,0x2802c8
  182ef3:	02 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
  182ef6:	c7 05 c0 02 28 00 12 	movl   $0x182a12,0x2802c0
  182efd:	2a 18 00 
  182f00:	c3                   	ret    

00182f01 <switch_to_main_thread>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182f01:	9c                   	pushf  
  182f02:	fa                   	cli    
  182f03:	58                   	pop    %eax
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */

	_Swap(irq_lock());
  182f04:	e8 d9 fb ff ff       	call   182ae2 <_Swap>
  182f09:	c3                   	ret    

00182f0a <_main>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  182f0a:	b8 02 00 00 00       	mov    $0x2,%eax
  182f0f:	e8 ab fe ff ff       	call   182dbf <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  182f14:	b8 05 00 00 00       	mov    $0x5,%eax
  182f19:	e8 a1 fe ff ff       	call   182dbf <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  182f1e:	b8 06 00 00 00       	mov    $0x6,%eax
  182f23:	e8 97 fe ff ff       	call   182dbf <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  182f28:	b8 07 00 00 00       	mov    $0x7,%eax
  182f2d:	e8 8d fe ff ff       	call   182dbf <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  182f32:	b8 03 00 00 00       	mov    $0x3,%eax
  182f37:	e8 83 fe ff ff       	call   182dbf <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  182f3c:	e8 dc 0d 00 00       	call   183d1d <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  182f41:	e8 2f d4 ff ff       	call   180375 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
  182f46:	a0 e8 04 28 00       	mov    0x2804e8,%al
  182f4b:	83 e0 fe             	and    $0xfffffffe,%eax
  182f4e:	a2 e8 04 28 00       	mov    %al,0x2804e8
  182f53:	c3                   	ret    

00182f54 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  182f54:	83 ec 48             	sub    $0x48,%esp
	 * Initialize kernel data structures. This step includes
	 * initializing the interrupt subsystem, which must be performed
	 * before the hardware initialization phase.
	 */

	prepare_multithreading(dummy_thread);
  182f57:	89 e0                	mov    %esp,%eax
  182f59:	e8 bd fe ff ff       	call   182e1b <prepare_multithreading>

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  182f5e:	b8 04 00 00 00       	mov    $0x4,%eax
  182f63:	e8 57 fe ff ff       	call   182dbf <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  182f68:	b8 00 00 00 00       	mov    $0x0,%eax
  182f6d:	e8 4d fe ff ff       	call   182dbf <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  182f72:	b8 01 00 00 00       	mov    $0x1,%eax
  182f77:	e8 43 fe ff ff       	call   182dbf <_sys_device_do_config_level>

	/* display boot banner */

	PRINT_BOOT_BANNER();

	switch_to_main_thread();
  182f7c:	e8 80 ff ff ff       	call   182f01 <switch_to_main_thread>

00182f81 <_set_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  182f81:	8d 48 10             	lea    0x10(%eax),%ecx
  182f84:	89 ca                	mov    %ecx,%edx
  182f86:	c1 fa 05             	sar    $0x5,%edx
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  182f89:	b8 01 00 00 00       	mov    $0x1,%eax
  182f8e:	d3 e0                	shl    %cl,%eax
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  182f90:	09 04 95 58 01 28 00 	or     %eax,0x280158(,%edx,4)
  182f97:	c3                   	ret    

00182f98 <_clear_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  182f98:	8d 48 10             	lea    0x10(%eax),%ecx
  182f9b:	89 c8                	mov    %ecx,%eax
  182f9d:	c1 f8 05             	sar    $0x5,%eax
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  182fa0:	ba 01 00 00 00       	mov    $0x1,%edx
  182fa5:	d3 e2                	shl    %cl,%edx
static void _clear_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap &= ~_get_ready_q_prio_bit(prio);
  182fa7:	f7 d2                	not    %edx
  182fa9:	21 14 85 58 01 28 00 	and    %edx,0x280158(,%eax,4)
  182fb0:	c3                   	ret    

00182fb1 <_get_ready_q_head>:

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  182fb1:	0f bc 05 58 01 28 00 	bsf    0x280158,%eax
  182fb8:	75 05                	jne    182fbf <_get_ready_q_head+0xe>
  182fba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 * @return a pointer to the head element
 */

static inline sys_dnode_t *sys_dlist_peek_head_not_empty(sys_dlist_t *list)
{
	return list->head;
  182fbf:	8b 04 c5 5c 01 28 00 	mov    0x28015c(,%eax,8),%eax

	struct k_thread *thread =
		(struct k_thread *)sys_dlist_peek_head_not_empty(list);

	return thread;
}
  182fc6:	c3                   	ret    

00182fc7 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  182fc7:	57                   	push   %edi
  182fc8:	56                   	push   %esi
  182fc9:	53                   	push   %ebx
  182fca:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  182fcc:	0f be 58 0a          	movsbl 0xa(%eax),%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
  182fd0:	8d 3c dd dc 01 28 00 	lea    0x2801dc(,%ebx,8),%edi

	_set_ready_q_prio_bit(thread->base.prio);
  182fd7:	89 d8                	mov    %ebx,%eax
  182fd9:	e8 a3 ff ff ff       	call   182f81 <_set_ready_q_prio_bit>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182fde:	89 3e                	mov    %edi,(%esi)
	node->prev = list->tail;
  182fe0:	83 c3 14             	add    $0x14,%ebx
  182fe3:	8b 04 dd 40 01 28 00 	mov    0x280140(,%ebx,8),%eax
  182fea:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  182fed:	8b 04 dd 40 01 28 00 	mov    0x280140(,%ebx,8),%eax
  182ff4:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  182ff6:	89 34 dd 40 01 28 00 	mov    %esi,0x280140(,%ebx,8)
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
  182ffd:	a1 54 01 28 00       	mov    0x280154,%eax
  183002:	8a 50 0a             	mov    0xa(%eax),%dl
  183005:	38 56 0a             	cmp    %dl,0xa(%esi)
  183008:	7d 02                	jge    18300c <_add_thread_to_ready_q+0x45>
  18300a:	89 f0                	mov    %esi,%eax
  18300c:	a3 54 01 28 00       	mov    %eax,0x280154
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
  183011:	5b                   	pop    %ebx
  183012:	5e                   	pop    %esi
  183013:	5f                   	pop    %edi
  183014:	c3                   	ret    

00183015 <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  183015:	56                   	push   %esi
  183016:	53                   	push   %ebx
  183017:	89 c3                	mov    %eax,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  183019:	0f be 40 0a          	movsbl 0xa(%eax),%eax
	sys_dlist_t *q = &_ready_q.q[q_index];
  18301d:	83 c0 11             	add    $0x11,%eax
  183020:	8d 14 c5 54 01 28 00 	lea    0x280154(,%eax,8),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  183027:	8b 4b 04             	mov    0x4(%ebx),%ecx
  18302a:	8b 33                	mov    (%ebx),%esi
  18302c:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  18302e:	8b 0b                	mov    (%ebx),%ecx
  183030:	8b 73 04             	mov    0x4(%ebx),%esi
  183033:	89 71 04             	mov    %esi,0x4(%ecx)

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  183036:	3b 14 c5 54 01 28 00 	cmp    0x280154(,%eax,8),%edx
  18303d:	75 09                	jne    183048 <_remove_thread_from_ready_q+0x33>
		_clear_ready_q_prio_bit(thread->base.prio);
  18303f:	0f be 43 0a          	movsbl 0xa(%ebx),%eax
  183043:	e8 50 ff ff ff       	call   182f98 <_clear_ready_q_prio_bit>
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  183048:	a1 54 01 28 00       	mov    0x280154,%eax
  18304d:	39 c3                	cmp    %eax,%ebx
  18304f:	75 05                	jne    183056 <_remove_thread_from_ready_q+0x41>
  183051:	e8 5b ff ff ff       	call   182fb1 <_get_ready_q_head>
  183056:	a3 54 01 28 00       	mov    %eax,0x280154
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
  18305b:	5b                   	pop    %ebx
  18305c:	5e                   	pop    %esi
  18305d:	c3                   	ret    

0018305e <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
  18305e:	57                   	push   %edi
  18305f:	56                   	push   %esi
  183060:	53                   	push   %ebx
  183061:	89 c3                	mov    %eax,%ebx
  183063:	89 d6                	mov    %edx,%esi
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  183065:	8b 12                	mov    (%edx),%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  183067:	39 d6                	cmp    %edx,%esi
  183069:	75 49                	jne    1830b4 <_pend_thread+0x56>
  18306b:	ba 00 00 00 00       	mov    $0x0,%edx
  183070:	eb 42                	jmp    1830b4 <_pend_thread+0x56>
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
  183072:	8a 43 0a             	mov    0xa(%ebx),%al
  183075:	38 42 0a             	cmp    %al,0xa(%edx)
  183078:	7e 28                	jle    1830a2 <_pend_thread+0x44>
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  18307a:	85 d2                	test   %edx,%edx
  18307c:	75 12                	jne    183090 <_pend_thread+0x32>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  18307e:	89 33                	mov    %esi,(%ebx)
	node->prev = list->tail;
  183080:	8b 46 04             	mov    0x4(%esi),%eax
  183083:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  183086:	8b 46 04             	mov    0x4(%esi),%eax
  183089:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  18308b:	89 5e 04             	mov    %ebx,0x4(%esi)
  18308e:	eb 38                	jmp    1830c8 <_pend_thread+0x6a>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  183090:	8b 42 04             	mov    0x4(%edx),%eax
  183093:	89 43 04             	mov    %eax,0x4(%ebx)
		node->next = insert_point;
  183096:	89 13                	mov    %edx,(%ebx)
		insert_point->prev->next = node;
  183098:	8b 42 04             	mov    0x4(%edx),%eax
  18309b:	89 18                	mov    %ebx,(%eax)
		insert_point->prev = node;
  18309d:	89 5a 04             	mov    %ebx,0x4(%edx)
  1830a0:	eb 26                	jmp    1830c8 <_pend_thread+0x6a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1830a2:	85 d2                	test   %edx,%edx
  1830a4:	74 0e                	je     1830b4 <_pend_thread+0x56>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1830a6:	3b 56 04             	cmp    0x4(%esi),%edx
  1830a9:	74 04                	je     1830af <_pend_thread+0x51>
  1830ab:	8b 12                	mov    (%edx),%edx
  1830ad:	eb 05                	jmp    1830b4 <_pend_thread+0x56>
  1830af:	ba 00 00 00 00       	mov    $0x0,%edx
{
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
  1830b4:	85 d2                	test   %edx,%edx
  1830b6:	75 ba                	jne    183072 <_pend_thread+0x14>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1830b8:	89 33                	mov    %esi,(%ebx)
	node->prev = list->tail;
  1830ba:	8b 46 04             	mov    0x4(%esi),%eax
  1830bd:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  1830c0:	8b 46 04             	mov    0x4(%esi),%eax
  1830c3:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  1830c5:	89 5e 04             	mov    %ebx,0x4(%esi)
}

/* mark a thread as pending in its TCS */
static inline void _mark_thread_as_pending(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_PENDING;
  1830c8:	80 4b 09 02          	orb    $0x2,0x9(%ebx)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
  1830cc:	83 f9 ff             	cmp    $0xffffffff,%ecx
  1830cf:	0f 84 03 01 00 00    	je     1831d8 <_pend_thread+0x17a>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  1830d5:	83 c1 09             	add    $0x9,%ecx
  1830d8:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  1830dd:	89 c8                	mov    %ecx,%eax
  1830df:	f7 e2                	mul    %edx
  1830e1:	c1 ea 03             	shr    $0x3,%edx
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
  1830e4:	42                   	inc    %edx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  1830e5:	8d 7b 10             	lea    0x10(%ebx),%edi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  1830e8:	89 57 10             	mov    %edx,0x10(%edi)
	timeout->thread = thread;
  1830eb:	89 5f 08             	mov    %ebx,0x8(%edi)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  1830ee:	89 77 0c             	mov    %esi,0xc(%edi)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1830f1:	a1 4c 01 28 00       	mov    0x28014c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1830f6:	3d 4c 01 28 00       	cmp    $0x28014c,%eax
  1830fb:	75 07                	jne    183104 <_pend_thread+0xa6>
  1830fd:	ba 00 00 00 00       	mov    $0x0,%edx
  183102:	eb 02                	jmp    183106 <_pend_thread+0xa8>
  183104:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  183106:	85 d2                	test   %edx,%edx
  183108:	74 15                	je     18311f <_pend_thread+0xc1>
  18310a:	3d 4c 01 28 00       	cmp    $0x28014c,%eax
  18310f:	0f 85 9f 00 00 00    	jne    1831b4 <_pend_thread+0x156>
  183115:	b8 00 00 00 00       	mov    $0x0,%eax
  18311a:	e9 95 00 00 00       	jmp    1831b4 <_pend_thread+0x156>
  18311f:	b8 00 00 00 00       	mov    $0x0,%eax
  183124:	e9 8b 00 00 00       	jmp    1831b4 <_pend_thread+0x156>
		if (*delta <= in_q->delta_ticks_from_prev) {
  183129:	8b 57 10             	mov    0x10(%edi),%edx
  18312c:	8b 48 10             	mov    0x10(%eax),%ecx
  18312f:	39 ca                	cmp    %ecx,%edx
  183131:	7f 3a                	jg     18316d <_pend_thread+0x10f>
			in_q->delta_ticks_from_prev -= *delta;
  183133:	29 d1                	sub    %edx,%ecx
  183135:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  183138:	85 c0                	test   %eax,%eax
  18313a:	75 1e                	jne    18315a <_pend_thread+0xfc>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  18313c:	c7 43 10 4c 01 28 00 	movl   $0x28014c,0x10(%ebx)
	node->prev = list->tail;
  183143:	a1 50 01 28 00       	mov    0x280150,%eax
  183148:	89 47 04             	mov    %eax,0x4(%edi)

	list->tail->next = node;
  18314b:	a1 50 01 28 00       	mov    0x280150,%eax
  183150:	89 38                	mov    %edi,(%eax)
	list->tail = node;
  183152:	89 3d 50 01 28 00    	mov    %edi,0x280150
  183158:	eb 7e                	jmp    1831d8 <_pend_thread+0x17a>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  18315a:	8b 50 04             	mov    0x4(%eax),%edx
  18315d:	89 57 04             	mov    %edx,0x4(%edi)
		node->next = insert_point;
  183160:	89 43 10             	mov    %eax,0x10(%ebx)
		insert_point->prev->next = node;
  183163:	8b 50 04             	mov    0x4(%eax),%edx
  183166:	89 3a                	mov    %edi,(%edx)
		insert_point->prev = node;
  183168:	89 78 04             	mov    %edi,0x4(%eax)
  18316b:	eb 6b                	jmp    1831d8 <_pend_thread+0x17a>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  18316d:	29 ca                	sub    %ecx,%edx
  18316f:	89 57 10             	mov    %edx,0x10(%edi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  183172:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183174:	85 c0                	test   %eax,%eax
  183176:	74 0c                	je     183184 <_pend_thread+0x126>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183178:	3b 05 50 01 28 00    	cmp    0x280150,%eax
  18317e:	74 08                	je     183188 <_pend_thread+0x12a>
  183180:	8b 08                	mov    (%eax),%ecx
  183182:	eb 09                	jmp    18318d <_pend_thread+0x12f>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183184:	89 c1                	mov    %eax,%ecx
  183186:	eb 05                	jmp    18318d <_pend_thread+0x12f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183188:	b9 00 00 00 00       	mov    $0x0,%ecx
  18318d:	85 c9                	test   %ecx,%ecx
  18318f:	74 1e                	je     1831af <_pend_thread+0x151>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183191:	85 d2                	test   %edx,%edx
  183193:	74 0c                	je     1831a1 <_pend_thread+0x143>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183195:	3b 15 50 01 28 00    	cmp    0x280150,%edx
  18319b:	74 0b                	je     1831a8 <_pend_thread+0x14a>
  18319d:	8b 00                	mov    (%eax),%eax
  18319f:	eb 13                	jmp    1831b4 <_pend_thread+0x156>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1831a1:	b8 00 00 00 00       	mov    $0x0,%eax
  1831a6:	eb 0c                	jmp    1831b4 <_pend_thread+0x156>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1831a8:	b8 00 00 00 00       	mov    $0x0,%eax
  1831ad:	eb 05                	jmp    1831b4 <_pend_thread+0x156>
  1831af:	b8 00 00 00 00       	mov    $0x0,%eax
  1831b4:	85 c0                	test   %eax,%eax
  1831b6:	0f 85 6d ff ff ff    	jne    183129 <_pend_thread+0xcb>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1831bc:	c7 43 10 4c 01 28 00 	movl   $0x28014c,0x10(%ebx)
	node->prev = list->tail;
  1831c3:	a1 50 01 28 00       	mov    0x280150,%eax
  1831c8:	89 47 04             	mov    %eax,0x4(%edi)

	list->tail->next = node;
  1831cb:	a1 50 01 28 00       	mov    0x280150,%eax
  1831d0:	89 38                	mov    %edi,(%eax)
	list->tail = node;
  1831d2:	89 3d 50 01 28 00    	mov    %edi,0x280150

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
  1831d8:	5b                   	pop    %ebx
  1831d9:	5e                   	pop    %esi
  1831da:	5f                   	pop    %edi
  1831db:	c3                   	ret    

001831dc <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
  1831dc:	56                   	push   %esi
  1831dd:	53                   	push   %ebx
  1831de:	89 c3                	mov    %eax,%ebx
  1831e0:	89 d6                	mov    %edx,%esi
	_remove_thread_from_ready_q(_current);
  1831e2:	a1 48 01 28 00       	mov    0x280148,%eax
  1831e7:	e8 29 fe ff ff       	call   183015 <_remove_thread_from_ready_q>
	_pend_thread(_current, wait_q, timeout);
  1831ec:	89 f1                	mov    %esi,%ecx
  1831ee:	89 da                	mov    %ebx,%edx
  1831f0:	a1 48 01 28 00       	mov    0x280148,%eax
  1831f5:	e8 64 fe ff ff       	call   18305e <_pend_thread>
}
  1831fa:	5b                   	pop    %ebx
  1831fb:	5e                   	pop    %esi
  1831fc:	c3                   	ret    

001831fd <__must_switch_threads>:
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  1831fd:	a1 48 01 28 00       	mov    0x280148,%eax
  183202:	0f be 50 0a          	movsbl 0xa(%eax),%edx
  183206:	0f bc 05 58 01 28 00 	bsf    0x280158,%eax
  18320d:	75 05                	jne    183214 <__must_switch_threads+0x17>
  18320f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	int abs_prio = (find_lsb_set(ready_range) - 1) + (bitmap << 5);

	__ASSERT(abs_prio < K_NUM_PRIORITIES, "prio out-of-range\n");

	return abs_prio - _NUM_COOP_PRIO;
  183214:	83 e8 10             	sub    $0x10,%eax
	return _is_prio1_higher_than_or_equal_to_prio2(prio1, prio2);
}

static inline int _is_prio1_higher_than_prio2(int prio1, int prio2)
{
	return prio1 < prio2;
  183217:	39 c2                	cmp    %eax,%edx
  183219:	0f 9f c0             	setg   %al
  18321c:	0f b6 c0             	movzbl %al,%eax
#else
	return 0;
#endif
}
  18321f:	c3                   	ret    

00183220 <_reschedule_threads>:

/* reschedule threads if the scheduler is not locked */
/* not callable from ISR */
/* must be called with interrupts locked */
void _reschedule_threads(int key)
{
  183220:	53                   	push   %ebx
  183221:	89 c3                	mov    %eax,%ebx
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  183223:	a1 48 01 28 00       	mov    0x280148,%eax
  183228:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  18322d:	77 10                	ja     18323f <_reschedule_threads+0x1f>
  18322f:	e8 c9 ff ff ff       	call   1831fd <__must_switch_threads>
  183234:	85 c0                	test   %eax,%eax
  183236:	74 0c                	je     183244 <_reschedule_threads+0x24>
  183238:	b8 01 00 00 00       	mov    $0x1,%eax
  18323d:	eb 05                	jmp    183244 <_reschedule_threads+0x24>
  18323f:	b8 00 00 00 00       	mov    $0x0,%eax
#ifdef CONFIG_PREEMPT_ENABLED
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
  183244:	85 c0                	test   %eax,%eax
  183246:	74 09                	je     183251 <_reschedule_threads+0x31>
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  183248:	89 d8                	mov    %ebx,%eax
  18324a:	e8 93 f8 ff ff       	call   182ae2 <_Swap>
  18324f:	eb 06                	jmp    183257 <_reschedule_threads+0x37>
  183251:	f6 c7 02             	test   $0x2,%bh
  183254:	74 01                	je     183257 <_reschedule_threads+0x37>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183256:	fb                   	sti    
		irq_unlock(key);
	}
#else
	irq_unlock(key);
#endif
}
  183257:	5b                   	pop    %ebx
  183258:	c3                   	ret    

00183259 <k_sched_unlock>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183259:	9c                   	pushf  
  18325a:	fa                   	cli    
  18325b:	58                   	pop    %eax

	int key = irq_lock();

	/* compiler_barrier() not needed, comes from irq_lock() */

	++_current->base.sched_locked;
  18325c:	8b 0d 48 01 28 00    	mov    0x280148,%ecx
  183262:	8a 51 0b             	mov    0xb(%ecx),%dl
  183265:	42                   	inc    %edx
  183266:	88 51 0b             	mov    %dl,0xb(%ecx)

	K_DEBUG("scheduler unlocked (%p:%d)\n",
		_current, _current->base.sched_locked);

	_reschedule_threads(key);
  183269:	e8 b2 ff ff ff       	call   183220 <_reschedule_threads>
  18326e:	c3                   	ret    

0018326f <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  18326f:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	sys_dlist_t *q = &_ready_q.q[q_index];

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  183273:	3b 04 cd e0 01 28 00 	cmp    0x2801e0(,%ecx,8),%eax
  18327a:	74 53                	je     1832cf <_move_thread_to_end_of_prio_q+0x60>
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  18327c:	56                   	push   %esi
  18327d:	53                   	push   %ebx
  18327e:	8d 51 10             	lea    0x10(%ecx),%edx
  183281:	8d 1c cd dc 01 28 00 	lea    0x2801dc(,%ecx,8),%ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  183288:	8b 48 04             	mov    0x4(%eax),%ecx
  18328b:	8b 30                	mov    (%eax),%esi
  18328d:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  18328f:	8b 08                	mov    (%eax),%ecx
  183291:	8b 70 04             	mov    0x4(%eax),%esi
  183294:	89 71 04             	mov    %esi,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  183297:	89 18                	mov    %ebx,(%eax)
	node->prev = list->tail;
  183299:	83 c2 04             	add    $0x4,%edx
  18329c:	8b 0c d5 40 01 28 00 	mov    0x280140(,%edx,8),%ecx
  1832a3:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  1832a6:	8b 0c d5 40 01 28 00 	mov    0x280140(,%edx,8),%ecx
  1832ad:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  1832af:	89 04 d5 40 01 28 00 	mov    %eax,0x280140(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  1832b6:	8b 15 54 01 28 00    	mov    0x280154,%edx
  1832bc:	39 d0                	cmp    %edx,%eax
  1832be:	75 07                	jne    1832c7 <_move_thread_to_end_of_prio_q+0x58>
  1832c0:	e8 ec fc ff ff       	call   182fb1 <_get_ready_q_head>
  1832c5:	89 c2                	mov    %eax,%edx
  1832c7:	89 15 54 01 28 00    	mov    %edx,0x280154
#endif
}
  1832cd:	5b                   	pop    %ebx
  1832ce:	5e                   	pop    %esi
  1832cf:	c3                   	ret    

001832d0 <k_yield>:

void k_yield(void)
{
  1832d0:	53                   	push   %ebx
  1832d1:	9c                   	pushf  
  1832d2:	fa                   	cli    
  1832d3:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	int key = irq_lock();

	_move_thread_to_end_of_prio_q(_current);
  1832d4:	a1 48 01 28 00       	mov    0x280148,%eax
  1832d9:	e8 91 ff ff ff       	call   18326f <_move_thread_to_end_of_prio_q>

	if (_current == _get_next_ready_thread()) {
  1832de:	a1 54 01 28 00       	mov    0x280154,%eax
  1832e3:	39 05 48 01 28 00    	cmp    %eax,0x280148
  1832e9:	75 08                	jne    1832f3 <k_yield+0x23>
  1832eb:	f6 c7 02             	test   $0x2,%bh
  1832ee:	74 0a                	je     1832fa <k_yield+0x2a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1832f0:	fb                   	sti    
  1832f1:	eb 07                	jmp    1832fa <k_yield+0x2a>
		irq_unlock(key);
	} else {
		_Swap(key);
  1832f3:	89 d8                	mov    %ebx,%eax
  1832f5:	e8 e8 f7 ff ff       	call   182ae2 <_Swap>
	}
}
  1832fa:	5b                   	pop    %ebx
  1832fb:	c3                   	ret    

001832fc <k_sleep>:

void k_sleep(int32_t duration)
{
  1832fc:	57                   	push   %edi
  1832fd:	56                   	push   %esi
  1832fe:	53                   	push   %ebx
  1832ff:	83 ec 04             	sub    $0x4,%esp
	__ASSERT(duration != K_FOREVER, "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
  183302:	85 c0                	test   %eax,%eax
  183304:	75 0a                	jne    183310 <k_sleep+0x14>
		k_yield();
  183306:	e8 c5 ff ff ff       	call   1832d0 <k_yield>
		return;
  18330b:	e9 25 01 00 00       	jmp    183435 <k_sleep+0x139>
  183310:	83 c0 09             	add    $0x9,%eax
  183313:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  183318:	f7 e2                	mul    %edx
  18331a:	c1 ea 03             	shr    $0x3,%edx
	}

	ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  18331d:	42                   	inc    %edx
  18331e:	89 14 24             	mov    %edx,(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183321:	9c                   	pushf  
  183322:	fa                   	cli    
  183323:	5b                   	pop    %ebx
	key = irq_lock();

	_remove_thread_from_ready_q(_current);
  183324:	a1 48 01 28 00       	mov    0x280148,%eax
  183329:	e8 e7 fc ff ff       	call   183015 <_remove_thread_from_ready_q>
	_add_thread_timeout(_current, NULL, ticks);
  18332e:	8b 04 24             	mov    (%esp),%eax
  183331:	8b 3d 48 01 28 00    	mov    0x280148,%edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  183337:	8d 77 10             	lea    0x10(%edi),%esi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  18333a:	89 46 10             	mov    %eax,0x10(%esi)
	timeout->thread = thread;
  18333d:	89 7e 08             	mov    %edi,0x8(%esi)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  183340:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  183347:	a1 4c 01 28 00       	mov    0x28014c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  18334c:	3d 4c 01 28 00       	cmp    $0x28014c,%eax
  183351:	75 07                	jne    18335a <k_sleep+0x5e>
  183353:	ba 00 00 00 00       	mov    $0x0,%edx
  183358:	eb 02                	jmp    18335c <k_sleep+0x60>
  18335a:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  18335c:	85 d2                	test   %edx,%edx
  18335e:	74 15                	je     183375 <k_sleep+0x79>
  183360:	3d 4c 01 28 00       	cmp    $0x28014c,%eax
  183365:	0f 85 9f 00 00 00    	jne    18340a <k_sleep+0x10e>
  18336b:	b8 00 00 00 00       	mov    $0x0,%eax
  183370:	e9 95 00 00 00       	jmp    18340a <k_sleep+0x10e>
  183375:	b8 00 00 00 00       	mov    $0x0,%eax
  18337a:	e9 8b 00 00 00       	jmp    18340a <k_sleep+0x10e>
		if (*delta <= in_q->delta_ticks_from_prev) {
  18337f:	8b 56 10             	mov    0x10(%esi),%edx
  183382:	8b 48 10             	mov    0x10(%eax),%ecx
  183385:	39 ca                	cmp    %ecx,%edx
  183387:	7f 3a                	jg     1833c3 <k_sleep+0xc7>
			in_q->delta_ticks_from_prev -= *delta;
  183389:	29 d1                	sub    %edx,%ecx
  18338b:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  18338e:	85 c0                	test   %eax,%eax
  183390:	75 1e                	jne    1833b0 <k_sleep+0xb4>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  183392:	c7 47 10 4c 01 28 00 	movl   $0x28014c,0x10(%edi)
	node->prev = list->tail;
  183399:	a1 50 01 28 00       	mov    0x280150,%eax
  18339e:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  1833a1:	a1 50 01 28 00       	mov    0x280150,%eax
  1833a6:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  1833a8:	89 35 50 01 28 00    	mov    %esi,0x280150
  1833ae:	eb 7e                	jmp    18342e <k_sleep+0x132>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  1833b0:	8b 50 04             	mov    0x4(%eax),%edx
  1833b3:	89 56 04             	mov    %edx,0x4(%esi)
		node->next = insert_point;
  1833b6:	89 47 10             	mov    %eax,0x10(%edi)
		insert_point->prev->next = node;
  1833b9:	8b 50 04             	mov    0x4(%eax),%edx
  1833bc:	89 32                	mov    %esi,(%edx)
		insert_point->prev = node;
  1833be:	89 70 04             	mov    %esi,0x4(%eax)
  1833c1:	eb 6b                	jmp    18342e <k_sleep+0x132>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  1833c3:	29 ca                	sub    %ecx,%edx
  1833c5:	89 56 10             	mov    %edx,0x10(%esi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1833c8:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1833ca:	85 c0                	test   %eax,%eax
  1833cc:	74 0c                	je     1833da <k_sleep+0xde>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1833ce:	3b 05 50 01 28 00    	cmp    0x280150,%eax
  1833d4:	74 08                	je     1833de <k_sleep+0xe2>
  1833d6:	8b 08                	mov    (%eax),%ecx
  1833d8:	eb 09                	jmp    1833e3 <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1833da:	89 c1                	mov    %eax,%ecx
  1833dc:	eb 05                	jmp    1833e3 <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1833de:	b9 00 00 00 00       	mov    $0x0,%ecx
  1833e3:	85 c9                	test   %ecx,%ecx
  1833e5:	74 1e                	je     183405 <k_sleep+0x109>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1833e7:	85 d2                	test   %edx,%edx
  1833e9:	74 0c                	je     1833f7 <k_sleep+0xfb>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1833eb:	3b 15 50 01 28 00    	cmp    0x280150,%edx
  1833f1:	74 0b                	je     1833fe <k_sleep+0x102>
  1833f3:	8b 00                	mov    (%eax),%eax
  1833f5:	eb 13                	jmp    18340a <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1833f7:	b8 00 00 00 00       	mov    $0x0,%eax
  1833fc:	eb 0c                	jmp    18340a <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1833fe:	b8 00 00 00 00       	mov    $0x0,%eax
  183403:	eb 05                	jmp    18340a <k_sleep+0x10e>
  183405:	b8 00 00 00 00       	mov    $0x0,%eax
  18340a:	85 c0                	test   %eax,%eax
  18340c:	0f 85 6d ff ff ff    	jne    18337f <k_sleep+0x83>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  183412:	c7 47 10 4c 01 28 00 	movl   $0x28014c,0x10(%edi)
	node->prev = list->tail;
  183419:	a1 50 01 28 00       	mov    0x280150,%eax
  18341e:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  183421:	a1 50 01 28 00       	mov    0x280150,%eax
  183426:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  183428:	89 35 50 01 28 00    	mov    %esi,0x280150

	_Swap(key);
  18342e:	89 d8                	mov    %ebx,%eax
  183430:	e8 ad f6 ff ff       	call   182ae2 <_Swap>
#endif
}
  183435:	83 c4 04             	add    $0x4,%esp
  183438:	5b                   	pop    %ebx
  183439:	5e                   	pop    %esi
  18343a:	5f                   	pop    %edi
  18343b:	c3                   	ret    

0018343c <k_current_get>:
}

k_tid_t k_current_get(void)
{
	return _current;
}
  18343c:	a1 48 01 28 00       	mov    0x280148,%eax
  183441:	c3                   	ret    

00183442 <init_sem_module>:
{
	ARG_UNUSED(dev);

	struct k_sem *sem;

	for (sem = _k_sem_list_start; sem < _k_sem_list_end; sem++) {
  183442:	b8 a4 00 28 00       	mov    $0x2800a4,%eax
  183447:	eb 1a                	jmp    183463 <init_sem_module+0x21>
  183449:	9c                   	pushf  
  18344a:	fa                   	cli    
  18344b:	5a                   	pop    %edx
		SYS_TRACING_OBJ_INIT(k_sem, sem);
  18344c:	8b 0d cc 02 28 00    	mov    0x2802cc,%ecx
  183452:	89 48 10             	mov    %ecx,0x10(%eax)
  183455:	a3 cc 02 28 00       	mov    %eax,0x2802cc
  18345a:	f6 c6 02             	test   $0x2,%dh
  18345d:	74 01                	je     183460 <init_sem_module+0x1e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18345f:	fb                   	sti    
{
	ARG_UNUSED(dev);

	struct k_sem *sem;

	for (sem = _k_sem_list_start; sem < _k_sem_list_end; sem++) {
  183460:	83 c0 14             	add    $0x14,%eax
  183463:	3d a4 00 28 00       	cmp    $0x2800a4,%eax
  183468:	72 df                	jb     183449 <init_sem_module+0x7>
		SYS_TRACING_OBJ_INIT(k_sem, sem);
	}
	return 0;
}
  18346a:	b8 00 00 00 00       	mov    $0x0,%eax
  18346f:	c3                   	ret    

00183470 <handle_sem_group>:
	return 0;
}

/* cancel all but specified semaphore in list if part of a semphore group */
static void handle_sem_group(struct k_sem *sem, struct sem_thread *sem_thread)
{
  183470:	55                   	push   %ebp
  183471:	57                   	push   %edi
  183472:	56                   	push   %esi
  183473:	53                   	push   %ebx
  183474:	83 ec 04             	sub    $0x4,%esp
	struct sem_desc *desc = NULL;
	sys_dlist_t *list;
	sys_dnode_t *node;
	sys_dnode_t *next;

	list = (sys_dlist_t *)sem_thread->desc.thread->base.swap_data;
  183477:	8b 52 30             	mov    0x30(%edx),%edx
  18347a:	8b 72 0c             	mov    0xc(%edx),%esi
  18347d:	89 34 24             	mov    %esi,(%esp)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  183480:	8b 1e                	mov    (%esi),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  183482:	39 de                	cmp    %ebx,%esi
  183484:	75 09                	jne    18348f <handle_sem_group+0x1f>
  183486:	bb 00 00 00 00       	mov    $0x0,%ebx
  18348b:	eb 02                	jmp    18348f <handle_sem_group+0x1f>

		if (desc->sem != sem) {
			sys_dlist_remove(node);
		}

		node = next;
  18348d:	89 f3                	mov    %esi,%ebx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18348f:	85 db                	test   %ebx,%ebx
  183491:	74 0c                	je     18349f <handle_sem_group+0x2f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183493:	8b 34 24             	mov    (%esp),%esi
  183496:	3b 5e 04             	cmp    0x4(%esi),%ebx
  183499:	74 08                	je     1834a3 <handle_sem_group+0x33>
  18349b:	8b 33                	mov    (%ebx),%esi
  18349d:	eb 09                	jmp    1834a8 <handle_sem_group+0x38>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18349f:	89 de                	mov    %ebx,%esi
  1834a1:	eb 05                	jmp    1834a8 <handle_sem_group+0x38>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1834a3:	be 00 00 00 00       	mov    $0x0,%esi
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  1834a8:	8d 53 e8             	lea    -0x18(%ebx),%edx
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  1834ab:	8b 7a 10             	mov    0x10(%edx),%edi
  1834ae:	83 ff ff             	cmp    $0xffffffff,%edi
  1834b1:	74 36                	je     1834e9 <handle_sem_group+0x79>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  1834b3:	89 d1                	mov    %edx,%ecx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  1834b5:	8b 2d 50 01 28 00    	mov    0x280150,%ebp
  1834bb:	39 ea                	cmp    %ebp,%edx
  1834bd:	74 14                	je     1834d3 <handle_sem_group+0x63>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1834bf:	85 d2                	test   %edx,%edx
  1834c1:	74 0d                	je     1834d0 <handle_sem_group+0x60>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1834c3:	39 ea                	cmp    %ebp,%edx
  1834c5:	74 04                	je     1834cb <handle_sem_group+0x5b>
  1834c7:	8b 0a                	mov    (%edx),%ecx
  1834c9:	eb 05                	jmp    1834d0 <handle_sem_group+0x60>
  1834cb:	b9 00 00 00 00       	mov    $0x0,%ecx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  1834d0:	01 79 10             	add    %edi,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1834d3:	8b 4a 04             	mov    0x4(%edx),%ecx
  1834d6:	8b 3a                	mov    (%edx),%edi
  1834d8:	89 39                	mov    %edi,(%ecx)
	node->next->prev = node->prev;
  1834da:	8b 0a                	mov    (%edx),%ecx
  1834dc:	8b 7a 04             	mov    0x4(%edx),%edi
  1834df:	89 79 04             	mov    %edi,0x4(%ecx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  1834e2:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1834e9:	8b 53 dc             	mov    -0x24(%ebx),%edx
  1834ec:	8b 4b d8             	mov    -0x28(%ebx),%ecx
  1834ef:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1834f1:	8b 53 d8             	mov    -0x28(%ebx),%edx
  1834f4:	8b 4b dc             	mov    -0x24(%ebx),%ecx
  1834f7:	89 4a 04             	mov    %ecx,0x4(%edx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  1834fa:	80 63 e1 fd          	andb   $0xfd,-0x1f(%ebx)
		 * where the timeout of the dummy thread might have expired.
		 */
		_abort_thread_timeout(dummy);
		_unpend_thread(dummy);

		if (desc->sem != sem) {
  1834fe:	39 43 0c             	cmp    %eax,0xc(%ebx)
  183501:	74 0f                	je     183512 <handle_sem_group+0xa2>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  183503:	8b 53 04             	mov    0x4(%ebx),%edx
  183506:	8b 0b                	mov    (%ebx),%ecx
  183508:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  18350a:	8b 13                	mov    (%ebx),%edx
  18350c:	8b 4b 04             	mov    0x4(%ebx),%ecx
  18350f:	89 4a 04             	mov    %ecx,0x4(%edx)
			sys_dlist_remove(node);
		}

		node = next;
	} while (node != NULL);
  183512:	85 f6                	test   %esi,%esi
  183514:	0f 85 73 ff ff ff    	jne    18348d <handle_sem_group+0x1d>
	 * As this code may be executed several times by a semaphore group give
	 * operation, it is important to ensure that the attempt to ready the
	 * master thread is done only once.
	 */

	if (!_is_thread_ready(desc->thread)) {
  18351a:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  18351d:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  183521:	75 0d                	jne    183530 <handle_sem_group+0xc0>
  183523:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  183527:	75 0e                	jne    183537 <handle_sem_group+0xc7>
  183529:	b9 01 00 00 00       	mov    $0x1,%ecx
  18352e:	eb 0c                	jmp    18353c <handle_sem_group+0xcc>
  183530:	b9 00 00 00 00       	mov    $0x0,%ecx
  183535:	eb 05                	jmp    18353c <handle_sem_group+0xcc>
  183537:	b9 00 00 00 00       	mov    $0x0,%ecx
  18353c:	85 c9                	test   %ecx,%ecx
  18353e:	75 68                	jne    1835a8 <handle_sem_group+0x138>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  183540:	8d 50 10             	lea    0x10(%eax),%edx
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  183543:	8b 7a 10             	mov    0x10(%edx),%edi
  183546:	83 ff ff             	cmp    $0xffffffff,%edi
  183549:	74 39                	je     183584 <handle_sem_group+0x114>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  18354b:	89 d6                	mov    %edx,%esi
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  18354d:	8b 2d 50 01 28 00    	mov    0x280150,%ebp
  183553:	39 ea                	cmp    %ebp,%edx
  183555:	74 15                	je     18356c <handle_sem_group+0xfc>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183557:	85 d2                	test   %edx,%edx
  183559:	74 0e                	je     183569 <handle_sem_group+0xf9>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18355b:	39 ea                	cmp    %ebp,%edx
  18355d:	74 05                	je     183564 <handle_sem_group+0xf4>
  18355f:	8b 70 10             	mov    0x10(%eax),%esi
  183562:	eb 05                	jmp    183569 <handle_sem_group+0xf9>
  183564:	be 00 00 00 00       	mov    $0x0,%esi
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  183569:	01 7e 10             	add    %edi,0x10(%esi)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18356c:	8b 72 04             	mov    0x4(%edx),%esi
  18356f:	8b 78 10             	mov    0x10(%eax),%edi
  183572:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
  183574:	8b 40 10             	mov    0x10(%eax),%eax
  183577:	8b 72 04             	mov    0x4(%edx),%esi
  18357a:	89 70 04             	mov    %esi,0x4(%eax)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  18357d:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
		_abort_thread_timeout(desc->thread);
		_mark_thread_as_not_pending(desc->thread);
  183584:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  183587:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		if (_is_thread_ready(desc->thread)) {
  18358b:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  18358e:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  183592:	75 0b                	jne    18359f <handle_sem_group+0x12f>
  183594:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  183598:	75 05                	jne    18359f <handle_sem_group+0x12f>
  18359a:	b9 01 00 00 00       	mov    $0x1,%ecx
  18359f:	85 c9                	test   %ecx,%ecx
  1835a1:	74 05                	je     1835a8 <handle_sem_group+0x138>
			_add_thread_to_ready_q(desc->thread);
  1835a3:	e8 1f fa ff ff       	call   182fc7 <_add_thread_to_ready_q>
		}
	}
	_set_thread_return_value(desc->thread, 0);
  1835a8:	8b 43 08             	mov    0x8(%ebx),%eax
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  1835ab:	8b 40 28             	mov    0x28(%eax),%eax
  1835ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  1835b4:	83 c4 04             	add    $0x4,%esp
  1835b7:	5b                   	pop    %ebx
  1835b8:	5e                   	pop    %esi
  1835b9:	5f                   	pop    %edi
  1835ba:	5d                   	pop    %ebp
  1835bb:	c3                   	ret    

001835bc <do_sem_give>:
	sem->count += (sem->count != sem->limit);
}

/* returns 1 if _Swap() will need to be invoked, 0 otherwise */
static int do_sem_give(struct k_sem *sem)
{
  1835bc:	57                   	push   %edi
  1835bd:	56                   	push   %esi
  1835be:	53                   	push   %ebx
#ifdef CONFIG_SEMAPHORE_GROUPS
	struct k_thread *thread = NULL;
  1835bf:	bb 00 00 00 00       	mov    $0x0,%ebx

again:
	thread = _find_first_thread_to_unpend(&sem->wait_q, thread);
  1835c4:	89 c1                	mov    %eax,%ecx
_find_first_thread_to_unpend(_wait_q_t *wait_q, struct k_thread *from)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	extern volatile int _handling_timeouts;

	if (_handling_timeouts) {
  1835c6:	8b 15 d0 02 28 00    	mov    0x2802d0,%edx
  1835cc:	85 d2                	test   %edx,%edx
  1835ce:	74 3f                	je     18360f <do_sem_give+0x53>
		sys_dlist_t *q = (sys_dlist_t *)wait_q;
		sys_dnode_t *cur = from ? &from->base.k_q_node : NULL;

		/* skip threads that have an expired timeout */
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  1835d0:	85 db                	test   %ebx,%ebx
  1835d2:	74 10                	je     1835e4 <do_sem_give+0x28>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1835d4:	3b 58 04             	cmp    0x4(%eax),%ebx
  1835d7:	74 04                	je     1835dd <do_sem_give+0x21>
  1835d9:	8b 1b                	mov    (%ebx),%ebx
  1835db:	eb 2c                	jmp    183609 <do_sem_give+0x4d>
  1835dd:	bb 00 00 00 00       	mov    $0x0,%ebx
  1835e2:	eb 25                	jmp    183609 <do_sem_give+0x4d>
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1835e4:	8b 18                	mov    (%eax),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1835e6:	39 d8                	cmp    %ebx,%eax
  1835e8:	75 1f                	jne    183609 <do_sem_give+0x4d>
  1835ea:	bb 00 00 00 00       	mov    $0x0,%ebx
  1835ef:	eb 18                	jmp    183609 <do_sem_give+0x4d>
			struct k_thread *thread = (struct k_thread *)cur;

			if (_is_thread_timeout_expired(thread)) {
  1835f1:	83 7b 20 fe          	cmpl   $0xfffffffe,0x20(%ebx)
  1835f5:	75 23                	jne    18361a <do_sem_give+0x5e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1835f7:	85 db                	test   %ebx,%ebx
  1835f9:	74 0e                	je     183609 <do_sem_give+0x4d>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1835fb:	3b 59 04             	cmp    0x4(%ecx),%ebx
  1835fe:	74 04                	je     183604 <do_sem_give+0x48>
  183600:	8b 1b                	mov    (%ebx),%ebx
  183602:	eb 05                	jmp    183609 <do_sem_give+0x4d>
  183604:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (_handling_timeouts) {
		sys_dlist_t *q = (sys_dlist_t *)wait_q;
		sys_dnode_t *cur = from ? &from->base.k_q_node : NULL;

		/* skip threads that have an expired timeout */
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  183609:	85 db                	test   %ebx,%ebx
  18360b:	75 e4                	jne    1835f1 <do_sem_give+0x35>
  18360d:	eb 0b                	jmp    18361a <do_sem_give+0x5e>
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  18360f:	8b 18                	mov    (%eax),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  183611:	39 d8                	cmp    %ebx,%eax
  183613:	75 05                	jne    18361a <do_sem_give+0x5e>
  183615:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (!thread) {
  18361a:	85 db                	test   %ebx,%ebx
  18361c:	75 1b                	jne    183639 <do_sem_give+0x7d>
#endif
}

static inline void increment_count_up_to_limit(struct k_sem *sem)
{
	sem->count += (sem->count != sem->limit);
  18361e:	8b 48 08             	mov    0x8(%eax),%ecx
  183621:	3b 48 0c             	cmp    0xc(%eax),%ecx
  183624:	0f 95 c2             	setne  %dl
  183627:	0f b6 d2             	movzbl %dl,%edx
  18362a:	01 ca                	add    %ecx,%edx
  18362c:	89 50 08             	mov    %edx,0x8(%eax)

again:
	thread = _find_first_thread_to_unpend(&sem->wait_q, thread);
	if (!thread) {
		increment_count_up_to_limit(sem);
		return handle_poll_event(sem);
  18362f:	b8 00 00 00 00       	mov    $0x0,%eax
  183634:	e9 e2 00 00 00       	jmp    18371b <do_sem_give+0x15f>
	thread->base.thread_state &= ~states;
}

static inline int _is_thread_state_set(struct k_thread *thread, uint32_t state)
{
	return !!(thread->base.thread_state & state);
  183639:	0f b6 53 09          	movzbl 0x9(%ebx),%edx
  18363d:	83 e2 01             	and    $0x1,%edx
  183640:	89 d1                	mov    %edx,%ecx
	}

	if (unlikely(_is_thread_dummy(thread))) {
  183642:	85 d2                	test   %edx,%edx
  183644:	74 19                	je     18365f <do_sem_give+0xa3>
		/*
		 * The awakened thread is a dummy struct sem_thread and thus
		 * was involved in a semaphore group operation.
		 */
		struct sem_thread *sem_thread = (struct sem_thread *)thread;
		struct k_thread *real_thread = sem_thread->desc.thread;
  183646:	8b 53 30             	mov    0x30(%ebx),%edx
		 * care of signalling the waiter that its operation has
		 * timedout. In that case, we look for the next thread not part
		 * of the same k_sem_group_take operation to give it the
		 * semaphore.
		 */
		if (_is_thread_timeout_expired(real_thread)) {
  183649:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
  18364d:	0f 84 71 ff ff ff    	je     1835c4 <do_sem_give+0x8>
		/*
		 * Do not dequeue the dummy thread: that will be done when
		 * looping through the list of dummy waiters in
		 * handle_sem_group().
		 */
		handle_sem_group(sem, sem_thread);
  183653:	89 da                	mov    %ebx,%edx
  183655:	e8 16 fe ff ff       	call   183470 <handle_sem_group>
  18365a:	e9 82 00 00 00       	jmp    1836e1 <do_sem_give+0x125>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18365f:	8b 43 04             	mov    0x4(%ebx),%eax
  183662:	8b 13                	mov    (%ebx),%edx
  183664:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  183666:	8b 03                	mov    (%ebx),%eax
  183668:	8b 53 04             	mov    0x4(%ebx),%edx
  18366b:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  18366e:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  183672:	8d 43 10             	lea    0x10(%ebx),%eax
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  183675:	8b 70 10             	mov    0x10(%eax),%esi
  183678:	83 fe ff             	cmp    $0xffffffff,%esi
  18367b:	74 36                	je     1836b3 <do_sem_give+0xf7>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  18367d:	89 c2                	mov    %eax,%edx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  18367f:	8b 3d 50 01 28 00    	mov    0x280150,%edi
  183685:	39 f8                	cmp    %edi,%eax
  183687:	74 14                	je     18369d <do_sem_give+0xe1>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183689:	85 c0                	test   %eax,%eax
  18368b:	74 0d                	je     18369a <do_sem_give+0xde>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18368d:	39 f8                	cmp    %edi,%eax
  18368f:	74 04                	je     183695 <do_sem_give+0xd9>
  183691:	8b 10                	mov    (%eax),%edx
  183693:	eb 05                	jmp    18369a <do_sem_give+0xde>
  183695:	ba 00 00 00 00       	mov    $0x0,%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  18369a:	01 72 10             	add    %esi,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18369d:	8b 50 04             	mov    0x4(%eax),%edx
  1836a0:	8b 30                	mov    (%eax),%esi
  1836a2:	89 32                	mov    %esi,(%edx)
	node->next->prev = node->prev;
  1836a4:	8b 10                	mov    (%eax),%edx
  1836a6:	8b 70 04             	mov    0x4(%eax),%esi
  1836a9:	89 72 04             	mov    %esi,0x4(%edx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  1836ac:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1836b3:	8a 43 09             	mov    0x9(%ebx),%al
  1836b6:	88 c2                	mov    %al,%dl
  1836b8:	83 e2 fb             	and    $0xfffffffb,%edx
  1836bb:	88 53 09             	mov    %dl,0x9(%ebx)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1836be:	a8 1b                	test   $0x1b,%al
  1836c0:	75 0b                	jne    1836cd <do_sem_give+0x111>
  1836c2:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  1836c6:	75 05                	jne    1836cd <do_sem_give+0x111>
  1836c8:	b9 01 00 00 00       	mov    $0x1,%ecx
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  1836cd:	85 c9                	test   %ecx,%ecx
  1836cf:	74 07                	je     1836d8 <do_sem_give+0x11c>
		_add_thread_to_ready_q(thread);
  1836d1:	89 d8                	mov    %ebx,%eax
  1836d3:	e8 ef f8 ff ff       	call   182fc7 <_add_thread_to_ready_q>
  1836d8:	8b 43 28             	mov    0x28(%ebx),%eax
  1836db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(void)_abort_thread_timeout(thread);
	_ready_thread(thread);
	_set_thread_return_value(thread, 0);
#endif

	return !_is_in_isr() && _must_switch_threads();
  1836e1:	83 3d 40 01 28 00 00 	cmpl   $0x0,0x280140
  1836e8:	75 2c                	jne    183716 <do_sem_give+0x15a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  1836ea:	a1 48 01 28 00       	mov    0x280148,%eax
  1836ef:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  1836f4:	77 10                	ja     183706 <do_sem_give+0x14a>
  1836f6:	e8 02 fb ff ff       	call   1831fd <__must_switch_threads>
  1836fb:	85 c0                	test   %eax,%eax
  1836fd:	74 0c                	je     18370b <do_sem_give+0x14f>
  1836ff:	b8 01 00 00 00       	mov    $0x1,%eax
  183704:	eb 05                	jmp    18370b <do_sem_give+0x14f>
  183706:	b8 00 00 00 00       	mov    $0x0,%eax
  18370b:	85 c0                	test   %eax,%eax
  18370d:	74 0c                	je     18371b <do_sem_give+0x15f>
  18370f:	b8 01 00 00 00       	mov    $0x1,%eax
  183714:	eb 05                	jmp    18371b <do_sem_give+0x15f>
  183716:	b8 00 00 00 00       	mov    $0x0,%eax
}
  18371b:	5b                   	pop    %ebx
  18371c:	5e                   	pop    %esi
  18371d:	5f                   	pop    %edi
  18371e:	c3                   	ret    

0018371f <k_sem_init>:
void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
  18371f:	89 50 08             	mov    %edx,0x8(%eax)
	sem->limit = limit;
  183722:	89 48 0c             	mov    %ecx,0xc(%eax)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  183725:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  183727:	89 40 04             	mov    %eax,0x4(%eax)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18372a:	9c                   	pushf  
  18372b:	fa                   	cli    
  18372c:	5a                   	pop    %edx
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
  18372d:	8b 0d cc 02 28 00    	mov    0x2802cc,%ecx
  183733:	89 48 10             	mov    %ecx,0x10(%eax)
  183736:	a3 cc 02 28 00       	mov    %eax,0x2802cc
  18373b:	f6 c6 02             	test   $0x2,%dh
  18373e:	74 01                	je     183741 <k_sem_init+0x22>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183740:	fb                   	sti    
  183741:	c3                   	ret    

00183742 <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
  183742:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183743:	9c                   	pushf  
  183744:	fa                   	cli    
  183745:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
  183746:	e8 71 fe ff ff       	call   1835bc <do_sem_give>
  18374b:	85 c0                	test   %eax,%eax
  18374d:	74 09                	je     183758 <k_sem_give+0x16>
		_Swap(key);
  18374f:	89 d8                	mov    %ebx,%eax
  183751:	e8 8c f3 ff ff       	call   182ae2 <_Swap>
  183756:	eb 06                	jmp    18375e <k_sem_give+0x1c>
  183758:	f6 c7 02             	test   $0x2,%bh
  18375b:	74 01                	je     18375e <k_sem_give+0x1c>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18375d:	fb                   	sti    
	} else {
		irq_unlock(key);
	}
}
  18375e:	5b                   	pop    %ebx
  18375f:	c3                   	ret    

00183760 <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
  183760:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183761:	9c                   	pushf  
  183762:	fa                   	cli    
  183763:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
  183764:	8b 48 08             	mov    0x8(%eax),%ecx
  183767:	85 c9                	test   %ecx,%ecx
  183769:	74 11                	je     18377c <k_sem_take+0x1c>
		sem->count--;
  18376b:	49                   	dec    %ecx
  18376c:	89 48 08             	mov    %ecx,0x8(%eax)
  18376f:	f6 c7 02             	test   $0x2,%bh
  183772:	74 27                	je     18379b <k_sem_take+0x3b>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183774:	fb                   	sti    
		irq_unlock(key);
		return 0;
  183775:	b8 00 00 00 00       	mov    $0x0,%eax
  18377a:	eb 2b                	jmp    1837a7 <k_sem_take+0x47>
	}

	if (timeout == K_NO_WAIT) {
  18377c:	85 d2                	test   %edx,%edx
  18377e:	75 0d                	jne    18378d <k_sem_take+0x2d>
  183780:	f6 c7 02             	test   $0x2,%bh
  183783:	74 1d                	je     1837a2 <k_sem_take+0x42>
  183785:	fb                   	sti    
		irq_unlock(key);
		return -EBUSY;
  183786:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  18378b:	eb 1a                	jmp    1837a7 <k_sem_take+0x47>
	}

	_pend_current_thread(&sem->wait_q, timeout);
  18378d:	e8 4a fa ff ff       	call   1831dc <_pend_current_thread>

	return _Swap(key);
  183792:	89 d8                	mov    %ebx,%eax
  183794:	e8 49 f3 ff ff       	call   182ae2 <_Swap>
  183799:	eb 0c                	jmp    1837a7 <k_sem_take+0x47>
	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
		sem->count--;
		irq_unlock(key);
		return 0;
  18379b:	b8 00 00 00 00       	mov    $0x0,%eax
  1837a0:	eb 05                	jmp    1837a7 <k_sem_take+0x47>
	}

	if (timeout == K_NO_WAIT) {
		irq_unlock(key);
		return -EBUSY;
  1837a2:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	}

	_pend_current_thread(&sem->wait_q, timeout);

	return _Swap(key);
}
  1837a7:	5b                   	pop    %ebx
  1837a8:	c3                   	ret    

001837a9 <handle_time_slicing>:
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
	if (_time_slice_duration == 0) {
  1837a9:	8b 15 64 02 28 00    	mov    0x280264,%edx
  1837af:	85 d2                	test   %edx,%edx
  1837b1:	74 50                	je     183803 <handle_time_slicing+0x5a>
		return;
	}

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  1837b3:	8b 0d 48 01 28 00    	mov    0x280148,%ecx
  1837b9:	0f be 49 0a          	movsbl 0xa(%ecx),%ecx
  1837bd:	39 0d 60 02 28 00    	cmp    %ecx,0x280260
  1837c3:	7f 3e                	jg     183803 <handle_time_slicing+0x5a>
 *   in this function and at thread level
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
  1837c5:	57                   	push   %edi
  1837c6:	56                   	push   %esi
  1837c7:	53                   	push   %ebx
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
  1837c8:	89 c1                	mov    %eax,%ecx
  1837ca:	89 c6                	mov    %eax,%esi
  1837cc:	01 c6                	add    %eax,%esi
  1837ce:	c1 e1 03             	shl    $0x3,%ecx
  1837d1:	01 f1                	add    %esi,%ecx

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
  1837d3:	03 0d d4 02 28 00    	add    0x2802d4,%ecx
  1837d9:	89 0d d4 02 28 00    	mov    %ecx,0x2802d4
	if (_time_slice_elapsed >= _time_slice_duration) {
  1837df:	39 ca                	cmp    %ecx,%edx
  1837e1:	7f 1d                	jg     183800 <handle_time_slicing+0x57>

		unsigned int key;

		_time_slice_elapsed = 0;
  1837e3:	c7 05 d4 02 28 00 00 	movl   $0x0,0x2802d4
  1837ea:	00 00 00 

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1837ed:	9c                   	pushf  
  1837ee:	fa                   	cli    
  1837ef:	5b                   	pop    %ebx

		key = irq_lock();
		_move_thread_to_end_of_prio_q(_current);
  1837f0:	a1 48 01 28 00       	mov    0x280148,%eax
  1837f5:	e8 75 fa ff ff       	call   18326f <_move_thread_to_end_of_prio_q>
  1837fa:	f6 c7 02             	test   $0x2,%bh
  1837fd:	74 01                	je     183800 <handle_time_slicing+0x57>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1837ff:	fb                   	sti    
		irq_unlock(key);
	}
}
  183800:	5b                   	pop    %ebx
  183801:	5e                   	pop    %esi
  183802:	5f                   	pop    %edi
  183803:	c3                   	ret    

00183804 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  183804:	57                   	push   %edi
  183805:	56                   	push   %esi
  183806:	53                   	push   %ebx
  183807:	83 ec 08             	sub    $0x8,%esp
  18380a:	89 c6                	mov    %eax,%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18380c:	9c                   	pushf  
  18380d:	fa                   	cli    
  18380e:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
  18380f:	89 f3                	mov    %esi,%ebx
  183811:	c1 fb 1f             	sar    $0x1f,%ebx
  183814:	01 35 d8 02 28 00    	add    %esi,0x2802d8
  18381a:	11 1d dc 02 28 00    	adc    %ebx,0x2802dc
  183820:	f6 c4 02             	test   $0x2,%ah
  183823:	74 01                	je     183826 <_nano_sys_clock_tick_announce+0x22>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183825:	fb                   	sti    
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  183826:	89 24 24             	mov    %esp,(%esp)
	list->tail = (sys_dnode_t *)list;
  183829:	89 64 24 04          	mov    %esp,0x4(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18382d:	9c                   	pushf  
  18382e:	fa                   	cli    
  18382f:	59                   	pop    %ecx
  183830:	89 ca                	mov    %ecx,%edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  183832:	a1 4c 01 28 00       	mov    0x28014c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  183837:	3d 4c 01 28 00       	cmp    $0x28014c,%eax
  18383c:	75 05                	jne    183843 <_nano_sys_clock_tick_announce+0x3f>
  18383e:	b8 00 00 00 00       	mov    $0x0,%eax
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (!head) {
  183843:	85 c0                	test   %eax,%eax
  183845:	75 0f                	jne    183856 <_nano_sys_clock_tick_announce+0x52>
  183847:	f6 c5 02             	test   $0x2,%ch
  18384a:	0f 84 52 01 00 00    	je     1839a2 <_nano_sys_clock_tick_announce+0x19e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183850:	fb                   	sti    
  183851:	e9 4c 01 00 00       	jmp    1839a2 <_nano_sys_clock_tick_announce+0x19e>
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
  183856:	29 70 10             	sub    %esi,0x10(%eax)
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
  183859:	c7 05 d0 02 28 00 01 	movl   $0x1,0x2802d0
  183860:	00 00 00 
  183863:	eb 41                	jmp    1838a6 <_nano_sys_clock_tick_announce+0xa2>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  183865:	8b 48 04             	mov    0x4(%eax),%ecx
  183868:	8b 18                	mov    (%eax),%ebx
  18386a:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  18386c:	8b 08                	mov    (%eax),%ecx
  18386e:	8b 58 04             	mov    0x4(%eax),%ebx
  183871:	89 59 04             	mov    %ebx,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
  183874:	8b 0c 24             	mov    (%esp),%ecx
  183877:	89 08                	mov    %ecx,(%eax)
	node->prev = list;
  183879:	89 60 04             	mov    %esp,0x4(%eax)

	list->head->prev = node;
  18387c:	8b 0c 24             	mov    (%esp),%ecx
  18387f:	89 41 04             	mov    %eax,0x4(%ecx)
	list->head = node;
  183882:	89 04 24             	mov    %eax,(%esp)
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
  183885:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
  18388c:	f6 c6 02             	test   $0x2,%dh
  18388f:	74 01                	je     183892 <_nano_sys_clock_tick_announce+0x8e>
  183891:	fb                   	sti    

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183892:	9c                   	pushf  
  183893:	fa                   	cli    
  183894:	5a                   	pop    %edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  183895:	a1 4c 01 28 00       	mov    0x28014c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  18389a:	3d 4c 01 28 00       	cmp    $0x28014c,%eax
  18389f:	75 05                	jne    1838a6 <_nano_sys_clock_tick_announce+0xa2>
  1838a1:	b8 00 00 00 00       	mov    $0x0,%eax
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
  1838a6:	85 c0                	test   %eax,%eax
  1838a8:	74 06                	je     1838b0 <_nano_sys_clock_tick_announce+0xac>
  1838aa:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  1838ae:	74 b5                	je     183865 <_nano_sys_clock_tick_announce+0x61>
  1838b0:	f6 c6 02             	test   $0x2,%dh
  1838b3:	74 01                	je     1838b6 <_nano_sys_clock_tick_announce+0xb2>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1838b5:	fb                   	sti    
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1838b6:	8b 14 24             	mov    (%esp),%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1838b9:	39 e2                	cmp    %esp,%edx
  1838bb:	75 05                	jne    1838c2 <_nano_sys_clock_tick_announce+0xbe>
  1838bd:	ba 00 00 00 00       	mov    $0x0,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1838c2:	85 d2                	test   %edx,%edx
  1838c4:	74 0d                	je     1838d3 <_nano_sys_clock_tick_announce+0xcf>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1838c6:	3b 54 24 04          	cmp    0x4(%esp),%edx
  1838ca:	74 0e                	je     1838da <_nano_sys_clock_tick_announce+0xd6>
  1838cc:	8b 1a                	mov    (%edx),%ebx
  1838ce:	e9 bd 00 00 00       	jmp    183990 <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1838d3:	89 d3                	mov    %edx,%ebx
  1838d5:	e9 b6 00 00 00       	jmp    183990 <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1838da:	bb 00 00 00 00       	mov    $0x0,%ebx
  1838df:	e9 ac 00 00 00       	jmp    183990 <_nano_sys_clock_tick_announce+0x18c>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1838e4:	8b 42 04             	mov    0x4(%edx),%eax
  1838e7:	8b 0a                	mov    (%edx),%ecx
  1838e9:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  1838eb:	8b 02                	mov    (%edx),%eax
  1838ed:	8b 4a 04             	mov    0x4(%edx),%ecx
  1838f0:	89 48 04             	mov    %ecx,0x4(%eax)
 * kept as -EAGAIN, set previously in _Swap().
 */

static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
  1838f3:	8b 42 08             	mov    0x8(%edx),%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1838f6:	9c                   	pushf  
  1838f7:	fa                   	cli    
  1838f8:	5f                   	pop    %edi
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
  1838f9:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	K_DEBUG("timeout %p\n", timeout);
	if (thread) {
  183900:	85 c0                	test   %eax,%eax
  183902:	74 5d                	je     183961 <_nano_sys_clock_tick_announce+0x15d>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
  183904:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  183908:	74 1a                	je     183924 <_nano_sys_clock_tick_announce+0x120>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18390a:	8b 50 04             	mov    0x4(%eax),%edx
  18390d:	8b 08                	mov    (%eax),%ecx
  18390f:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  183911:	8b 10                	mov    (%eax),%edx
  183913:	8b 48 04             	mov    0x4(%eax),%ecx
  183916:	89 4a 04             	mov    %ecx,0x4(%edx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  183919:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
  18391d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  183924:	8a 50 09             	mov    0x9(%eax),%dl
  183927:	88 d1                	mov    %dl,%cl
  183929:	83 e1 fb             	and    $0xfffffffb,%ecx
  18392c:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  18392f:	f6 c2 1b             	test   $0x1b,%dl
  183932:	75 0d                	jne    183941 <_nano_sys_clock_tick_announce+0x13d>
  183934:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  183938:	75 0e                	jne    183948 <_nano_sys_clock_tick_announce+0x144>
  18393a:	ba 01 00 00 00       	mov    $0x1,%edx
  18393f:	eb 0c                	jmp    18394d <_nano_sys_clock_tick_announce+0x149>
  183941:	ba 00 00 00 00       	mov    $0x0,%edx
  183946:	eb 05                	jmp    18394d <_nano_sys_clock_tick_announce+0x149>
  183948:	ba 00 00 00 00       	mov    $0x0,%edx
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  18394d:	85 d2                	test   %edx,%edx
  18394f:	74 05                	je     183956 <_nano_sys_clock_tick_announce+0x152>
		_add_thread_to_ready_q(thread);
  183951:	e8 71 f6 ff ff       	call   182fc7 <_add_thread_to_ready_q>
  183956:	f7 c7 00 02 00 00    	test   $0x200,%edi
  18395c:	74 17                	je     183975 <_nano_sys_clock_tick_announce+0x171>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18395e:	fb                   	sti    
  18395f:	eb 14                	jmp    183975 <_nano_sys_clock_tick_announce+0x171>
  183961:	f7 c7 00 02 00 00    	test   $0x200,%edi
  183967:	74 01                	je     18396a <_nano_sys_clock_tick_announce+0x166>
  183969:	fb                   	sti    
		_unpend_thread_timing_out(thread, timeout);
		_ready_thread(thread);
		irq_unlock(key);
	} else {
		irq_unlock(key);
		if (timeout->func) {
  18396a:	8b 4a 14             	mov    0x14(%edx),%ecx
  18396d:	85 c9                	test   %ecx,%ecx
  18396f:	74 04                	je     183975 <_nano_sys_clock_tick_announce+0x171>
			timeout->func(timeout);
  183971:	89 d0                	mov    %edx,%eax
  183973:	ff d1                	call   *%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183975:	85 db                	test   %ebx,%ebx
  183977:	74 0a                	je     183983 <_nano_sys_clock_tick_announce+0x17f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183979:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
  18397d:	74 08                	je     183987 <_nano_sys_clock_tick_announce+0x183>
  18397f:	8b 03                	mov    (%ebx),%eax
  183981:	eb 09                	jmp    18398c <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183983:	89 d8                	mov    %ebx,%eax
  183985:	eb 05                	jmp    18398c <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183987:	b8 00 00 00 00       	mov    $0x0,%eax

static inline void _handle_expired_timeouts(sys_dlist_t *expired)
{
	sys_dnode_t *timeout, *next;

	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
  18398c:	89 da                	mov    %ebx,%edx
  18398e:	89 c3                	mov    %eax,%ebx
  183990:	85 d2                	test   %edx,%edx
  183992:	0f 85 4c ff ff ff    	jne    1838e4 <_nano_sys_clock_tick_announce+0xe0>

	irq_unlock(key);

	_handle_expired_timeouts(&expired);

	_handling_timeouts = 0;
  183998:	c7 05 d0 02 28 00 00 	movl   $0x0,0x2802d0
  18399f:	00 00 00 
	irq_unlock(key);

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
  1839a2:	89 f0                	mov    %esi,%eax
  1839a4:	e8 00 fe ff ff       	call   1837a9 <handle_time_slicing>
}
  1839a9:	83 c4 08             	add    $0x8,%esp
  1839ac:	5b                   	pop    %ebx
  1839ad:	5e                   	pop    %esi
  1839ae:	5f                   	pop    %edi
  1839af:	c3                   	ret    

001839b0 <_k_thread_single_start>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1839b0:	8a 50 09             	mov    0x9(%eax),%dl
  1839b3:	88 d1                	mov    %dl,%cl
  1839b5:	83 e1 fb             	and    $0xfffffffb,%ecx
  1839b8:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1839bb:	f6 c2 1b             	test   $0x1b,%dl
  1839be:	75 0d                	jne    1839cd <_k_thread_single_start+0x1d>
  1839c0:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1839c4:	75 0e                	jne    1839d4 <_k_thread_single_start+0x24>
  1839c6:	ba 01 00 00 00       	mov    $0x1,%edx
  1839cb:	eb 0c                	jmp    1839d9 <_k_thread_single_start+0x29>
  1839cd:	ba 00 00 00 00       	mov    $0x0,%edx
  1839d2:	eb 05                	jmp    1839d9 <_k_thread_single_start+0x29>
  1839d4:	ba 00 00 00 00       	mov    $0x0,%edx

void _k_thread_single_start(struct k_thread *thread)
{
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  1839d9:	85 d2                	test   %edx,%edx
  1839db:	74 05                	je     1839e2 <_k_thread_single_start+0x32>
		_add_thread_to_ready_q(thread);
  1839dd:	e8 e5 f5 ff ff       	call   182fc7 <_add_thread_to_ready_q>
  1839e2:	c3                   	ret    

001839e3 <start_thread>:
	CODE_UNREACHABLE;
}

#ifdef CONFIG_MULTITHREADING
static void start_thread(struct k_thread *thread)
{
  1839e3:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1839e4:	9c                   	pushf  
  1839e5:	fa                   	cli    
  1839e6:	5b                   	pop    %ebx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1839e7:	8a 50 09             	mov    0x9(%eax),%dl
  1839ea:	88 d1                	mov    %dl,%cl
  1839ec:	83 e1 fb             	and    $0xfffffffb,%ecx
  1839ef:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1839f2:	f6 c2 1b             	test   $0x1b,%dl
  1839f5:	75 0d                	jne    183a04 <start_thread+0x21>
  1839f7:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1839fb:	75 0e                	jne    183a0b <start_thread+0x28>
  1839fd:	ba 01 00 00 00       	mov    $0x1,%edx
  183a02:	eb 0c                	jmp    183a10 <start_thread+0x2d>
  183a04:	ba 00 00 00 00       	mov    $0x0,%edx
  183a09:	eb 05                	jmp    183a10 <start_thread+0x2d>
  183a0b:	ba 00 00 00 00       	mov    $0x0,%edx
	int key = irq_lock(); /* protect kernel queues */

	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  183a10:	85 d2                	test   %edx,%edx
  183a12:	74 33                	je     183a47 <start_thread+0x64>
		_add_thread_to_ready_q(thread);
  183a14:	e8 ae f5 ff ff       	call   182fc7 <_add_thread_to_ready_q>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  183a19:	a1 48 01 28 00       	mov    0x280148,%eax
  183a1e:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  183a23:	77 10                	ja     183a35 <start_thread+0x52>
  183a25:	e8 d3 f7 ff ff       	call   1831fd <__must_switch_threads>
  183a2a:	85 c0                	test   %eax,%eax
  183a2c:	74 0c                	je     183a3a <start_thread+0x57>
  183a2e:	b8 01 00 00 00       	mov    $0x1,%eax
  183a33:	eb 05                	jmp    183a3a <start_thread+0x57>
  183a35:	b8 00 00 00 00       	mov    $0x0,%eax
		if (_must_switch_threads()) {
  183a3a:	85 c0                	test   %eax,%eax
  183a3c:	74 09                	je     183a47 <start_thread+0x64>
			_Swap(key);
  183a3e:	89 d8                	mov    %ebx,%eax
  183a40:	e8 9d f0 ff ff       	call   182ae2 <_Swap>
			return;
  183a45:	eb 06                	jmp    183a4d <start_thread+0x6a>
  183a47:	f6 c7 02             	test   $0x2,%bh
  183a4a:	74 01                	je     183a4d <start_thread+0x6a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183a4c:	fb                   	sti    
		}
	}

	irq_unlock(key);
}
  183a4d:	5b                   	pop    %ebx
  183a4e:	c3                   	ret    

00183a4f <schedule_new_thread>:
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
  183a4f:	57                   	push   %edi
  183a50:	56                   	push   %esi
  183a51:	53                   	push   %ebx
  183a52:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  183a54:	85 d2                	test   %edx,%edx
  183a56:	75 0a                	jne    183a62 <schedule_new_thread+0x13>
		start_thread(thread);
  183a58:	e8 86 ff ff ff       	call   1839e3 <start_thread>
  183a5d:	e9 18 01 00 00       	jmp    183b7a <schedule_new_thread+0x12b>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  183a62:	83 c2 09             	add    $0x9,%edx
  183a65:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  183a6a:	89 d0                	mov    %edx,%eax
  183a6c:	f7 e1                	mul    %ecx
  183a6e:	c1 ea 03             	shr    $0x3,%edx
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  183a71:	42                   	inc    %edx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183a72:	9c                   	pushf  
  183a73:	fa                   	cli    
  183a74:	5f                   	pop    %edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  183a75:	8d 46 10             	lea    0x10(%esi),%eax
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  183a78:	89 50 10             	mov    %edx,0x10(%eax)
	timeout->thread = thread;
  183a7b:	89 70 08             	mov    %esi,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  183a7e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  183a85:	8b 15 4c 01 28 00    	mov    0x28014c,%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  183a8b:	81 fa 4c 01 28 00    	cmp    $0x28014c,%edx
  183a91:	75 07                	jne    183a9a <schedule_new_thread+0x4b>
  183a93:	b9 00 00 00 00       	mov    $0x0,%ecx
  183a98:	eb 02                	jmp    183a9c <schedule_new_thread+0x4d>
  183a9a:	89 d1                	mov    %edx,%ecx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  183a9c:	85 c9                	test   %ecx,%ecx
  183a9e:	74 16                	je     183ab6 <schedule_new_thread+0x67>
  183aa0:	81 fa 4c 01 28 00    	cmp    $0x28014c,%edx
  183aa6:	0f 85 a0 00 00 00    	jne    183b4c <schedule_new_thread+0xfd>
  183aac:	ba 00 00 00 00       	mov    $0x0,%edx
  183ab1:	e9 96 00 00 00       	jmp    183b4c <schedule_new_thread+0xfd>
  183ab6:	ba 00 00 00 00       	mov    $0x0,%edx
  183abb:	e9 8c 00 00 00       	jmp    183b4c <schedule_new_thread+0xfd>
		if (*delta <= in_q->delta_ticks_from_prev) {
  183ac0:	8b 48 10             	mov    0x10(%eax),%ecx
  183ac3:	8b 5a 10             	mov    0x10(%edx),%ebx
  183ac6:	39 d9                	cmp    %ebx,%ecx
  183ac8:	7f 3b                	jg     183b05 <schedule_new_thread+0xb6>
			in_q->delta_ticks_from_prev -= *delta;
  183aca:	29 cb                	sub    %ecx,%ebx
  183acc:	89 5a 10             	mov    %ebx,0x10(%edx)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  183acf:	85 d2                	test   %edx,%edx
  183ad1:	75 1f                	jne    183af2 <schedule_new_thread+0xa3>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  183ad3:	c7 46 10 4c 01 28 00 	movl   $0x28014c,0x10(%esi)
	node->prev = list->tail;
  183ada:	8b 15 50 01 28 00    	mov    0x280150,%edx
  183ae0:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  183ae3:	8b 15 50 01 28 00    	mov    0x280150,%edx
  183ae9:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  183aeb:	a3 50 01 28 00       	mov    %eax,0x280150
  183af0:	eb 7f                	jmp    183b71 <schedule_new_thread+0x122>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  183af2:	8b 4a 04             	mov    0x4(%edx),%ecx
  183af5:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
  183af8:	89 56 10             	mov    %edx,0x10(%esi)
		insert_point->prev->next = node;
  183afb:	8b 4a 04             	mov    0x4(%edx),%ecx
  183afe:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
  183b00:	89 42 04             	mov    %eax,0x4(%edx)
  183b03:	eb 6c                	jmp    183b71 <schedule_new_thread+0x122>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  183b05:	29 d9                	sub    %ebx,%ecx
  183b07:	89 48 10             	mov    %ecx,0x10(%eax)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  183b0a:	89 d1                	mov    %edx,%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183b0c:	85 d2                	test   %edx,%edx
  183b0e:	74 0c                	je     183b1c <schedule_new_thread+0xcd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183b10:	3b 15 50 01 28 00    	cmp    0x280150,%edx
  183b16:	74 08                	je     183b20 <schedule_new_thread+0xd1>
  183b18:	8b 1a                	mov    (%edx),%ebx
  183b1a:	eb 09                	jmp    183b25 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183b1c:	89 d3                	mov    %edx,%ebx
  183b1e:	eb 05                	jmp    183b25 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183b20:	bb 00 00 00 00       	mov    $0x0,%ebx
  183b25:	85 db                	test   %ebx,%ebx
  183b27:	74 1e                	je     183b47 <schedule_new_thread+0xf8>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183b29:	85 c9                	test   %ecx,%ecx
  183b2b:	74 0c                	je     183b39 <schedule_new_thread+0xea>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183b2d:	3b 0d 50 01 28 00    	cmp    0x280150,%ecx
  183b33:	74 0b                	je     183b40 <schedule_new_thread+0xf1>
  183b35:	8b 12                	mov    (%edx),%edx
  183b37:	eb 13                	jmp    183b4c <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183b39:	ba 00 00 00 00       	mov    $0x0,%edx
  183b3e:	eb 0c                	jmp    183b4c <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183b40:	ba 00 00 00 00       	mov    $0x0,%edx
  183b45:	eb 05                	jmp    183b4c <schedule_new_thread+0xfd>
  183b47:	ba 00 00 00 00       	mov    $0x0,%edx
  183b4c:	85 d2                	test   %edx,%edx
  183b4e:	0f 85 6c ff ff ff    	jne    183ac0 <schedule_new_thread+0x71>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  183b54:	c7 46 10 4c 01 28 00 	movl   $0x28014c,0x10(%esi)
	node->prev = list->tail;
  183b5b:	8b 15 50 01 28 00    	mov    0x280150,%edx
  183b61:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  183b64:	8b 15 50 01 28 00    	mov    0x280150,%edx
  183b6a:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  183b6c:	a3 50 01 28 00       	mov    %eax,0x280150
  183b71:	f7 c7 00 02 00 00    	test   $0x200,%edi
  183b77:	74 01                	je     183b7a <schedule_new_thread+0x12b>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183b79:	fb                   	sti    
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  183b7a:	5b                   	pop    %ebx
  183b7b:	5e                   	pop    %esi
  183b7c:	5f                   	pop    %edi
  183b7d:	c3                   	ret    

00183b7e <k_is_in_isr>:
}
#endif

int k_is_in_isr(void)
{
	return _is_in_isr();
  183b7e:	83 3d 40 01 28 00 00 	cmpl   $0x0,0x280140
  183b85:	0f 95 c0             	setne  %al
  183b88:	0f b6 c0             	movzbl %al,%eax
}
  183b8b:	c3                   	ret    

00183b8c <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.user_options & K_ESSENTIAL;
  183b8c:	a1 48 01 28 00       	mov    0x280148,%eax
  183b91:	8a 40 08             	mov    0x8(%eax),%al
  183b94:	83 e0 01             	and    $0x1,%eax
}
  183b97:	c3                   	ret    

00183b98 <_thread_monitor_exit>:
#if defined(CONFIG_THREAD_MONITOR)
/*
 * Remove a thread from the kernel's list of active threads.
 */
void _thread_monitor_exit(struct k_thread *thread)
{
  183b98:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183b99:	9c                   	pushf  
  183b9a:	fa                   	cli    
  183b9b:	5b                   	pop    %ebx
	unsigned int key = irq_lock();

	if (thread == _kernel.threads) {
  183b9c:	8b 0d 5c 02 28 00    	mov    0x28025c,%ecx
  183ba2:	39 c1                	cmp    %eax,%ecx
  183ba4:	75 0c                	jne    183bb2 <_thread_monitor_exit+0x1a>
		_kernel.threads = _kernel.threads->next_thread;
  183ba6:	8b 41 38             	mov    0x38(%ecx),%eax
  183ba9:	a3 5c 02 28 00       	mov    %eax,0x28025c
  183bae:	eb 0f                	jmp    183bbf <_thread_monitor_exit+0x27>
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
			prev_thread = prev_thread->next_thread;
  183bb0:	89 d1                	mov    %edx,%ecx
		_kernel.threads = _kernel.threads->next_thread;
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
  183bb2:	8b 51 38             	mov    0x38(%ecx),%edx
  183bb5:	39 d0                	cmp    %edx,%eax
  183bb7:	75 f7                	jne    183bb0 <_thread_monitor_exit+0x18>
			prev_thread = prev_thread->next_thread;
		}
		prev_thread->next_thread = thread->next_thread;
  183bb9:	8b 40 38             	mov    0x38(%eax),%eax
  183bbc:	89 41 38             	mov    %eax,0x38(%ecx)
  183bbf:	f6 c7 02             	test   $0x2,%bh
  183bc2:	74 01                	je     183bc5 <_thread_monitor_exit+0x2d>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183bc4:	fb                   	sti    
	}

	irq_unlock(key);
}
  183bc5:	5b                   	pop    %ebx
  183bc6:	c3                   	ret    

00183bc7 <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
  183bc7:	53                   	push   %ebx
  183bc8:	89 c3                	mov    %eax,%ebx
  183bca:	89 d0                	mov    %edx,%eax
  183bcc:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
  183bce:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  183bd2:	ff d3                	call   *%ebx

#ifdef CONFIG_MULTITHREADING
	if (_is_thread_essential()) {
  183bd4:	e8 b3 ff ff ff       	call   183b8c <_is_thread_essential>
  183bd9:	85 c0                	test   %eax,%eax
  183bdb:	74 0f                	je     183bec <_thread_entry+0x25>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  183bdd:	ba a0 4e 18 00       	mov    $0x184ea0,%edx
  183be2:	b8 03 00 00 00       	mov    $0x3,%eax
  183be7:	e8 cb ef ff ff       	call   182bb7 <_NanoFatalErrorHandler>
				       &_default_esf);
	}

	k_thread_abort(_current);
  183bec:	a1 48 01 28 00       	mov    0x280148,%eax
  183bf1:	e8 e0 01 00 00       	call   183dd6 <k_thread_abort>

00183bf6 <_k_thread_group_op>:
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  183bf6:	55                   	push   %ebp
  183bf7:	57                   	push   %edi
  183bf8:	56                   	push   %esi
  183bf9:	53                   	push   %ebx
  183bfa:	89 c6                	mov    %eax,%esi
  183bfc:	89 d5                	mov    %edx,%ebp
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  183bfe:	8b 15 48 01 28 00    	mov    0x280148,%edx
  183c04:	8a 42 0b             	mov    0xb(%edx),%al
  183c07:	48                   	dec    %eax
  183c08:	88 42 0b             	mov    %al,0xb(%edx)

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  183c0b:	bb a4 00 28 00       	mov    $0x2800a4,%ebx
  183c10:	eb 18                	jmp    183c2a <_k_thread_group_op+0x34>
		if (is_in_any_group(thread_data, groups)) {
  183c12:	85 73 28             	test   %esi,0x28(%ebx)
  183c15:	74 10                	je     183c27 <_k_thread_group_op+0x31>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183c17:	9c                   	pushf  
  183c18:	fa                   	cli    
  183c19:	5f                   	pop    %edi
			key = irq_lock();
			func(thread_data->thread);
  183c1a:	8b 03                	mov    (%ebx),%eax
  183c1c:	ff d5                	call   *%ebp
  183c1e:	f7 c7 00 02 00 00    	test   $0x200,%edi
  183c24:	74 01                	je     183c27 <_k_thread_group_op+0x31>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183c26:	fb                   	sti    

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  183c27:	83 c3 2c             	add    $0x2c,%ebx
  183c2a:	81 fb a4 00 28 00    	cmp    $0x2800a4,%ebx
  183c30:	72 e0                	jb     183c12 <_k_thread_group_op+0x1c>

	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
  183c32:	a1 48 01 28 00       	mov    0x280148,%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  183c37:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  183c3b:	75 0d                	jne    183c4a <_k_thread_group_op+0x54>
  183c3d:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  183c41:	75 0e                	jne    183c51 <_k_thread_group_op+0x5b>
  183c43:	b8 01 00 00 00       	mov    $0x1,%eax
  183c48:	eb 0c                	jmp    183c56 <_k_thread_group_op+0x60>
  183c4a:	b8 00 00 00 00       	mov    $0x0,%eax
  183c4f:	eb 05                	jmp    183c56 <_k_thread_group_op+0x60>
  183c51:	b8 00 00 00 00       	mov    $0x0,%eax
  183c56:	85 c0                	test   %eax,%eax
  183c58:	74 07                	je     183c61 <_k_thread_group_op+0x6b>
		k_sched_unlock();
  183c5a:	e8 fa f5 ff ff       	call   183259 <k_sched_unlock>
		return;
  183c5f:	eb 15                	jmp    183c76 <_k_thread_group_op+0x80>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183c61:	9c                   	pushf  
  183c62:	fa                   	cli    
  183c63:	58                   	pop    %eax
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 0, "");

	compiler_barrier();

	++_current->base.sched_locked;
  183c64:	8b 0d 48 01 28 00    	mov    0x280148,%ecx
  183c6a:	8a 51 0b             	mov    0xb(%ecx),%dl
  183c6d:	42                   	inc    %edx
  183c6e:	88 51 0b             	mov    %dl,0xb(%ecx)
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  183c71:	e8 6c ee ff ff       	call   182ae2 <_Swap>
}
  183c76:	5b                   	pop    %ebx
  183c77:	5e                   	pop    %esi
  183c78:	5f                   	pop    %edi
  183c79:	5d                   	pop    %ebp
  183c7a:	c3                   	ret    

00183c7b <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  183c7b:	56                   	push   %esi
  183c7c:	53                   	push   %ebx
  183c7d:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
  183c7f:	8b 40 30             	mov    0x30(%eax),%eax
  183c82:	85 c0                	test   %eax,%eax
  183c84:	74 02                	je     183c88 <_k_thread_single_abort+0xd>
		thread->fn_abort();
  183c86:	ff d0                	call   *%eax
	return !(thread->base.thread_state & _THREAD_PRESTART);
}

static inline int _is_thread_prevented_from_running(struct k_thread *thread)
{
	uint8_t state = thread->base.thread_state;
  183c88:	8a 43 09             	mov    0x9(%ebx),%al
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  183c8b:	a8 1f                	test   $0x1f,%al
  183c8d:	75 0d                	jne    183c9c <_k_thread_single_abort+0x21>
  183c8f:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  183c93:	75 0e                	jne    183ca3 <_k_thread_single_abort+0x28>
  183c95:	ba 01 00 00 00       	mov    $0x1,%edx
  183c9a:	eb 0c                	jmp    183ca8 <_k_thread_single_abort+0x2d>
  183c9c:	ba 00 00 00 00       	mov    $0x0,%edx
  183ca1:	eb 05                	jmp    183ca8 <_k_thread_single_abort+0x2d>
  183ca3:	ba 00 00 00 00       	mov    $0x0,%edx
	}

	if (_is_thread_ready(thread)) {
  183ca8:	85 d2                	test   %edx,%edx
  183caa:	74 09                	je     183cb5 <_k_thread_single_abort+0x3a>
		_remove_thread_from_ready_q(thread);
  183cac:	89 d8                	mov    %ebx,%eax
  183cae:	e8 62 f3 ff ff       	call   183015 <_remove_thread_from_ready_q>
  183cb3:	eb 61                	jmp    183d16 <_k_thread_single_abort+0x9b>
	} else {
		if (_is_thread_pending(thread)) {
  183cb5:	a8 02                	test   $0x2,%al
  183cb7:	74 13                	je     183ccc <_k_thread_single_abort+0x51>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  183cb9:	8b 43 04             	mov    0x4(%ebx),%eax
  183cbc:	8b 13                	mov    (%ebx),%edx
  183cbe:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  183cc0:	8b 03                	mov    (%ebx),%eax
  183cc2:	8b 53 04             	mov    0x4(%ebx),%edx
  183cc5:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  183cc8:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  183ccc:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  183cd0:	74 44                	je     183d16 <_k_thread_single_abort+0x9b>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  183cd2:	8d 43 10             	lea    0x10(%ebx),%eax
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  183cd5:	8b 48 10             	mov    0x10(%eax),%ecx
  183cd8:	83 f9 ff             	cmp    $0xffffffff,%ecx
  183cdb:	74 39                	je     183d16 <_k_thread_single_abort+0x9b>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  183cdd:	89 c2                	mov    %eax,%edx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  183cdf:	8b 35 50 01 28 00    	mov    0x280150,%esi
  183ce5:	39 f0                	cmp    %esi,%eax
  183ce7:	74 15                	je     183cfe <_k_thread_single_abort+0x83>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183ce9:	85 c0                	test   %eax,%eax
  183ceb:	74 0e                	je     183cfb <_k_thread_single_abort+0x80>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  183ced:	39 f0                	cmp    %esi,%eax
  183cef:	74 05                	je     183cf6 <_k_thread_single_abort+0x7b>
  183cf1:	8b 53 10             	mov    0x10(%ebx),%edx
  183cf4:	eb 05                	jmp    183cfb <_k_thread_single_abort+0x80>
  183cf6:	ba 00 00 00 00       	mov    $0x0,%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  183cfb:	01 4a 10             	add    %ecx,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  183cfe:	8b 50 04             	mov    0x4(%eax),%edx
  183d01:	8b 4b 10             	mov    0x10(%ebx),%ecx
  183d04:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  183d06:	8b 53 10             	mov    0x10(%ebx),%edx
  183d09:	8b 48 04             	mov    0x4(%eax),%ecx
  183d0c:	89 4a 04             	mov    %ecx,0x4(%edx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  183d0f:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_DEAD;
  183d16:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  183d1a:	5b                   	pop    %ebx
  183d1b:	5e                   	pop    %esi
  183d1c:	c3                   	ret    

00183d1d <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
  183d1d:	56                   	push   %esi
  183d1e:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  183d1f:	bb a4 00 28 00       	mov    $0x2800a4,%ebx
  183d24:	eb 27                	jmp    183d4d <_init_static_threads+0x30>
		_task_group_adjust(thread_data);
		_new_thread(
  183d26:	8b 4b 08             	mov    0x8(%ebx),%ecx
  183d29:	8b 53 04             	mov    0x4(%ebx),%edx
  183d2c:	ff 73 1c             	pushl  0x1c(%ebx)
  183d2f:	ff 73 18             	pushl  0x18(%ebx)
  183d32:	ff 73 14             	pushl  0x14(%ebx)
  183d35:	ff 73 10             	pushl  0x10(%ebx)
  183d38:	ff 73 0c             	pushl  0xc(%ebx)
  183d3b:	8b 03                	mov    (%ebx),%eax
  183d3d:	e8 2f ee ff ff       	call   182b71 <_new_thread>
  183d42:	83 c4 14             	add    $0x14,%esp
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  183d45:	8b 03                	mov    (%ebx),%eax
  183d47:	89 58 2c             	mov    %ebx,0x2c(%eax)
#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  183d4a:	83 c3 2c             	add    $0x2c,%ebx
  183d4d:	81 fb a4 00 28 00    	cmp    $0x2800a4,%ebx
  183d53:	72 d1                	jb     183d26 <_init_static_threads+0x9>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  183d55:	8b 15 48 01 28 00    	mov    0x280148,%edx
  183d5b:	8a 42 0b             	mov    0xb(%edx),%al
  183d5e:	48                   	dec    %eax
  183d5f:	88 42 0b             	mov    %al,0xb(%edx)
	}

	_sched_lock();
#if defined(CONFIG_LEGACY_KERNEL)
	/* Start all (legacy) threads that are part of the EXE task group */
	_k_thread_group_op(K_TASK_GROUP_EXE, _k_thread_single_start);
  183d62:	ba b0 39 18 00       	mov    $0x1839b0,%edx
  183d67:	b8 01 00 00 00       	mov    $0x1,%eax
  183d6c:	e8 85 fe ff ff       	call   183bf6 <_k_thread_group_op>
  183d71:	9c                   	pushf  
  183d72:	fa                   	cli    
  183d73:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  183d74:	bb a4 00 28 00       	mov    $0x2800a4,%ebx
  183d79:	eb 12                	jmp    183d8d <_init_static_threads+0x70>
		if (thread_data->init_delay != K_FOREVER) {
  183d7b:	8b 53 20             	mov    0x20(%ebx),%edx
  183d7e:	83 fa ff             	cmp    $0xffffffff,%edx
  183d81:	74 07                	je     183d8a <_init_static_threads+0x6d>
			schedule_new_thread(thread_data->thread,
  183d83:	8b 03                	mov    (%ebx),%eax
  183d85:	e8 c5 fc ff ff       	call   183a4f <schedule_new_thread>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  183d8a:	83 c3 2c             	add    $0x2c,%ebx
  183d8d:	81 fb a4 00 28 00    	cmp    $0x2800a4,%ebx
  183d93:	72 e6                	jb     183d7b <_init_static_threads+0x5e>
  183d95:	f7 c6 00 02 00 00    	test   $0x200,%esi
  183d9b:	74 01                	je     183d9e <_init_static_threads+0x81>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183d9d:	fb                   	sti    
			schedule_new_thread(thread_data->thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
  183d9e:	e8 b6 f4 ff ff       	call   183259 <k_sched_unlock>
}
  183da3:	5b                   	pop    %ebx
  183da4:	5e                   	pop    %esi
  183da5:	c3                   	ret    

00183da6 <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  183da6:	53                   	push   %ebx
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
  183da7:	8a 5c 24 08          	mov    0x8(%esp),%bl
  183dab:	88 58 08             	mov    %bl,0x8(%eax)
	thread_base->thread_state = (uint8_t)initial_state;
  183dae:	88 48 09             	mov    %cl,0x9(%eax)

	thread_base->prio = priority;
  183db1:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
  183db4:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
  183db8:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  183dbf:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  183dc6:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  183dcd:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  183dd4:	5b                   	pop    %ebx
  183dd5:	c3                   	ret    

00183dd6 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
  183dd6:	56                   	push   %esi
  183dd7:	53                   	push   %ebx
  183dd8:	89 c3                	mov    %eax,%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183dda:	9c                   	pushf  
  183ddb:	fa                   	cli    
  183ddc:	5e                   	pop    %esi
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  183ddd:	e8 99 fe ff ff       	call   183c7b <_k_thread_single_abort>
	_thread_monitor_exit(thread);
  183de2:	89 d8                	mov    %ebx,%eax
  183de4:	e8 af fd ff ff       	call   183b98 <_thread_monitor_exit>

	if (_current == thread) {
  183de9:	3b 1d 48 01 28 00    	cmp    0x280148,%ebx
  183def:	75 07                	jne    183df8 <k_thread_abort+0x22>
		_Swap(key);
  183df1:	89 f0                	mov    %esi,%eax
  183df3:	e8 ea ec ff ff       	call   182ae2 <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  183df8:	89 f0                	mov    %esi,%eax
  183dfa:	e8 21 f4 ff ff       	call   183220 <_reschedule_threads>
}
  183dff:	5b                   	pop    %ebx
  183e00:	5e                   	pop    %esi
  183e01:	c3                   	ret    

00183e02 <_sys_power_save_idle>:
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
  183e02:	e8 8a eb ff ff       	call   182991 <k_cpu_idle>
  183e07:	c3                   	ret    

00183e08 <idle>:
  183e08:	9c                   	pushf  
  183e09:	fa                   	cli    
  183e0a:	58                   	pop    %eax
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  183e0b:	a1 4c 01 28 00       	mov    0x28014c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  183e10:	3d 4c 01 28 00       	cmp    $0x28014c,%eax
  183e15:	75 05                	jne    183e1c <idle+0x14>
  183e17:	b8 00 00 00 00       	mov    $0x0,%eax
static inline int32_t _get_next_timeout_expiry(void)
{
	struct _timeout *t = (struct _timeout *)
			     sys_dlist_peek_head(&_timeout_q);

	return t ? t->delta_ticks_from_prev : K_FOREVER;
  183e1c:	85 c0                	test   %eax,%eax
  183e1e:	74 05                	je     183e25 <idle+0x1d>
  183e20:	8b 40 10             	mov    0x10(%eax),%eax
  183e23:	eb 05                	jmp    183e2a <idle+0x22>
  183e25:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	__idle_tsc = _tsc_read();
#endif

	for (;;) {
		(void)irq_lock();
		_sys_power_save_idle(_get_next_timeout_expiry());
  183e2a:	e8 d3 ff ff ff       	call   183e02 <_sys_power_save_idle>

		IDLE_YIELD_IF_COOP();
	}
  183e2f:	eb d7                	jmp    183e08 <idle>

00183e31 <_OffsetAbsSyms>:
/* tTaskStateSegment structure member offsets */


/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));
  183e31:	c3                   	ret    

00183e32 <__addsf3>:
  183e32:	55                   	push   %ebp
  183e33:	89 d1                	mov    %edx,%ecx
  183e35:	c1 e9 17             	shr    $0x17,%ecx
  183e38:	57                   	push   %edi
  183e39:	89 c7                	mov    %eax,%edi
  183e3b:	56                   	push   %esi
  183e3c:	53                   	push   %ebx
  183e3d:	89 c3                	mov    %eax,%ebx
  183e3f:	c1 e8 17             	shr    $0x17,%eax
  183e42:	89 d6                	mov    %edx,%esi
  183e44:	0f b6 c0             	movzbl %al,%eax
  183e47:	81 e3 ff ff 7f 00    	and    $0x7fffff,%ebx
  183e4d:	81 e6 ff ff 7f 00    	and    $0x7fffff,%esi
  183e53:	0f b6 e9             	movzbl %cl,%ebp
  183e56:	c1 ef 1f             	shr    $0x1f,%edi
  183e59:	89 c1                	mov    %eax,%ecx
  183e5b:	c1 ea 1f             	shr    $0x1f,%edx
  183e5e:	29 e9                	sub    %ebp,%ecx
  183e60:	c1 e3 03             	shl    $0x3,%ebx
  183e63:	c1 e6 03             	shl    $0x3,%esi
  183e66:	39 d7                	cmp    %edx,%edi
  183e68:	0f 85 6c 01 00 00    	jne    183fda <__addsf3+0x1a8>
  183e6e:	83 f9 00             	cmp    $0x0,%ecx
  183e71:	7e 3c                	jle    183eaf <__addsf3+0x7d>
  183e73:	85 ed                	test   %ebp,%ebp
  183e75:	75 22                	jne    183e99 <__addsf3+0x67>
  183e77:	85 f6                	test   %esi,%esi
  183e79:	0f 84 60 03 00 00    	je     1841df <__addsf3+0x3ad>
  183e7f:	49                   	dec    %ecx
  183e80:	75 07                	jne    183e89 <__addsf3+0x57>
  183e82:	01 f3                	add    %esi,%ebx
  183e84:	e9 25 01 00 00       	jmp    183fae <__addsf3+0x17c>
  183e89:	3d ff 00 00 00       	cmp    $0xff,%eax
  183e8e:	0f 85 f6 00 00 00    	jne    183f8a <__addsf3+0x158>
  183e94:	e9 46 03 00 00       	jmp    1841df <__addsf3+0x3ad>
  183e99:	81 ce 00 00 00 04    	or     $0x4000000,%esi
  183e9f:	3d ff 00 00 00       	cmp    $0xff,%eax
  183ea4:	0f 85 e0 00 00 00    	jne    183f8a <__addsf3+0x158>
  183eaa:	e9 30 03 00 00       	jmp    1841df <__addsf3+0x3ad>
  183eaf:	74 5d                	je     183f0e <__addsf3+0xdc>
  183eb1:	85 c0                	test   %eax,%eax
  183eb3:	75 1a                	jne    183ecf <__addsf3+0x9d>
  183eb5:	85 db                	test   %ebx,%ebx
  183eb7:	0f 84 d8 02 00 00    	je     184195 <__addsf3+0x363>
  183ebd:	83 f1 ff             	xor    $0xffffffff,%ecx
  183ec0:	74 43                	je     183f05 <__addsf3+0xd3>
  183ec2:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  183ec8:	75 19                	jne    183ee3 <__addsf3+0xb1>
  183eca:	e9 d0 02 00 00       	jmp    18419f <__addsf3+0x36d>
  183ecf:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  183ed5:	0f 84 c4 02 00 00    	je     18419f <__addsf3+0x36d>
  183edb:	f7 d9                	neg    %ecx
  183edd:	81 cb 00 00 00 04    	or     $0x4000000,%ebx
  183ee3:	83 f9 1b             	cmp    $0x1b,%ecx
  183ee6:	0f 8f 33 03 00 00    	jg     18421f <__addsf3+0x3ed>
  183eec:	b8 20 00 00 00       	mov    $0x20,%eax
  183ef1:	89 da                	mov    %ebx,%edx
  183ef3:	29 c8                	sub    %ecx,%eax
  183ef5:	d3 ea                	shr    %cl,%edx
  183ef7:	89 c1                	mov    %eax,%ecx
  183ef9:	d3 e3                	shl    %cl,%ebx
  183efb:	85 db                	test   %ebx,%ebx
  183efd:	0f 95 c3             	setne  %bl
  183f00:	0f b6 db             	movzbl %bl,%ebx
  183f03:	09 d3                	or     %edx,%ebx
  183f05:	01 f3                	add    %esi,%ebx
  183f07:	89 e8                	mov    %ebp,%eax
  183f09:	e9 a0 00 00 00       	jmp    183fae <__addsf3+0x17c>
  183f0e:	8d 50 01             	lea    0x1(%eax),%edx
  183f11:	0f b6 ca             	movzbl %dl,%ecx
  183f14:	49                   	dec    %ecx
  183f15:	7f 5c                	jg     183f73 <__addsf3+0x141>
  183f17:	85 c0                	test   %eax,%eax
  183f19:	75 2e                	jne    183f49 <__addsf3+0x117>
  183f1b:	85 db                	test   %ebx,%ebx
  183f1d:	0f 84 78 02 00 00    	je     18419b <__addsf3+0x369>
  183f23:	85 f6                	test   %esi,%esi
  183f25:	0f 84 b4 02 00 00    	je     1841df <__addsf3+0x3ad>
  183f2b:	01 f3                	add    %esi,%ebx
  183f2d:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  183f33:	0f 84 a6 02 00 00    	je     1841df <__addsf3+0x3ad>
  183f39:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  183f3f:	b8 01 00 00 00       	mov    $0x1,%eax
  183f44:	e9 96 02 00 00       	jmp    1841df <__addsf3+0x3ad>
  183f49:	85 db                	test   %ebx,%ebx
  183f4b:	0f 84 4e 02 00 00    	je     18419f <__addsf3+0x36d>
  183f51:	b8 ff 00 00 00       	mov    $0xff,%eax
  183f56:	85 f6                	test   %esi,%esi
  183f58:	0f 84 81 02 00 00    	je     1841df <__addsf3+0x3ad>
  183f5e:	c1 ee 03             	shr    $0x3,%esi
  183f61:	c1 eb 03             	shr    $0x3,%ebx
  183f64:	39 f3                	cmp    %esi,%ebx
  183f66:	0f 83 94 01 00 00    	jae    184100 <__addsf3+0x2ce>
  183f6c:	89 f3                	mov    %esi,%ebx
  183f6e:	e9 8d 01 00 00       	jmp    184100 <__addsf3+0x2ce>
  183f73:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  183f79:	0f 84 27 02 00 00    	je     1841a6 <__addsf3+0x374>
  183f7f:	01 f3                	add    %esi,%ebx
  183f81:	89 d0                	mov    %edx,%eax
  183f83:	d1 eb                	shr    %ebx
  183f85:	e9 55 02 00 00       	jmp    1841df <__addsf3+0x3ad>
  183f8a:	ba 01 00 00 00       	mov    $0x1,%edx
  183f8f:	83 f9 1b             	cmp    $0x1b,%ecx
  183f92:	7f 18                	jg     183fac <__addsf3+0x17a>
  183f94:	bd 20 00 00 00       	mov    $0x20,%ebp
  183f99:	89 f2                	mov    %esi,%edx
  183f9b:	29 cd                	sub    %ecx,%ebp
  183f9d:	d3 ea                	shr    %cl,%edx
  183f9f:	89 e9                	mov    %ebp,%ecx
  183fa1:	d3 e6                	shl    %cl,%esi
  183fa3:	31 c9                	xor    %ecx,%ecx
  183fa5:	85 f6                	test   %esi,%esi
  183fa7:	0f 95 c1             	setne  %cl
  183faa:	09 ca                	or     %ecx,%edx
  183fac:	01 d3                	add    %edx,%ebx
  183fae:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  183fb4:	0f 84 25 02 00 00    	je     1841df <__addsf3+0x3ad>
  183fba:	40                   	inc    %eax
  183fbb:	3d ff 00 00 00       	cmp    $0xff,%eax
  183fc0:	0f 84 e5 01 00 00    	je     1841ab <__addsf3+0x379>
  183fc6:	89 da                	mov    %ebx,%edx
  183fc8:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  183fce:	d1 eb                	shr    %ebx
  183fd0:	83 e2 01             	and    $0x1,%edx
  183fd3:	09 d3                	or     %edx,%ebx
  183fd5:	e9 05 02 00 00       	jmp    1841df <__addsf3+0x3ad>
  183fda:	83 f9 00             	cmp    $0x0,%ecx
  183fdd:	7e 3c                	jle    18401b <__addsf3+0x1e9>
  183fdf:	85 ed                	test   %ebp,%ebp
  183fe1:	75 22                	jne    184005 <__addsf3+0x1d3>
  183fe3:	85 f6                	test   %esi,%esi
  183fe5:	0f 84 f4 01 00 00    	je     1841df <__addsf3+0x3ad>
  183feb:	49                   	dec    %ecx
  183fec:	75 07                	jne    183ff5 <__addsf3+0x1c3>
  183fee:	29 f3                	sub    %esi,%ebx
  183ff0:	e9 52 01 00 00       	jmp    184147 <__addsf3+0x315>
  183ff5:	3d ff 00 00 00       	cmp    $0xff,%eax
  183ffa:	0f 85 23 01 00 00    	jne    184123 <__addsf3+0x2f1>
  184000:	e9 da 01 00 00       	jmp    1841df <__addsf3+0x3ad>
  184005:	81 ce 00 00 00 04    	or     $0x4000000,%esi
  18400b:	3d ff 00 00 00       	cmp    $0xff,%eax
  184010:	0f 85 0d 01 00 00    	jne    184123 <__addsf3+0x2f1>
  184016:	e9 c4 01 00 00       	jmp    1841df <__addsf3+0x3ad>
  18401b:	74 65                	je     184082 <__addsf3+0x250>
  18401d:	85 c0                	test   %eax,%eax
  18401f:	75 1e                	jne    18403f <__addsf3+0x20d>
  184021:	85 db                	test   %ebx,%ebx
  184023:	0f 84 86 01 00 00    	je     1841af <__addsf3+0x37d>
  184029:	83 f1 ff             	xor    $0xffffffff,%ecx
  18402c:	75 04                	jne    184032 <__addsf3+0x200>
  18402e:	29 de                	sub    %ebx,%esi
  184030:	eb 45                	jmp    184077 <__addsf3+0x245>
  184032:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  184038:	75 19                	jne    184053 <__addsf3+0x221>
  18403a:	e9 79 01 00 00       	jmp    1841b8 <__addsf3+0x386>
  18403f:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  184045:	0f 84 6d 01 00 00    	je     1841b8 <__addsf3+0x386>
  18404b:	f7 d9                	neg    %ecx
  18404d:	81 cb 00 00 00 04    	or     $0x4000000,%ebx
  184053:	b8 01 00 00 00       	mov    $0x1,%eax
  184058:	83 f9 1b             	cmp    $0x1b,%ecx
  18405b:	7f 18                	jg     184075 <__addsf3+0x243>
  18405d:	b8 20 00 00 00       	mov    $0x20,%eax
  184062:	89 df                	mov    %ebx,%edi
  184064:	29 c8                	sub    %ecx,%eax
  184066:	d3 ef                	shr    %cl,%edi
  184068:	89 c1                	mov    %eax,%ecx
  18406a:	31 c0                	xor    %eax,%eax
  18406c:	d3 e3                	shl    %cl,%ebx
  18406e:	85 db                	test   %ebx,%ebx
  184070:	0f 95 c0             	setne  %al
  184073:	09 f8                	or     %edi,%eax
  184075:	29 c6                	sub    %eax,%esi
  184077:	89 f3                	mov    %esi,%ebx
  184079:	89 e8                	mov    %ebp,%eax
  18407b:	89 d7                	mov    %edx,%edi
  18407d:	e9 c5 00 00 00       	jmp    184147 <__addsf3+0x315>
  184082:	8d 48 01             	lea    0x1(%eax),%ecx
  184085:	0f b6 c9             	movzbl %cl,%ecx
  184088:	49                   	dec    %ecx
  184089:	7f 7a                	jg     184105 <__addsf3+0x2d3>
  18408b:	85 c0                	test   %eax,%eax
  18408d:	75 3c                	jne    1840cb <__addsf3+0x299>
  18408f:	85 db                	test   %ebx,%ebx
  184091:	75 0a                	jne    18409d <__addsf3+0x26b>
  184093:	85 f6                	test   %esi,%esi
  184095:	0f 84 29 01 00 00    	je     1841c4 <__addsf3+0x392>
  18409b:	eb 16                	jmp    1840b3 <__addsf3+0x281>
  18409d:	85 f6                	test   %esi,%esi
  18409f:	0f 84 3a 01 00 00    	je     1841df <__addsf3+0x3ad>
  1840a5:	89 d9                	mov    %ebx,%ecx
  1840a7:	29 f1                	sub    %esi,%ecx
  1840a9:	f7 c1 00 00 00 04    	test   $0x4000000,%ecx
  1840af:	74 0b                	je     1840bc <__addsf3+0x28a>
  1840b1:	29 de                	sub    %ebx,%esi
  1840b3:	89 f3                	mov    %esi,%ebx
  1840b5:	89 d7                	mov    %edx,%edi
  1840b7:	e9 23 01 00 00       	jmp    1841df <__addsf3+0x3ad>
  1840bc:	89 cb                	mov    %ecx,%ebx
  1840be:	85 c9                	test   %ecx,%ecx
  1840c0:	0f 85 19 01 00 00    	jne    1841df <__addsf3+0x3ad>
  1840c6:	e9 12 01 00 00       	jmp    1841dd <__addsf3+0x3ab>
  1840cb:	85 db                	test   %ebx,%ebx
  1840cd:	75 16                	jne    1840e5 <__addsf3+0x2b3>
  1840cf:	85 f6                	test   %esi,%esi
  1840d1:	0f 84 f1 00 00 00    	je     1841c8 <__addsf3+0x396>
  1840d7:	89 f3                	mov    %esi,%ebx
  1840d9:	89 d7                	mov    %edx,%edi
  1840db:	b8 ff 00 00 00       	mov    $0xff,%eax
  1840e0:	e9 fa 00 00 00       	jmp    1841df <__addsf3+0x3ad>
  1840e5:	b8 ff 00 00 00       	mov    $0xff,%eax
  1840ea:	85 f6                	test   %esi,%esi
  1840ec:	0f 84 ed 00 00 00    	je     1841df <__addsf3+0x3ad>
  1840f2:	c1 eb 03             	shr    $0x3,%ebx
  1840f5:	c1 ee 03             	shr    $0x3,%esi
  1840f8:	39 f3                	cmp    %esi,%ebx
  1840fa:	73 04                	jae    184100 <__addsf3+0x2ce>
  1840fc:	89 f3                	mov    %esi,%ebx
  1840fe:	89 d7                	mov    %edx,%edi
  184100:	c1 e3 03             	shl    $0x3,%ebx
  184103:	eb d6                	jmp    1840db <__addsf3+0x2a9>
  184105:	89 dd                	mov    %ebx,%ebp
  184107:	29 f5                	sub    %esi,%ebp
  184109:	f7 c5 00 00 00 04    	test   $0x4000000,%ebp
  18410f:	74 08                	je     184119 <__addsf3+0x2e7>
  184111:	29 de                	sub    %ebx,%esi
  184113:	89 d7                	mov    %edx,%edi
  184115:	89 f5                	mov    %esi,%ebp
  184117:	eb 42                	jmp    18415b <__addsf3+0x329>
  184119:	85 ed                	test   %ebp,%ebp
  18411b:	0f 84 b8 00 00 00    	je     1841d9 <__addsf3+0x3a7>
  184121:	eb 38                	jmp    18415b <__addsf3+0x329>
  184123:	ba 01 00 00 00       	mov    $0x1,%edx
  184128:	83 f9 1b             	cmp    $0x1b,%ecx
  18412b:	7f 18                	jg     184145 <__addsf3+0x313>
  18412d:	bd 20 00 00 00       	mov    $0x20,%ebp
  184132:	89 f2                	mov    %esi,%edx
  184134:	29 cd                	sub    %ecx,%ebp
  184136:	d3 ea                	shr    %cl,%edx
  184138:	89 e9                	mov    %ebp,%ecx
  18413a:	d3 e6                	shl    %cl,%esi
  18413c:	31 c9                	xor    %ecx,%ecx
  18413e:	85 f6                	test   %esi,%esi
  184140:	0f 95 c1             	setne  %cl
  184143:	09 ca                	or     %ecx,%edx
  184145:	29 d3                	sub    %edx,%ebx
  184147:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  18414d:	0f 84 8c 00 00 00    	je     1841df <__addsf3+0x3ad>
  184153:	81 e3 ff ff ff 03    	and    $0x3ffffff,%ebx
  184159:	89 dd                	mov    %ebx,%ebp
  18415b:	0f bd cd             	bsr    %ebp,%ecx
  18415e:	83 f1 1f             	xor    $0x1f,%ecx
  184161:	83 e9 05             	sub    $0x5,%ecx
  184164:	d3 e5                	shl    %cl,%ebp
  184166:	39 c8                	cmp    %ecx,%eax
  184168:	7f 1f                	jg     184189 <__addsf3+0x357>
  18416a:	29 c1                	sub    %eax,%ecx
  18416c:	ba 20 00 00 00       	mov    $0x20,%edx
  184171:	41                   	inc    %ecx
  184172:	89 e8                	mov    %ebp,%eax
  184174:	29 ca                	sub    %ecx,%edx
  184176:	31 db                	xor    %ebx,%ebx
  184178:	d3 e8                	shr    %cl,%eax
  18417a:	89 d1                	mov    %edx,%ecx
  18417c:	d3 e5                	shl    %cl,%ebp
  18417e:	85 ed                	test   %ebp,%ebp
  184180:	0f 95 c3             	setne  %bl
  184183:	09 c3                	or     %eax,%ebx
  184185:	31 c0                	xor    %eax,%eax
  184187:	eb 56                	jmp    1841df <__addsf3+0x3ad>
  184189:	89 eb                	mov    %ebp,%ebx
  18418b:	29 c8                	sub    %ecx,%eax
  18418d:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  184193:	eb 4a                	jmp    1841df <__addsf3+0x3ad>
  184195:	89 f3                	mov    %esi,%ebx
  184197:	89 e8                	mov    %ebp,%eax
  184199:	eb 44                	jmp    1841df <__addsf3+0x3ad>
  18419b:	89 f3                	mov    %esi,%ebx
  18419d:	eb 40                	jmp    1841df <__addsf3+0x3ad>
  18419f:	89 f3                	mov    %esi,%ebx
  1841a1:	e9 35 ff ff ff       	jmp    1840db <__addsf3+0x2a9>
  1841a6:	b8 ff 00 00 00       	mov    $0xff,%eax
  1841ab:	31 db                	xor    %ebx,%ebx
  1841ad:	eb 30                	jmp    1841df <__addsf3+0x3ad>
  1841af:	89 f3                	mov    %esi,%ebx
  1841b1:	89 e8                	mov    %ebp,%eax
  1841b3:	e9 fd fe ff ff       	jmp    1840b5 <__addsf3+0x283>
  1841b8:	89 f3                	mov    %esi,%ebx
  1841ba:	b8 ff 00 00 00       	mov    $0xff,%eax
  1841bf:	e9 f1 fe ff ff       	jmp    1840b5 <__addsf3+0x283>
  1841c4:	89 c3                	mov    %eax,%ebx
  1841c6:	eb 15                	jmp    1841dd <__addsf3+0x3ab>
  1841c8:	bb 00 00 00 02       	mov    $0x2000000,%ebx
  1841cd:	b8 ff 00 00 00       	mov    $0xff,%eax
  1841d2:	bf 01 00 00 00       	mov    $0x1,%edi
  1841d7:	eb 06                	jmp    1841df <__addsf3+0x3ad>
  1841d9:	31 db                	xor    %ebx,%ebx
  1841db:	31 c0                	xor    %eax,%eax
  1841dd:	31 ff                	xor    %edi,%edi
  1841df:	f6 c3 07             	test   $0x7,%bl
  1841e2:	74 0d                	je     1841f1 <__addsf3+0x3bf>
  1841e4:	89 da                	mov    %ebx,%edx
  1841e6:	83 e2 0f             	and    $0xf,%edx
  1841e9:	83 fa 04             	cmp    $0x4,%edx
  1841ec:	74 03                	je     1841f1 <__addsf3+0x3bf>
  1841ee:	83 c3 04             	add    $0x4,%ebx
  1841f1:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  1841f7:	74 10                	je     184209 <__addsf3+0x3d7>
  1841f9:	40                   	inc    %eax
  1841fa:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  184200:	3d ff 00 00 00       	cmp    $0xff,%eax
  184205:	75 02                	jne    184209 <__addsf3+0x3d7>
  184207:	31 db                	xor    %ebx,%ebx
  184209:	c1 eb 03             	shr    $0x3,%ebx
  18420c:	3d ff 00 00 00       	cmp    $0xff,%eax
  184211:	75 16                	jne    184229 <__addsf3+0x3f7>
  184213:	85 db                	test   %ebx,%ebx
  184215:	74 12                	je     184229 <__addsf3+0x3f7>
  184217:	81 cb 00 00 40 00    	or     $0x400000,%ebx
  18421d:	eb 0a                	jmp    184229 <__addsf3+0x3f7>
  18421f:	bb 01 00 00 00       	mov    $0x1,%ebx
  184224:	e9 dc fc ff ff       	jmp    183f05 <__addsf3+0xd3>
  184229:	0f b6 c0             	movzbl %al,%eax
  18422c:	c1 e0 17             	shl    $0x17,%eax
  18422f:	81 e3 ff ff 7f 00    	and    $0x7fffff,%ebx
  184235:	c1 e7 1f             	shl    $0x1f,%edi
  184238:	09 c3                	or     %eax,%ebx
  18423a:	89 d8                	mov    %ebx,%eax
  18423c:	5b                   	pop    %ebx
  18423d:	09 f8                	or     %edi,%eax
  18423f:	5e                   	pop    %esi
  184240:	5f                   	pop    %edi
  184241:	5d                   	pop    %ebp
  184242:	c3                   	ret    

00184243 <__mulsf3>:
  184243:	55                   	push   %ebp
  184244:	57                   	push   %edi
  184245:	56                   	push   %esi
  184246:	53                   	push   %ebx
  184247:	83 ec 10             	sub    $0x10,%esp
  18424a:	89 c1                	mov    %eax,%ecx
  18424c:	c1 e9 1f             	shr    $0x1f,%ecx
  18424f:	89 c3                	mov    %eax,%ebx
  184251:	89 0c 24             	mov    %ecx,(%esp)
  184254:	81 e3 ff ff 7f 00    	and    $0x7fffff,%ebx
  18425a:	0f b6 3c 24          	movzbl (%esp),%edi
  18425e:	c1 e8 17             	shr    $0x17,%eax
  184261:	89 7c 24 04          	mov    %edi,0x4(%esp)
  184265:	0f b6 e8             	movzbl %al,%ebp
  184268:	84 c0                	test   %al,%al
  18426a:	74 12                	je     18427e <__mulsf3+0x3b>
  18426c:	fe c0                	inc    %al
  18426e:	74 2d                	je     18429d <__mulsf3+0x5a>
  184270:	81 cb 00 00 80 00    	or     $0x800000,%ebx
  184276:	83 ed 7f             	sub    $0x7f,%ebp
  184279:	c1 e3 03             	shl    $0x3,%ebx
  18427c:	eb 1b                	jmp    184299 <__mulsf3+0x56>
  18427e:	bf 01 00 00 00       	mov    $0x1,%edi
  184283:	85 db                	test   %ebx,%ebx
  184285:	74 1e                	je     1842a5 <__mulsf3+0x62>
  184287:	0f bd c3             	bsr    %ebx,%eax
  18428a:	83 f0 1f             	xor    $0x1f,%eax
  18428d:	8d 48 fb             	lea    -0x5(%eax),%ecx
  184290:	d3 e3                	shl    %cl,%ebx
  184292:	89 e9                	mov    %ebp,%ecx
  184294:	29 c1                	sub    %eax,%ecx
  184296:	8d 69 8a             	lea    -0x76(%ecx),%ebp
  184299:	31 ff                	xor    %edi,%edi
  18429b:	eb 08                	jmp    1842a5 <__mulsf3+0x62>
  18429d:	83 fb 01             	cmp    $0x1,%ebx
  1842a0:	19 ff                	sbb    %edi,%edi
  1842a2:	83 c7 03             	add    $0x3,%edi
  1842a5:	89 d6                	mov    %edx,%esi
  1842a7:	89 d1                	mov    %edx,%ecx
  1842a9:	c1 ea 1f             	shr    $0x1f,%edx
  1842ac:	81 e6 ff ff 7f 00    	and    $0x7fffff,%esi
  1842b2:	c1 e9 17             	shr    $0x17,%ecx
  1842b5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1842b9:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
  1842be:	0f b6 c1             	movzbl %cl,%eax
  1842c1:	89 54 24 08          	mov    %edx,0x8(%esp)
  1842c5:	84 c9                	test   %cl,%cl
  1842c7:	74 16                	je     1842df <__mulsf3+0x9c>
  1842c9:	fe c1                	inc    %cl
  1842cb:	74 2f                	je     1842fc <__mulsf3+0xb9>
  1842cd:	81 ce 00 00 80 00    	or     $0x800000,%esi
  1842d3:	83 e8 7f             	sub    $0x7f,%eax
  1842d6:	8d 34 f5 00 00 00 00 	lea    0x0(,%esi,8),%esi
  1842dd:	eb 19                	jmp    1842f8 <__mulsf3+0xb5>
  1842df:	ba 01 00 00 00       	mov    $0x1,%edx
  1842e4:	85 f6                	test   %esi,%esi
  1842e6:	74 1c                	je     184304 <__mulsf3+0xc1>
  1842e8:	0f bd d6             	bsr    %esi,%edx
  1842eb:	83 f2 1f             	xor    $0x1f,%edx
  1842ee:	29 d0                	sub    %edx,%eax
  1842f0:	8d 4a fb             	lea    -0x5(%edx),%ecx
  1842f3:	d3 e6                	shl    %cl,%esi
  1842f5:	8d 40 8a             	lea    -0x76(%eax),%eax
  1842f8:	31 d2                	xor    %edx,%edx
  1842fa:	eb 08                	jmp    184304 <__mulsf3+0xc1>
  1842fc:	83 fe 01             	cmp    $0x1,%esi
  1842ff:	19 d2                	sbb    %edx,%edx
  184301:	83 c2 03             	add    $0x3,%edx
  184304:	8a 4c 24 0c          	mov    0xc(%esp),%cl
  184308:	33 0c 24             	xor    (%esp),%ecx
  18430b:	0f b6 c9             	movzbl %cl,%ecx
  18430e:	89 0c 24             	mov    %ecx,(%esp)
  184311:	8d 4c 05 00          	lea    0x0(%ebp,%eax,1),%ecx
  184315:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
  18431c:	09 d0                	or     %edx,%eax
  18431e:	8d 69 01             	lea    0x1(%ecx),%ebp
  184321:	48                   	dec    %eax
  184322:	83 f8 0e             	cmp    $0xe,%eax
  184325:	77 0b                	ja     184332 <__mulsf3+0xef>
  184327:	ff 24 85 08 4f 18 00 	jmp    *0x184f08(,%eax,4)
  18432e:	89 f3                	mov    %esi,%ebx
  184330:	eb 5d                	jmp    18438f <__mulsf3+0x14c>
  184332:	89 d8                	mov    %ebx,%eax
  184334:	31 db                	xor    %ebx,%ebx
  184336:	f7 e6                	mul    %esi
  184338:	c1 e2 06             	shl    $0x6,%edx
  18433b:	89 c7                	mov    %eax,%edi
  18433d:	c1 ef 1a             	shr    $0x1a,%edi
  184340:	09 fa                	or     %edi,%edx
  184342:	c1 e0 06             	shl    $0x6,%eax
  184345:	0f 95 c3             	setne  %bl
  184348:	09 d3                	or     %edx,%ebx
  18434a:	f7 c3 00 00 00 08    	test   $0x8000000,%ebx
  184350:	0f 84 0f 01 00 00    	je     184465 <__mulsf3+0x222>
  184356:	89 d8                	mov    %ebx,%eax
  184358:	83 e3 01             	and    $0x1,%ebx
  18435b:	d1 e8                	shr    %eax
  18435d:	89 e9                	mov    %ebp,%ecx
  18435f:	09 c3                	or     %eax,%ebx
  184361:	e9 ff 00 00 00       	jmp    184465 <__mulsf3+0x222>
  184366:	39 f3                	cmp    %esi,%ebx
  184368:	0f 83 ce 00 00 00    	jae    18443c <__mulsf3+0x1f9>
  18436e:	8b 44 24 08          	mov    0x8(%esp),%eax
  184372:	89 f3                	mov    %esi,%ebx
  184374:	89 44 24 04          	mov    %eax,0x4(%esp)
  184378:	e9 bf 00 00 00       	jmp    18443c <__mulsf3+0x1f9>
  18437d:	8b 44 24 04          	mov    0x4(%esp),%eax
  184381:	89 04 24             	mov    %eax,(%esp)
  184384:	eb 0b                	jmp    184391 <__mulsf3+0x14e>
  184386:	8b 44 24 08          	mov    0x8(%esp),%eax
  18438a:	89 f3                	mov    %esi,%ebx
  18438c:	89 04 24             	mov    %eax,(%esp)
  18438f:	89 d7                	mov    %edx,%edi
  184391:	83 ff 02             	cmp    $0x2,%edi
  184394:	0f 84 b3 00 00 00    	je     18444d <__mulsf3+0x20a>
  18439a:	83 ff 03             	cmp    $0x3,%edi
  18439d:	0f 84 a0 00 00 00    	je     184443 <__mulsf3+0x200>
  1843a3:	31 d2                	xor    %edx,%edx
  1843a5:	31 c0                	xor    %eax,%eax
  1843a7:	4f                   	dec    %edi
  1843a8:	0f 84 be 00 00 00    	je     18446c <__mulsf3+0x229>
  1843ae:	8d 45 7f             	lea    0x7f(%ebp),%eax
  1843b1:	85 c0                	test   %eax,%eax
  1843b3:	7e 37                	jle    1843ec <__mulsf3+0x1a9>
  1843b5:	f6 c3 07             	test   $0x7,%bl
  1843b8:	74 0d                	je     1843c7 <__mulsf3+0x184>
  1843ba:	89 da                	mov    %ebx,%edx
  1843bc:	83 e2 0f             	and    $0xf,%edx
  1843bf:	83 fa 04             	cmp    $0x4,%edx
  1843c2:	74 03                	je     1843c7 <__mulsf3+0x184>
  1843c4:	83 c3 04             	add    $0x4,%ebx
  1843c7:	f7 c3 00 00 00 08    	test   $0x8000000,%ebx
  1843cd:	74 0c                	je     1843db <__mulsf3+0x198>
  1843cf:	81 e3 ff ff ff f7    	and    $0xf7ffffff,%ebx
  1843d5:	8d 85 80 00 00 00    	lea    0x80(%ebp),%eax
  1843db:	3d fe 00 00 00       	cmp    $0xfe,%eax
  1843e0:	7f 6b                	jg     18444d <__mulsf3+0x20a>
  1843e2:	c1 eb 03             	shr    $0x3,%ebx
  1843e5:	89 da                	mov    %ebx,%edx
  1843e7:	e9 80 00 00 00       	jmp    18446c <__mulsf3+0x229>
  1843ec:	b9 01 00 00 00       	mov    $0x1,%ecx
  1843f1:	29 c1                	sub    %eax,%ecx
  1843f3:	83 f9 1b             	cmp    $0x1b,%ecx
  1843f6:	7f 5e                	jg     184456 <__mulsf3+0x213>
  1843f8:	b8 20 00 00 00       	mov    $0x20,%eax
  1843fd:	89 da                	mov    %ebx,%edx
  1843ff:	29 c8                	sub    %ecx,%eax
  184401:	d3 ea                	shr    %cl,%edx
  184403:	89 c1                	mov    %eax,%ecx
  184405:	31 c0                	xor    %eax,%eax
  184407:	d3 e3                	shl    %cl,%ebx
  184409:	85 db                	test   %ebx,%ebx
  18440b:	0f 95 c0             	setne  %al
  18440e:	09 c2                	or     %eax,%edx
  184410:	f6 c2 07             	test   $0x7,%dl
  184413:	74 0d                	je     184422 <__mulsf3+0x1df>
  184415:	89 d0                	mov    %edx,%eax
  184417:	83 e0 0f             	and    $0xf,%eax
  18441a:	83 f8 04             	cmp    $0x4,%eax
  18441d:	74 03                	je     184422 <__mulsf3+0x1df>
  18441f:	83 c2 04             	add    $0x4,%edx
  184422:	f7 c2 00 00 00 04    	test   $0x4000000,%edx
  184428:	75 32                	jne    18445c <__mulsf3+0x219>
  18442a:	c1 ea 03             	shr    $0x3,%edx
  18442d:	eb 29                	jmp    184458 <__mulsf3+0x215>
  18442f:	bb 00 00 40 00       	mov    $0x400000,%ebx
  184434:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  18443b:	00 
  18443c:	8b 44 24 04          	mov    0x4(%esp),%eax
  184440:	89 04 24             	mov    %eax,(%esp)
  184443:	81 cb 00 00 40 00    	or     $0x400000,%ebx
  184449:	89 da                	mov    %ebx,%edx
  18444b:	eb 02                	jmp    18444f <__mulsf3+0x20c>
  18444d:	31 d2                	xor    %edx,%edx
  18444f:	b8 ff 00 00 00       	mov    $0xff,%eax
  184454:	eb 16                	jmp    18446c <__mulsf3+0x229>
  184456:	31 d2                	xor    %edx,%edx
  184458:	31 c0                	xor    %eax,%eax
  18445a:	eb 10                	jmp    18446c <__mulsf3+0x229>
  18445c:	31 d2                	xor    %edx,%edx
  18445e:	b8 01 00 00 00       	mov    $0x1,%eax
  184463:	eb 07                	jmp    18446c <__mulsf3+0x229>
  184465:	89 cd                	mov    %ecx,%ebp
  184467:	e9 42 ff ff ff       	jmp    1843ae <__mulsf3+0x16b>
  18446c:	0f b6 c0             	movzbl %al,%eax
  18446f:	c1 e0 17             	shl    $0x17,%eax
  184472:	8b 34 24             	mov    (%esp),%esi
  184475:	81 e2 ff ff 7f 00    	and    $0x7fffff,%edx
  18447b:	83 c4 10             	add    $0x10,%esp
  18447e:	c1 e6 1f             	shl    $0x1f,%esi
  184481:	09 c2                	or     %eax,%edx
  184483:	09 f2                	or     %esi,%edx
  184485:	5b                   	pop    %ebx
  184486:	89 d0                	mov    %edx,%eax
  184488:	5e                   	pop    %esi
  184489:	5f                   	pop    %edi
  18448a:	5d                   	pop    %ebp
  18448b:	c3                   	ret    

0018448c <__floatsisf>:
  18448c:	57                   	push   %edi
  18448d:	85 c0                	test   %eax,%eax
  18448f:	56                   	push   %esi
  184490:	53                   	push   %ebx
  184491:	0f 84 90 00 00 00    	je     184527 <__floatsisf+0x9b>
  184497:	99                   	cltd   
  184498:	89 c3                	mov    %eax,%ebx
  18449a:	31 d0                	xor    %edx,%eax
  18449c:	c1 eb 1f             	shr    $0x1f,%ebx
  18449f:	29 d0                	sub    %edx,%eax
  1844a1:	0f bd f8             	bsr    %eax,%edi
  1844a4:	ba 9e 00 00 00       	mov    $0x9e,%edx
  1844a9:	83 f7 1f             	xor    $0x1f,%edi
  1844ac:	89 c6                	mov    %eax,%esi
  1844ae:	29 fa                	sub    %edi,%edx
  1844b0:	81 fa 96 00 00 00    	cmp    $0x96,%edx
  1844b6:	7f 0b                	jg     1844c3 <__floatsisf+0x37>
  1844b8:	b9 96 00 00 00       	mov    $0x96,%ecx
  1844bd:	29 d1                	sub    %edx,%ecx
  1844bf:	d3 e0                	shl    %cl,%eax
  1844c1:	eb 6a                	jmp    18452d <__floatsisf+0xa1>
  1844c3:	81 fa 99 00 00 00    	cmp    $0x99,%edx
  1844c9:	7e 1d                	jle    1844e8 <__floatsisf+0x5c>
  1844cb:	b9 05 00 00 00       	mov    $0x5,%ecx
  1844d0:	29 f9                	sub    %edi,%ecx
  1844d2:	d3 e8                	shr    %cl,%eax
  1844d4:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1844d9:	29 d1                	sub    %edx,%ecx
  1844db:	d3 e6                	shl    %cl,%esi
  1844dd:	31 c9                	xor    %ecx,%ecx
  1844df:	85 f6                	test   %esi,%esi
  1844e1:	0f 95 c1             	setne  %cl
  1844e4:	09 c8                	or     %ecx,%eax
  1844e6:	89 c6                	mov    %eax,%esi
  1844e8:	b9 99 00 00 00       	mov    $0x99,%ecx
  1844ed:	29 d1                	sub    %edx,%ecx
  1844ef:	85 c9                	test   %ecx,%ecx
  1844f1:	7e 02                	jle    1844f5 <__floatsisf+0x69>
  1844f3:	d3 e6                	shl    %cl,%esi
  1844f5:	89 f0                	mov    %esi,%eax
  1844f7:	25 ff ff ff fb       	and    $0xfbffffff,%eax
  1844fc:	f7 c6 07 00 00 00    	test   $0x7,%esi
  184502:	74 0b                	je     18450f <__floatsisf+0x83>
  184504:	83 e6 0f             	and    $0xf,%esi
  184507:	83 fe 04             	cmp    $0x4,%esi
  18450a:	74 03                	je     18450f <__floatsisf+0x83>
  18450c:	83 c0 04             	add    $0x4,%eax
  18450f:	a9 00 00 00 04       	test   $0x4000000,%eax
  184514:	74 0c                	je     184522 <__floatsisf+0x96>
  184516:	ba 9f 00 00 00       	mov    $0x9f,%edx
  18451b:	25 ff ff ff fb       	and    $0xfbffffff,%eax
  184520:	29 fa                	sub    %edi,%edx
  184522:	c1 e8 03             	shr    $0x3,%eax
  184525:	eb 06                	jmp    18452d <__floatsisf+0xa1>
  184527:	31 c0                	xor    %eax,%eax
  184529:	31 d2                	xor    %edx,%edx
  18452b:	31 db                	xor    %ebx,%ebx
  18452d:	0f b6 d2             	movzbl %dl,%edx
  184530:	c1 e2 17             	shl    $0x17,%edx
  184533:	25 ff ff 7f 00       	and    $0x7fffff,%eax
  184538:	c1 e3 1f             	shl    $0x1f,%ebx
  18453b:	09 d0                	or     %edx,%eax
  18453d:	09 d8                	or     %ebx,%eax
  18453f:	5b                   	pop    %ebx
  184540:	5e                   	pop    %esi
  184541:	5f                   	pop    %edi
  184542:	c3                   	ret    

00184543 <__extendsfdf2>:
  184543:	89 c2                	mov    %eax,%edx
  184545:	55                   	push   %ebp
  184546:	c1 ea 17             	shr    $0x17,%edx
  184549:	89 c5                	mov    %eax,%ebp
  18454b:	0f b6 d2             	movzbl %dl,%edx
  18454e:	57                   	push   %edi
  18454f:	81 e5 ff ff 7f 00    	and    $0x7fffff,%ebp
  184555:	8d 4a 01             	lea    0x1(%edx),%ecx
  184558:	56                   	push   %esi
  184559:	0f b6 c9             	movzbl %cl,%ecx
  18455c:	c1 e8 1f             	shr    $0x1f,%eax
  18455f:	53                   	push   %ebx
  184560:	49                   	dec    %ecx
  184561:	7e 10                	jle    184573 <__extendsfdf2+0x30>
  184563:	89 eb                	mov    %ebp,%ebx
  184565:	81 c2 80 03 00 00    	add    $0x380,%edx
  18456b:	c1 eb 03             	shr    $0x3,%ebx
  18456e:	c1 e5 1d             	shl    $0x1d,%ebp
  184571:	eb 58                	jmp    1845cb <__extendsfdf2+0x88>
  184573:	85 d2                	test   %edx,%edx
  184575:	75 33                	jne    1845aa <__extendsfdf2+0x67>
  184577:	85 ed                	test   %ebp,%ebp
  184579:	74 45                	je     1845c0 <__extendsfdf2+0x7d>
  18457b:	0f bd f5             	bsr    %ebp,%esi
  18457e:	83 f6 1f             	xor    $0x1f,%esi
  184581:	83 fe 0a             	cmp    $0xa,%esi
  184584:	7f 12                	jg     184598 <__extendsfdf2+0x55>
  184586:	b9 0b 00 00 00       	mov    $0xb,%ecx
  18458b:	89 eb                	mov    %ebp,%ebx
  18458d:	29 f1                	sub    %esi,%ecx
  18458f:	d3 eb                	shr    %cl,%ebx
  184591:	8d 4e 15             	lea    0x15(%esi),%ecx
  184594:	d3 e5                	shl    %cl,%ebp
  184596:	eb 09                	jmp    1845a1 <__extendsfdf2+0x5e>
  184598:	89 eb                	mov    %ebp,%ebx
  18459a:	8d 4e f5             	lea    -0xb(%esi),%ecx
  18459d:	d3 e3                	shl    %cl,%ebx
  18459f:	31 ed                	xor    %ebp,%ebp
  1845a1:	ba 89 03 00 00       	mov    $0x389,%edx
  1845a6:	29 f2                	sub    %esi,%edx
  1845a8:	eb 21                	jmp    1845cb <__extendsfdf2+0x88>
  1845aa:	31 db                	xor    %ebx,%ebx
  1845ac:	85 ed                	test   %ebp,%ebp
  1845ae:	74 16                	je     1845c6 <__extendsfdf2+0x83>
  1845b0:	89 eb                	mov    %ebp,%ebx
  1845b2:	c1 eb 03             	shr    $0x3,%ebx
  1845b5:	c1 e5 1d             	shl    $0x1d,%ebp
  1845b8:	81 cb 00 00 08 00    	or     $0x80000,%ebx
  1845be:	eb 06                	jmp    1845c6 <__extendsfdf2+0x83>
  1845c0:	31 db                	xor    %ebx,%ebx
  1845c2:	31 d2                	xor    %edx,%edx
  1845c4:	eb 05                	jmp    1845cb <__extendsfdf2+0x88>
  1845c6:	ba ff 07 00 00       	mov    $0x7ff,%edx
  1845cb:	31 ff                	xor    %edi,%edi
  1845cd:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
  1845d3:	89 f9                	mov    %edi,%ecx
  1845d5:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
  1845db:	c1 e0 1f             	shl    $0x1f,%eax
  1845de:	81 e1 00 00 f0 ff    	and    $0xfff00000,%ecx
  1845e4:	09 cb                	or     %ecx,%ebx
  1845e6:	89 d1                	mov    %edx,%ecx
  1845e8:	c1 e1 14             	shl    $0x14,%ecx
  1845eb:	89 da                	mov    %ebx,%edx
  1845ed:	81 e2 ff ff 0f 80    	and    $0x800fffff,%edx
  1845f3:	5b                   	pop    %ebx
  1845f4:	09 ca                	or     %ecx,%edx
  1845f6:	5e                   	pop    %esi
  1845f7:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
  1845fd:	5f                   	pop    %edi
  1845fe:	09 c2                	or     %eax,%edx
  184600:	89 e8                	mov    %ebp,%eax
  184602:	5d                   	pop    %ebp
  184603:	c3                   	ret    

00184604 <_handle_exc_0_vector_0_stub>:
  184604:	6a 00                	push   $0x0
  184606:	68 0b 2d 18 00       	push   $0x182d0b
  18460b:	e9 02 e4 ff ff       	jmp    182a12 <_exception_enter>

00184610 <_handle_exc_2_vector_2_stub>:
  184610:	6a 00                	push   $0x0
  184612:	68 17 2d 18 00       	push   $0x182d17
  184617:	e9 f6 e3 ff ff       	jmp    182a12 <_exception_enter>

0018461c <_handle_exc_4_vector_4_stub>:
  18461c:	6a 00                	push   $0x0
  18461e:	68 23 2d 18 00       	push   $0x182d23
  184623:	e9 ea e3 ff ff       	jmp    182a12 <_exception_enter>

00184628 <_handle_exc_5_vector_5_stub>:
  184628:	6a 00                	push   $0x0
  18462a:	68 2f 2d 18 00       	push   $0x182d2f
  18462f:	e9 de e3 ff ff       	jmp    182a12 <_exception_enter>

00184634 <_handle_exc_6_vector_6_stub>:
  184634:	6a 00                	push   $0x0
  184636:	68 3b 2d 18 00       	push   $0x182d3b
  18463b:	e9 d2 e3 ff ff       	jmp    182a12 <_exception_enter>

00184640 <_handle_exc_7_vector_7_stub>:
  184640:	6a 00                	push   $0x0
  184642:	68 47 2d 18 00       	push   $0x182d47
  184647:	e9 c6 e3 ff ff       	jmp    182a12 <_exception_enter>

0018464c <_handle_exc_8_vector_8_stub>:
  18464c:	68 53 2d 18 00       	push   $0x182d53
  184651:	e9 bc e3 ff ff       	jmp    182a12 <_exception_enter>

00184656 <_handle_exc_10_vector_10_stub>:
  184656:	68 5f 2d 18 00       	push   $0x182d5f
  18465b:	e9 b2 e3 ff ff       	jmp    182a12 <_exception_enter>

00184660 <_handle_exc_11_vector_11_stub>:
  184660:	68 6b 2d 18 00       	push   $0x182d6b
  184665:	e9 a8 e3 ff ff       	jmp    182a12 <_exception_enter>

0018466a <_handle_exc_12_vector_12_stub>:
  18466a:	68 77 2d 18 00       	push   $0x182d77
  18466f:	e9 9e e3 ff ff       	jmp    182a12 <_exception_enter>

00184674 <_handle_exc_13_vector_13_stub>:
  184674:	68 83 2d 18 00       	push   $0x182d83
  184679:	e9 94 e3 ff ff       	jmp    182a12 <_exception_enter>

0018467e <_handle_exc_14_vector_14_stub>:
  18467e:	68 8f 2d 18 00       	push   $0x182d8f
  184683:	e9 8a e3 ff ff       	jmp    182a12 <_exception_enter>

00184688 <_handle_exc_16_vector_16_stub>:
  184688:	6a 00                	push   $0x0
  18468a:	68 9b 2d 18 00       	push   $0x182d9b
  18468f:	e9 7e e3 ff ff       	jmp    182a12 <_exception_enter>

00184694 <_handle_exc_17_vector_17_stub>:
  184694:	68 a7 2d 18 00       	push   $0x182da7
  184699:	e9 74 e3 ff ff       	jmp    182a12 <_exception_enter>

0018469e <_handle_exc_18_vector_18_stub>:
  18469e:	6a 00                	push   $0x0
  1846a0:	68 b3 2d 18 00       	push   $0x182db3
  1846a5:	e9 68 e3 ff ff       	jmp    182a12 <_exception_enter>
