
zephyr.elf:     ファイル形式 elf32-iamcu


セクション text の逆アセンブル:

00180000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  180000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  180003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  180008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  18000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  18000c:	0f 01 1d 4c 00 18 00 	lidtl  0x18004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  180013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  180016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  180019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
  18001c:	bc a0 05 28 00       	mov    $0x2805a0,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  180021:	81 c4 00 01 00 00    	add    $0x100,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
  180027:	bf 00 00 28 00       	mov    $0x280000,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
  18002c:	be 18 72 18 00       	mov    $0x187218,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
  180031:	b9 d2 00 00 00       	mov    $0xd2,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
  180036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  180038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  18003a:	bf 60 03 28 00       	mov    $0x280360,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  18003f:	b9 90 00 00 00       	mov    $0x90,%ecx
	cld
  180044:	fc                   	cld    
	rep
  180045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  180047:	e9 d2 23 00 00       	jmp    18241e <_Cstart>

0018004c <_Idt>:
  18004c:	ff 01 18 70 18 00 66 90 66 90 66 90 66 90 66 90     ...p..f.f.f.f.f.
  18005c:	66 90 66 90                                         f.f.

00180060 <_thread_entry_wrapper>:
  180060:	58                   	pop    %eax
  180061:	5a                   	pop    %edx
  180062:	59                   	pop    %ecx
  180063:	6a 00                	push   $0x0
  180065:	e9 27 30 00 00       	jmp    183091 <_thread_entry>

0018006a <degrees_to_direction>:
	return 0;
}

/* Convert degrees into compass direction. */
static const char *degrees_to_direction(unsigned int deg)
{
  18006a:	89 c2                	mov    %eax,%edx
	if (deg >= 360) {
  18006c:	3d 67 01 00 00       	cmp    $0x167,%eax
  180071:	76 0c                	jbe    18007f <degrees_to_direction+0x15>
		deg %= 360;
  180073:	b9 68 01 00 00       	mov    $0x168,%ecx
  180078:	ba 00 00 00 00       	mov    $0x0,%edx
  18007d:	f7 f1                	div    %ecx
	}

	if (deg >= 338 || deg < 23) {
  18007f:	8d 42 e9             	lea    -0x17(%edx),%eax
  180082:	3d 3a 01 00 00       	cmp    $0x13a,%eax
  180087:	77 30                	ja     1800b9 <degrees_to_direction+0x4f>
		return "N";
	} else if (deg < 68) {
  180089:	83 fa 43             	cmp    $0x43,%edx
  18008c:	76 31                	jbe    1800bf <degrees_to_direction+0x55>
		return "NE";
	} else if (deg < 113) {
  18008e:	83 fa 70             	cmp    $0x70,%edx
  180091:	76 32                	jbe    1800c5 <degrees_to_direction+0x5b>
		return "E";
	} else if (deg < 158) {
  180093:	81 fa 9d 00 00 00    	cmp    $0x9d,%edx
  180099:	76 30                	jbe    1800cb <degrees_to_direction+0x61>
		return "SE";
	} else if (deg < 203) {
  18009b:	81 fa ca 00 00 00    	cmp    $0xca,%edx
  1800a1:	76 2e                	jbe    1800d1 <degrees_to_direction+0x67>
		return "S";
	} else if (deg < 248) {
  1800a3:	81 fa f7 00 00 00    	cmp    $0xf7,%edx
  1800a9:	76 2c                	jbe    1800d7 <degrees_to_direction+0x6d>
		return "SW";
	} else if (deg < 293) {
  1800ab:	81 fa 24 01 00 00    	cmp    $0x124,%edx
  1800b1:	77 2a                	ja     1800dd <degrees_to_direction+0x73>
		return "W";
  1800b3:	b8 2e 69 18 00       	mov    $0x18692e,%eax
  1800b8:	c3                   	ret    
	if (deg >= 360) {
		deg %= 360;
	}

	if (deg >= 338 || deg < 23) {
		return "N";
  1800b9:	b8 20 69 18 00       	mov    $0x186920,%eax
  1800be:	c3                   	ret    
	} else if (deg < 68) {
		return "NE";
  1800bf:	b8 22 69 18 00       	mov    $0x186922,%eax
  1800c4:	c3                   	ret    
	} else if (deg < 113) {
		return "E";
  1800c5:	b8 23 69 18 00       	mov    $0x186923,%eax
  1800ca:	c3                   	ret    
	} else if (deg < 158) {
		return "SE";
  1800cb:	b8 25 69 18 00       	mov    $0x186925,%eax
  1800d0:	c3                   	ret    
	} else if (deg < 203) {
		return "S";
  1800d1:	b8 28 69 18 00       	mov    $0x186928,%eax
  1800d6:	c3                   	ret    
	} else if (deg < 248) {
		return "SW";
  1800d7:	b8 2a 69 18 00       	mov    $0x18692a,%eax
  1800dc:	c3                   	ret    
	} else if (deg < 293) {
		return "W";
	} else {
		return "NW";
  1800dd:	b8 2d 69 18 00       	mov    $0x18692d,%eax
	}
}
  1800e2:	c3                   	ret    

001800e3 <read_register>:

	return 0;
}

static int read_register(uint16_t addr, uint8_t reg, uint8_t *const data, uint32_t len)
{
  1800e3:	55                   	push   %ebp
  1800e4:	57                   	push   %edi
  1800e5:	56                   	push   %esi
  1800e6:	53                   	push   %ebx
  1800e7:	83 ec 10             	sub    $0x10,%esp
  1800ea:	89 cf                	mov    %ecx,%edi
  1800ec:	88 14 24             	mov    %dl,(%esp)
	if (i2c_write(i2c_dev, &reg, 1, addr) != 0) {
  1800ef:	8b 35 28 05 28 00    	mov    0x280528,%esi
 * @retval -EIO General input / output error.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  1800f5:	8b 6e 04             	mov    0x4(%esi),%ebp
	struct i2c_msg msg;

	msg.buf = buf;
  1800f8:	89 64 24 04          	mov    %esp,0x4(%esp)
	msg.len = num_bytes;
  1800fc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  180103:	00 
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  180104:	c6 44 24 0c 02       	movb   $0x2,0xc(%esp)

	return api->transfer(dev, &msg, 1, addr);
  180109:	0f b7 d8             	movzwl %ax,%ebx
  18010c:	53                   	push   %ebx
  18010d:	b9 01 00 00 00       	mov    $0x1,%ecx
  180112:	8d 54 24 08          	lea    0x8(%esp),%edx
  180116:	89 f0                	mov    %esi,%eax
  180118:	ff 55 04             	call   *0x4(%ebp)
  18011b:	83 c4 04             	add    $0x4,%esp
  18011e:	85 c0                	test   %eax,%eax
  180120:	74 14                	je     180136 <read_register+0x53>
		printk("Error on i2c_write()\n");
  180122:	68 30 69 18 00       	push   $0x186930
  180127:	e8 7d 10 00 00       	call   1811a9 <printk>
  18012c:	83 c4 04             	add    $0x4,%esp
		return 1;
  18012f:	b8 01 00 00 00       	mov    $0x1,%eax
  180134:	eb 3f                	jmp    180175 <read_register+0x92>
	}

	if (i2c_read(i2c_dev, data, len, addr) != 0) {
  180136:	a1 28 05 28 00       	mov    0x280528,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_read(struct device *dev, uint8_t *buf,
			   uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  18013b:	8b 70 04             	mov    0x4(%eax),%esi
	struct i2c_msg msg;

	msg.buf = buf;
  18013e:	89 7c 24 04          	mov    %edi,0x4(%esp)
	msg.len = num_bytes;
  180142:	8b 54 24 24          	mov    0x24(%esp),%edx
  180146:	89 54 24 08          	mov    %edx,0x8(%esp)
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
  18014a:	c6 44 24 0c 03       	movb   $0x3,0xc(%esp)

	return api->transfer(dev, &msg, 1, addr);
  18014f:	53                   	push   %ebx
  180150:	b9 01 00 00 00       	mov    $0x1,%ecx
  180155:	8d 54 24 08          	lea    0x8(%esp),%edx
  180159:	ff 56 04             	call   *0x4(%esi)
  18015c:	83 c4 04             	add    $0x4,%esp
  18015f:	85 c0                	test   %eax,%eax
  180161:	74 12                	je     180175 <read_register+0x92>
		printk("Error on i2c_read()\n");
  180163:	68 46 69 18 00       	push   $0x186946
  180168:	e8 3c 10 00 00       	call   1811a9 <printk>
  18016d:	83 c4 04             	add    $0x4,%esp
		return 1;
  180170:	b8 01 00 00 00       	mov    $0x1,%eax
	}
	return 0;
}
  180175:	83 c4 10             	add    $0x10,%esp
  180178:	5b                   	pop    %ebx
  180179:	5e                   	pop    %esi
  18017a:	5f                   	pop    %edi
  18017b:	5d                   	pop    %ebp
  18017c:	c3                   	ret    

0018017d <read_Temperature>:
	return 0;
}


static void read_Temperature()
{
  18017d:	83 ec 04             	sub    $0x4,%esp
	int8_t data;

	if (read_register(BMC150_I2C_ADDR, ACCD_TEMP_REG, &data, 1)!= 0)
  180180:	6a 01                	push   $0x1
  180182:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  180186:	ba 08 00 00 00       	mov    $0x8,%edx
  18018b:	b8 10 00 00 00       	mov    $0x10,%eax
  180190:	e8 4e ff ff ff       	call   1800e3 <read_register>
  180195:	83 c4 04             	add    $0x4,%esp
  180198:	85 c0                	test   %eax,%eax
  18019a:	74 0c                	je     1801a8 <read_Temperature+0x2b>
	{
		temp_val = 999;
  18019c:	c7 05 7c 03 28 00 00 	movl   $0x4479c000,0x28037c
  1801a3:	c0 79 44 
  1801a6:	eb 23                	jmp    1801cb <read_Temperature+0x4e>
		return;
	}
	temp_val = ((float)data) / 2 + 23;
  1801a8:	0f be 44 24 03       	movsbl 0x3(%esp),%eax
  1801ad:	e8 e3 47 00 00       	call   184995 <__floatsisf>
  1801b2:	ba 00 00 00 3f       	mov    $0x3f000000,%edx
  1801b7:	e8 3a 45 00 00       	call   1846f6 <__mulsf3>
  1801bc:	ba 00 00 b8 41       	mov    $0x41b80000,%edx
  1801c1:	e8 1f 41 00 00       	call   1842e5 <__addsf3>
  1801c6:	a3 7c 03 28 00       	mov    %eax,0x28037c
}
  1801cb:	83 c4 04             	add    $0x4,%esp
  1801ce:	c3                   	ret    

001801cf <write_register>:
	}
	return 0;
}

static int write_register(uint16_t addr, uint8_t reg, uint8_t data)
{
  1801cf:	56                   	push   %esi
  1801d0:	53                   	push   %ebx
  1801d1:	83 ec 10             	sub    $0x10,%esp
  1801d4:	89 c3                	mov    %eax,%ebx
	int8_t data1[2];

	data1[0] = reg;
  1801d6:	88 54 24 0e          	mov    %dl,0xe(%esp)
	data1[1] = data;
  1801da:	88 4c 24 0f          	mov    %cl,0xf(%esp)
	if (i2c_write(i2c_dev, &data1, sizeof(data1), addr) != 0)
  1801de:	a1 28 05 28 00       	mov    0x280528,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  1801e3:	8b 70 04             	mov    0x4(%eax),%esi
	struct i2c_msg msg;

	msg.buf = buf;
  1801e6:	8d 54 24 0e          	lea    0xe(%esp),%edx
  1801ea:	89 14 24             	mov    %edx,(%esp)
	msg.len = num_bytes;
  1801ed:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1801f4:	00 
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  1801f5:	c6 44 24 08 02       	movb   $0x2,0x8(%esp)

	return api->transfer(dev, &msg, 1, addr);
  1801fa:	0f b7 db             	movzwl %bx,%ebx
  1801fd:	53                   	push   %ebx
  1801fe:	b9 01 00 00 00       	mov    $0x1,%ecx
  180203:	8d 54 24 04          	lea    0x4(%esp),%edx
  180207:	ff 56 04             	call   *0x4(%esi)
  18020a:	83 c4 04             	add    $0x4,%esp
  18020d:	85 c0                	test   %eax,%eax
  18020f:	74 12                	je     180223 <write_register+0x54>
	{
		printk("Error on i2c_write()\n");
  180211:	68 30 69 18 00       	push   $0x186930
  180216:	e8 8e 0f 00 00       	call   1811a9 <printk>
  18021b:	83 c4 04             	add    $0x4,%esp
		return 1;
  18021e:	b8 01 00 00 00       	mov    $0x1,%eax
	}
	return 0;
}
  180223:	83 c4 10             	add    $0x10,%esp
  180226:	5b                   	pop    %ebx
  180227:	5e                   	pop    %esi
  180228:	c3                   	ret    

00180229 <write_Acc_range>:
	temp_val = ((float)data) / 2 + 23;
}

static void write_Acc_range(uint8_t data)
{
	if (write_register(BMC150_I2C_ADDR, ACCELEROMTER_RANGE, data) != 0)
  180229:	0f b6 c8             	movzbl %al,%ecx
  18022c:	ba 0f 00 00 00       	mov    $0xf,%edx
  180231:	b8 10 00 00 00       	mov    $0x10,%eax
  180236:	e8 94 ff ff ff       	call   1801cf <write_register>
  18023b:	85 c0                	test   %eax,%eax
  18023d:	74 0d                	je     18024c <write_Acc_range+0x23>
	{
		printk("Error on i2c_write()\n");
  18023f:	68 30 69 18 00       	push   $0x186930
  180244:	e8 60 0f 00 00       	call   1811a9 <printk>
  180249:	83 c4 04             	add    $0x4,%esp
  18024c:	c3                   	ret    

0018024d <write_Acc_bandwidth>:
}


static void write_Acc_bandwidth(uint8_t data)
{
	if (write_register(BMC150_I2C_ADDR, ACCELEROMTER_BANDWIDTH, data) != 0)
  18024d:	0f b6 c8             	movzbl %al,%ecx
  180250:	ba 10 00 00 00       	mov    $0x10,%edx
  180255:	b8 10 00 00 00       	mov    $0x10,%eax
  18025a:	e8 70 ff ff ff       	call   1801cf <write_register>
  18025f:	85 c0                	test   %eax,%eax
  180261:	74 0d                	je     180270 <write_Acc_bandwidth+0x23>
	{
		printk("Error on i2c_write()\n");
  180263:	68 30 69 18 00       	push   $0x186930
  180268:	e8 3c 0f 00 00       	call   1811a9 <printk>
  18026d:	83 c4 04             	add    $0x4,%esp
  180270:	c3                   	ret    

00180271 <read_Accelerometer>:
		return;
	}
}
static void read_Accelerometer()
{
  180271:	53                   	push   %ebx
  180272:	83 ec 14             	sub    $0x14,%esp
	int8_t reg;
	int8_t data[6];
	int16_t lsb, msb;

	reg = DATA_ACC_X_LSB;
  180275:	c6 44 24 13 02       	movb   $0x2,0x13(%esp)
	if (i2c_write(i2c_dev, &reg, 1, BMC150_I2C_ADDR) != 0) {
  18027a:	a1 28 05 28 00       	mov    0x280528,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_write(struct device *dev, uint8_t *buf,
			    uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  18027f:	8b 58 04             	mov    0x4(%eax),%ebx
	struct i2c_msg msg;

	msg.buf = buf;
  180282:	8d 54 24 13          	lea    0x13(%esp),%edx
  180286:	89 14 24             	mov    %edx,(%esp)
	msg.len = num_bytes;
  180289:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  180290:	00 
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
  180291:	c6 44 24 08 02       	movb   $0x2,0x8(%esp)

	return api->transfer(dev, &msg, 1, addr);
  180296:	6a 10                	push   $0x10
  180298:	b9 01 00 00 00       	mov    $0x1,%ecx
  18029d:	8d 54 24 04          	lea    0x4(%esp),%edx
  1802a1:	ff 53 04             	call   *0x4(%ebx)
  1802a4:	83 c4 04             	add    $0x4,%esp
  1802a7:	85 c0                	test   %eax,%eax
  1802a9:	74 12                	je     1802bd <read_Accelerometer+0x4c>
		printk("Error on i2c_write()\n");
  1802ab:	68 30 69 18 00       	push   $0x186930
  1802b0:	e8 f4 0e 00 00       	call   1811a9 <printk>
  1802b5:	83 c4 04             	add    $0x4,%esp
		return;
  1802b8:	e9 e5 00 00 00       	jmp    1803a2 <read_Accelerometer+0x131>
	}

	if (i2c_read(i2c_dev, data, 6, BMC150_I2C_ADDR) != 0) {
  1802bd:	a1 28 05 28 00       	mov    0x280528,%eax
 * @retval -EIO General input / output error.
 */
static inline int i2c_read(struct device *dev, uint8_t *buf,
			   uint32_t num_bytes, uint16_t addr)
{
	const struct i2c_driver_api *api = dev->driver_api;
  1802c2:	8b 58 04             	mov    0x4(%eax),%ebx
	struct i2c_msg msg;

	msg.buf = buf;
  1802c5:	8d 54 24 0d          	lea    0xd(%esp),%edx
  1802c9:	89 14 24             	mov    %edx,(%esp)
	msg.len = num_bytes;
  1802cc:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)
  1802d3:	00 
	msg.flags = I2C_MSG_READ | I2C_MSG_STOP;
  1802d4:	c6 44 24 08 03       	movb   $0x3,0x8(%esp)

	return api->transfer(dev, &msg, 1, addr);
  1802d9:	6a 10                	push   $0x10
  1802db:	b9 01 00 00 00       	mov    $0x1,%ecx
  1802e0:	8d 54 24 04          	lea    0x4(%esp),%edx
  1802e4:	ff 53 04             	call   *0x4(%ebx)
  1802e7:	83 c4 04             	add    $0x4,%esp
  1802ea:	85 c0                	test   %eax,%eax
  1802ec:	74 12                	je     180300 <read_Accelerometer+0x8f>
		printk("Error on i2c_read()\n");
  1802ee:	68 46 69 18 00       	push   $0x186946
  1802f3:	e8 b1 0e 00 00       	call   1811a9 <printk>
  1802f8:	83 c4 04             	add    $0x4,%esp
		return;
  1802fb:	e9 a2 00 00 00       	jmp    1803a2 <read_Accelerometer+0x131>
	}

	lsb = data[0];
  180300:	66 0f be 54 24 0d    	movsbw 0xd(%esp),%dx
	msb = data[1];
	msb <<= 8;
  180306:	0f be 44 24 0e       	movsbl 0xe(%esp),%eax
  18030b:	c1 e0 08             	shl    $0x8,%eax
	acc_x = (msb | lsb) >> 4;
  18030e:	09 d0                	or     %edx,%eax
  180310:	66 c1 f8 04          	sar    $0x4,%ax
  180314:	66 a3 6c 03 28 00    	mov    %ax,0x28036c
	acc_x_val = ((float)acc_x) * 2 / 4096;
  18031a:	98                   	cwtl   
  18031b:	e8 75 46 00 00       	call   184995 <__floatsisf>
  180320:	89 c2                	mov    %eax,%edx
  180322:	e8 be 3f 00 00       	call   1842e5 <__addsf3>
  180327:	ba 00 00 80 39       	mov    $0x39800000,%edx
  18032c:	e8 c5 43 00 00       	call   1846f6 <__mulsf3>
  180331:	a3 78 03 28 00       	mov    %eax,0x280378

	lsb = data[2];
  180336:	66 0f be 54 24 0f    	movsbw 0xf(%esp),%dx
	msb = data[3];
	msb <<= 8;
  18033c:	0f be 44 24 10       	movsbl 0x10(%esp),%eax
  180341:	c1 e0 08             	shl    $0x8,%eax
	acc_y = (msb | lsb) >> 4;
  180344:	09 d0                	or     %edx,%eax
  180346:	66 c1 f8 04          	sar    $0x4,%ax
  18034a:	66 a3 6a 03 28 00    	mov    %ax,0x28036a
	acc_y_val = ((float)acc_y) * 2 / 4096;
  180350:	98                   	cwtl   
  180351:	e8 3f 46 00 00       	call   184995 <__floatsisf>
  180356:	89 c2                	mov    %eax,%edx
  180358:	e8 88 3f 00 00       	call   1842e5 <__addsf3>
  18035d:	ba 00 00 80 39       	mov    $0x39800000,%edx
  180362:	e8 8f 43 00 00       	call   1846f6 <__mulsf3>
  180367:	a3 74 03 28 00       	mov    %eax,0x280374

	lsb = data[4];
  18036c:	66 0f be 54 24 11    	movsbw 0x11(%esp),%dx
	msb = data[5];
	msb <<= 8;
  180372:	0f be 44 24 12       	movsbl 0x12(%esp),%eax
  180377:	c1 e0 08             	shl    $0x8,%eax
	acc_z = (msb | lsb) >> 4;
  18037a:	09 d0                	or     %edx,%eax
  18037c:	66 c1 f8 04          	sar    $0x4,%ax
  180380:	66 a3 68 03 28 00    	mov    %ax,0x280368
	acc_z_val = ((float)acc_z) * 2 / 4096;
  180386:	98                   	cwtl   
  180387:	e8 09 46 00 00       	call   184995 <__floatsisf>
  18038c:	89 c2                	mov    %eax,%edx
  18038e:	e8 52 3f 00 00       	call   1842e5 <__addsf3>
  180393:	ba 00 00 80 39       	mov    $0x39800000,%edx
  180398:	e8 59 43 00 00       	call   1846f6 <__mulsf3>
  18039d:	a3 70 03 28 00       	mov    %eax,0x280370
}
  1803a2:	83 c4 14             	add    $0x14,%esp
  1803a5:	5b                   	pop    %ebx
  1803a6:	c3                   	ret    

001803a7 <i2c_init>:
	cfg.raw = 0;
	cfg.bits.use_10_bit_addr = 0;
	cfg.bits.speed = I2C_SPEED_STANDARD;
	cfg.bits.is_master_device = 1;

	i2c_dev = device_get_binding("I2C_0");
  1803a7:	b8 5b 69 18 00       	mov    $0x18695b,%eax
  1803ac:	e8 fb 1e 00 00       	call   1822ac <device_get_binding>
  1803b1:	a3 28 05 28 00       	mov    %eax,0x280528
	if (!i2c_dev) {
  1803b6:	85 c0                	test   %eax,%eax
  1803b8:	75 13                	jne    1803cd <i2c_init+0x26>
		printk("I2C0: Device not found.\n");
  1803ba:	68 61 69 18 00       	push   $0x186961
  1803bf:	e8 e5 0d 00 00       	call   1811a9 <printk>
  1803c4:	83 c4 04             	add    $0x4,%esp
		return -1;
  1803c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1803cc:	c3                   	ret    
 * @retval 0 If successful.
 * @retval -EIO General input / output error, failed to configure device.
 */
static inline int i2c_configure(struct device *dev, uint32_t dev_config)
{
	const struct i2c_driver_api *api = dev->driver_api;
  1803cd:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->configure(dev, dev_config);
  1803d0:	ba 12 00 00 00       	mov    $0x12,%edx
  1803d5:	ff 11                	call   *(%ecx)
	}

	if (i2c_configure(i2c_dev, cfg.raw) != 0) {
  1803d7:	85 c0                	test   %eax,%eax
  1803d9:	74 12                	je     1803ed <i2c_init+0x46>
		printk("Error on i2c_configure()\n");
  1803db:	68 7a 69 18 00       	push   $0x18697a
  1803e0:	e8 c4 0d 00 00       	call   1811a9 <printk>
  1803e5:	83 c4 04             	add    $0x4,%esp
		return -1;
  1803e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}

	return 0;
}
  1803ed:	c3                   	ret    

001803ee <bmx1xx_init>:
	acc_z = (msb | lsb) >> 4;
	acc_z_val = ((float)acc_z) * 2 / 4096;
}

int bmx1xx_init()
{
  1803ee:	83 ec 04             	sub    $0x4,%esp
	int rc;
	uint8_t data;

	rc = read_register(BMC150_I2C_ADDR, BMX1XX_REG_ACCEL_CHIPID, &data,
  1803f1:	6a 01                	push   $0x1
  1803f3:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  1803f7:	ba 00 00 00 00       	mov    $0x0,%edx
  1803fc:	b8 10 00 00 00       	mov    $0x10,%eax
  180401:	e8 dd fc ff ff       	call   1800e3 <read_register>
  180406:	83 c4 04             	add    $0x4,%esp
			   sizeof(data));
	if (rc != 0) {
  180409:	85 c0                	test   %eax,%eax
  18040b:	75 13                	jne    180420 <bmx1xx_init+0x32>
		return rc;
	}

	if (data != BMX1XX_CHIP_ID_MAJOR) {
  18040d:	80 7c 24 03 fa       	cmpb   $0xfa,0x3(%esp)
  180412:	74 07                	je     18041b <bmx1xx_init+0x2d>
		return -ENODEV;
  180414:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  180419:	eb 05                	jmp    180420 <bmx1xx_init+0x32>
	}

	return 0;
  18041b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  180420:	83 c4 04             	add    $0x4,%esp
  180423:	c3                   	ret    

00180424 <mag_init>:

int mag_init()
{
	/* Activate the magneto. */
	if (0 != write_register(BMC150_I2C_MAG_ADDR, BMX1XX_REG_MAG_POWER_MODES, BMX1XX_MAG_POWER_ACTIVE))
  180424:	b9 01 00 00 00       	mov    $0x1,%ecx
  180429:	ba 4b 00 00 00       	mov    $0x4b,%edx
  18042e:	b8 12 00 00 00       	mov    $0x12,%eax
  180433:	e8 97 fd ff ff       	call   1801cf <write_register>
  180438:	85 c0                	test   %eax,%eax
  18043a:	74 13                	je     18044f <mag_init+0x2b>
	{
		printk("Error: Unable to set BMC150 power state.");
  18043c:	68 c8 69 18 00       	push   $0x1869c8
  180441:	e8 63 0d 00 00       	call   1811a9 <printk>
  180446:	83 c4 04             	add    $0x4,%esp
		return 1;
  180449:	b8 01 00 00 00       	mov    $0x1,%eax
  18044e:	c3                   	ret    
	}

	k_sleep(10);
  18044f:	b8 0a 00 00 00       	mov    $0xa,%eax
  180454:	e8 6d 23 00 00       	call   1827c6 <k_sleep>

	// Change magnetometer mode in Active mode
	if (0 != write_register(BMC150_I2C_MAG_ADDR, BMX1XX_REG_MAG_OPERATION_MODES, 0x38))
  180459:	b9 38 00 00 00       	mov    $0x38,%ecx
  18045e:	ba 4c 00 00 00       	mov    $0x4c,%edx
  180463:	b8 12 00 00 00       	mov    $0x12,%eax
  180468:	e8 62 fd ff ff       	call   1801cf <write_register>
  18046d:	85 c0                	test   %eax,%eax
  18046f:	74 13                	je     180484 <mag_init+0x60>
	{
		printk("Error: Unable to set BMC150 Active mode.");
  180471:	68 f4 69 18 00       	push   $0x1869f4
  180476:	e8 2e 0d 00 00       	call   1811a9 <printk>
  18047b:	83 c4 04             	add    $0x4,%esp
		return 1;
  18047e:	b8 01 00 00 00       	mov    $0x1,%eax
  180483:	c3                   	ret    
	}

	// Enable magnetometer axes
	if (0 != write_register(BMC150_I2C_MAG_ADDR, BMC150_MAGN_REG_INT_DRDY, 0x07))
  180484:	b9 07 00 00 00       	mov    $0x7,%ecx
  180489:	ba 4e 00 00 00       	mov    $0x4e,%edx
  18048e:	b8 12 00 00 00       	mov    $0x12,%eax
  180493:	e8 37 fd ff ff       	call   1801cf <write_register>
  180498:	85 c0                	test   %eax,%eax
  18049a:	74 13                	je     1804af <mag_init+0x8b>
	{
		printk("Error: Unable to set BMC150 magnetometer axes.");
  18049c:	68 20 6a 18 00       	push   $0x186a20
  1804a1:	e8 03 0d 00 00       	call   1811a9 <printk>
  1804a6:	83 c4 04             	add    $0x4,%esp
		return 1;
  1804a9:	b8 01 00 00 00       	mov    $0x1,%eax
  1804ae:	c3                   	ret    
	}

	//  Enable interrupts for every axis and override
	if (0 != write_register(BMC150_I2C_MAG_ADDR, BMC150_MAGN_REG_INT, 0xFF))
  1804af:	b9 ff 00 00 00       	mov    $0xff,%ecx
  1804b4:	ba 4d 00 00 00       	mov    $0x4d,%edx
  1804b9:	b8 12 00 00 00       	mov    $0x12,%eax
  1804be:	e8 0c fd ff ff       	call   1801cf <write_register>
  1804c3:	85 c0                	test   %eax,%eax
  1804c5:	74 12                	je     1804d9 <mag_init+0xb5>
	{
		printk("Error: Unable to set BMC150 Enable interrupts.");
  1804c7:	68 50 6a 18 00       	push   $0x186a50
  1804cc:	e8 d8 0c 00 00       	call   1811a9 <printk>
  1804d1:	83 c4 04             	add    $0x4,%esp
		return 1;
  1804d4:	b8 01 00 00 00       	mov    $0x1,%eax
	}

	return 0;
}
  1804d9:	c3                   	ret    

001804da <bmx1xx_read_mag>:
		return "NW";
	}
}

int bmx1xx_read_mag(bmx1xx_mag_t *const mag)
{
  1804da:	56                   	push   %esi
  1804db:	53                   	push   %ebx
  1804dc:	83 ec 08             	sub    $0x8,%esp
  1804df:	89 c3                	mov    %eax,%ebx
	int rc = 0;
	uint8_t raw_mag[6];
	int16_t x, y, z;

	rc = read_register(BMC150_I2C_MAG_ADDR, BMX1XX_REG_MAG_X_LSB, raw_mag,
  1804e1:	6a 06                	push   $0x6
  1804e3:	8d 4c 24 06          	lea    0x6(%esp),%ecx
  1804e7:	ba 42 00 00 00       	mov    $0x42,%edx
  1804ec:	b8 12 00 00 00       	mov    $0x12,%eax
  1804f1:	e8 ed fb ff ff       	call   1800e3 <read_register>
  1804f6:	83 c4 04             	add    $0x4,%esp
			   sizeof(raw_mag));
	if (rc != 0) {
  1804f9:	85 c0                	test   %eax,%eax
  1804fb:	75 4e                	jne    18054b <bmx1xx_read_mag+0x71>
		return rc;
	}

	x = EXTRACT_MAG_XY(raw_mag[1], raw_mag[0]);
  1804fd:	0f b6 54 24 03       	movzbl 0x3(%esp),%edx
  180502:	c1 e2 08             	shl    $0x8,%edx
  180505:	0f b6 44 24 02       	movzbl 0x2(%esp),%eax
  18050a:	09 c2                	or     %eax,%edx
  18050c:	66 c1 fa 03          	sar    $0x3,%dx
	y = EXTRACT_MAG_XY(raw_mag[3], raw_mag[2]);
  180510:	0f b6 44 24 05       	movzbl 0x5(%esp),%eax
  180515:	c1 e0 08             	shl    $0x8,%eax
  180518:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
  18051d:	09 c8                	or     %ecx,%eax
  18051f:	66 c1 f8 03          	sar    $0x3,%ax
  180523:	89 c1                	mov    %eax,%ecx
	z = EXTRACT_MAG_Z(raw_mag[5], raw_mag[4]);
  180525:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
  18052a:	c1 e0 08             	shl    $0x8,%eax
  18052d:	0f b6 74 24 06       	movzbl 0x6(%esp),%esi
  180532:	09 f0                	or     %esi,%eax
  180534:	66 d1 f8             	sar    %ax

	mag->x = x;
  180537:	0f bf d2             	movswl %dx,%edx
  18053a:	89 13                	mov    %edx,(%ebx)
	mag->y = y;
  18053c:	0f bf d1             	movswl %cx,%edx
  18053f:	89 53 04             	mov    %edx,0x4(%ebx)
	mag->z = z;
  180542:	98                   	cwtl   
  180543:	89 43 08             	mov    %eax,0x8(%ebx)

	return 0;
  180546:	b8 00 00 00 00       	mov    $0x0,%eax
}
  18054b:	83 c4 08             	add    $0x8,%esp
  18054e:	5b                   	pop    %ebx
  18054f:	5e                   	pop    %esi
  180550:	c3                   	ret    

00180551 <main>:


void main(void)
{
  180551:	57                   	push   %edi
  180552:	56                   	push   %esi
  180553:	83 ec 4c             	sub    $0x4c,%esp
	uint8_t buf[64];
	bmx1xx_mag_t mag = {0};
  180556:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  18055d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  180564:	00 
  180565:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  18056c:	00 
	int deg;
	/* Adjusted magnetometer readings */
	double mag_x, mag_y, mag_z;


	printk("Start I2C BMC150 sample\n");
  18056d:	68 94 69 18 00       	push   $0x186994
  180572:	e8 32 0c 00 00       	call   1811a9 <printk>
  180577:	83 c4 04             	add    $0x4,%esp

	i2c_init();
  18057a:	e8 28 fe ff ff       	call   1803a7 <i2c_init>

	if(bmx1xx_init() != 0)
  18057f:	e8 6a fe ff ff       	call   1803ee <bmx1xx_init>
  180584:	85 c0                	test   %eax,%eax
  180586:	74 12                	je     18059a <main+0x49>
	{
		printk("Error I2C BMC150 sample\n");
  180588:	68 ad 69 18 00       	push   $0x1869ad
  18058d:	e8 17 0c 00 00       	call   1811a9 <printk>
  180592:	83 c4 04             	add    $0x4,%esp
		return;
  180595:	e9 1e 01 00 00       	jmp    1806b8 <main+0x167>
	}

	mag_init();
  18059a:	e8 85 fe ff ff       	call   180424 <mag_init>

	write_Acc_range(ACCELEROMETER_RANGE_2G);
  18059f:	b8 03 00 00 00       	mov    $0x3,%eax
  1805a4:	e8 80 fc ff ff       	call   180229 <write_Acc_range>
	write_Acc_bandwidth(ACCELEROMTER_BANDWIDTH_64MS);
  1805a9:	b8 08 00 00 00       	mov    $0x8,%eax
  1805ae:	e8 9a fc ff ff       	call   18024d <write_Acc_bandwidth>

	while (1) {
		read_Temperature();
  1805b3:	e8 c5 fb ff ff       	call   18017d <read_Temperature>
		read_Accelerometer();
  1805b8:	e8 b4 fc ff ff       	call   180271 <read_Accelerometer>
		sprintf(buf, "ACC:x:%+04d, y:%+04d, z:%+04d, temp:%d\n", acc_x, acc_y, acc_z, (int)temp_val);
  1805bd:	a1 7c 03 28 00       	mov    0x28037c,%eax
  1805c2:	e8 78 43 00 00       	call   18493f <__fixsfsi>
  1805c7:	50                   	push   %eax
  1805c8:	0f bf 05 68 03 28 00 	movswl 0x280368,%eax
  1805cf:	50                   	push   %eax
  1805d0:	0f bf 05 6a 03 28 00 	movswl 0x28036a,%eax
  1805d7:	50                   	push   %eax
  1805d8:	0f bf 05 6c 03 28 00 	movswl 0x28036c,%eax
  1805df:	50                   	push   %eax
  1805e0:	68 80 6a 18 00       	push   $0x186a80
  1805e5:	8d 74 24 20          	lea    0x20(%esp),%esi
  1805e9:	56                   	push   %esi
  1805ea:	e8 ab 33 00 00       	call   18399a <siprintf>
  1805ef:	83 c4 18             	add    $0x18,%esp
		printk(buf);
  1805f2:	56                   	push   %esi
  1805f3:	e8 b1 0b 00 00       	call   1811a9 <printk>
  1805f8:	83 c4 04             	add    $0x4,%esp

		/* Read the value from the magneto. */
		bmx1xx_read_mag(&mag);
  1805fb:	89 e0                	mov    %esp,%eax
  1805fd:	e8 d8 fe ff ff       	call   1804da <bmx1xx_read_mag>

		/* Calculate the heading. */
		heading = atan2((double)mag.y, (double)mag.x);
  180602:	8b 04 24             	mov    (%esp),%eax
  180605:	e8 15 61 00 00       	call   18671f <__floatsidf>
  18060a:	89 c6                	mov    %eax,%esi
  18060c:	89 d7                	mov    %edx,%edi
  18060e:	8b 44 24 04          	mov    0x4(%esp),%eax
  180612:	e8 08 61 00 00       	call   18671f <__floatsidf>
  180617:	57                   	push   %edi
  180618:	56                   	push   %esi
  180619:	e8 de 2c 00 00       	call   1832fc <atan2>
  18061e:	83 c4 08             	add    $0x8,%esp
  180621:	89 c6                	mov    %eax,%esi
  180623:	89 d7                	mov    %edx,%edi
		if (heading < 0) {
  180625:	6a 00                	push   $0x0
  180627:	6a 00                	push   $0x0
  180629:	e8 90 52 00 00       	call   1858be <__ledf2>
  18062e:	83 c4 08             	add    $0x8,%esp
  180631:	85 c0                	test   %eax,%eax
  180633:	79 1a                	jns    18064f <main+0xfe>
			heading += (2 * M_PI);
  180635:	68 fb 21 19 40       	push   $0x401921fb
  18063a:	68 18 2d 44 54       	push   $0x54442d18
  18063f:	89 f0                	mov    %esi,%eax
  180641:	89 fa                	mov    %edi,%edx
  180643:	e8 04 44 00 00       	call   184a4c <__adddf3>
  180648:	83 c4 08             	add    $0x8,%esp
  18064b:	89 c6                	mov    %eax,%esi
  18064d:	89 d7                	mov    %edx,%edi
		}

		/* Convert the heading into degrees. */
		deg = (int)((heading * 180) / M_PI);
  18064f:	68 00 80 66 40       	push   $0x40668000
  180654:	6a 00                	push   $0x0
  180656:	89 f0                	mov    %esi,%eax
  180658:	89 fa                	mov    %edi,%edx
  18065a:	e8 6f 53 00 00       	call   1859ce <__muldf3>
  18065f:	83 c4 08             	add    $0x8,%esp
  180662:	68 fb 21 09 40       	push   $0x400921fb
  180667:	68 18 2d 44 54       	push   $0x54442d18
  18066c:	e8 2d 4c 00 00       	call   18529e <__divdf3>
  180671:	83 c4 08             	add    $0x8,%esp
  180674:	e8 3e 60 00 00       	call   1866b7 <__fixdfsi>
  180679:	89 c6                	mov    %eax,%esi

		sprintf(buf, "MAG:x:%+04d, y:%+04d, z:%+04d, deg:%03d, dir:%s\n", mag.x, mag.y, mag.z, deg, degrees_to_direction(deg));
  18067b:	e8 ea f9 ff ff       	call   18006a <degrees_to_direction>
  180680:	50                   	push   %eax
  180681:	56                   	push   %esi
  180682:	ff 74 24 10          	pushl  0x10(%esp)
  180686:	ff 74 24 10          	pushl  0x10(%esp)
  18068a:	ff 74 24 10          	pushl  0x10(%esp)
  18068e:	68 a8 6a 18 00       	push   $0x186aa8
  180693:	8d 74 24 24          	lea    0x24(%esp),%esi
  180697:	56                   	push   %esi
  180698:	e8 fd 32 00 00       	call   18399a <siprintf>
  18069d:	83 c4 1c             	add    $0x1c,%esp
		printk(buf);
  1806a0:	56                   	push   %esi
  1806a1:	e8 03 0b 00 00       	call   1811a9 <printk>
  1806a6:	83 c4 04             	add    $0x4,%esp

		k_sleep(500);
  1806a9:	b8 f4 01 00 00       	mov    $0x1f4,%eax
  1806ae:	e8 13 21 00 00       	call   1827c6 <k_sleep>
	}
  1806b3:	e9 fb fe ff ff       	jmp    1805b3 <main+0x62>
}
  1806b8:	83 c4 4c             	add    $0x4c,%esp
  1806bb:	5e                   	pop    %esi
  1806bc:	5f                   	pop    %edi
  1806bd:	c3                   	ret    

001806be <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1806be:	53                   	push   %ebx
  1806bf:	89 c3                	mov    %eax,%ebx
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  1806c1:	83 f8 0a             	cmp    $0xa,%eax
  1806c4:	75 10                	jne    1806d6 <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
  1806c6:	a1 80 03 28 00       	mov    0x280380,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  1806cb:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  1806ce:	ba 0d 00 00 00       	mov    $0xd,%edx
  1806d3:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
  1806d6:	a1 80 03 28 00       	mov    0x280380,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  1806db:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  1806de:	0f b6 d3             	movzbl %bl,%edx
  1806e1:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
  1806e4:	89 d8                	mov    %ebx,%eax
  1806e6:	5b                   	pop    %ebx
  1806e7:	c3                   	ret    

001806e8 <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
  1806e8:	b8 be 06 18 00       	mov    $0x1806be,%eax
  1806ed:	e8 c4 08 00 00       	call   180fb6 <__printk_hook_install>
  1806f2:	c3                   	ret    

001806f3 <uart_console_init>:
static int uart_console_init(struct device *arg)
{

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  1806f3:	b8 d9 6a 18 00       	mov    $0x186ad9,%eax
  1806f8:	e8 af 1b 00 00       	call   1822ac <device_get_binding>
  1806fd:	a3 80 03 28 00       	mov    %eax,0x280380
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  180702:	e8 e1 ff ff ff       	call   1806e8 <uart_console_hook_install>

	return 0;
}
  180707:	b8 00 00 00 00       	mov    $0x0,%eax
  18070c:	c3                   	ret    

0018070d <is_tx_fifo_full>:
}

#if CONFIG_UART_INTERRUPT_DRIVEN
static bool is_tx_fifo_full(qm_uart_t instance)
{
	return !!(QM_UART[instance]->lsr & QM_UART_LSR_THRE);
  18070d:	8b 04 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%eax
  180714:	8b 40 14             	mov    0x14(%eax),%eax
  180717:	a8 20                	test   $0x20,%al
  180719:	0f 95 c0             	setne  %al
}
  18071c:	c3                   	ret    

0018071d <is_data_ready>:
	return i;
}

static bool is_data_ready(qm_uart_t instance)
{
	return QM_UART[instance]->lsr & QM_UART_LSR_DR;
  18071d:	8b 04 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%eax
  180724:	8b 40 14             	mov    0x14(%eax),%eax
  180727:	83 e0 01             	and    $0x1,%eax
}
  18072a:	c3                   	ret    

0018072b <uart_qmsi_irq_tx_enable>:
	return i;
}

static void uart_qmsi_irq_tx_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18072b:	8b 00                	mov    (%eax),%eax
  18072d:	8b 40 08             	mov    0x8(%eax),%eax
  180730:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ETBEI;
  180732:	8b 14 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%edx
  180739:	8b 42 04             	mov    0x4(%edx),%eax
  18073c:	83 c8 02             	or     $0x2,%eax
  18073f:	89 42 04             	mov    %eax,0x4(%edx)
  180742:	c3                   	ret    

00180743 <uart_qmsi_irq_tx_disable>:
}

static void uart_qmsi_irq_tx_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180743:	8b 00                	mov    (%eax),%eax
  180745:	8b 40 08             	mov    0x8(%eax),%eax
  180748:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ETBEI;
  18074a:	8b 14 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%edx
  180751:	8b 42 04             	mov    0x4(%edx),%eax
  180754:	83 e0 fd             	and    $0xfffffffd,%eax
  180757:	89 42 04             	mov    %eax,0x4(%edx)
  18075a:	c3                   	ret    

0018075b <uart_qmsi_irq_tx_ready>:
}

static int uart_qmsi_irq_tx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  18075b:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  18075e:	8a 40 04             	mov    0x4(%eax),%al

	return id == QM_UART_IIR_THR_EMPTY;
  180761:	83 e0 0f             	and    $0xf,%eax
  180764:	3c 02                	cmp    $0x2,%al
  180766:	0f 94 c0             	sete   %al
  180769:	0f b6 c0             	movzbl %al,%eax
}
  18076c:	c3                   	ret    

0018076d <uart_qmsi_irq_tx_empty>:

static int uart_qmsi_irq_tx_empty(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18076d:	8b 00                	mov    (%eax),%eax
  18076f:	8b 40 08             	mov    0x8(%eax),%eax
  180772:	8b 00                	mov    (%eax),%eax
	const uint32_t mask = (QM_UART_LSR_TEMT | QM_UART_LSR_THRE);

	return (QM_UART[instance]->lsr & mask) == mask;
  180774:	8b 04 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%eax
  18077b:	8b 40 14             	mov    0x14(%eax),%eax
  18077e:	83 e0 60             	and    $0x60,%eax
  180781:	83 f8 60             	cmp    $0x60,%eax
  180784:	0f 94 c0             	sete   %al
  180787:	0f b6 c0             	movzbl %al,%eax
}
  18078a:	c3                   	ret    

0018078b <uart_qmsi_irq_rx_enable>:

static void uart_qmsi_irq_rx_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18078b:	8b 00                	mov    (%eax),%eax
  18078d:	8b 40 08             	mov    0x8(%eax),%eax
  180790:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ERBFI;
  180792:	8b 14 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%edx
  180799:	8b 42 04             	mov    0x4(%edx),%eax
  18079c:	83 c8 01             	or     $0x1,%eax
  18079f:	89 42 04             	mov    %eax,0x4(%edx)
  1807a2:	c3                   	ret    

001807a3 <uart_qmsi_irq_rx_disable>:
}

static void uart_qmsi_irq_rx_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1807a3:	8b 00                	mov    (%eax),%eax
  1807a5:	8b 40 08             	mov    0x8(%eax),%eax
  1807a8:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ERBFI;
  1807aa:	8b 14 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%edx
  1807b1:	8b 42 04             	mov    0x4(%edx),%eax
  1807b4:	83 e0 fe             	and    $0xfffffffe,%eax
  1807b7:	89 42 04             	mov    %eax,0x4(%edx)
  1807ba:	c3                   	ret    

001807bb <uart_qmsi_irq_rx_ready>:
}

static int uart_qmsi_irq_rx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  1807bb:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  1807be:	8a 50 04             	mov    0x4(%eax),%dl
  1807c1:	83 e2 0f             	and    $0xf,%edx

	return (id == QM_UART_IIR_RECV_DATA_AVAIL) ||
  1807c4:	83 fa 04             	cmp    $0x4,%edx
  1807c7:	0f 94 c1             	sete   %cl
	       (id == QM_UART_IIR_CHAR_TIMEOUT);
  1807ca:	83 fa 0c             	cmp    $0xc,%edx
  1807cd:	0f 94 c0             	sete   %al
static int uart_qmsi_irq_rx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);

	return (id == QM_UART_IIR_RECV_DATA_AVAIL) ||
  1807d0:	09 c8                	or     %ecx,%eax
  1807d2:	0f b6 c0             	movzbl %al,%eax
	       (id == QM_UART_IIR_CHAR_TIMEOUT);
}
  1807d5:	c3                   	ret    

001807d6 <uart_qmsi_irq_err_enable>:

static void uart_qmsi_irq_err_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1807d6:	8b 00                	mov    (%eax),%eax
  1807d8:	8b 40 08             	mov    0x8(%eax),%eax
  1807db:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ELSI;
  1807dd:	8b 14 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%edx
  1807e4:	8b 42 04             	mov    0x4(%edx),%eax
  1807e7:	83 c8 04             	or     $0x4,%eax
  1807ea:	89 42 04             	mov    %eax,0x4(%edx)
  1807ed:	c3                   	ret    

001807ee <uart_qmsi_irq_err_disable>:
}

static void uart_qmsi_irq_err_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1807ee:	8b 00                	mov    (%eax),%eax
  1807f0:	8b 40 08             	mov    0x8(%eax),%eax
  1807f3:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ELSI;
  1807f5:	8b 14 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%edx
  1807fc:	8b 42 04             	mov    0x4(%edx),%eax
  1807ff:	83 e0 fb             	and    $0xfffffffb,%eax
  180802:	89 42 04             	mov    %eax,0x4(%edx)
  180805:	c3                   	ret    

00180806 <uart_qmsi_irq_is_pending>:
}

static int uart_qmsi_irq_is_pending(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180806:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  180809:	8a 40 04             	mov    0x4(%eax),%al

	return !(id == IIR_IID_NO_INTERRUPT_PENDING);
  18080c:	83 e0 0f             	and    $0xf,%eax
  18080f:	3c 01                	cmp    $0x1,%al
  180811:	0f 95 c0             	setne  %al
  180814:	0f b6 c0             	movzbl %al,%eax
}
  180817:	c3                   	ret    

00180818 <uart_qmsi_irq_update>:

static int uart_qmsi_irq_update(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180818:	8b 10                	mov    (%eax),%edx
  18081a:	8b 52 08             	mov    0x8(%edx),%edx
  18081d:	8b 12                	mov    (%edx),%edx
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  18081f:	8b 40 08             	mov    0x8(%eax),%eax

	drv_data->iir_cache = QM_UART[instance]->iir_fcr;
  180822:	8b 14 95 c0 02 28 00 	mov    0x2802c0(,%edx,4),%edx
  180829:	8b 52 08             	mov    0x8(%edx),%edx
  18082c:	88 50 04             	mov    %dl,0x4(%eax)
	return 1;
}
  18082f:	b8 01 00 00 00       	mov    $0x1,%eax
  180834:	c3                   	ret    

00180835 <uart_qmsi_irq_callback_set>:

static void uart_qmsi_irq_callback_set(struct device *dev,
				       uart_irq_callback_t cb)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180835:	8b 40 08             	mov    0x8(%eax),%eax

	drv_data->user_cb = cb;
  180838:	89 10                	mov    %edx,(%eax)
  18083a:	c3                   	ret    

0018083b <uart_qmsi_isr>:
}

static void uart_qmsi_isr(void *arg)
{
  18083b:	53                   	push   %ebx
  18083c:	89 c3                	mov    %eax,%ebx
	struct device *dev = arg;
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  18083e:	8b 40 08             	mov    0x8(%eax),%eax

	if (drv_data->user_cb)
  180841:	8b 10                	mov    (%eax),%edx
  180843:	85 d2                	test   %edx,%edx
  180845:	74 04                	je     18084b <uart_qmsi_isr+0x10>
		drv_data->user_cb(dev);
  180847:	89 d8                	mov    %ebx,%eax
  180849:	ff d2                	call   *%edx

	device_busy_clear(dev);
  18084b:	89 d8                	mov    %ebx,%eax
  18084d:	e8 92 1a 00 00       	call   1822e4 <device_busy_clear>
}
  180852:	5b                   	pop    %ebx
  180853:	c3                   	ret    

00180854 <irq_config_func_0>:
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  180854:	b9 00 80 00 00       	mov    $0x8000,%ecx
  180859:	ba 08 00 00 00       	mov    $0x8,%edx
  18085e:	b8 28 00 00 00       	mov    $0x28,%eax
  180863:	e8 b1 02 00 00       	call   180b19 <__irq_controller_irq_config>
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT),
		    CONFIG_UART_QMSI_0_IRQ_PRI, uart_qmsi_isr,
		    DEVICE_GET(uart_0), UART_IRQ_FLAGS);
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT));
  180868:	b8 08 00 00 00       	mov    $0x8,%eax
  18086d:	e8 82 02 00 00       	call   180af4 <_arch_irq_enable>
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->uart_0_int_mask);
  180872:	a1 60 04 80 b0       	mov    0xb0800460,%eax
  180877:	83 e0 fe             	and    $0xfffffffe,%eax
  18087a:	a3 60 04 80 b0       	mov    %eax,0xb0800460
  18087f:	c3                   	ret    

00180880 <uart_qmsi_isr_irq8_stub>:
#ifdef CONFIG_UART_QMSI_0
static void irq_config_func_0(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT),
  180880:	68 00 03 28 00       	push   $0x280300
  180885:	68 3b 08 18 00       	push   $0x18083b
  18088a:	e9 a1 16 00 00       	jmp    181f30 <_interrupt_enter>

0018088f <uart_qmsi_isr_irq6_stub>:
#ifdef CONFIG_UART_QMSI_1
static void irq_config_func_1(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_1_INT),
  18088f:	68 f4 02 28 00       	push   $0x2802f4
  180894:	68 3b 08 18 00       	push   $0x18083b
  180899:	e9 92 16 00 00       	jmp    181f30 <_interrupt_enter>

0018089e <_timer_int_handler_irq10_stub>:
  18089e:	6a 00                	push   $0x0
  1808a0:	68 18 0a 18 00       	push   $0x180a18
  1808a5:	e9 86 16 00 00       	jmp    181f30 <_interrupt_enter>

001808aa <qm_i2c_0_irq_isr_irq4_stub>:
  1808aa:	6a 00                	push   $0x0
  1808ac:	68 84 19 18 00       	push   $0x181984
  1808b1:	e9 7a 16 00 00       	jmp    181f30 <_interrupt_enter>

001808b6 <irq_config_func_1>:
  1808b6:	b9 00 80 00 00       	mov    $0x8000,%ecx
  1808bb:	ba 06 00 00 00       	mov    $0x6,%edx
  1808c0:	b8 26 00 00 00       	mov    $0x26,%eax
  1808c5:	e8 4f 02 00 00       	call   180b19 <__irq_controller_irq_config>
		    CONFIG_UART_QMSI_1_IRQ_PRI, uart_qmsi_isr,
		    DEVICE_GET(uart_1), UART_IRQ_FLAGS);
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_UART_1_INT));
  1808ca:	b8 06 00 00 00       	mov    $0x6,%eax
  1808cf:	e8 20 02 00 00       	call   180af4 <_arch_irq_enable>
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->uart_1_int_mask);
  1808d4:	a1 64 04 80 b0       	mov    0xb0800464,%eax
  1808d9:	83 e0 fe             	and    $0xfffffffe,%eax
  1808dc:	a3 64 04 80 b0       	mov    %eax,0xb0800464
  1808e1:	c3                   	ret    

001808e2 <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
  1808e2:	56                   	push   %esi
  1808e3:	53                   	push   %ebx
  1808e4:	83 ec 0c             	sub    $0xc,%esp
  1808e7:	89 c6                	mov    %eax,%esi
	const struct uart_qmsi_config_info *config = dev->config->config_info;
  1808e9:	8b 00                	mov    (%eax),%eax
  1808eb:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
  1808ee:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
	cfg.baud_divisor = config->baud_divisor;
  1808f5:	8b 43 08             	mov    0x8(%ebx),%eax
  1808f8:	89 44 24 04          	mov    %eax,0x4(%esp)
	cfg.hw_fc = config->hw_fc;
  1808fc:	8a 43 0c             	mov    0xc(%ebx),%al
  1808ff:	88 44 24 08          	mov    %al,0x8(%esp)

	clk_periph_enable(config->clock_gate);
  180903:	8b 43 04             	mov    0x4(%ebx),%eax
  180906:	e8 13 09 00 00       	call   18121e <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
  18090b:	89 e2                	mov    %esp,%edx
  18090d:	8b 03                	mov    (%ebx),%eax
  18090f:	e8 de 12 00 00       	call   181bf2 <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
  180914:	89 f0                	mov    %esi,%eax
  180916:	ff 53 10             	call   *0x10(%ebx)
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
  180919:	c7 46 04 00 6b 18 00 	movl   $0x186b00,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  180920:	b8 00 00 00 00       	mov    $0x0,%eax
  180925:	83 c4 0c             	add    $0xc,%esp
  180928:	5b                   	pop    %ebx
  180929:	5e                   	pop    %esi
  18092a:	c3                   	ret    

0018092b <uart_qmsi_fifo_read>:
	return QM_UART[instance]->lsr & QM_UART_LSR_DR;
}

static int uart_qmsi_fifo_read(struct device *dev, uint8_t *rx_data,
				  const int size)
{
  18092b:	55                   	push   %ebp
  18092c:	57                   	push   %edi
  18092d:	56                   	push   %esi
  18092e:	53                   	push   %ebx
  18092f:	89 d5                	mov    %edx,%ebp
  180931:	89 cf                	mov    %ecx,%edi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180933:	8b 10                	mov    (%eax),%edx
  180935:	8b 52 08             	mov    0x8(%edx),%edx
  180938:	8b 32                	mov    (%edx),%esi
	int i;

	device_busy_set(dev);
  18093a:	e8 a4 19 00 00       	call   1822e3 <device_busy_set>

	for (i = 0; i < size && is_data_ready(instance); i++) {
  18093f:	bb 00 00 00 00       	mov    $0x0,%ebx
  180944:	eb 0e                	jmp    180954 <uart_qmsi_fifo_read+0x29>
		rx_data[i] = QM_UART[instance]->rbr_thr_dll;
  180946:	8b 04 b5 c0 02 28 00 	mov    0x2802c0(,%esi,4),%eax
  18094d:	8b 00                	mov    (%eax),%eax
  18094f:	88 44 1d 00          	mov    %al,0x0(%ebp,%ebx,1)
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
	int i;

	device_busy_set(dev);

	for (i = 0; i < size && is_data_ready(instance); i++) {
  180953:	43                   	inc    %ebx
  180954:	39 fb                	cmp    %edi,%ebx
  180956:	7d 0b                	jge    180963 <uart_qmsi_fifo_read+0x38>
  180958:	89 f0                	mov    %esi,%eax
  18095a:	e8 be fd ff ff       	call   18071d <is_data_ready>
  18095f:	84 c0                	test   %al,%al
  180961:	75 e3                	jne    180946 <uart_qmsi_fifo_read+0x1b>
		rx_data[i] = QM_UART[instance]->rbr_thr_dll;
	}

	return i;
}
  180963:	89 d8                	mov    %ebx,%eax
  180965:	5b                   	pop    %ebx
  180966:	5e                   	pop    %esi
  180967:	5f                   	pop    %edi
  180968:	5d                   	pop    %ebp
  180969:	c3                   	ret    

0018096a <uart_qmsi_fifo_fill>:
	return !!(QM_UART[instance]->lsr & QM_UART_LSR_THRE);
}

static int uart_qmsi_fifo_fill(struct device *dev, const uint8_t *tx_data,
				  int size)
{
  18096a:	55                   	push   %ebp
  18096b:	57                   	push   %edi
  18096c:	56                   	push   %esi
  18096d:	53                   	push   %ebx
  18096e:	89 d5                	mov    %edx,%ebp
  180970:	89 cf                	mov    %ecx,%edi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180972:	8b 10                	mov    (%eax),%edx
  180974:	8b 52 08             	mov    0x8(%edx),%edx
  180977:	8b 32                	mov    (%edx),%esi
	int i;

	device_busy_set(dev);
  180979:	e8 65 19 00 00       	call   1822e3 <device_busy_set>

	for (i = 0; i < size && !is_tx_fifo_full(instance); i++) {
  18097e:	bb 00 00 00 00       	mov    $0x0,%ebx
  180983:	eb 0f                	jmp    180994 <uart_qmsi_fifo_fill+0x2a>
		QM_UART[instance]->rbr_thr_dll = tx_data[i];
  180985:	8b 04 b5 c0 02 28 00 	mov    0x2802c0(,%esi,4),%eax
  18098c:	0f b6 54 1d 00       	movzbl 0x0(%ebp,%ebx,1),%edx
  180991:	89 10                	mov    %edx,(%eax)
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
	int i;

	device_busy_set(dev);

	for (i = 0; i < size && !is_tx_fifo_full(instance); i++) {
  180993:	43                   	inc    %ebx
  180994:	39 fb                	cmp    %edi,%ebx
  180996:	7d 0b                	jge    1809a3 <uart_qmsi_fifo_fill+0x39>
  180998:	89 f0                	mov    %esi,%eax
  18099a:	e8 6e fd ff ff       	call   18070d <is_tx_fifo_full>
  18099f:	84 c0                	test   %al,%al
  1809a1:	74 e2                	je     180985 <uart_qmsi_fifo_fill+0x1b>
		QM_UART[instance]->rbr_thr_dll = tx_data[i];
	}

	return i;
}
  1809a3:	89 d8                	mov    %ebx,%eax
  1809a5:	5b                   	pop    %ebx
  1809a6:	5e                   	pop    %esi
  1809a7:	5f                   	pop    %edi
  1809a8:	5d                   	pop    %ebp
  1809a9:	c3                   	ret    

001809aa <uart_qmsi_err_check>:
	qm_uart_write(instance, data);
	return data;
}

static int uart_qmsi_err_check(struct device *dev)
{
  1809aa:	83 ec 04             	sub    $0x4,%esp
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1809ad:	8b 00                	mov    (%eax),%eax
  1809af:	8b 40 08             	mov    0x8(%eax),%eax
  1809b2:	8b 00                	mov    (%eax),%eax

	/* QMSI and Zephyr use the same bits to represent UART errors
	 * so we don't need to translate each error bit from QMSI API
	 * to Zephyr API.
	 */
	qm_uart_get_status(instance, &status);
  1809b4:	89 e2                	mov    %esp,%edx
  1809b6:	e8 aa 12 00 00       	call   181c65 <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
  1809bb:	8b 04 24             	mov    (%esp),%eax
  1809be:	83 e0 1e             	and    $0x1e,%eax
}
  1809c1:	83 c4 04             	add    $0x4,%esp
  1809c4:	c3                   	ret    

001809c5 <uart_qmsi_poll_out>:
	return 0;
}

static unsigned char uart_qmsi_poll_out(struct device *dev,
					unsigned char data)
{
  1809c5:	53                   	push   %ebx
  1809c6:	89 d3                	mov    %edx,%ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1809c8:	8b 00                	mov    (%eax),%eax
  1809ca:	8b 40 08             	mov    0x8(%eax),%eax
  1809cd:	8b 00                	mov    (%eax),%eax

	qm_uart_write(instance, data);
  1809cf:	0f b6 d2             	movzbl %dl,%edx
  1809d2:	e8 d1 12 00 00       	call   181ca8 <qm_uart_write>
	return data;
}
  1809d7:	88 d8                	mov    %bl,%al
  1809d9:	5b                   	pop    %ebx
  1809da:	c3                   	ret    

001809db <uart_qmsi_poll_in>:
	      uart_qmsi_device_ctrl, &drv_data_1, &config_info_1, PRE_KERNEL_1,
	      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL);
#endif /* CONFIG_UART_QMSI_1 */

static int uart_qmsi_poll_in(struct device *dev, unsigned char *data)
{
  1809db:	56                   	push   %esi
  1809dc:	53                   	push   %ebx
  1809dd:	83 ec 04             	sub    $0x4,%esp
  1809e0:	89 d6                	mov    %edx,%esi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1809e2:	8b 00                	mov    (%eax),%eax
  1809e4:	8b 40 08             	mov    0x8(%eax),%eax
  1809e7:	8b 18                	mov    (%eax),%ebx
	qm_uart_status_t status;

	qm_uart_get_status(instance, &status);
  1809e9:	89 e2                	mov    %esp,%edx
  1809eb:	89 d8                	mov    %ebx,%eax
  1809ed:	e8 73 12 00 00       	call   181c65 <qm_uart_get_status>
	/* In order to check if there is any data to read from UART
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
  1809f2:	f6 04 24 40          	testb  $0x40,(%esp)
  1809f6:	74 15                	je     180a0d <uart_qmsi_poll_in+0x32>
		return -1;

	qm_uart_read(instance, data, NULL);
  1809f8:	b9 00 00 00 00       	mov    $0x0,%ecx
  1809fd:	89 f2                	mov    %esi,%edx
  1809ff:	89 d8                	mov    %ebx,%eax
  180a01:	e8 c4 12 00 00       	call   181cca <qm_uart_read>
	return 0;
  180a06:	b8 00 00 00 00       	mov    $0x0,%eax
  180a0b:	eb 05                	jmp    180a12 <uart_qmsi_poll_in+0x37>
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
		return -1;
  180a0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	qm_uart_read(instance, data, NULL);
	return 0;
}
  180a12:	83 c4 04             	add    $0x4,%esp
  180a15:	5b                   	pop    %ebx
  180a16:	5e                   	pop    %esi
  180a17:	c3                   	ret    

00180a18 <_timer_int_handler>:
		timer_mode = TIMER_MODE_PERIODIC;
	}

	_sys_clock_final_tick_announce();
#else
	_sys_clock_tick_announce();
  180a18:	a1 c8 02 28 00       	mov    0x2802c8,%eax
  180a1d:	e8 ac 22 00 00       	call   182cce <_nano_sys_clock_tick_announce>
  180a22:	c3                   	ret    

00180a23 <_sys_clock_driver_init>:
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
  180a23:	a1 cc 02 28 00       	mov    0x2802cc,%eax
  180a28:	48                   	dec    %eax
 * @param count Count from which timer is to count down
 * @return N/A
 */
static inline void initial_count_register_set(uint32_t count)
{
	*_REG_TIMER_ICR = count;
  180a29:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
 *
 * @return N/A
 */
static inline void periodic_mode_set(void)
{
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
  180a2e:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
  180a33:	0d 00 00 02 00       	or     $0x20000,%eax
  180a38:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180a3d:	b9 00 00 00 00       	mov    $0x0,%ecx
  180a42:	ba 0a 00 00 00       	mov    $0xa,%edx
  180a47:	b8 2a 00 00 00       	mov    $0x2a,%eax
  180a4c:	e8 c8 00 00 00       	call   180b19 <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
  180a51:	b8 0a 00 00 00       	mov    $0xa,%eax
  180a56:	e8 99 00 00 00       	call   180af4 <_arch_irq_enable>

	return 0;
}
  180a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  180a60:	c3                   	ret    

00180a61 <_mvic_rte_set>:
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  180a61:	89 c1                	mov    %eax,%ecx
  180a63:	83 e1 07             	and    $0x7,%ecx
  180a66:	01 c9                	add    %ecx,%ecx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  180a68:	83 e0 18             	and    $0x18,%eax
  180a6b:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  180a6e:	09 c8                	or     %ecx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  180a70:	9c                   	pushf  
  180a71:	fa                   	cli    
  180a72:	59                   	pop    %ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180a73:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
  180a78:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  180a7e:	f6 c5 02             	test   $0x2,%ch
  180a81:	74 01                	je     180a84 <_mvic_rte_set+0x23>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  180a83:	fb                   	sti    
  180a84:	c3                   	ret    

00180a85 <_mvic_rte_update>:
 * @param mask of bits to be modified
 *
 * @returns N/A
 */
static void _mvic_rte_update(unsigned int irq, uint32_t value, uint32_t mask)
{
  180a85:	53                   	push   %ebx
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  180a86:	89 c3                	mov    %eax,%ebx
  180a88:	83 e3 07             	and    $0x7,%ebx
  180a8b:	01 db                	add    %ebx,%ebx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  180a8d:	83 e0 18             	and    $0x18,%eax
  180a90:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  180a93:	09 d8                	or     %ebx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  180a95:	9c                   	pushf  
  180a96:	fa                   	cli    
  180a97:	5b                   	pop    %ebx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180a98:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180a9d:	a1 10 00 c0 fe       	mov    0xfec00010,%eax
	key = irq_lock();

	sys_write32(regsel, MVIC_IOREGSEL);

	old_value = sys_read32(MVIC_IOWIN);
	updated_value = (old_value & ~mask) | (value & mask);
  180aa2:	31 c2                	xor    %eax,%edx
  180aa4:	21 d1                	and    %edx,%ecx
  180aa6:	31 c8                	xor    %ecx,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180aa8:	a3 10 00 c0 fe       	mov    %eax,0xfec00010
  180aad:	f6 c7 02             	test   $0x2,%bh
  180ab0:	74 01                	je     180ab3 <_mvic_rte_update+0x2e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  180ab2:	fb                   	sti    
	sys_write32(updated_value, MVIC_IOWIN);

	irq_unlock(key);
}
  180ab3:	5b                   	pop    %ebx
  180ab4:	c3                   	ret    

00180ab5 <_mvic_init>:
 * This routine replaces the standard Local APIC / IO APIC init routines.
 *
 * @returns: N/A
 */
static int _mvic_init(struct device *unused)
{
  180ab5:	53                   	push   %ebx
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  180ab6:	bb 00 00 00 00       	mov    $0x0,%ebx
  180abb:	eb 0d                	jmp    180aca <_mvic_init+0x15>
		_mvic_rte_set(i, MVIC_IOWIN_MASK);
  180abd:	ba 00 00 01 00       	mov    $0x10000,%edx
  180ac2:	89 d8                	mov    %ebx,%eax
  180ac4:	e8 98 ff ff ff       	call   180a61 <_mvic_rte_set>
{
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  180ac9:	43                   	inc    %ebx
  180aca:	83 fb 1f             	cmp    $0x1f,%ebx
  180acd:	7e ee                	jle    180abd <_mvic_init+0x8>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180acf:	b8 00 00 00 00       	mov    $0x0,%eax
  180ad4:	a3 80 00 e0 fe       	mov    %eax,0xfee00080
  180ad9:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
  180ade:	b8 0a 00 01 00       	mov    $0x1000a,%eax
  180ae3:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180ae8:	b8 00 00 00 00       	mov    $0x0,%eax
  180aed:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	/* discard a pending interrupt if any */
	sys_write32(0, MVIC_EOI);

	return 0;

}
  180af2:	5b                   	pop    %ebx
  180af3:	c3                   	ret    

00180af4 <_arch_irq_enable>:
SYS_INIT(_mvic_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


void _arch_irq_enable(unsigned int irq)
{
	if (irq == CONFIG_MVIC_TIMER_IRQ) {
  180af4:	83 f8 0a             	cmp    $0xa,%eax
  180af7:	75 10                	jne    180b09 <_arch_irq_enable+0x15>
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180af9:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
		sys_write32(sys_read32(MVIC_LVTTIMER) & ~MVIC_LVTTIMER_MASK,
  180afe:	25 ff ff fe ff       	and    $0xfffeffff,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180b03:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180b08:	c3                   	ret    
			    MVIC_LVTTIMER);
	} else {
		_mvic_rte_update(irq, 0, MVIC_IOWIN_MASK);
  180b09:	b9 00 00 01 00       	mov    $0x10000,%ecx
  180b0e:	ba 00 00 00 00       	mov    $0x0,%edx
  180b13:	e8 6d ff ff ff       	call   180a85 <_mvic_rte_update>
  180b18:	c3                   	ret    

00180b19 <__irq_controller_irq_config>:

	/* Vector argument always ignored. There are no triggering options
	 * for the timer, so nothing to do at all for that case. Other I/O
	 * interrupts need their triggering set
	 */
	if (irq != CONFIG_MVIC_TIMER_IRQ) {
  180b19:	83 fa 0a             	cmp    $0xa,%edx
  180b1c:	74 0f                	je     180b2d <__irq_controller_irq_config+0x14>
  180b1e:	89 d0                	mov    %edx,%eax
		_mvic_rte_set(irq, MVIC_IOWIN_MASK | flags);
  180b20:	81 c9 00 00 01 00    	or     $0x10000,%ecx
  180b26:	89 ca                	mov    %ecx,%edx
  180b28:	e8 34 ff ff ff       	call   180a61 <_mvic_rte_set>
  180b2d:	c3                   	ret    

00180b2e <__irq_controller_isr_vector_get>:
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180b2e:	a1 10 01 e0 fe       	mov    0xfee00110,%eax
{
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
  180b33:	85 c0                	test   %eax,%eax
  180b35:	74 0e                	je     180b45 <__irq_controller_isr_vector_get+0x17>

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  180b37:	0f bd c0             	bsr    %eax,%eax
  180b3a:	75 05                	jne    180b41 <__irq_controller_isr_vector_get+0x13>
  180b3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		return -1;
	}
	return 32 + (find_msb_set(isr) - 1);
  180b41:	83 c0 20             	add    $0x20,%eax
  180b44:	c3                   	ret    
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
		return -1;
  180b45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
	return 32 + (find_msb_set(isr) - 1);
}
  180b4a:	c3                   	ret    

00180b4b <transfer_complete>:
			 uint32_t len)
{
	struct device *dev = (struct device *) data;
	struct i2c_qmsi_driver_data *driver_data;

	driver_data = GET_DRIVER_DATA(dev);
  180b4b:	8b 40 08             	mov    0x8(%eax),%eax
	driver_data->transfer_status = rc;
  180b4e:	89 50 14             	mov    %edx,0x14(%eax)
	k_sem_give(&driver_data->device_sync_sem);
  180b51:	e8 b6 20 00 00       	call   182c0c <k_sem_give>
  180b56:	c3                   	ret    

00180b57 <i2c_qmsi_transfer>:
}

static int i2c_qmsi_transfer(struct device *dev, struct i2c_msg *msgs,
			     uint8_t num_msgs, uint16_t addr)
{
  180b57:	55                   	push   %ebp
  180b58:	57                   	push   %edi
  180b59:	56                   	push   %esi
  180b5a:	53                   	push   %ebx
  180b5b:	83 ec 2c             	sub    $0x2c,%esp
  180b5e:	88 4c 24 05          	mov    %cl,0x5(%esp)
  180b62:	8b 7c 24 40          	mov    0x40(%esp),%edi
  180b66:	66 89 7c 24 06       	mov    %di,0x6(%esp)
	struct i2c_qmsi_driver_data *driver_data = GET_DRIVER_DATA(dev);
  180b6b:	8b 70 08             	mov    0x8(%eax),%esi
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
  180b6e:	8b 18                	mov    (%eax),%ebx
  180b70:	8b 5b 08             	mov    0x8(%ebx),%ebx
  180b73:	8b 1b                	mov    (%ebx),%ebx
  180b75:	89 1c 24             	mov    %ebx,(%esp)
	int rc;

	__ASSERT_NO_MSG(msgs);
	if (!num_msgs) {
  180b78:	84 c9                	test   %cl,%cl
  180b7a:	0f 84 f5 00 00 00    	je     180c75 <i2c_qmsi_transfer+0x11e>
  180b80:	89 54 24 0c          	mov    %edx,0xc(%esp)
  180b84:	89 44 24 08          	mov    %eax,0x8(%esp)
		return 0;
	}

	device_busy_set(dev);
  180b88:	e8 56 17 00 00       	call   1822e3 <device_busy_set>

	for (int i = 0; i < num_msgs; i++) {
  180b8d:	bb 00 00 00 00       	mov    $0x0,%ebx
  180b92:	89 f5                	mov    %esi,%ebp
  180b94:	e9 bf 00 00 00       	jmp    180c58 <i2c_qmsi_transfer+0x101>
		uint8_t op =  msgs[i].flags & I2C_MSG_RW_MASK;
  180b99:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
  180b9c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  180ba3:	03 54 24 0c          	add    0xc(%esp),%edx
		bool stop = (msgs[i].flags & I2C_MSG_STOP) == I2C_MSG_STOP;
  180ba7:	8a 42 08             	mov    0x8(%edx),%al
  180baa:	d0 e8                	shr    %al
  180bac:	83 e0 01             	and    $0x1,%eax
  180baf:	89 c6                	mov    %eax,%esi
		qm_i2c_transfer_t xfer = { 0 };
  180bb1:	8d 7c 24 10          	lea    0x10(%esp),%edi
  180bb5:	b9 07 00 00 00       	mov    $0x7,%ecx
  180bba:	b8 00 00 00 00       	mov    $0x0,%eax
  180bbf:	f3 ab                	rep stos %eax,%es:(%edi)
		if (op == I2C_MSG_WRITE) {
  180bc1:	f6 42 08 01          	testb  $0x1,0x8(%edx)
  180bc5:	75 0f                	jne    180bd6 <i2c_qmsi_transfer+0x7f>
			xfer.tx = msgs[i].buf;
  180bc7:	8b 02                	mov    (%edx),%eax
  180bc9:	89 44 24 10          	mov    %eax,0x10(%esp)
			xfer.tx_len = msgs[i].len;
  180bcd:	8b 42 04             	mov    0x4(%edx),%eax
  180bd0:	89 44 24 14          	mov    %eax,0x14(%esp)
  180bd4:	eb 0d                	jmp    180be3 <i2c_qmsi_transfer+0x8c>
		} else {
			xfer.rx = msgs[i].buf;
  180bd6:	8b 02                	mov    (%edx),%eax
  180bd8:	89 44 24 18          	mov    %eax,0x18(%esp)
			xfer.rx_len = msgs[i].len;
  180bdc:	8b 42 04             	mov    0x4(%edx),%eax
  180bdf:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		}

		xfer.callback = transfer_complete;
  180be3:	c7 44 24 24 4b 0b 18 	movl   $0x180b4b,0x24(%esp)
  180bea:	00 
		xfer.callback_data = dev;
  180beb:	8b 44 24 08          	mov    0x8(%esp),%eax
  180bef:	89 44 24 28          	mov    %eax,0x28(%esp)
		xfer.stop = stop;
  180bf3:	89 f0                	mov    %esi,%eax
  180bf5:	88 44 24 20          	mov    %al,0x20(%esp)

		k_sem_take(&driver_data->sem, K_FOREVER);
  180bf9:	8d 75 18             	lea    0x18(%ebp),%esi
  180bfc:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  180c01:	89 f0                	mov    %esi,%eax
  180c03:	e8 22 20 00 00       	call   182c2a <k_sem_take>
		rc = qm_i2c_master_irq_transfer(instance, &xfer, addr);
  180c08:	0f b7 4c 24 06       	movzwl 0x6(%esp),%ecx
  180c0d:	8d 54 24 10          	lea    0x10(%esp),%edx
  180c11:	8b 04 24             	mov    (%esp),%eax
  180c14:	e8 47 0f 00 00       	call   181b60 <qm_i2c_master_irq_transfer>
  180c19:	89 c7                	mov    %eax,%edi
		k_sem_give(&driver_data->sem);
  180c1b:	89 f0                	mov    %esi,%eax
  180c1d:	e8 ea 1f 00 00       	call   182c0c <k_sem_give>

		if (rc != 0) {
  180c22:	85 ff                	test   %edi,%edi
  180c24:	74 0b                	je     180c31 <i2c_qmsi_transfer+0xda>
			device_busy_clear(dev);
  180c26:	8b 44 24 08          	mov    0x8(%esp),%eax
  180c2a:	e8 b5 16 00 00       	call   1822e4 <device_busy_clear>
			return -EIO;
  180c2f:	eb 20                	jmp    180c51 <i2c_qmsi_transfer+0xfa>
		}

		/* Block current thread until the I2C transfer completes. */
		k_sem_take(&driver_data->device_sync_sem, K_FOREVER);
  180c31:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  180c36:	89 e8                	mov    %ebp,%eax
  180c38:	e8 ed 1f 00 00       	call   182c2a <k_sem_take>

		if (driver_data->transfer_status != 0) {
  180c3d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  180c41:	74 0b                	je     180c4e <i2c_qmsi_transfer+0xf7>
			device_busy_clear(dev);
  180c43:	8b 44 24 08          	mov    0x8(%esp),%eax
  180c47:	e8 98 16 00 00       	call   1822e4 <device_busy_clear>
			return -EIO;
  180c4c:	eb 03                	jmp    180c51 <i2c_qmsi_transfer+0xfa>
		return 0;
	}

	device_busy_set(dev);

	for (int i = 0; i < num_msgs; i++) {
  180c4e:	43                   	inc    %ebx
  180c4f:	eb 07                	jmp    180c58 <i2c_qmsi_transfer+0x101>
		rc = qm_i2c_master_irq_transfer(instance, &xfer, addr);
		k_sem_give(&driver_data->sem);

		if (rc != 0) {
			device_busy_clear(dev);
			return -EIO;
  180c51:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  180c56:	eb 22                	jmp    180c7a <i2c_qmsi_transfer+0x123>
		return 0;
	}

	device_busy_set(dev);

	for (int i = 0; i < num_msgs; i++) {
  180c58:	0f b6 44 24 05       	movzbl 0x5(%esp),%eax
  180c5d:	39 c3                	cmp    %eax,%ebx
  180c5f:	0f 8c 34 ff ff ff    	jl     180b99 <i2c_qmsi_transfer+0x42>
			device_busy_clear(dev);
			return -EIO;
		}
	}

	device_busy_clear(dev);
  180c65:	8b 44 24 08          	mov    0x8(%esp),%eax
  180c69:	e8 76 16 00 00       	call   1822e4 <device_busy_clear>

	return 0;
  180c6e:	b8 00 00 00 00       	mov    $0x0,%eax
  180c73:	eb 05                	jmp    180c7a <i2c_qmsi_transfer+0x123>
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
	int rc;

	__ASSERT_NO_MSG(msgs);
	if (!num_msgs) {
		return 0;
  180c75:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	device_busy_clear(dev);

	return 0;
}
  180c7a:	83 c4 2c             	add    $0x2c,%esp
  180c7d:	5b                   	pop    %ebx
  180c7e:	5e                   	pop    %esi
  180c7f:	5f                   	pop    %edi
  180c80:	5d                   	pop    %ebp
  180c81:	c3                   	ret    

00180c82 <i2c_qmsi_configure>:
	      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL);

#endif /* CONFIG_I2C_1 */

static int i2c_qmsi_configure(struct device *dev, uint32_t config)
{
  180c82:	57                   	push   %edi
  180c83:	56                   	push   %esi
  180c84:	53                   	push   %ebx
  180c85:	83 ec 14             	sub    $0x14,%esp
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
  180c88:	8b 08                	mov    (%eax),%ecx
  180c8a:	8b 49 08             	mov    0x8(%ecx),%ecx
  180c8d:	8b 19                	mov    (%ecx),%ebx
	struct i2c_qmsi_driver_data *driver_data = GET_DRIVER_DATA(dev);
  180c8f:	8b 78 08             	mov    0x8(%eax),%edi
	qm_i2c_reg_t *const controller = QM_I2C[instance];
  180c92:	8b 34 9d bc 02 28 00 	mov    0x2802bc(,%ebx,4),%esi
	qm_i2c_config_t qm_cfg;

	cfg.raw = config;

	/* This driver only supports master mode. */
	if (!cfg.bits.is_master_device)
  180c99:	f6 c2 10             	test   $0x10,%dl
  180c9c:	74 74                	je     180d12 <i2c_qmsi_configure+0x90>
		return -EINVAL;

	qm_cfg.mode = QM_I2C_MASTER;
  180c9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180ca5:	00 
	qm_cfg.address_mode = (cfg.bits.use_10_bit_addr) ? QM_I2C_10_BIT :
  180ca6:	89 d0                	mov    %edx,%eax
  180ca8:	83 e0 01             	and    $0x1,%eax
  180cab:	89 44 24 04          	mov    %eax,0x4(%esp)
							   QM_I2C_7_BIT;

	switch (cfg.bits.speed) {
  180caf:	d1 ea                	shr    %edx
  180cb1:	83 e2 07             	and    $0x7,%edx
  180cb4:	80 fa 02             	cmp    $0x2,%dl
  180cb7:	74 13                	je     180ccc <i2c_qmsi_configure+0x4a>
  180cb9:	80 fa 03             	cmp    $0x3,%dl
  180cbc:	74 17                	je     180cd5 <i2c_qmsi_configure+0x53>
  180cbe:	80 fa 01             	cmp    $0x1,%dl
  180cc1:	75 56                	jne    180d19 <i2c_qmsi_configure+0x97>
	case I2C_SPEED_STANDARD:
		qm_cfg.speed = QM_I2C_SPEED_STD;
  180cc3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
		break;
  180cca:	eb 10                	jmp    180cdc <i2c_qmsi_configure+0x5a>
	case I2C_SPEED_FAST:
		qm_cfg.speed = QM_I2C_SPEED_FAST;
  180ccc:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
		break;
  180cd3:	eb 07                	jmp    180cdc <i2c_qmsi_configure+0x5a>
	case I2C_SPEED_FAST_PLUS:
		qm_cfg.speed = QM_I2C_SPEED_FAST_PLUS;
  180cd5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
		break;
	default:
		return -EINVAL;
	}

	k_sem_take(&driver_data->sem, K_FOREVER);
  180cdc:	83 c7 18             	add    $0x18,%edi
  180cdf:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  180ce4:	89 f8                	mov    %edi,%eax
  180ce6:	e8 3f 1f 00 00       	call   182c2a <k_sem_take>
	rc = qm_i2c_set_config(instance, &qm_cfg);
  180ceb:	89 e2                	mov    %esp,%edx
  180ced:	89 d8                	mov    %ebx,%eax
  180cef:	e8 9b 0c 00 00       	call   18198f <qm_i2c_set_config>
  180cf4:	89 c3                	mov    %eax,%ebx
	k_sem_give(&driver_data->sem);
  180cf6:	89 f8                	mov    %edi,%eax
  180cf8:	e8 0f 1f 00 00       	call   182c0c <k_sem_give>

	controller->ic_sda_hold = (CONFIG_I2C_SDA_RX_HOLD << 16) +
  180cfd:	c7 46 7c 10 00 18 00 	movl   $0x180010,0x7c(%esi)
				   CONFIG_I2C_SDA_TX_HOLD;

	controller->ic_sda_setup = CONFIG_I2C_SDA_SETUP;
  180d04:	c7 86 94 00 00 00 02 	movl   $0x2,0x94(%esi)
  180d0b:	00 00 00 

	return rc;
  180d0e:	89 d8                	mov    %ebx,%eax
  180d10:	eb 0c                	jmp    180d1e <i2c_qmsi_configure+0x9c>

	cfg.raw = config;

	/* This driver only supports master mode. */
	if (!cfg.bits.is_master_device)
		return -EINVAL;
  180d12:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  180d17:	eb 05                	jmp    180d1e <i2c_qmsi_configure+0x9c>
		break;
	case I2C_SPEED_FAST_PLUS:
		qm_cfg.speed = QM_I2C_SPEED_FAST_PLUS;
		break;
	default:
		return -EINVAL;
  180d19:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
				   CONFIG_I2C_SDA_TX_HOLD;

	controller->ic_sda_setup = CONFIG_I2C_SDA_SETUP;

	return rc;
}
  180d1e:	83 c4 14             	add    $0x14,%esp
  180d21:	5b                   	pop    %ebx
  180d22:	5e                   	pop    %esi
  180d23:	5f                   	pop    %edi
  180d24:	c3                   	ret    

00180d25 <i2c_qmsi_init>:
	.configure = i2c_qmsi_configure,
	.transfer = i2c_qmsi_transfer,
};

static int i2c_qmsi_init(struct device *dev)
{
  180d25:	55                   	push   %ebp
  180d26:	57                   	push   %edi
  180d27:	56                   	push   %esi
  180d28:	53                   	push   %ebx
  180d29:	89 c6                	mov    %eax,%esi
	struct i2c_qmsi_driver_data *driver_data = GET_DRIVER_DATA(dev);
  180d2b:	8b 58 08             	mov    0x8(%eax),%ebx
	const struct i2c_qmsi_config_info *config = dev->config->config_info;
  180d2e:	8b 00                	mov    (%eax),%eax
  180d30:	8b 78 08             	mov    0x8(%eax),%edi
	qm_i2c_t instance = GET_CONTROLLER_INSTANCE(dev);
  180d33:	8b 2f                	mov    (%edi),%ebp
	int err;

	k_sem_init(&driver_data->device_sync_sem, 0, UINT_MAX);
  180d35:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  180d3a:	ba 00 00 00 00       	mov    $0x0,%edx
  180d3f:	89 d8                	mov    %ebx,%eax
  180d41:	e8 a3 1e 00 00       	call   182be9 <k_sem_init>
	k_sem_init(&driver_data->sem, 0, UINT_MAX);
  180d46:	83 c3 18             	add    $0x18,%ebx
  180d49:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  180d4e:	ba 00 00 00 00       	mov    $0x0,%edx
  180d53:	89 d8                	mov    %ebx,%eax
  180d55:	e8 8f 1e 00 00       	call   182be9 <k_sem_init>
	k_sem_give(&driver_data->sem);
  180d5a:	89 d8                	mov    %ebx,%eax
  180d5c:	e8 ab 1e 00 00       	call   182c0c <k_sem_give>

	switch (instance) {
  180d61:	85 ed                	test   %ebp,%ebp
  180d63:	75 4f                	jne    180db4 <i2c_qmsi_init+0x8f>
  180d65:	b9 00 80 00 00       	mov    $0x8000,%ecx
  180d6a:	ba 04 00 00 00       	mov    $0x4,%edx
  180d6f:	b8 24 00 00 00       	mov    $0x24,%eax
  180d74:	e8 a0 fd ff ff       	call   180b19 <__irq_controller_irq_config>
		 * to Lakemont core.
		 */
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_I2C_0_INT),
			    CONFIG_I2C_0_IRQ_PRI, qm_i2c_0_irq_isr, NULL,
			    (IOAPIC_LEVEL | IOAPIC_HIGH));
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_I2C_0_INT));
  180d79:	b8 04 00 00 00       	mov    $0x4,%eax
  180d7e:	e8 71 fd ff ff       	call   180af4 <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(
  180d83:	a1 48 04 80 b0       	mov    0xb0800448,%eax
  180d88:	83 e0 fe             	and    $0xfffffffe,%eax
  180d8b:	a3 48 04 80 b0       	mov    %eax,0xb0800448

	default:
		return -EIO;
	}

	clk_periph_enable(config->clock_gate);
  180d90:	8b 47 08             	mov    0x8(%edi),%eax
  180d93:	e8 86 04 00 00       	call   18121e <clk_periph_enable>

	err = i2c_qmsi_configure(dev, config->default_cfg.raw);
  180d98:	8b 57 04             	mov    0x4(%edi),%edx
  180d9b:	89 f0                	mov    %esi,%eax
  180d9d:	e8 e0 fe ff ff       	call   180c82 <i2c_qmsi_configure>
	if (err < 0) {
  180da2:	85 c0                	test   %eax,%eax
  180da4:	78 13                	js     180db9 <i2c_qmsi_init+0x94>
		return err;
	}

	dev->driver_api = &api;
  180da6:	c7 46 04 44 6b 18 00 	movl   $0x186b44,0x4(%esi)

	i2c_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
  180dad:	b8 00 00 00 00       	mov    $0x0,%eax
  180db2:	eb 05                	jmp    180db9 <i2c_qmsi_init+0x94>
				QM_INTERRUPT_ROUTER->i2c_master_1_int_mask);
		break;
#endif /* CONFIG_I2C_1 */

	default:
		return -EIO;
  180db4:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	dev->driver_api = &api;

	i2c_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  180db9:	5b                   	pop    %ebx
  180dba:	5e                   	pop    %esi
  180dbb:	5f                   	pop    %edi
  180dbc:	5d                   	pop    %ebp
  180dbd:	c3                   	ret    

00180dbe <pinmux_get>:
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_get(struct device *dev, uint32_t pin,
			  uint32_t *func)
{
  180dbe:	56                   	push   %esi
  180dbf:	53                   	push   %ebx
  180dc0:	89 cb                	mov    %ecx,%ebx
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
  180dc2:	89 d6                	mov    %edx,%esi
  180dc4:	c1 ee 04             	shr    $0x4,%esi

	/* The pin offset within the register */
	uint32_t pin_no = pin % 16;
  180dc7:	83 e2 0f             	and    $0xf,%edx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
  180dca:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  180dcd:	b8 03 00 00 00       	mov    $0x3,%eax
  180dd2:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
  180dd4:	8b 14 b5 30 09 80 b0 	mov    -0x4f7ff6d0(,%esi,4),%edx
  180ddb:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
  180ddd:	d3 e8                	shr    %cl,%eax

	*func = mode;
  180ddf:	89 03                	mov    %eax,(%ebx)

	return 0;
}
  180de1:	b8 00 00 00 00       	mov    $0x0,%eax
  180de6:	5b                   	pop    %ebx
  180de7:	5e                   	pop    %esi
  180de8:	c3                   	ret    

00180de9 <pinmux_initialize>:
};

static int pinmux_initialize(struct device *port)
{
	return 0;
}
  180de9:	b8 00 00 00 00       	mov    $0x0,%eax
  180dee:	c3                   	ret    

00180def <pinmux_input>:
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_input(struct device *dev, uint32_t pin,
			    uint8_t func)
{
  180def:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
  180df1:	84 c9                	test   %cl,%cl
  180df3:	0f 95 c2             	setne  %dl
  180df6:	0f b6 d2             	movzbl %dl,%edx
  180df9:	e8 a1 0f 00 00       	call   181d9f <qm_pmux_input_en>
  180dfe:	85 c0                	test   %eax,%eax
  180e00:	74 05                	je     180e07 <pinmux_input+0x18>
  180e02:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180e07:	c3                   	ret    

00180e08 <pinmux_pullup>:
	return 0;
}

static int pinmux_pullup(struct device *dev, uint32_t pin,
			     uint8_t func)
{
  180e08:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
  180e0a:	84 c9                	test   %cl,%cl
  180e0c:	0f 95 c2             	setne  %dl
  180e0f:	0f b6 d2             	movzbl %dl,%edx
  180e12:	e8 e9 0f 00 00       	call   181e00 <qm_pmux_pullup_en>
  180e17:	85 c0                	test   %eax,%eax
  180e19:	74 05                	je     180e20 <pinmux_pullup+0x18>
  180e1b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180e20:	c3                   	ret    

00180e21 <pinmux_set>:

#define MASK_2_BITS	0x3

static int pinmux_set(struct device *dev, uint32_t pin,
			  uint32_t func)
{
  180e21:	89 d0                	mov    %edx,%eax
  180e23:	89 ca                	mov    %ecx,%edx
	ARG_UNUSED(dev);

	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
  180e25:	e8 1d 0f 00 00       	call   181d47 <qm_pmux_select>
  180e2a:	85 c0                	test   %eax,%eax
  180e2c:	74 05                	je     180e33 <pinmux_set+0x12>
  180e2e:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180e33:	c3                   	ret    

00180e34 <_sbrk>:
	return 0;
}
FUNC_ALIAS(_lseek, lseek, int);

void *_sbrk(int count)
{
  180e34:	53                   	push   %ebx
	void *ptr = heap_base + heap_sz;
  180e35:	8b 15 cc 03 28 00    	mov    0x2803cc,%edx
  180e3b:	8d 9a a0 09 28 00    	lea    0x2809a0(%edx),%ebx

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
  180e41:	01 c2                	add    %eax,%edx
  180e43:	b9 00 20 28 00       	mov    $0x282000,%ecx
  180e48:	81 e9 a0 09 28 00    	sub    $0x2809a0,%ecx
  180e4e:	39 ca                	cmp    %ecx,%edx
  180e50:	73 0a                	jae    180e5c <_sbrk+0x28>
		heap_sz += count;
  180e52:	89 15 cc 03 28 00    	mov    %edx,0x2803cc
		return ptr;
  180e58:	89 d8                	mov    %ebx,%eax
  180e5a:	eb 05                	jmp    180e61 <_sbrk+0x2d>
	} else {
		return (void *)-1;
  180e5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
  180e61:	5b                   	pop    %ebx
  180e62:	c3                   	ret    

00180e63 <_nop_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  180e63:	b8 00 00 00 00       	mov    $0x0,%eax
  180e68:	c3                   	ret    

00180e69 <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
  180e69:	8b 0a                	mov    (%edx),%ecx
  180e6b:	41                   	inc    %ecx
  180e6c:	89 0a                	mov    %ecx,(%edx)
	return _char_out(c);
  180e6e:	ff 15 b4 02 28 00    	call   *0x2802b4
}
  180e74:	c3                   	ret    

00180e75 <_printk_hex_ulong>:
 * @return N/A
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  180e75:	55                   	push   %ebp
  180e76:	57                   	push   %edi
  180e77:	56                   	push   %esi
  180e78:	53                   	push   %ebx
  180e79:	83 ec 08             	sub    $0x8,%esp
  180e7c:	89 c5                	mov    %eax,%ebp
  180e7e:	89 14 24             	mov    %edx,(%esp)
  180e81:	89 cf                	mov    %ecx,%edi
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
  180e83:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  180e8a:	00 
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
  180e8b:	bb 00 00 00 00       	mov    $0x0,%ebx
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
  180e90:	ba 08 00 00 00       	mov    $0x8,%edx
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  180e95:	eb 65                	jmp    180efc <_printk_hex_ulong+0x87>
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  180e97:	8d 72 ff             	lea    -0x1(%edx),%esi
  180e9a:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  180ea1:	89 f8                	mov    %edi,%eax
  180ea3:	d3 e8                	shr    %cl,%eax

		if (nibble || found_largest_digit || size == 1) {
  180ea5:	83 e0 0f             	and    $0xf,%eax
  180ea8:	0f 95 c1             	setne  %cl
  180eab:	08 d9                	or     %bl,%cl
  180ead:	75 05                	jne    180eb4 <_printk_hex_ulong+0x3f>
  180eaf:	83 fa 01             	cmp    $0x1,%edx
  180eb2:	75 1b                	jne    180ecf <_printk_hex_ulong+0x5a>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
  180eb4:	3c 09                	cmp    $0x9,%al
  180eb6:	7e 04                	jle    180ebc <_printk_hex_ulong+0x47>
  180eb8:	b2 57                	mov    $0x57,%dl
  180eba:	eb 02                	jmp    180ebe <_printk_hex_ulong+0x49>
  180ebc:	b2 30                	mov    $0x30,%dl
  180ebe:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
  180ec0:	0f be c0             	movsbl %al,%eax
  180ec3:	8b 14 24             	mov    (%esp),%edx
  180ec6:	ff d5                	call   *%ebp

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  180ec8:	bb 01 00 00 00       	mov    $0x1,%ebx
			nibble += nibble > 9 ? 87 : 48;
			out((int)nibble, ctx);
			continue;
  180ecd:	eb 2b                	jmp    180efa <_printk_hex_ulong+0x85>
		}

		if (remaining-- <= min_width) {
  180ecf:	8b 44 24 04          	mov    0x4(%esp),%eax
  180ed3:	8d 48 ff             	lea    -0x1(%eax),%ecx
  180ed6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  180eda:	3b 44 24 20          	cmp    0x20(%esp),%eax
  180ede:	7f 1a                	jg     180efa <_printk_hex_ulong+0x85>
			out((int)(pad_zero ? '0' : ' '), ctx);
  180ee0:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  180ee5:	74 07                	je     180eee <_printk_hex_ulong+0x79>
  180ee7:	b8 30 00 00 00       	mov    $0x30,%eax
  180eec:	eb 05                	jmp    180ef3 <_printk_hex_ulong+0x7e>
  180eee:	b8 20 00 00 00       	mov    $0x20,%eax
  180ef3:	8b 14 24             	mov    (%esp),%edx
  180ef6:	ff d5                	call   *%ebp
  180ef8:	eb 00                	jmp    180efa <_printk_hex_ulong+0x85>

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  180efa:	89 f2                	mov    %esi,%edx
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  180efc:	85 d2                	test   %edx,%edx
  180efe:	75 97                	jne    180e97 <_printk_hex_ulong+0x22>

		if (remaining-- <= min_width) {
			out((int)(pad_zero ? '0' : ' '), ctx);
		}
	}
}
  180f00:	83 c4 08             	add    $0x8,%esp
  180f03:	5b                   	pop    %ebx
  180f04:	5e                   	pop    %esi
  180f05:	5f                   	pop    %edi
  180f06:	5d                   	pop    %ebp
  180f07:	c3                   	ret    

00180f08 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  180f08:	55                   	push   %ebp
  180f09:	57                   	push   %edi
  180f0a:	56                   	push   %esi
  180f0b:	53                   	push   %ebx
  180f0c:	83 ec 08             	sub    $0x8,%esp
  180f0f:	89 c5                	mov    %eax,%ebp
  180f11:	89 54 24 04          	mov    %edx,0x4(%esp)
	unsigned long remainder = num;
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  180f15:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  180f1a:	7f 08                	jg     180f24 <_printk_dec_ulong+0x1c>
		min_width = 1;
  180f1c:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  180f23:	00 
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  180f24:	89 0c 24             	mov    %ecx,(%esp)
  180f27:	bf 0a 00 00 00       	mov    $0xa,%edi
  180f2c:	bb 00 00 00 00       	mov    $0x0,%ebx
  180f31:	be ff c9 9a 3b       	mov    $0x3b9ac9ff,%esi
  180f36:	eb 65                	jmp    180f9d <_printk_dec_ulong+0x95>
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  180f38:	3b 34 24             	cmp    (%esp),%esi
  180f3b:	0f 92 c0             	setb   %al
  180f3e:	08 d8                	or     %bl,%al
  180f40:	74 1d                	je     180f5f <_printk_dec_ulong+0x57>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
  180f42:	8d 4e 01             	lea    0x1(%esi),%ecx
  180f45:	8b 04 24             	mov    (%esp),%eax
  180f48:	ba 00 00 00 00       	mov    $0x0,%edx
  180f4d:	f7 f1                	div    %ecx
  180f4f:	83 c0 30             	add    $0x30,%eax
  180f52:	8b 54 24 04          	mov    0x4(%esp),%edx
  180f56:	ff d5                	call   *%ebp
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  180f58:	bb 01 00 00 00       	mov    $0x1,%ebx
  180f5d:	eb 1f                	jmp    180f7e <_printk_dec_ulong+0x76>
			out((int)((remainder / (pos + 1)) + 48), ctx);
		} else if (remaining <= min_width) {
  180f5f:	3b 7c 24 20          	cmp    0x20(%esp),%edi
  180f63:	7f 19                	jg     180f7e <_printk_dec_ulong+0x76>
			out((int)(pad_zero ? '0' : ' '), ctx);
  180f65:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  180f6a:	74 07                	je     180f73 <_printk_dec_ulong+0x6b>
  180f6c:	b8 30 00 00 00       	mov    $0x30,%eax
  180f71:	eb 05                	jmp    180f78 <_printk_dec_ulong+0x70>
  180f73:	b8 20 00 00 00       	mov    $0x20,%eax
  180f78:	8b 54 24 04          	mov    0x4(%esp),%edx
  180f7c:	ff d5                	call   *%ebp
		}
		remaining--;
  180f7e:	4f                   	dec    %edi
		remainder %= (pos + 1);
  180f7f:	8d 4e 01             	lea    0x1(%esi),%ecx
  180f82:	8b 04 24             	mov    (%esp),%eax
  180f85:	ba 00 00 00 00       	mov    $0x0,%edx
  180f8a:	f7 f1                	div    %ecx
  180f8c:	89 14 24             	mov    %edx,(%esp)
		pos /= 10;
  180f8f:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  180f94:	89 f0                	mov    %esi,%eax
  180f96:	f7 e2                	mul    %edx
  180f98:	89 d6                	mov    %edx,%esi
  180f9a:	c1 ee 03             	shr    $0x3,%esi
	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
  180f9d:	83 fe 08             	cmp    $0x8,%esi
  180fa0:	77 96                	ja     180f38 <_printk_dec_ulong+0x30>
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
	}
	out((int)(remainder + 48), ctx);
  180fa2:	8b 04 24             	mov    (%esp),%eax
  180fa5:	83 c0 30             	add    $0x30,%eax
  180fa8:	8b 54 24 04          	mov    0x4(%esp),%edx
  180fac:	ff d5                	call   *%ebp
}
  180fae:	83 c4 08             	add    $0x8,%esp
  180fb1:	5b                   	pop    %ebx
  180fb2:	5e                   	pop    %esi
  180fb3:	5f                   	pop    %edi
  180fb4:	5d                   	pop    %ebp
  180fb5:	c3                   	ret    

00180fb6 <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  180fb6:	a3 b4 02 28 00       	mov    %eax,0x2802b4
  180fbb:	c3                   	ret    

00180fbc <_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
  180fbc:	55                   	push   %ebp
  180fbd:	57                   	push   %edi
  180fbe:	56                   	push   %esi
  180fbf:	53                   	push   %ebx
  180fc0:	83 ec 10             	sub    $0x10,%esp
  180fc3:	89 c7                	mov    %eax,%edi
  180fc5:	89 54 24 04          	mov    %edx,0x4(%esp)
  180fc9:	89 cb                	mov    %ecx,%ebx
  180fcb:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
	int min_width = -1;
  180fcf:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
  180fd6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180fdd:	00 
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  180fde:	be 00 00 00 00       	mov    $0x0,%esi
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  180fe3:	e9 af 01 00 00       	jmp    181197 <_vprintk+0x1db>
		if (!might_format) {
  180fe8:	85 f6                	test   %esi,%esi
  180fea:	75 16                	jne    181002 <_vprintk+0x46>
			if (*fmt != '%') {
  180fec:	3c 25                	cmp    $0x25,%al
  180fee:	0f 84 84 01 00 00    	je     181178 <_vprintk+0x1bc>
				out((int)*fmt, ctx);
  180ff4:	0f be c0             	movsbl %al,%eax
  180ff7:	8b 54 24 04          	mov    0x4(%esp),%edx
  180ffb:	ff d7                	call   *%edi
  180ffd:	e9 94 01 00 00       	jmp    181196 <_vprintk+0x1da>
				might_format = 1;
				min_width = -1;
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
  181002:	8d 50 db             	lea    -0x25(%eax),%edx
  181005:	80 fa 55             	cmp    $0x55,%dl
  181008:	0f 87 4f 01 00 00    	ja     18115d <_vprintk+0x1a1>
  18100e:	0f b6 d2             	movzbl %dl,%edx
  181011:	ff 24 95 80 6b 18 00 	jmp    *0x186b80(,%edx,4)
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  181018:	8b 14 24             	mov    (%esp),%edx
  18101b:	c1 ea 1f             	shr    $0x1f,%edx
  18101e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  181023:	0f 94 c1             	sete   %cl
  181026:	84 d1                	test   %dl,%cl
  181028:	0f 85 60 01 00 00    	jne    18118e <_vprintk+0x1d2>
					pad_zero = 1;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
  18102e:	83 3c 24 00          	cmpl   $0x0,(%esp)
  181032:	79 0e                	jns    181042 <_vprintk+0x86>
					min_width = *fmt - '0';
  181034:	0f be c0             	movsbl %al,%eax
  181037:	83 e8 30             	sub    $0x30,%eax
  18103a:	89 04 24             	mov    %eax,(%esp)
  18103d:	e9 54 01 00 00       	jmp    181196 <_vprintk+0x1da>
				} else {
					min_width = 10 * min_width + *fmt - '0';
  181042:	8b 0c 24             	mov    (%esp),%ecx
  181045:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  181048:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  18104b:	0f be c0             	movsbl %al,%eax
  18104e:	8d 44 02 d0          	lea    -0x30(%edx,%eax,1),%eax
  181052:	89 04 24             	mov    %eax,(%esp)
  181055:	e9 3c 01 00 00       	jmp    181196 <_vprintk+0x1da>
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  18105a:	8d 75 04             	lea    0x4(%ebp),%esi
  18105d:	8b 6d 00             	mov    0x0(%ebp),%ebp

				if (d < 0) {
  181060:	85 ed                	test   %ebp,%ebp
  181062:	79 10                	jns    181074 <_vprintk+0xb8>
					out((int)'-', ctx);
  181064:	8b 54 24 04          	mov    0x4(%esp),%edx
  181068:	b8 2d 00 00 00       	mov    $0x2d,%eax
  18106d:	ff d7                	call   *%edi
					d = -d;
  18106f:	f7 dd                	neg    %ebp
					min_width--;
  181071:	ff 0c 24             	decl   (%esp)
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
  181074:	ff 34 24             	pushl  (%esp)
  181077:	ff 74 24 0c          	pushl  0xc(%esp)
  18107b:	89 e9                	mov    %ebp,%ecx
  18107d:	8b 54 24 0c          	mov    0xc(%esp),%edx
  181081:	89 f8                	mov    %edi,%eax
  181083:	e8 80 fe ff ff       	call   180f08 <_printk_dec_ulong>
  181088:	83 c4 08             	add    $0x8,%esp
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  18108b:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  18108d:	be 00 00 00 00       	mov    $0x0,%esi
					d = -d;
					min_width--;
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
  181092:	e9 ff 00 00 00       	jmp    181196 <_vprintk+0x1da>
			}
			case 'u': {
				unsigned long u = va_arg(
  181097:	8d 75 04             	lea    0x4(%ebp),%esi
  18109a:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
  18109d:	ff 34 24             	pushl  (%esp)
  1810a0:	ff 74 24 0c          	pushl  0xc(%esp)
  1810a4:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1810a8:	89 f8                	mov    %edi,%eax
  1810aa:	e8 59 fe ff ff       	call   180f08 <_printk_dec_ulong>
  1810af:	83 c4 08             	add    $0x8,%esp
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  1810b2:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  1810b4:	be 00 00 00 00       	mov    $0x0,%esi
			case 'u': {
				unsigned long u = va_arg(
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
						  min_width);
				break;
  1810b9:	e9 d8 00 00 00       	jmp    181196 <_vprintk+0x1da>
			}
			case 'p':
				  out('0', ctx);
  1810be:	8b 74 24 04          	mov    0x4(%esp),%esi
  1810c2:	89 f2                	mov    %esi,%edx
  1810c4:	b8 30 00 00 00       	mov    $0x30,%eax
  1810c9:	ff d7                	call   *%edi
				  out('x', ctx);
  1810cb:	89 f2                	mov    %esi,%edx
  1810cd:	b8 78 00 00 00       	mov    $0x78,%eax
  1810d2:	ff d7                	call   *%edi
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
				  min_width = 8;
  1810d4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
			}
			case 'p':
				  out('0', ctx);
				  out('x', ctx);
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
  1810db:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1810e2:	00 
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  1810e3:	8d 75 04             	lea    0x4(%ebp),%esi
  1810e6:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
  1810e9:	ff 34 24             	pushl  (%esp)
  1810ec:	ff 74 24 0c          	pushl  0xc(%esp)
  1810f0:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1810f4:	89 f8                	mov    %edi,%eax
  1810f6:	e8 7a fd ff ff       	call   180e75 <_printk_hex_ulong>
  1810fb:	83 c4 08             	add    $0x8,%esp
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  1810fe:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181100:	be 00 00 00 00       	mov    $0x0,%esi
			case 'X': {
				unsigned long x = va_arg(
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
  181105:	e9 8c 00 00 00       	jmp    181196 <_vprintk+0x1da>
			}
			case 's': {
				char *s = va_arg(ap, char *);
  18110a:	8d 75 04             	lea    0x4(%ebp),%esi
  18110d:	8b 6d 00             	mov    0x0(%ebp),%ebp
  181110:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  181114:	8b 5c 24 04          	mov    0x4(%esp),%ebx

				while (*s)
  181118:	eb 08                	jmp    181122 <_vprintk+0x166>
					out((int)(*s++), ctx);
  18111a:	45                   	inc    %ebp
  18111b:	0f be c0             	movsbl %al,%eax
  18111e:	89 da                	mov    %ebx,%edx
  181120:	ff d7                	call   *%edi
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);

				while (*s)
  181122:	8a 45 00             	mov    0x0(%ebp),%al
  181125:	84 c0                	test   %al,%al
  181127:	75 f1                	jne    18111a <_vprintk+0x15e>
  181129:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  18112d:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  18112f:	be 00 00 00 00       	mov    $0x0,%esi
  181134:	eb 60                	jmp    181196 <_vprintk+0x1da>
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  181136:	8d 75 04             	lea    0x4(%ebp),%esi
  181139:	8b 45 00             	mov    0x0(%ebp),%eax

				out(c, ctx);
  18113c:	8b 54 24 04          	mov    0x4(%esp),%edx
  181140:	ff d7                	call   *%edi
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  181142:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181144:	be 00 00 00 00       	mov    $0x0,%esi
			}
			case 'c': {
				int c = va_arg(ap, int);

				out(c, ctx);
				break;
  181149:	eb 4b                	jmp    181196 <_vprintk+0x1da>
			}
			case '%': {
				out((int)'%', ctx);
  18114b:	8b 54 24 04          	mov    0x4(%esp),%edx
  18114f:	b8 25 00 00 00       	mov    $0x25,%eax
  181154:	ff d7                	call   *%edi
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181156:	be 00 00 00 00       	mov    $0x0,%esi
				out(c, ctx);
				break;
			}
			case '%': {
				out((int)'%', ctx);
				break;
  18115b:	eb 39                	jmp    181196 <_vprintk+0x1da>
			}
			default:
				out((int)'%', ctx);
  18115d:	8b 74 24 04          	mov    0x4(%esp),%esi
  181161:	89 f2                	mov    %esi,%edx
  181163:	b8 25 00 00 00       	mov    $0x25,%eax
  181168:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
  18116a:	0f be 03             	movsbl (%ebx),%eax
  18116d:	89 f2                	mov    %esi,%edx
  18116f:	ff d7                	call   *%edi
				break;
			}
			might_format = 0;
  181171:	be 00 00 00 00       	mov    $0x0,%esi
				break;
			}
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
  181176:	eb 1e                	jmp    181196 <_vprintk+0x1da>
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
  181178:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
				pad_zero = 0;
  18117f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  181186:	00 
	while (*fmt) {
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
  181187:	be 01 00 00 00       	mov    $0x1,%esi
  18118c:	eb 08                	jmp    181196 <_vprintk+0x1da>
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
					pad_zero = 1;
  18118e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  181195:	00 
				break;
			}
			might_format = 0;
		}
still_might_format:
		++fmt;
  181196:	43                   	inc    %ebx
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  181197:	8a 03                	mov    (%ebx),%al
  181199:	84 c0                	test   %al,%al
  18119b:	0f 85 47 fe ff ff    	jne    180fe8 <_vprintk+0x2c>
			might_format = 0;
		}
still_might_format:
		++fmt;
	}
}
  1811a1:	83 c4 10             	add    $0x10,%esp
  1811a4:	5b                   	pop    %ebx
  1811a5:	5e                   	pop    %esi
  1811a6:	5f                   	pop    %edi
  1811a7:	5d                   	pop    %ebp
  1811a8:	c3                   	ret    

001811a9 <printk>:
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
  1811a9:	83 ec 04             	sub    $0x4,%esp
	struct out_context ctx = { 0 };
  1811ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	va_list ap;

	va_start(ap, fmt);
  1811b3:	8d 44 24 0c          	lea    0xc(%esp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
  1811b7:	50                   	push   %eax
  1811b8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  1811bc:	8d 54 24 04          	lea    0x4(%esp),%edx
  1811c0:	b8 69 0e 18 00       	mov    $0x180e69,%eax
  1811c5:	e8 f2 fd ff ff       	call   180fbc <_vprintk>
	va_end(ap);

	return ctx.count;
}
  1811ca:	8b 44 24 04          	mov    0x4(%esp),%eax
  1811ce:	83 c4 08             	add    $0x8,%esp
  1811d1:	c3                   	ret    

001811d2 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_SOC, 1);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
  1811d2:	c3                   	ret    

001811d3 <_pinmux_defaults>:
/******** End PINMUX mapping **************************/

#define PINMUX_MAX_REGISTERS 2

static void _pinmux_defaults(uint32_t base)
{
  1811d3:	53                   	push   %ebx
  1811d4:	83 ec 08             	sub    $0x8,%esp
	PIN_CONFIG(mux_config,  6, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config,  7, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 12, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 13, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 14, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
  1811d7:	c7 04 24 42 a1 00 aa 	movl   $0xaa00a142,(%esp)
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);
  1811de:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  1811e5:	00 

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  1811e6:	ba 00 00 00 00       	mov    $0x0,%edx
  1811eb:	eb 0a                	jmp    1811f7 <_pinmux_defaults+0x24>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
  1811ed:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
  1811f0:	8b 0c 94             	mov    (%esp,%edx,4),%ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1811f3:	89 4b 30             	mov    %ecx,0x30(%ebx)
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  1811f6:	42                   	inc    %edx
  1811f7:	83 fa 01             	cmp    $0x1,%edx
  1811fa:	7e f1                	jle    1811ed <_pinmux_defaults+0x1a>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}
  1811fc:	83 c4 08             	add    $0x8,%esp
  1811ff:	5b                   	pop    %ebx
  181200:	c3                   	ret    

00181201 <pinmux_initialize>:

static int pinmux_initialize(struct device *port)
{
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);
  181201:	b8 00 09 80 b0       	mov    $0xb0800900,%eax
  181206:	e8 c8 ff ff ff       	call   1811d3 <_pinmux_defaults>

	/*
	 * MAGIC NUMBER: 0x1 is used as the pullup is a single bit in a
	 * 32-bit register.
	 */
	(*(mux_register)) = ((*(mux_register)) & ~(0x1 << pin_offset)) |
  18120b:	a1 20 09 80 b0       	mov    0xb0800920,%eax
  181210:	83 c8 20             	or     $0x20,%eax
  181213:	a3 20 09 80 b0       	mov    %eax,0xb0800920

	/* Enable the UART RX pin to receive input */
	_quark_mcu_set_mux(PINMUX_BASE_ADDR + PINMUX_INPUT_OFFSET, 5, 0x1);

	return 0;
}
  181218:	b8 00 00 00 00       	mov    $0x0,%eax
  18121d:	c3                   	ret    

0018121e <clk_periph_enable>:

int clk_periph_enable(const clk_periph_t clocks)
{
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
  18121e:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
  181224:	09 d0                	or     %edx,%eax
  181226:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
  18122b:	b8 00 00 00 00       	mov    $0x0,%eax
  181230:	c3                   	ret    

00181231 <clk_sys_get_ticks_per_us>:
}

uint32_t clk_sys_get_ticks_per_us(void)
{
	return ticks_per_us;
}
  181231:	a1 b8 02 28 00       	mov    0x2802b8,%eax
  181236:	c3                   	ret    

00181237 <clk_sys_udelay>:

void clk_sys_udelay(uint32_t microseconds)
{
  181237:	56                   	push   %esi
  181238:	53                   	push   %ebx
	uint32_t timeout = ticks_per_us * microseconds;
  181239:	0f af 05 b8 02 28 00 	imul   0x2802b8,%eax
  181240:	89 c6                	mov    %eax,%esi
/* rdtsc */
extern __inline unsigned long long
__attribute__((__gnu_inline__, __always_inline__, __artificial__))
__rdtsc (void)
{
  return __builtin_ia32_rdtsc ();
  181242:	0f 31                	rdtsc  
  181244:	89 c1                	mov    %eax,%ecx
  181246:	89 d3                	mov    %edx,%ebx
  181248:	0f 31                	rdtsc  
	unsigned long long tsc_start;
	tsc_start = get_ticks();
	/* We need to wait until timeout system clock ticks has occurred. */
	while (get_ticks() - tsc_start < timeout) {
  18124a:	29 c8                	sub    %ecx,%eax
  18124c:	19 da                	sbb    %ebx,%edx
  18124e:	83 fa 00             	cmp    $0x0,%edx
  181251:	77 04                	ja     181257 <clk_sys_udelay+0x20>
  181253:	39 f0                	cmp    %esi,%eax
  181255:	72 f1                	jb     181248 <clk_sys_udelay+0x11>
	}
}
  181257:	5b                   	pop    %ebx
  181258:	5e                   	pop    %esi
  181259:	c3                   	ret    

0018125a <get_i2c_clk_freq_in_mhz>:
 *
 * @return [uint32_t] I2C freq_in_mhz.
 */
uint32_t get_i2c_clk_freq_in_mhz(void)
{
	return clk_sys_get_ticks_per_us() >>
  18125a:	e8 d2 ff ff ff       	call   181231 <clk_sys_get_ticks_per_us>
	       ((QM_SCSS_CCU->ccu_periph_clk_div_ctl0 &
  18125f:	8b 0d 1c 00 80 b0    	mov    0xb080001c,%ecx
  181265:	83 e1 f9             	and    $0xfffffff9,%ecx
		 CLK_PERIPH_DIV_DEF_MASK) >>
  181268:	d1 e9                	shr    %ecx
 *
 * @return [uint32_t] I2C freq_in_mhz.
 */
uint32_t get_i2c_clk_freq_in_mhz(void)
{
	return clk_sys_get_ticks_per_us() >>
  18126a:	d3 e8                	shr    %cl,%eax
	       ((QM_SCSS_CCU->ccu_periph_clk_div_ctl0 &
		 CLK_PERIPH_DIV_DEF_MASK) >>
		QM_CCU_PERIPH_PCLK_DIV_OFFSET);
}
  18126c:	c3                   	ret    

0018126d <empty_rx_fifo>:
 * received data.
 */
static void empty_rx_fifo(const qm_i2c_t i2c,
			  const volatile qm_i2c_transfer_t *const transfer,
			  qm_i2c_reg_t *const controller)
{
  18126d:	55                   	push   %ebp
  18126e:	57                   	push   %edi
  18126f:	56                   	push   %esi
  181270:	53                   	push   %ebx
  181271:	89 c7                	mov    %eax,%edi
  181273:	89 d6                	mov    %edx,%esi
  181275:	89 cb                	mov    %ecx,%ebx
	while (controller->ic_status & QM_I2C_IC_STATUS_RFNE) {
  181277:	eb 6b                	jmp    1812e4 <empty_rx_fifo+0x77>
		if (!transfer_ongoing) {
  181279:	a0 d2 03 28 00       	mov    0x2803d2,%al
  18127e:	84 c0                	test   %al,%al
  181280:	75 05                	jne    181287 <empty_rx_fifo+0x1a>
			/* Dummy read. */
			controller->ic_data_cmd;
  181282:	8b 43 10             	mov    0x10(%ebx),%eax
  181285:	eb 5d                	jmp    1812e4 <empty_rx_fifo+0x77>
		} else {
			if (transfer->rx_len > i2c_read_pos[i2c]) {
  181287:	8b 56 0c             	mov    0xc(%esi),%edx
  18128a:	8b 04 bd d8 03 28 00 	mov    0x2803d8(,%edi,4),%eax
  181291:	39 c2                	cmp    %eax,%edx
  181293:	76 1a                	jbe    1812af <empty_rx_fifo+0x42>
				transfer->rx[i2c_read_pos[i2c]++] =
  181295:	8b 56 08             	mov    0x8(%esi),%edx
  181298:	8b 04 bd d8 03 28 00 	mov    0x2803d8(,%edi,4),%eax
  18129f:	8d 48 01             	lea    0x1(%eax),%ecx
  1812a2:	89 0c bd d8 03 28 00 	mov    %ecx,0x2803d8(,%edi,4)
				    controller->ic_data_cmd & 0xFF;
  1812a9:	8b 4b 10             	mov    0x10(%ebx),%ecx
		if (!transfer_ongoing) {
			/* Dummy read. */
			controller->ic_data_cmd;
		} else {
			if (transfer->rx_len > i2c_read_pos[i2c]) {
				transfer->rx[i2c_read_pos[i2c]++] =
  1812ac:	88 0c 02             	mov    %cl,(%edx,%eax,1)
				    controller->ic_data_cmd & 0xFF;
			}

			if (transfer->rx_len == i2c_read_pos[i2c]) {
  1812af:	8b 56 0c             	mov    0xc(%esi),%edx
  1812b2:	8b 04 bd d8 03 28 00 	mov    0x2803d8(,%edi,4),%eax
  1812b9:	39 c2                	cmp    %eax,%edx
  1812bb:	75 27                	jne    1812e4 <empty_rx_fifo+0x77>
				/*
				 * End user transfer if user does not update
				 * buffers.
				 */
				transfer_ongoing = false;
  1812bd:	c6 05 d2 03 28 00 00 	movb   $0x0,0x2803d2

				if (transfer->callback) {
  1812c4:	8b 46 14             	mov    0x14(%esi),%eax
  1812c7:	85 c0                	test   %eax,%eax
  1812c9:	74 19                	je     1812e4 <empty_rx_fifo+0x77>
					transfer->callback(
  1812cb:	8b 6e 14             	mov    0x14(%esi),%ebp
  1812ce:	8b 56 0c             	mov    0xc(%esi),%edx
  1812d1:	8b 46 18             	mov    0x18(%esi),%eax
  1812d4:	52                   	push   %edx
  1812d5:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  1812da:	ba 00 00 00 00       	mov    $0x0,%edx
  1812df:	ff d5                	call   *%ebp
  1812e1:	83 c4 04             	add    $0x4,%esp
 */
static void empty_rx_fifo(const qm_i2c_t i2c,
			  const volatile qm_i2c_transfer_t *const transfer,
			  qm_i2c_reg_t *const controller)
{
	while (controller->ic_status & QM_I2C_IC_STATUS_RFNE) {
  1812e4:	8b 43 70             	mov    0x70(%ebx),%eax
  1812e7:	a8 08                	test   $0x8,%al
  1812e9:	75 8e                	jne    181279 <empty_rx_fifo+0xc>
					    QM_I2C_RX_FULL, transfer->rx_len);
				}
			}
		}
	}
}
  1812eb:	5b                   	pop    %ebx
  1812ec:	5e                   	pop    %esi
  1812ed:	5f                   	pop    %edi
  1812ee:	5d                   	pop    %ebp
  1812ef:	c3                   	ret    

001812f0 <slave_fill_tx_fifo>:
 * data.
 */
static void slave_fill_tx_fifo(const qm_i2c_t i2c,
			       const volatile qm_i2c_transfer_t *const transfer,
			       qm_i2c_reg_t *const controller)
{
  1812f0:	55                   	push   %ebp
  1812f1:	57                   	push   %edi
  1812f2:	56                   	push   %esi
  1812f3:	53                   	push   %ebx
  1812f4:	89 c7                	mov    %eax,%edi
  1812f6:	89 d6                	mov    %edx,%esi
  1812f8:	89 cb                	mov    %ecx,%ebx
	while ((controller->ic_status & QM_I2C_IC_STATUS_TNF) &&
  1812fa:	eb 6f                	jmp    18136b <slave_fill_tx_fifo+0x7b>
	       (!(controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_ABRT))) {
		if (!transfer_ongoing) {
  1812fc:	a0 d2 03 28 00       	mov    0x2803d2,%al
  181301:	84 c0                	test   %al,%al
  181303:	75 09                	jne    18130e <slave_fill_tx_fifo+0x1e>
			/* Dummy write. */
			controller->ic_data_cmd = 0;
  181305:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  18130c:	eb 5d                	jmp    18136b <slave_fill_tx_fifo+0x7b>

		} else {
			if (transfer->tx_len > i2c_write_pos[i2c]) {
  18130e:	8b 56 04             	mov    0x4(%esi),%edx
  181311:	8b 04 bd dc 03 28 00 	mov    0x2803dc(,%edi,4),%eax
  181318:	39 c2                	cmp    %eax,%edx
  18131a:	76 1a                	jbe    181336 <slave_fill_tx_fifo+0x46>
				controller->ic_data_cmd =
				    transfer->tx[i2c_write_pos[i2c]++];
  18131c:	8b 16                	mov    (%esi),%edx
  18131e:	8b 04 bd dc 03 28 00 	mov    0x2803dc(,%edi,4),%eax
  181325:	8d 48 01             	lea    0x1(%eax),%ecx
  181328:	89 0c bd dc 03 28 00 	mov    %ecx,0x2803dc(,%edi,4)
			/* Dummy write. */
			controller->ic_data_cmd = 0;

		} else {
			if (transfer->tx_len > i2c_write_pos[i2c]) {
				controller->ic_data_cmd =
  18132f:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
  181333:	89 43 10             	mov    %eax,0x10(%ebx)
				    transfer->tx[i2c_write_pos[i2c]++];
			}

			if (transfer->tx_len == i2c_write_pos[i2c]) {
  181336:	8b 56 04             	mov    0x4(%esi),%edx
  181339:	8b 04 bd dc 03 28 00 	mov    0x2803dc(,%edi,4),%eax
  181340:	39 c2                	cmp    %eax,%edx
  181342:	75 27                	jne    18136b <slave_fill_tx_fifo+0x7b>
				/*
				 * End user transfer if user does not update
				 * buffers.
				 */
				transfer_ongoing = false;
  181344:	c6 05 d2 03 28 00 00 	movb   $0x0,0x2803d2

				if (transfer->callback) {
  18134b:	8b 46 14             	mov    0x14(%esi),%eax
  18134e:	85 c0                	test   %eax,%eax
  181350:	74 19                	je     18136b <slave_fill_tx_fifo+0x7b>
					transfer->callback(
  181352:	8b 6e 14             	mov    0x14(%esi),%ebp
  181355:	8b 56 04             	mov    0x4(%esi),%edx
  181358:	8b 46 18             	mov    0x18(%esi),%eax
  18135b:	52                   	push   %edx
  18135c:	b9 00 00 80 00       	mov    $0x800000,%ecx
  181361:	ba 00 00 00 00       	mov    $0x0,%edx
  181366:	ff d5                	call   *%ebp
  181368:	83 c4 04             	add    $0x4,%esp
 */
static void slave_fill_tx_fifo(const qm_i2c_t i2c,
			       const volatile qm_i2c_transfer_t *const transfer,
			       qm_i2c_reg_t *const controller)
{
	while ((controller->ic_status & QM_I2C_IC_STATUS_TNF) &&
  18136b:	8b 43 70             	mov    0x70(%ebx),%eax
  18136e:	a8 02                	test   $0x2,%al
  181370:	74 07                	je     181379 <slave_fill_tx_fifo+0x89>
	       (!(controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_ABRT))) {
  181372:	8b 43 2c             	mov    0x2c(%ebx),%eax
 */
static void slave_fill_tx_fifo(const qm_i2c_t i2c,
			       const volatile qm_i2c_transfer_t *const transfer,
			       qm_i2c_reg_t *const controller)
{
	while ((controller->ic_status & QM_I2C_IC_STATUS_TNF) &&
  181375:	a8 40                	test   $0x40,%al
  181377:	74 83                	je     1812fc <slave_fill_tx_fifo+0xc>
					    QM_I2C_TX_EMPTY, transfer->tx_len);
				}
			}
		}
	}
}
  181379:	5b                   	pop    %ebx
  18137a:	5e                   	pop    %esi
  18137b:	5f                   	pop    %edi
  18137c:	5d                   	pop    %ebp
  18137d:	c3                   	ret    

0018137e <master_fill_tx_fifo>:

static uint32_t
master_fill_tx_fifo(const qm_i2c_t i2c,
		    const volatile qm_i2c_transfer_t *const transfer,
		    qm_i2c_reg_t *const controller)
{
  18137e:	55                   	push   %ebp
  18137f:	57                   	push   %edi
  181380:	56                   	push   %esi
  181381:	53                   	push   %ebx
  181382:	83 ec 04             	sub    $0x4,%esp
  181385:	89 d7                	mov    %edx,%edi
  181387:	89 cd                	mov    %ecx,%ebp
	uint32_t ic_data_cmd, count_tx = (QM_I2C_FIFO_SIZE - TX_TL);
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
  181389:	8b 5a 04             	mov    0x4(%edx),%ebx
  18138c:	8b 14 85 dc 03 28 00 	mov    0x2803dc(,%eax,4),%edx
  181393:	29 d3                	sub    %edx,%ebx
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];
  181395:	8b 4f 0c             	mov    0xc(%edi),%ecx
  181398:	8b 14 85 d8 03 28 00 	mov    0x2803d8(,%eax,4),%edx
  18139f:	29 d1                	sub    %edx,%ecx
  1813a1:	89 0c 24             	mov    %ecx,(%esp)
static uint32_t
master_fill_tx_fifo(const qm_i2c_t i2c,
		    const volatile qm_i2c_transfer_t *const transfer,
		    qm_i2c_reg_t *const controller)
{
	uint32_t ic_data_cmd, count_tx = (QM_I2C_FIFO_SIZE - TX_TL);
  1813a4:	be 0e 00 00 00       	mov    $0xe,%esi
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];

	while ((count_tx) && write_buffer_remaining) {
  1813a9:	eb 32                	jmp    1813dd <master_fill_tx_fifo+0x5f>
		count_tx--;
  1813ab:	4e                   	dec    %esi
		write_buffer_remaining--;
  1813ac:	4b                   	dec    %ebx

		/*
		 * Write command -IC_DATA_CMD[8] = 0.
		 * Fill IC_DATA_CMD[7:0] with the data.
		 */
		ic_data_cmd = transfer->tx[i2c_write_pos[i2c]];
  1813ad:	8b 0f                	mov    (%edi),%ecx
  1813af:	8b 14 85 dc 03 28 00 	mov    0x2803dc(,%eax,4),%edx
  1813b6:	0f b6 14 11          	movzbl (%ecx,%edx,1),%edx

		/*
		 * If transfer is a combined transfer, only send stop at
		 * end of the transfer sequence.
		 */
		if (transfer->stop && (write_buffer_remaining == 0) &&
  1813ba:	8a 4f 10             	mov    0x10(%edi),%cl
  1813bd:	84 c9                	test   %cl,%cl
  1813bf:	74 0a                	je     1813cb <master_fill_tx_fifo+0x4d>
  1813c1:	8b 0c 24             	mov    (%esp),%ecx
  1813c4:	09 d9                	or     %ebx,%ecx
  1813c6:	75 03                	jne    1813cb <master_fill_tx_fifo+0x4d>
		    (read_buffer_remaining == 0)) {

			ic_data_cmd |= QM_I2C_IC_DATA_CMD_STOP_BIT_CTRL;
  1813c8:	80 ce 02             	or     $0x2,%dh
		}

		/* Write data. */
		controller->ic_data_cmd = ic_data_cmd;
  1813cb:	89 55 10             	mov    %edx,0x10(%ebp)
		i2c_write_pos[i2c]++;
  1813ce:	8b 14 85 dc 03 28 00 	mov    0x2803dc(,%eax,4),%edx
  1813d5:	42                   	inc    %edx
  1813d6:	89 14 85 dc 03 28 00 	mov    %edx,0x2803dc(,%eax,4)
{
	uint32_t ic_data_cmd, count_tx = (QM_I2C_FIFO_SIZE - TX_TL);
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];

	while ((count_tx) && write_buffer_remaining) {
  1813dd:	85 f6                	test   %esi,%esi
  1813df:	0f 95 c2             	setne  %dl
  1813e2:	85 db                	test   %ebx,%ebx
  1813e4:	0f 95 c1             	setne  %cl
  1813e7:	84 d1                	test   %dl,%cl
  1813e9:	75 c0                	jne    1813ab <master_fill_tx_fifo+0x2d>
		 * goes above the threshold.
		 */
	}

	return write_buffer_remaining;
}
  1813eb:	89 d8                	mov    %ebx,%eax
  1813ed:	83 c4 04             	add    $0x4,%esp
  1813f0:	5b                   	pop    %ebx
  1813f1:	5e                   	pop    %esi
  1813f2:	5f                   	pop    %edi
  1813f3:	5d                   	pop    %ebp
  1813f4:	c3                   	ret    

001813f5 <controller_enable>:
	return 0;
}

static void controller_enable(const qm_i2c_t i2c)
{
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  1813f5:	8b 14 85 bc 02 28 00 	mov    0x2802bc(,%eax,4),%edx

	if (!(controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN)) {
  1813fc:	8b 82 9c 00 00 00    	mov    0x9c(%edx),%eax
  181402:	a8 01                	test   $0x1,%al
  181404:	75 13                	jne    181419 <controller_enable+0x24>
		/* Enable controller. */
		controller->ic_enable |= QM_I2C_IC_ENABLE_CONTROLLER_EN;
  181406:	8b 42 6c             	mov    0x6c(%edx),%eax
  181409:	83 c8 01             	or     $0x1,%eax
  18140c:	89 42 6c             	mov    %eax,0x6c(%edx)

		/* Wait until controller is enabled. */
		while (!(controller->ic_enable_status &
  18140f:	8b 82 9c 00 00 00    	mov    0x9c(%edx),%eax
  181415:	a8 01                	test   $0x1,%al
  181417:	74 f6                	je     18140f <controller_enable+0x1a>
			 QM_I2C_IC_ENABLE_STATUS_IC_EN))
			;
	}

	/* Be sure that all interrupts flag are cleared. */
	controller->ic_clr_intr;
  181419:	8b 42 40             	mov    0x40(%edx),%eax
  18141c:	c3                   	ret    

0018141d <controller_disable>:
}

static int controller_disable(const qm_i2c_t i2c)
{
  18141d:	56                   	push   %esi
  18141e:	53                   	push   %ebx
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  18141f:	8b 34 85 bc 02 28 00 	mov    0x2802bc(,%eax,4),%esi
	int poll_count = I2C_POLL_COUNT;

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;
  181426:	8b 46 6c             	mov    0x6c(%esi),%eax
  181429:	83 e0 fe             	and    $0xfffffffe,%eax
  18142c:	89 46 6c             	mov    %eax,0x6c(%esi)
}

static int controller_disable(const qm_i2c_t i2c)
{
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
	int poll_count = I2C_POLL_COUNT;
  18142f:	b8 40 42 0f 00       	mov    $0xf4240,%eax

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
  181434:	eb 0c                	jmp    181442 <controller_disable+0x25>
	       poll_count--) {
		clk_sys_udelay(I2C_POLL_MICROSECOND);
  181436:	b8 01 00 00 00       	mov    $0x1,%eax
  18143b:	e8 f7 fd ff ff       	call   181237 <clk_sys_udelay>
	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
	       poll_count--) {
  181440:	89 d8                	mov    %ebx,%eax

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
  181442:	8b 96 9c 00 00 00    	mov    0x9c(%esi),%edx
  181448:	f6 c2 01             	test   $0x1,%dl
  18144b:	74 07                	je     181454 <controller_disable+0x37>
	       poll_count--) {
  18144d:	8d 58 ff             	lea    -0x1(%eax),%ebx

	/* Disable controller. */
	controller->ic_enable &= ~QM_I2C_IC_ENABLE_CONTROLLER_EN;

	/* Wait until controller is disabled. */
	while ((controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN) &&
  181450:	85 c0                	test   %eax,%eax
  181452:	75 e2                	jne    181436 <controller_disable+0x19>
	       poll_count--) {
		clk_sys_udelay(I2C_POLL_MICROSECOND);
	}

	/* Returns 0 if ok, meaning controller is disabled. */
	return (controller->ic_enable_status & QM_I2C_IC_ENABLE_STATUS_IC_EN);
  181454:	8b 86 9c 00 00 00    	mov    0x9c(%esi),%eax
  18145a:	83 e0 01             	and    $0x1,%eax
}
  18145d:	5b                   	pop    %ebx
  18145e:	5e                   	pop    %esi
  18145f:	c3                   	ret    

00181460 <i2c_isr_irq_handler>:
		}
	}
}

static void i2c_isr_irq_handler(const qm_i2c_t i2c)
{
  181460:	55                   	push   %ebp
  181461:	57                   	push   %edi
  181462:	56                   	push   %esi
  181463:	53                   	push   %ebx
  181464:	83 ec 08             	sub    $0x8,%esp
  181467:	89 c3                	mov    %eax,%ebx
	const volatile qm_i2c_transfer_t *const transfer = i2c_transfer[i2c];
  181469:	8b 3c 85 e0 03 28 00 	mov    0x2803e0(,%eax,4),%edi
	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  181470:	8b 34 85 bc 02 28 00 	mov    0x2802bc(,%eax,4),%esi

	/* Check TX_OVER error. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_OVER) {
  181477:	8b 46 2c             	mov    0x2c(%esi),%eax
  18147a:	a8 08                	test   $0x8,%al
  18147c:	74 35                	je     1814b3 <i2c_isr_irq_handler+0x53>
		/* Clear interrupt. */
		controller->ic_clr_tx_over;
  18147e:	8b 46 4c             	mov    0x4c(%esi),%eax

		/* Mask interrupts. */
		controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  181481:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

		controller_disable(i2c);
  181488:	89 d8                	mov    %ebx,%eax
  18148a:	e8 8e ff ff ff       	call   18141d <controller_disable>
		if (transfer->callback) {
  18148f:	8b 47 14             	mov    0x14(%edi),%eax
  181492:	85 c0                	test   %eax,%eax
  181494:	74 1d                	je     1814b3 <i2c_isr_irq_handler+0x53>
			transfer->callback(transfer->callback_data, -EIO,
  181496:	8b 6f 14             	mov    0x14(%edi),%ebp
  181499:	8b 14 9d dc 03 28 00 	mov    0x2803dc(,%ebx,4),%edx
  1814a0:	8b 47 18             	mov    0x18(%edi),%eax
  1814a3:	52                   	push   %edx
  1814a4:	b9 00 00 08 00       	mov    $0x80000,%ecx
  1814a9:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
  1814ae:	ff d5                	call   *%ebp
  1814b0:	83 c4 04             	add    $0x4,%esp
					   QM_I2C_TX_OVER, i2c_write_pos[i2c]);
		}
	}

	/* Check for RX_UNDER error. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_UNDER) {
  1814b3:	8b 46 2c             	mov    0x2c(%esi),%eax
  1814b6:	a8 01                	test   $0x1,%al
  1814b8:	74 35                	je     1814ef <i2c_isr_irq_handler+0x8f>
		/* Clear interrupt. */
		controller->ic_clr_rx_under;
  1814ba:	8b 46 44             	mov    0x44(%esi),%eax

		/* Mask interrupts. */
		controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  1814bd:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

		controller_disable(i2c);
  1814c4:	89 d8                	mov    %ebx,%eax
  1814c6:	e8 52 ff ff ff       	call   18141d <controller_disable>
		if (transfer->callback) {
  1814cb:	8b 47 14             	mov    0x14(%edi),%eax
  1814ce:	85 c0                	test   %eax,%eax
  1814d0:	74 1d                	je     1814ef <i2c_isr_irq_handler+0x8f>
			transfer->callback(transfer->callback_data, -EIO,
  1814d2:	8b 6f 14             	mov    0x14(%edi),%ebp
  1814d5:	8b 14 9d dc 03 28 00 	mov    0x2803dc(,%ebx,4),%edx
  1814dc:	8b 47 18             	mov    0x18(%edi),%eax
  1814df:	52                   	push   %edx
  1814e0:	b9 00 00 20 00       	mov    $0x200000,%ecx
  1814e5:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
  1814ea:	ff d5                	call   *%ebp
  1814ec:	83 c4 04             	add    $0x4,%esp
	/*
	 * TX ABORT interrupt.
	 * Avoid spurious interrupts by checking RX DONE interrupt: RX_DONE
	 * interrupt also trigger a TX_ABORT interrupt when flushing FIFO.
	 */
	if ((controller->ic_intr_stat &
  1814ef:	8b 46 2c             	mov    0x2c(%esi),%eax
  1814f2:	25 c0 00 00 00       	and    $0xc0,%eax
  1814f7:	83 f8 40             	cmp    $0x40,%eax
  1814fa:	75 63                	jne    18155f <i2c_isr_irq_handler+0xff>

	*status = QM_I2C_TX_ABORT;

	/* Get source of TX_ABRT interrupt. */
	*status |=
	    (controller->ic_tx_abrt_source & QM_I2C_IC_TX_ABRT_SOURCE_ALL_MASK);
  1814fc:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
  181502:	89 c2                	mov    %eax,%edx
  181504:	81 e2 ff ff 01 00    	and    $0x1ffff,%edx
		    QM_I2C_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT));

	*status = QM_I2C_TX_ABORT;

	/* Get source of TX_ABRT interrupt. */
	*status |=
  18150a:	81 ca 00 00 04 00    	or     $0x40000,%edx
  181510:	89 14 24             	mov    %edx,(%esp)
	    (controller->ic_tx_abrt_source & QM_I2C_IC_TX_ABRT_SOURCE_ALL_MASK);

	/* Clear TX ABORT interrupt. */
	controller->ic_clr_tx_abrt;
  181513:	8b 56 54             	mov    0x54(%esi),%edx

	/* Mask interrupts. */
	controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  181516:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

	return rc = (*status & QM_I2C_TX_ABRT_USER_ABRT) ? -ECANCELED : -EIO;
  18151d:	a9 00 00 01 00       	test   $0x10000,%eax
  181522:	74 0a                	je     18152e <i2c_isr_irq_handler+0xce>
  181524:	c7 44 24 04 74 ff ff 	movl   $0xffffff74,0x4(%esp)
  18152b:	ff 
  18152c:	eb 08                	jmp    181536 <i2c_isr_irq_handler+0xd6>
  18152e:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  181535:	ff 
	qm_i2c_status_t status = 0;
	int rc = 0;

	rc = handle_tx_abrt_common(controller, &status);

	controller_disable(i2c);
  181536:	89 d8                	mov    %ebx,%eax
  181538:	e8 e0 fe ff ff       	call   18141d <controller_disable>
	if (transfer->callback) {
  18153d:	8b 47 14             	mov    0x14(%edi),%eax
  181540:	85 c0                	test   %eax,%eax
  181542:	74 1b                	je     18155f <i2c_isr_irq_handler+0xff>
		transfer->callback(transfer->callback_data, rc, status,
  181544:	8b 6f 14             	mov    0x14(%edi),%ebp
  181547:	8b 14 9d dc 03 28 00 	mov    0x2803dc(,%ebx,4),%edx
  18154e:	8b 47 18             	mov    0x18(%edi),%eax
  181551:	52                   	push   %edx
  181552:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  181556:	8b 54 24 08          	mov    0x8(%esp),%edx
  18155a:	ff d5                	call   *%ebp
  18155c:	83 c4 04             	add    $0x4,%esp
	    QM_I2C_IC_INTR_STAT_TX_ABRT) {
		handle_irq_tx_abrt(i2c, transfer, controller);
	}

	/* Master mode. */
	if (controller->ic_con & QM_I2C_IC_CON_MASTER_MODE) {
  18155f:	8b 06                	mov    (%esi),%eax
  181561:	a8 01                	test   $0x1,%al
  181563:	0f 84 d4 01 00 00    	je     18173d <i2c_isr_irq_handler+0x2dd>
		/* Check for RX_OVER error. */
		if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_OVER) {
  181569:	8b 46 2c             	mov    0x2c(%esi),%eax
  18156c:	a8 02                	test   $0x2,%al
  18156e:	74 35                	je     1815a5 <i2c_isr_irq_handler+0x145>
			/* Clear interrupt. */
			controller->ic_clr_rx_over;
  181570:	8b 46 48             	mov    0x48(%esi),%eax

			/* Mask interrupts. */
			controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  181573:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

			controller_disable(i2c);
  18157a:	89 d8                	mov    %ebx,%eax
  18157c:	e8 9c fe ff ff       	call   18141d <controller_disable>
			if (transfer->callback) {
  181581:	8b 47 14             	mov    0x14(%edi),%eax
  181584:	85 c0                	test   %eax,%eax
  181586:	74 1d                	je     1815a5 <i2c_isr_irq_handler+0x145>
				transfer->callback(transfer->callback_data,
  181588:	8b 6f 14             	mov    0x14(%edi),%ebp
  18158b:	8b 14 9d dc 03 28 00 	mov    0x2803dc(,%ebx,4),%edx
  181592:	8b 47 18             	mov    0x18(%edi),%eax
  181595:	52                   	push   %edx
  181596:	b9 00 00 10 00       	mov    $0x100000,%ecx
  18159b:	ba fb ff ff ff       	mov    $0xfffffffb,%edx
  1815a0:	ff d5                	call   *%ebp
  1815a2:	83 c4 04             	add    $0x4,%esp
i2c_isr_master_handler(const qm_i2c_t i2c,
		       const volatile qm_i2c_transfer_t *const transfer,
		       qm_i2c_reg_t *const controller)
{
	uint32_t count_tx;
	uint32_t read_buffer_remaining = transfer->rx_len - i2c_read_pos[i2c];
  1815a5:	8b 57 0c             	mov    0xc(%edi),%edx
  1815a8:	8b 04 9d d8 03 28 00 	mov    0x2803d8(,%ebx,4),%eax
  1815af:	29 c2                	sub    %eax,%edx
  1815b1:	89 14 24             	mov    %edx,(%esp)
	uint32_t write_buffer_remaining = transfer->tx_len - i2c_write_pos[i2c];
  1815b4:	8b 57 04             	mov    0x4(%edi),%edx
  1815b7:	8b 04 9d dc 03 28 00 	mov    0x2803dc(,%ebx,4),%eax
  1815be:	29 c2                	sub    %eax,%edx
  1815c0:	89 d5                	mov    %edx,%ebp
	uint32_t missing_bytes;

	/* RX read from buffer. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {
  1815c2:	8b 46 2c             	mov    0x2c(%esi),%eax
  1815c5:	a8 04                	test   $0x4,%al
  1815c7:	75 68                	jne    181631 <i2c_isr_irq_handler+0x1d1>
  1815c9:	e9 84 00 00 00       	jmp    181652 <i2c_isr_irq_handler+0x1f2>

		while (read_buffer_remaining && controller->ic_rxflr) {
			transfer->rx[i2c_read_pos[i2c]] =
  1815ce:	8b 57 08             	mov    0x8(%edi),%edx
  1815d1:	8b 04 9d d8 03 28 00 	mov    0x2803d8(,%ebx,4),%eax
			    controller->ic_data_cmd;
  1815d8:	8b 4e 10             	mov    0x10(%esi),%ecx

	/* RX read from buffer. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {

		while (read_buffer_remaining && controller->ic_rxflr) {
			transfer->rx[i2c_read_pos[i2c]] =
  1815db:	88 0c 02             	mov    %cl,(%edx,%eax,1)
			    controller->ic_data_cmd;
			read_buffer_remaining--;
			i2c_read_pos[i2c]++;
  1815de:	8b 04 9d d8 03 28 00 	mov    0x2803d8(,%ebx,4),%eax
  1815e5:	40                   	inc    %eax
  1815e6:	89 04 9d d8 03 28 00 	mov    %eax,0x2803d8(,%ebx,4)

			if (read_buffer_remaining == 0) {
  1815ed:	ff 0c 24             	decl   (%esp)
  1815f0:	75 43                	jne    181635 <i2c_isr_irq_handler+0x1d5>
				/*
				 * Mask RX full interrupt if transfer
				 * complete.
				 */
				controller->ic_intr_mask &=
  1815f2:	8b 46 30             	mov    0x30(%esi),%eax
  1815f5:	83 e0 eb             	and    $0xffffffeb,%eax
  1815f8:	89 46 30             	mov    %eax,0x30(%esi)
				    ~(QM_I2C_IC_INTR_MASK_RX_FULL |
				      QM_I2C_IC_INTR_MASK_TX_EMPTY);

				if (transfer->stop) {
  1815fb:	8a 47 10             	mov    0x10(%edi),%al
  1815fe:	84 c0                	test   %al,%al
  181600:	74 07                	je     181609 <i2c_isr_irq_handler+0x1a9>
					controller_disable(i2c);
  181602:	89 d8                	mov    %ebx,%eax
  181604:	e8 14 fe ff ff       	call   18141d <controller_disable>
				}

				if (transfer->callback) {
  181609:	8b 47 14             	mov    0x14(%edi),%eax
  18160c:	85 c0                	test   %eax,%eax
  18160e:	74 25                	je     181635 <i2c_isr_irq_handler+0x1d5>
					transfer->callback(
  181610:	8b 47 14             	mov    0x14(%edi),%eax
  181613:	89 c5                	mov    %eax,%ebp
  181615:	8b 14 9d d8 03 28 00 	mov    0x2803d8(,%ebx,4),%edx
  18161c:	8b 47 18             	mov    0x18(%edi),%eax
  18161f:	52                   	push   %edx
  181620:	b9 00 00 00 00       	mov    $0x0,%ecx
  181625:	ba 00 00 00 00       	mov    $0x0,%edx
  18162a:	ff d5                	call   *%ebp
  18162c:	83 c4 04             	add    $0x4,%esp
  18162f:	eb 04                	jmp    181635 <i2c_isr_irq_handler+0x1d5>
  181631:	89 54 24 04          	mov    %edx,0x4(%esp)
	uint32_t missing_bytes;

	/* RX read from buffer. */
	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {

		while (read_buffer_remaining && controller->ic_rxflr) {
  181635:	83 3c 24 00          	cmpl   $0x0,(%esp)
  181639:	74 07                	je     181642 <i2c_isr_irq_handler+0x1e2>
  18163b:	8b 46 78             	mov    0x78(%esi),%eax
  18163e:	85 c0                	test   %eax,%eax
  181640:	75 8c                	jne    1815ce <i2c_isr_irq_handler+0x16e>
  181642:	8b 6c 24 04          	mov    0x4(%esp),%ebp
					    QM_I2C_IDLE, i2c_read_pos[i2c]);
				}
			}
		}

		if (read_buffer_remaining > 0 &&
  181646:	8b 04 24             	mov    (%esp),%eax
  181649:	48                   	dec    %eax
  18164a:	83 f8 04             	cmp    $0x4,%eax
  18164d:	77 03                	ja     181652 <i2c_isr_irq_handler+0x1f2>
			/*
			 * Adjust the RX threshold so the next 'RX_FULL'
			 * interrupt is generated when all the remaining
			 * data are received.
			 */
			controller->ic_rx_tl = read_buffer_remaining - 1;
  18164f:	89 46 38             	mov    %eax,0x38(%esi)
		 * RX_FULL INTR is autocleared when the buffer levels goes below
		 * the threshold.
		 */
	}

	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_EMPTY) {
  181652:	8b 46 2c             	mov    0x2c(%esi),%eax
  181655:	a8 10                	test   $0x10,%al
  181657:	0f 84 d4 02 00 00    	je     181931 <i2c_isr_irq_handler+0x4d1>

		if ((controller->ic_status & QM_I2C_IC_STATUS_TFE) &&
  18165d:	8b 46 70             	mov    0x70(%esi),%eax
  181660:	a8 04                	test   $0x4,%al
  181662:	74 46                	je     1816aa <i2c_isr_irq_handler+0x24a>
		    (transfer->tx != NULL) && (write_buffer_remaining == 0) &&
  181664:	8b 07                	mov    (%edi),%eax
		 */
	}

	if (controller->ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_EMPTY) {

		if ((controller->ic_status & QM_I2C_IC_STATUS_TFE) &&
  181666:	85 c0                	test   %eax,%eax
  181668:	74 40                	je     1816aa <i2c_isr_irq_handler+0x24a>
		    (transfer->tx != NULL) && (write_buffer_remaining == 0) &&
  18166a:	0b 2c 24             	or     (%esp),%ebp
  18166d:	75 3b                	jne    1816aa <i2c_isr_irq_handler+0x24a>
		    (read_buffer_remaining == 0)) {

			controller->ic_intr_mask &=
  18166f:	8b 46 30             	mov    0x30(%esi),%eax
  181672:	83 e0 ef             	and    $0xffffffef,%eax
  181675:	89 46 30             	mov    %eax,0x30(%esi)

			/*
			 * If this is not a combined transaction, disable the
			 * controller now.
			 */
			if (transfer->stop) {
  181678:	8a 47 10             	mov    0x10(%edi),%al
  18167b:	84 c0                	test   %al,%al
  18167d:	74 07                	je     181686 <i2c_isr_irq_handler+0x226>
				controller_disable(i2c);
  18167f:	89 d8                	mov    %ebx,%eax
  181681:	e8 97 fd ff ff       	call   18141d <controller_disable>
			}

			/* Callback. */
			if (transfer->callback) {
  181686:	8b 47 14             	mov    0x14(%edi),%eax
  181689:	85 c0                	test   %eax,%eax
  18168b:	74 1d                	je     1816aa <i2c_isr_irq_handler+0x24a>
				transfer->callback(transfer->callback_data, 0,
  18168d:	8b 6f 14             	mov    0x14(%edi),%ebp
  181690:	8b 14 9d dc 03 28 00 	mov    0x2803dc(,%ebx,4),%edx
  181697:	8b 47 18             	mov    0x18(%edi),%eax
  18169a:	52                   	push   %edx
  18169b:	b9 00 00 00 00       	mov    $0x0,%ecx
  1816a0:	ba 00 00 00 00       	mov    $0x0,%edx
  1816a5:	ff d5                	call   *%ebp
  1816a7:	83 c4 04             	add    $0x4,%esp
						   QM_I2C_IDLE,
						   i2c_write_pos[i2c]);
			}
		}

		write_buffer_remaining =
  1816aa:	89 f1                	mov    %esi,%ecx
  1816ac:	89 fa                	mov    %edi,%edx
  1816ae:	89 d8                	mov    %ebx,%eax
  1816b0:	e8 c9 fc ff ff       	call   18137e <master_fill_tx_fifo>
		 * waiting for some bytes after sending read request on the
		 * previous interruption. We have to take into account this
		 * value in order to not send too much request so we won't fall
		 * into rx overflow.
		 */
		missing_bytes = read_buffer_remaining - i2c_read_cmd_send[i2c];
  1816b5:	8b 14 9d d4 03 28 00 	mov    0x2803d4(,%ebx,4),%edx
  1816bc:	8b 0c 24             	mov    (%esp),%ecx
  1816bf:	29 d1                	sub    %edx,%ecx
  1816c1:	89 ca                	mov    %ecx,%edx
		 * cannot be more than the number of expected bytes.
		 */
		QM_ASSERT(controller->ic_rxflr <= missing_bytes);

		/* Count_tx is the remaining size in the FIFO. */
		count_tx = QM_I2C_FIFO_SIZE - controller->ic_txflr;
  1816c3:	8b 4e 74             	mov    0x74(%esi),%ecx
  1816c6:	bd 10 00 00 00       	mov    $0x10,%ebp
  1816cb:	29 cd                	sub    %ecx,%ebp

		if (count_tx > missing_bytes) {
  1816cd:	39 ea                	cmp    %ebp,%edx
  1816cf:	73 04                	jae    1816d5 <i2c_isr_irq_handler+0x275>
			count_tx -= missing_bytes;
  1816d1:	29 d5                	sub    %edx,%ebp
  1816d3:	eb 39                	jmp    18170e <i2c_isr_irq_handler+0x2ae>
		} else {
			count_tx = 0;
  1816d5:	bd 00 00 00 00       	mov    $0x0,%ebp
  1816da:	eb 32                	jmp    18170e <i2c_isr_irq_handler+0x2ae>
		}

		while (i2c_read_cmd_send[i2c] &&
		       (write_buffer_remaining == 0) && count_tx) {
			count_tx--;
  1816dc:	4d                   	dec    %ebp
			i2c_read_cmd_send[i2c]--;
  1816dd:	8b 14 9d d4 03 28 00 	mov    0x2803d4(,%ebx,4),%edx
  1816e4:	4a                   	dec    %edx
  1816e5:	89 14 9d d4 03 28 00 	mov    %edx,0x2803d4(,%ebx,4)

			/*
			 * If transfer is a combined transfer, only send stop at
			 * end of the transfer sequence.
			 */
			if (transfer->stop && (i2c_read_cmd_send[i2c] == 0)) {
  1816ec:	8a 57 10             	mov    0x10(%edi),%dl
  1816ef:	84 d2                	test   %dl,%dl
  1816f1:	74 14                	je     181707 <i2c_isr_irq_handler+0x2a7>
  1816f3:	8b 14 9d d4 03 28 00 	mov    0x2803d4(,%ebx,4),%edx
  1816fa:	85 d2                	test   %edx,%edx
  1816fc:	75 09                	jne    181707 <i2c_isr_irq_handler+0x2a7>
				controller->ic_data_cmd =
  1816fe:	c7 46 10 00 03 00 00 	movl   $0x300,0x10(%esi)
  181705:	eb 07                	jmp    18170e <i2c_isr_irq_handler+0x2ae>
				    QM_I2C_IC_DATA_CMD_READ |
				    QM_I2C_IC_DATA_CMD_STOP_BIT_CTRL;
			} else {
				controller->ic_data_cmd =
  181707:	c7 46 10 00 01 00 00 	movl   $0x100,0x10(%esi)
			count_tx -= missing_bytes;
		} else {
			count_tx = 0;
		}

		while (i2c_read_cmd_send[i2c] &&
  18170e:	8b 14 9d d4 03 28 00 	mov    0x2803d4(,%ebx,4),%edx
  181715:	85 d2                	test   %edx,%edx
  181717:	74 0d                	je     181726 <i2c_isr_irq_handler+0x2c6>
		       (write_buffer_remaining == 0) && count_tx) {
  181719:	85 c0                	test   %eax,%eax
  18171b:	0f 94 c2             	sete   %dl
  18171e:	85 ed                	test   %ebp,%ebp
  181720:	74 04                	je     181726 <i2c_isr_irq_handler+0x2c6>
  181722:	84 d2                	test   %dl,%dl
  181724:	75 b6                	jne    1816dc <i2c_isr_irq_handler+0x27c>
				    QM_I2C_IC_DATA_CMD_READ;
			}
		}

		/* Generate a tx_empty interrupt when TX FIFO is fully empty. */
		if ((write_buffer_remaining == 0) &&
  181726:	8b 0c 24             	mov    (%esp),%ecx
  181729:	09 c1                	or     %eax,%ecx
  18172b:	0f 85 00 02 00 00    	jne    181931 <i2c_isr_irq_handler+0x4d1>
		    (read_buffer_remaining == 0)) {
			controller->ic_tx_tl = 0;
  181731:	c7 46 3c 00 00 00 00 	movl   $0x0,0x3c(%esi)
  181738:	e9 f4 01 00 00       	jmp    181931 <i2c_isr_irq_handler+0x4d1>
i2c_isr_slave_handler(const qm_i2c_t i2c,
		      const volatile qm_i2c_transfer_t *const transfer,
		      qm_i2c_reg_t *const controller)
{
	/* Save register to speed up process in interrupt. */
	uint32_t ic_intr_stat = controller->ic_intr_stat;
  18173d:	8b 46 2c             	mov    0x2c(%esi),%eax
  181740:	89 04 24             	mov    %eax,(%esp)
	 * - General call (will only appear after few SCL clock cycles after
	 *   start interrupt).
	 */

	/* Stop condition detected. */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_STOP_DETECTED) {
  181743:	f6 c4 02             	test   $0x2,%ah
  181746:	0f 84 97 00 00 00    	je     1817e3 <i2c_isr_irq_handler+0x383>
		/* Empty RX FIFO. */
		empty_rx_fifo(i2c, transfer, controller);
  18174c:	89 f1                	mov    %esi,%ecx
  18174e:	89 fa                	mov    %edi,%edx
  181750:	89 d8                	mov    %ebx,%eax
  181752:	e8 16 fb ff ff       	call   18126d <empty_rx_fifo>
		 * been addressed.
		 * Driver only knows it has been addressed if:
		 * - It already triggered an interrupt on TX_EMPTY or RX_FULL
		 * - Data was read from RX FIFO.
		 */
		if ((transfer->stop == true) &&
  181757:	8a 47 10             	mov    0x10(%edi),%al
  18175a:	84 c0                	test   %al,%al
  18175c:	74 1b                	je     181779 <i2c_isr_irq_handler+0x319>
		    (is_addressed || (i2c_read_pos[i2c] != 0))) {
  18175e:	a0 d0 03 28 00       	mov    0x2803d0,%al
		 * been addressed.
		 * Driver only knows it has been addressed if:
		 * - It already triggered an interrupt on TX_EMPTY or RX_FULL
		 * - Data was read from RX FIFO.
		 */
		if ((transfer->stop == true) &&
  181763:	84 c0                	test   %al,%al
  181765:	75 0b                	jne    181772 <i2c_isr_irq_handler+0x312>
		    (is_addressed || (i2c_read_pos[i2c] != 0))) {
  181767:	8b 04 9d d8 03 28 00 	mov    0x2803d8(,%ebx,4),%eax
  18176e:	85 c0                	test   %eax,%eax
  181770:	74 07                	je     181779 <i2c_isr_irq_handler+0x319>
			controller_disable(i2c);
  181772:	89 d8                	mov    %ebx,%eax
  181774:	e8 a4 fc ff ff       	call   18141d <controller_disable>
		}

		if (transfer->callback) {
  181779:	8b 47 14             	mov    0x14(%edi),%eax
  18177c:	85 c0                	test   %eax,%eax
  18177e:	74 2d                	je     1817ad <i2c_isr_irq_handler+0x34d>
			transfer->callback(
  181780:	8b 6f 14             	mov    0x14(%edi),%ebp
			    transfer->callback_data, 0, QM_I2C_STOP_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
  181783:	a0 d2 03 28 00       	mov    0x2803d2,%al
		    (is_addressed || (i2c_read_pos[i2c] != 0))) {
			controller_disable(i2c);
		}

		if (transfer->callback) {
			transfer->callback(
  181788:	84 c0                	test   %al,%al
  18178a:	74 09                	je     181795 <i2c_isr_irq_handler+0x335>
  18178c:	8b 14 9d d8 03 28 00 	mov    0x2803d8(,%ebx,4),%edx
  181793:	eb 05                	jmp    18179a <i2c_isr_irq_handler+0x33a>
  181795:	ba 00 00 00 00       	mov    $0x0,%edx
  18179a:	8b 47 18             	mov    0x18(%edi),%eax
  18179d:	52                   	push   %edx
  18179e:	b9 00 00 00 02       	mov    $0x2000000,%ecx
  1817a3:	ba 00 00 00 00       	mov    $0x0,%edx
  1817a8:	ff d5                	call   *%ebp
  1817aa:	83 c4 04             	add    $0x4,%esp
			    transfer->callback_data, 0, QM_I2C_STOP_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
		}
		i2c_write_pos[i2c] = 0;
  1817ad:	c7 04 9d dc 03 28 00 	movl   $0x0,0x2803dc(,%ebx,4)
  1817b4:	00 00 00 00 
		i2c_read_pos[i2c] = 0;
  1817b8:	c7 04 9d d8 03 28 00 	movl   $0x0,0x2803d8(,%ebx,4)
  1817bf:	00 00 00 00 

		controller->ic_intr_mask &= ~QM_I2C_IC_INTR_MASK_TX_EMPTY;
  1817c3:	8b 46 30             	mov    0x30(%esi),%eax
  1817c6:	83 e0 ef             	and    $0xffffffef,%eax
  1817c9:	89 46 30             	mov    %eax,0x30(%esi)

		is_addressed = false;
  1817cc:	c6 05 d0 03 28 00 00 	movb   $0x0,0x2803d0

		/* Clear stop interrupt. */
		controller->ic_clr_stop_det;
  1817d3:	8b 46 60             	mov    0x60(%esi),%eax

		/*
		 * Read again the interrupt status in case of a start interrupt
		 * has been triggered in the meantime.
		 */
		ic_intr_stat = controller->ic_intr_stat;
  1817d6:	8b 46 2c             	mov    0x2c(%esi),%eax
  1817d9:	89 04 24             	mov    %eax,(%esp)
		first_start = true;
  1817dc:	c6 05 d1 03 28 00 01 	movb   $0x1,0x2803d1
	/*
	 * START or RESTART condition detected.
	 * The RESTART_DETECTED interrupt is not used as it is redundant with
	 * the START_DETECTED interrupt.
	 */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_START_DETECTED) {
  1817e3:	f7 04 24 00 04 00 00 	testl  $0x400,(%esp)
  1817ea:	74 71                	je     18185d <i2c_isr_irq_handler+0x3fd>
		if (!first_start) {
  1817ec:	a0 d1 03 28 00       	mov    0x2803d1,%al
  1817f1:	84 c0                	test   %al,%al
  1817f3:	75 0b                	jne    181800 <i2c_isr_irq_handler+0x3a0>
			empty_rx_fifo(i2c, transfer, controller);
  1817f5:	89 f1                	mov    %esi,%ecx
  1817f7:	89 fa                	mov    %edi,%edx
  1817f9:	89 d8                	mov    %ebx,%eax
  1817fb:	e8 6d fa ff ff       	call   18126d <empty_rx_fifo>
		}
		if (transfer->callback) {
  181800:	8b 47 14             	mov    0x14(%edi),%eax
  181803:	85 c0                	test   %eax,%eax
  181805:	74 2f                	je     181836 <i2c_isr_irq_handler+0x3d6>
			transfer->callback(
  181807:	8b 47 14             	mov    0x14(%edi),%eax
  18180a:	89 c5                	mov    %eax,%ebp
			    transfer->callback_data, 0, QM_I2C_START_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
  18180c:	a0 d2 03 28 00       	mov    0x2803d2,%al
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_START_DETECTED) {
		if (!first_start) {
			empty_rx_fifo(i2c, transfer, controller);
		}
		if (transfer->callback) {
			transfer->callback(
  181811:	84 c0                	test   %al,%al
  181813:	74 09                	je     18181e <i2c_isr_irq_handler+0x3be>
  181815:	8b 14 9d d8 03 28 00 	mov    0x2803d8(,%ebx,4),%edx
  18181c:	eb 05                	jmp    181823 <i2c_isr_irq_handler+0x3c3>
  18181e:	ba 00 00 00 00       	mov    $0x0,%edx
  181823:	8b 47 18             	mov    0x18(%edi),%eax
  181826:	52                   	push   %edx
  181827:	b9 00 00 40 00       	mov    $0x400000,%ecx
  18182c:	ba 00 00 00 00       	mov    $0x0,%edx
  181831:	ff d5                	call   *%ebp
  181833:	83 c4 04             	add    $0x4,%esp
			    transfer->callback_data, 0, QM_I2C_START_DETECTED,
			    (transfer_ongoing) ? i2c_read_pos[i2c] : 0);
		}
		transfer_ongoing = true;
  181836:	c6 05 d2 03 28 00 01 	movb   $0x1,0x2803d2
		i2c_write_pos[i2c] = 0;
  18183d:	c7 04 9d dc 03 28 00 	movl   $0x0,0x2803dc(,%ebx,4)
  181844:	00 00 00 00 
		i2c_read_pos[i2c] = 0;
  181848:	c7 04 9d d8 03 28 00 	movl   $0x0,0x2803d8(,%ebx,4)
  18184f:	00 00 00 00 

		/* Clear Start detected interrupt. */
		controller->ic_clr_start_det;
  181853:	8b 46 64             	mov    0x64(%esi),%eax
		first_start = false;
  181856:	c6 05 d1 03 28 00 00 	movb   $0x0,0x2803d1
	 *
	 * RX FIFO overflow must always be checked though, in case of an
	 * overflow happens during RX_FULL interrupt handling.
	 */
	/* RX FIFO Overflow. */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_OVER) {
  18185d:	f6 04 24 02          	testb  $0x2,(%esp)
  181861:	74 23                	je     181886 <i2c_isr_irq_handler+0x426>
		controller->ic_clr_rx_over;
  181863:	8b 46 48             	mov    0x48(%esi),%eax
		if (transfer->callback) {
  181866:	8b 47 14             	mov    0x14(%edi),%eax
  181869:	85 c0                	test   %eax,%eax
  18186b:	74 19                	je     181886 <i2c_isr_irq_handler+0x426>
			transfer->callback(transfer->callback_data, 0,
  18186d:	8b 47 14             	mov    0x14(%edi),%eax
  181870:	89 c5                	mov    %eax,%ebp
  181872:	8b 47 18             	mov    0x18(%edi),%eax
  181875:	6a 00                	push   $0x0
  181877:	b9 00 00 10 00       	mov    $0x100000,%ecx
  18187c:	ba 00 00 00 00       	mov    $0x0,%edx
  181881:	ff d5                	call   *%ebp
  181883:	83 c4 04             	add    $0x4,%esp
					   QM_I2C_RX_OVER, 0);
		}
	}

	/* RX FIFO FULL. */
	if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_FULL) {
  181886:	f6 04 24 04          	testb  $0x4,(%esp)
  18188a:	74 17                	je     1818a3 <i2c_isr_irq_handler+0x443>
		/* Empty RX FIFO. */
		empty_rx_fifo(i2c, transfer, controller);
  18188c:	89 f1                	mov    %esi,%ecx
  18188e:	89 fa                	mov    %edi,%edx
  181890:	89 d8                	mov    %ebx,%eax
  181892:	e8 d6 f9 ff ff       	call   18126d <empty_rx_fifo>

		/* Track activity of controller when addressed. */
		is_addressed = true;
  181897:	c6 05 d0 03 28 00 01 	movb   $0x1,0x2803d0
  18189e:	e9 8e 00 00 00       	jmp    181931 <i2c_isr_irq_handler+0x4d1>
	 * TX FIFO empty interrupt must be handled after RX DONE interrupt: when
	 * RX DONE is triggered, TX FIFO is flushed (thus emptied) creating a
	 * TX_ABORT interrupt and a TX_EMPTY condition. TX_ABORT shall be
	 * cleared and TX_EMPTY interrupt disabled.
	 */
	else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RD_REQ) {
  1818a3:	f6 04 24 20          	testb  $0x20,(%esp)
  1818a7:	74 20                	je     1818c9 <i2c_isr_irq_handler+0x469>
		/* Clear read request interrupt. */
		controller->ic_clr_rd_req;
  1818a9:	8b 46 50             	mov    0x50(%esi),%eax

		/* Track activity of controller when addressed. */
		is_addressed = true;
  1818ac:	c6 05 d0 03 28 00 01 	movb   $0x1,0x2803d0

		slave_fill_tx_fifo(i2c, transfer, controller);
  1818b3:	89 f1                	mov    %esi,%ecx
  1818b5:	89 fa                	mov    %edi,%edx
  1818b7:	89 d8                	mov    %ebx,%eax
  1818b9:	e8 32 fa ff ff       	call   1812f0 <slave_fill_tx_fifo>

		/* Enable TX EMPTY interrupts. */
		controller->ic_intr_mask |= QM_I2C_IC_INTR_MASK_TX_EMPTY;
  1818be:	8b 46 30             	mov    0x30(%esi),%eax
  1818c1:	83 c8 10             	or     $0x10,%eax
  1818c4:	89 46 30             	mov    %eax,0x30(%esi)
  1818c7:	eb 68                	jmp    181931 <i2c_isr_irq_handler+0x4d1>
	} else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_RX_DONE) {
  1818c9:	f6 04 24 80          	testb  $0x80,(%esp)
  1818cd:	74 14                	je     1818e3 <i2c_isr_irq_handler+0x483>
		controller->ic_clr_rx_done;
  1818cf:	8b 46 58             	mov    0x58(%esi),%eax
		/* Clear TX ABORT as it is triggered when FIFO is flushed. */
		controller->ic_clr_tx_abrt;
  1818d2:	8b 46 54             	mov    0x54(%esi),%eax

		/* Disable TX EMPTY interrupt. */
		controller->ic_intr_mask &= ~QM_I2C_IC_INTR_MASK_TX_EMPTY;
  1818d5:	8b 46 30             	mov    0x30(%esi),%eax
  1818d8:	83 e0 ef             	and    $0xffffffef,%eax
  1818db:	89 46 30             	mov    %eax,0x30(%esi)

		/*
		 * Read again the interrupt status in case of a stop or a start
		 * interrupt has been triggered in the meantime.
		 */
		ic_intr_stat = controller->ic_intr_stat;
  1818de:	8b 46 2c             	mov    0x2c(%esi),%eax
  1818e1:	eb 4e                	jmp    181931 <i2c_isr_irq_handler+0x4d1>

	} else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_TX_EMPTY) {
  1818e3:	f6 04 24 10          	testb  $0x10,(%esp)
  1818e7:	74 0d                	je     1818f6 <i2c_isr_irq_handler+0x496>
		slave_fill_tx_fifo(i2c, transfer, controller);
  1818e9:	89 f1                	mov    %esi,%ecx
  1818eb:	89 fa                	mov    %edi,%edx
  1818ed:	89 d8                	mov    %ebx,%eax
  1818ef:	e8 fc f9 ff ff       	call   1812f0 <slave_fill_tx_fifo>
  1818f4:	eb 3b                	jmp    181931 <i2c_isr_irq_handler+0x4d1>
	}

	/* General call detected. */
	else if (ic_intr_stat & QM_I2C_IC_INTR_STAT_GEN_CALL_DETECTED) {
  1818f6:	f7 04 24 00 08 00 00 	testl  $0x800,(%esp)
  1818fd:	74 32                	je     181931 <i2c_isr_irq_handler+0x4d1>
		if (transfer->callback) {
  1818ff:	8b 47 14             	mov    0x14(%edi),%eax
  181902:	85 c0                	test   %eax,%eax
  181904:	74 1c                	je     181922 <i2c_isr_irq_handler+0x4c2>
			transfer->callback(transfer->callback_data, 0,
  181906:	8b 5f 14             	mov    0x14(%edi),%ebx
  181909:	8b 47 18             	mov    0x18(%edi),%eax
  18190c:	6a 00                	push   $0x0
  18190e:	b9 00 00 00 04       	mov    $0x4000000,%ecx
  181913:	ba 00 00 00 00       	mov    $0x0,%edx
  181918:	ff d3                	call   *%ebx
  18191a:	83 c4 04             	add    $0x4,%esp
  18191d:	eb 03                	jmp    181922 <i2c_isr_irq_handler+0x4c2>
		 * read too early.
		 */
		while (controller->ic_intr_stat &
		       QM_I2C_IC_INTR_STAT_GEN_CALL_DETECTED) {
			/* Clear General call interrupt. */
			controller->ic_clr_gen_call;
  18191f:	8b 46 68             	mov    0x68(%esi),%eax
		/*
		 * Workaround.
		 * The interrupt may not actually be cleared when register is
		 * read too early.
		 */
		while (controller->ic_intr_stat &
  181922:	8b 46 2c             	mov    0x2c(%esi),%eax
  181925:	f6 c4 08             	test   $0x8,%ah
  181928:	75 f5                	jne    18191f <i2c_isr_irq_handler+0x4bf>
#else
		controller->ic_clr_gen_call;
#endif

		/* Track activity of controller when addressed. */
		is_addressed = true;
  18192a:	c6 05 d0 03 28 00 01 	movb   $0x1,0x2803d0
	}
	/* Slave mode. */
	else {
		i2c_isr_slave_handler(i2c, transfer, controller);
	}
}
  181931:	83 c4 08             	add    $0x8,%esp
  181934:	5b                   	pop    %ebx
  181935:	5e                   	pop    %esi
  181936:	5f                   	pop    %edi
  181937:	5d                   	pop    %ebp
  181938:	c3                   	ret    

00181939 <get_lo_cnt>:
	QM_ISR_EOI(QM_IRQ_I2C_1_INT_VECTOR);
}
#endif

static uint32_t get_lo_cnt(uint32_t lo_time_ns)
{
  181939:	53                   	push   %ebx
  18193a:	89 c3                	mov    %eax,%ebx
	return (((get_i2c_clk_freq_in_mhz() * lo_time_ns) / 1000) - 1);
  18193c:	e8 19 f9 ff ff       	call   18125a <get_i2c_clk_freq_in_mhz>
  181941:	0f af d8             	imul   %eax,%ebx
  181944:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  181949:	89 d8                	mov    %ebx,%eax
  18194b:	f7 e1                	mul    %ecx
  18194d:	c1 ea 06             	shr    $0x6,%edx
  181950:	8d 42 ff             	lea    -0x1(%edx),%eax
}
  181953:	5b                   	pop    %ebx
  181954:	c3                   	ret    

00181955 <get_hi_cnt>:

static uint32_t get_hi_cnt(qm_i2c_t i2c, uint32_t hi_time_ns)
{
  181955:	56                   	push   %esi
  181956:	53                   	push   %ebx
  181957:	89 c3                	mov    %eax,%ebx
  181959:	89 d6                	mov    %edx,%esi
	return ((((get_i2c_clk_freq_in_mhz() * hi_time_ns) / 1000) - 7 -
  18195b:	e8 fa f8 ff ff       	call   18125a <get_i2c_clk_freq_in_mhz>
  181960:	0f af f0             	imul   %eax,%esi
  181963:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  181968:	89 f0                	mov    %esi,%eax
  18196a:	f7 e1                	mul    %ecx
  18196c:	c1 ea 06             	shr    $0x6,%edx
		 QM_I2C[i2c]->ic_fs_spklen) +
  18196f:	8b 04 9d bc 02 28 00 	mov    0x2802bc(,%ebx,4),%eax
  181976:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
	return (((get_i2c_clk_freq_in_mhz() * lo_time_ns) / 1000) - 1);
}

static uint32_t get_hi_cnt(qm_i2c_t i2c, uint32_t hi_time_ns)
{
	return ((((get_i2c_clk_freq_in_mhz() * hi_time_ns) / 1000) - 7 -
  18197c:	29 c2                	sub    %eax,%edx
  18197e:	8d 42 fa             	lea    -0x6(%edx),%eax
		 QM_I2C[i2c]->ic_fs_spklen) +
		1);
}
  181981:	5b                   	pop    %ebx
  181982:	5e                   	pop    %esi
  181983:	c3                   	ret    

00181984 <qm_i2c_0_irq_isr>:
	}
}

QM_ISR_DECLARE(qm_i2c_0_irq_isr)
{
	i2c_isr_irq_handler(QM_I2C_0);
  181984:	b8 00 00 00 00       	mov    $0x0,%eax
  181989:	e8 d2 fa ff ff       	call   181460 <i2c_isr_irq_handler>
  18198e:	c3                   	ret    

0018198f <qm_i2c_set_config>:
		 QM_I2C[i2c]->ic_fs_spklen) +
		1);
}

int qm_i2c_set_config(const qm_i2c_t i2c, const qm_i2c_config_t *const cfg)
{
  18198f:	55                   	push   %ebp
  181990:	57                   	push   %edi
  181991:	56                   	push   %esi
  181992:	53                   	push   %ebx
  181993:	83 ec 0c             	sub    $0xc,%esp
  181996:	89 c3                	mov    %eax,%ebx
  181998:	89 d7                	mov    %edx,%edi
	uint32_t lcnt = 0, hcnt = 0, min_lcnt = 0, lcnt_diff = 0, ic_con = 0;
	QM_CHECK(i2c < QM_I2C_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  18199a:	8b 34 85 bc 02 28 00 	mov    0x2802bc(,%eax,4),%esi

	i2c_dma_context[i2c].ongoing_dma_rx_operation = false;
  1819a1:	c1 e0 06             	shl    $0x6,%eax
  1819a4:	c6 80 75 05 28 00 00 	movb   $0x0,0x280575(%eax)
	i2c_dma_context[i2c].ongoing_dma_tx_operation = false;
  1819ab:	c6 80 74 05 28 00 00 	movb   $0x0,0x280574(%eax)
	/* Mask all interrupts. */
	controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  1819b2:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)

	/* Disable controller. */
	if (controller_disable(i2c)) {
  1819b9:	89 d8                	mov    %ebx,%eax
  1819bb:	e8 5d fa ff ff       	call   18141d <controller_disable>
  1819c0:	85 c0                	test   %eax,%eax
  1819c2:	0f 85 7b 01 00 00    	jne    181b43 <qm_i2c_set_config+0x1b4>
  1819c8:	89 c5                	mov    %eax,%ebp
		return -EBUSY;
	}

	switch (cfg->mode) {
  1819ca:	8b 47 08             	mov    0x8(%edi),%eax
  1819cd:	85 c0                	test   %eax,%eax
  1819cf:	74 0e                	je     1819df <qm_i2c_set_config+0x50>
  1819d1:	83 f8 01             	cmp    $0x1,%eax
  1819d4:	0f 84 3c 01 00 00    	je     181b16 <qm_i2c_set_config+0x187>
  1819da:	e9 56 01 00 00       	jmp    181b35 <qm_i2c_set_config+0x1a6>
		/* Set mode. */
		ic_con = QM_I2C_IC_CON_MASTER_MODE | QM_I2C_IC_CON_RESTART_EN |
			 QM_I2C_IC_CON_SLAVE_DISABLE |
			 /* Set 7/10 bit address mode. */
			 (cfg->address_mode
			  << QM_I2C_IC_CON_10BITADDR_MASTER_OFFSET);
  1819df:	8b 47 04             	mov    0x4(%edi),%eax
  1819e2:	c1 e0 04             	shl    $0x4,%eax
	}

	switch (cfg->mode) {
	case QM_I2C_MASTER:
		/* Set mode. */
		ic_con = QM_I2C_IC_CON_MASTER_MODE | QM_I2C_IC_CON_RESTART_EN |
  1819e5:	89 c1                	mov    %eax,%ecx
  1819e7:	83 c9 61             	or     $0x61,%ecx
  1819ea:	89 0c 24             	mov    %ecx,(%esp)
		 *    at 50% duty cycle
		 * 2. adjust the hi/lo count to ensure that minimum hi/lo
		 *    timings are guaranteed as per spec.
		 */

		switch (cfg->speed) {
  1819ed:	8b 17                	mov    (%edi),%edx
  1819ef:	83 fa 02             	cmp    $0x2,%edx
  1819f2:	74 4f                	je     181a43 <qm_i2c_set_config+0xb4>
  1819f4:	83 fa 03             	cmp    $0x3,%edx
  1819f7:	0f 84 80 00 00 00    	je     181a7d <qm_i2c_set_config+0xee>
  1819fd:	83 fa 01             	cmp    $0x1,%edx
  181a00:	0f 85 b1 00 00 00    	jne    181ab7 <qm_i2c_set_config+0x128>
		case QM_I2C_SPEED_STD:

			ic_con |= QM_I2C_IC_CON_SPEED_SS;
  181a06:	83 c8 63             	or     $0x63,%eax
  181a09:	89 04 24             	mov    %eax,(%esp)

			controller->ic_fs_spklen = SPK_LEN_SS;
  181a0c:	c7 86 a0 00 00 00 01 	movl   $0x1,0xa0(%esi)
  181a13:	00 00 00 

			min_lcnt = get_lo_cnt(QM_I2C_MIN_SS_NS);
  181a16:	b8 5c 12 00 00       	mov    $0x125c,%eax
  181a1b:	e8 19 ff ff ff       	call   181939 <get_lo_cnt>
  181a20:	89 44 24 08          	mov    %eax,0x8(%esp)
			lcnt = get_lo_cnt(QM_I2C_SS_50_DC_NS);
  181a24:	b8 88 13 00 00       	mov    $0x1388,%eax
  181a29:	e8 0b ff ff ff       	call   181939 <get_lo_cnt>
  181a2e:	89 44 24 04          	mov    %eax,0x4(%esp)
			hcnt = get_hi_cnt(i2c, QM_I2C_SS_50_DC_NS);
  181a32:	ba 88 13 00 00       	mov    $0x1388,%edx
  181a37:	89 d8                	mov    %ebx,%eax
  181a39:	e8 17 ff ff ff       	call   181955 <get_hi_cnt>
			break;
  181a3e:	e9 89 00 00 00       	jmp    181acc <qm_i2c_set_config+0x13d>

		case QM_I2C_SPEED_FAST:
			ic_con |= QM_I2C_IC_CON_SPEED_FS_FSP;
  181a43:	83 c8 65             	or     $0x65,%eax
  181a46:	89 04 24             	mov    %eax,(%esp)

			controller->ic_fs_spklen = SPK_LEN_FS_FSP;
  181a49:	c7 86 a0 00 00 00 02 	movl   $0x2,0xa0(%esi)
  181a50:	00 00 00 

			min_lcnt = get_lo_cnt(QM_I2C_MIN_FS_NS);
  181a53:	b8 14 05 00 00       	mov    $0x514,%eax
  181a58:	e8 dc fe ff ff       	call   181939 <get_lo_cnt>
  181a5d:	89 44 24 08          	mov    %eax,0x8(%esp)
			lcnt = get_lo_cnt(QM_I2C_FS_50_DC_NS);
  181a61:	b8 e2 04 00 00       	mov    $0x4e2,%eax
  181a66:	e8 ce fe ff ff       	call   181939 <get_lo_cnt>
  181a6b:	89 44 24 04          	mov    %eax,0x4(%esp)
			hcnt = get_hi_cnt(i2c, QM_I2C_FS_50_DC_NS);
  181a6f:	ba e2 04 00 00       	mov    $0x4e2,%edx
  181a74:	89 d8                	mov    %ebx,%eax
  181a76:	e8 da fe ff ff       	call   181955 <get_hi_cnt>
			break;
  181a7b:	eb 4f                	jmp    181acc <qm_i2c_set_config+0x13d>

		case QM_I2C_SPEED_FAST_PLUS:
			ic_con |= QM_I2C_IC_CON_SPEED_FS_FSP;
  181a7d:	83 c8 65             	or     $0x65,%eax
  181a80:	89 04 24             	mov    %eax,(%esp)

			controller->ic_fs_spklen = SPK_LEN_FS_FSP;
  181a83:	c7 86 a0 00 00 00 02 	movl   $0x2,0xa0(%esi)
  181a8a:	00 00 00 

			min_lcnt = get_lo_cnt(QM_I2C_MIN_FSP_NS);
  181a8d:	b8 f4 01 00 00       	mov    $0x1f4,%eax
  181a92:	e8 a2 fe ff ff       	call   181939 <get_lo_cnt>
  181a97:	89 44 24 08          	mov    %eax,0x8(%esp)
			lcnt = get_lo_cnt(QM_I2C_FSP_50_DC_NS);
  181a9b:	b8 f4 01 00 00       	mov    $0x1f4,%eax
  181aa0:	e8 94 fe ff ff       	call   181939 <get_lo_cnt>
  181aa5:	89 44 24 04          	mov    %eax,0x4(%esp)
			hcnt = get_hi_cnt(i2c, QM_I2C_FSP_50_DC_NS);
  181aa9:	ba f4 01 00 00       	mov    $0x1f4,%edx
  181aae:	89 d8                	mov    %ebx,%eax
  181ab0:	e8 a0 fe ff ff       	call   181955 <get_hi_cnt>
			break;
  181ab5:	eb 15                	jmp    181acc <qm_i2c_set_config+0x13d>
		1);
}

int qm_i2c_set_config(const qm_i2c_t i2c, const qm_i2c_config_t *const cfg)
{
	uint32_t lcnt = 0, hcnt = 0, min_lcnt = 0, lcnt_diff = 0, ic_con = 0;
  181ab7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  181abe:	00 
  181abf:	b8 00 00 00 00       	mov    $0x0,%eax
  181ac4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  181acb:	00 
			lcnt = get_lo_cnt(QM_I2C_FSP_50_DC_NS);
			hcnt = get_hi_cnt(i2c, QM_I2C_FSP_50_DC_NS);
			break;
		}

		if (hcnt > QM_I2C_IC_HCNT_MAX || hcnt < QM_I2C_IC_HCNT_MIN) {
  181acc:	8d 50 fa             	lea    -0x6(%eax),%edx
  181acf:	81 fa ef ff 00 00    	cmp    $0xffef,%edx
  181ad5:	77 73                	ja     181b4a <qm_i2c_set_config+0x1bb>
			return -EINVAL;
		}

		if (lcnt > QM_I2C_IC_LCNT_MAX || lcnt < QM_I2C_IC_LCNT_MIN) {
  181ad7:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  181adb:	8d 53 f8             	lea    -0x8(%ebx),%edx
  181ade:	81 fa ed ff 00 00    	cmp    $0xffed,%edx
  181ae4:	77 6b                	ja     181b51 <qm_i2c_set_config+0x1c2>
			return -EINVAL;
		}

		/* Increment minimum low count to account for rounding down. */
		min_lcnt++;
  181ae6:	8b 54 24 08          	mov    0x8(%esp),%edx
  181aea:	42                   	inc    %edx
		if (lcnt < min_lcnt) {
  181aeb:	39 d3                	cmp    %edx,%ebx
  181aed:	73 0a                	jae    181af9 <qm_i2c_set_config+0x16a>
			lcnt_diff = (min_lcnt - lcnt);
  181aef:	89 d1                	mov    %edx,%ecx
  181af1:	29 d9                	sub    %ebx,%ecx
			lcnt += (lcnt_diff);
			hcnt -= (lcnt_diff);
  181af3:	29 c8                	sub    %ecx,%eax

		/* Increment minimum low count to account for rounding down. */
		min_lcnt++;
		if (lcnt < min_lcnt) {
			lcnt_diff = (min_lcnt - lcnt);
			lcnt += (lcnt_diff);
  181af5:	89 54 24 04          	mov    %edx,0x4(%esp)
			hcnt -= (lcnt_diff);
		}
		if (QM_I2C_SPEED_STD == cfg->speed) {
  181af9:	83 3f 01             	cmpl   $0x1,(%edi)
  181afc:	75 0c                	jne    181b0a <qm_i2c_set_config+0x17b>
			controller->ic_ss_scl_lcnt = lcnt;
  181afe:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  181b02:	89 4e 18             	mov    %ecx,0x18(%esi)
			controller->ic_ss_scl_hcnt = hcnt;
  181b05:	89 46 14             	mov    %eax,0x14(%esi)
  181b08:	eb 32                	jmp    181b3c <qm_i2c_set_config+0x1ad>
		} else {
			controller->ic_fs_scl_hcnt = hcnt;
  181b0a:	89 46 1c             	mov    %eax,0x1c(%esi)
			controller->ic_fs_scl_lcnt = lcnt;
  181b0d:	8b 44 24 04          	mov    0x4(%esp),%eax
  181b11:	89 46 20             	mov    %eax,0x20(%esi)
  181b14:	eb 26                	jmp    181b3c <qm_i2c_set_config+0x1ad>
		 * QM_I2C_IC_CON_MASTER_MODE and QM_I2C_IC_CON_SLAVE_DISABLE are
		 * deasserted.
		 */

		/* Set 7/10 bit address mode. */
		ic_con = cfg->address_mode
  181b16:	8b 47 04             	mov    0x4(%edi),%eax
  181b19:	c1 e0 03             	shl    $0x3,%eax
  181b1c:	89 04 24             	mov    %eax,(%esp)
			 << QM_I2C_IC_CON_10BITADDR_SLAVE_OFFSET;

		if (cfg->stop_detect_behaviour ==
  181b1f:	83 7f 10 01          	cmpl   $0x1,0x10(%edi)
  181b23:	75 07                	jne    181b2c <qm_i2c_set_config+0x19d>
		    QM_I2C_SLAVE_INTERRUPT_WHEN_ADDRESSED) {
			/* Set stop interrupt only when addressed. */
			ic_con |= QM_I2C_IC_CON_STOP_DET_IFADDRESSED;
  181b25:	81 0c 24 80 00 00 00 	orl    $0x80,(%esp)
		}

		/* Set slave address. */
		controller->ic_sar = cfg->slave_addr;
  181b2c:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  181b30:	89 46 08             	mov    %eax,0x8(%esi)
		break;
  181b33:	eb 07                	jmp    181b3c <qm_i2c_set_config+0x1ad>
		1);
}

int qm_i2c_set_config(const qm_i2c_t i2c, const qm_i2c_config_t *const cfg)
{
	uint32_t lcnt = 0, hcnt = 0, min_lcnt = 0, lcnt_diff = 0, ic_con = 0;
  181b35:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
		/* Set slave address. */
		controller->ic_sar = cfg->slave_addr;
		break;
	}

	controller->ic_con = ic_con;
  181b3c:	8b 04 24             	mov    (%esp),%eax
  181b3f:	89 06                	mov    %eax,(%esi)
	return 0;
  181b41:	eb 13                	jmp    181b56 <qm_i2c_set_config+0x1c7>
	/* Mask all interrupts. */
	controller->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;

	/* Disable controller. */
	if (controller_disable(i2c)) {
		return -EBUSY;
  181b43:	bd f0 ff ff ff       	mov    $0xfffffff0,%ebp
  181b48:	eb 0c                	jmp    181b56 <qm_i2c_set_config+0x1c7>
			hcnt = get_hi_cnt(i2c, QM_I2C_FSP_50_DC_NS);
			break;
		}

		if (hcnt > QM_I2C_IC_HCNT_MAX || hcnt < QM_I2C_IC_HCNT_MIN) {
			return -EINVAL;
  181b4a:	bd ea ff ff ff       	mov    $0xffffffea,%ebp
  181b4f:	eb 05                	jmp    181b56 <qm_i2c_set_config+0x1c7>
		}

		if (lcnt > QM_I2C_IC_LCNT_MAX || lcnt < QM_I2C_IC_LCNT_MIN) {
			return -EINVAL;
  181b51:	bd ea ff ff ff       	mov    $0xffffffea,%ebp
		break;
	}

	controller->ic_con = ic_con;
	return 0;
}
  181b56:	89 e8                	mov    %ebp,%eax
  181b58:	83 c4 0c             	add    $0xc,%esp
  181b5b:	5b                   	pop    %ebx
  181b5c:	5e                   	pop    %esi
  181b5d:	5f                   	pop    %edi
  181b5e:	5d                   	pop    %ebp
  181b5f:	c3                   	ret    

00181b60 <qm_i2c_master_irq_transfer>:
}

int qm_i2c_master_irq_transfer(const qm_i2c_t i2c,
			       const qm_i2c_transfer_t *const xfer,
			       const uint16_t slave_addr)
{
  181b60:	57                   	push   %edi
  181b61:	56                   	push   %esi
  181b62:	53                   	push   %ebx
  181b63:	89 c6                	mov    %eax,%esi
  181b65:	89 d7                	mov    %edx,%edi
	QM_CHECK(i2c < QM_I2C_NUM, -EINVAL);
	QM_CHECK(NULL != xfer, -EINVAL);
	QM_CHECK(slave_addr <= QM_I2C_IC_TAR_MASK, -EINVAL);

	qm_i2c_reg_t *const controller = QM_I2C[i2c];
  181b67:	8b 1c 85 bc 02 28 00 	mov    0x2802bc(,%eax,4),%ebx

	/* Write slave address to TAR. */
	controller->ic_tar &= ~QM_I2C_IC_TAR_MASK;
  181b6e:	8b 43 04             	mov    0x4(%ebx),%eax
  181b71:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  181b76:	89 43 04             	mov    %eax,0x4(%ebx)
	controller->ic_tar |= slave_addr;
  181b79:	8b 43 04             	mov    0x4(%ebx),%eax
  181b7c:	0f b7 c9             	movzwl %cx,%ecx
  181b7f:	09 c1                	or     %eax,%ecx
  181b81:	89 4b 04             	mov    %ecx,0x4(%ebx)

	i2c_write_pos[i2c] = 0;
  181b84:	c7 04 b5 dc 03 28 00 	movl   $0x0,0x2803dc(,%esi,4)
  181b8b:	00 00 00 00 
	i2c_read_pos[i2c] = 0;
  181b8f:	c7 04 b5 d8 03 28 00 	movl   $0x0,0x2803d8(,%esi,4)
  181b96:	00 00 00 00 
	i2c_read_cmd_send[i2c] = xfer->rx_len;
  181b9a:	8b 42 0c             	mov    0xc(%edx),%eax
  181b9d:	89 04 b5 d4 03 28 00 	mov    %eax,0x2803d4(,%esi,4)
	i2c_transfer[i2c] = xfer;
  181ba4:	89 14 b5 e0 03 28 00 	mov    %edx,0x2803e0(,%esi,4)

	/* Set threshold. */
	controller->ic_tx_tl = TX_TL;
  181bab:	c7 43 3c 02 00 00 00 	movl   $0x2,0x3c(%ebx)
	if (xfer->rx_len > 0 && xfer->rx_len < (RX_TL + 1)) {
  181bb2:	8b 42 0c             	mov    0xc(%edx),%eax
  181bb5:	48                   	dec    %eax
  181bb6:	83 f8 04             	cmp    $0x4,%eax
  181bb9:	77 05                	ja     181bc0 <qm_i2c_master_irq_transfer+0x60>
		/*
		 * If 'rx_len' is less than the default threshold, we have to
		 * change the threshold value so the 'RX FULL' interrupt is
		 * generated once all data from the transfer is received.
		 */
		controller->ic_rx_tl = xfer->rx_len - 1;
  181bbb:	89 43 38             	mov    %eax,0x38(%ebx)
  181bbe:	eb 07                	jmp    181bc7 <qm_i2c_master_irq_transfer+0x67>
	} else {
		controller->ic_rx_tl = RX_TL;
  181bc0:	c7 43 38 05 00 00 00 	movl   $0x5,0x38(%ebx)
	}

	/* Mask interrupts. */
	QM_I2C[i2c]->ic_intr_mask = QM_I2C_IC_INTR_MASK_ALL;
  181bc7:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)

	/* Enable controller. */
	controller_enable(i2c);
  181bce:	89 f0                	mov    %esi,%eax
  181bd0:	e8 20 f8 ff ff       	call   1813f5 <controller_enable>

	/* Start filling tx fifo. */
	master_fill_tx_fifo(i2c, xfer, controller);
  181bd5:	89 d9                	mov    %ebx,%ecx
  181bd7:	89 fa                	mov    %edi,%edx
  181bd9:	89 f0                	mov    %esi,%eax
  181bdb:	e8 9e f7 ff ff       	call   18137e <master_fill_tx_fifo>

	/* Unmask interrupts. */
	controller->ic_intr_mask |=
  181be0:	8b 43 30             	mov    0x30(%ebx),%eax
  181be3:	83 c8 5f             	or     $0x5f,%eax
  181be6:	89 43 30             	mov    %eax,0x30(%ebx)
	    QM_I2C_IC_INTR_MASK_RX_UNDER | QM_I2C_IC_INTR_MASK_RX_OVER |
	    QM_I2C_IC_INTR_MASK_RX_FULL | QM_I2C_IC_INTR_MASK_TX_OVER |
	    QM_I2C_IC_INTR_MASK_TX_EMPTY | QM_I2C_IC_INTR_MASK_TX_ABORT;

	return 0;
}
  181be9:	b8 00 00 00 00       	mov    $0x0,%eax
  181bee:	5b                   	pop    %ebx
  181bef:	5e                   	pop    %esi
  181bf0:	5f                   	pop    %edi
  181bf1:	c3                   	ret    

00181bf2 <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
  181bf2:	83 ec 04             	sub    $0x4,%esp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181bf5:	8b 04 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%eax
	volatile uint32_t unused_lsr __attribute__((unused));

	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;
  181bfc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
  181c03:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
  181c0a:	8b 4a 04             	mov    0x4(%edx),%ecx
  181c0d:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  181c13:	c1 e9 10             	shr    $0x10,%ecx
  181c16:	89 48 04             	mov    %ecx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
  181c19:	8b 4a 04             	mov    0x4(%edx),%ecx
  181c1c:	0f b6 cd             	movzbl %ch,%ecx
  181c1f:	89 08                	mov    %ecx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
  181c21:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  181c25:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
  181c2b:	8b 0a                	mov    (%edx),%ecx
  181c2d:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
  181c30:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
  181c37:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  181c3b:	74 09                	je     181c46 <qm_uart_set_config+0x54>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
  181c3d:	8b 50 10             	mov    0x10(%eax),%edx
  181c40:	83 ca 22             	or     $0x22,%edx
  181c43:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
  181c46:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
  181c4d:	8b 50 04             	mov    0x4(%eax),%edx
  181c50:	80 ca 80             	or     $0x80,%dl
  181c53:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
  181c56:	8b 40 14             	mov    0x14(%eax),%eax
  181c59:	89 04 24             	mov    %eax,(%esp)

	return 0;
}
  181c5c:	b8 00 00 00 00       	mov    $0x0,%eax
  181c61:	83 c4 04             	add    $0x4,%esp
  181c64:	c3                   	ret    

00181c65 <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
  181c65:	56                   	push   %esi
  181c66:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
  181c67:	8b 04 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%eax
	uint32_t lsr = regs->lsr;
  181c6e:	8b 48 14             	mov    0x14(%eax),%ecx

	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
  181c71:	89 cb                	mov    %ecx,%ebx
  181c73:	83 e3 1e             	and    $0x1e,%ebx
  181c76:	89 1a                	mov    %ebx,(%edx)

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
  181c78:	8b 70 1c             	mov    0x1c(%eax),%esi
  181c7b:	f7 c6 01 00 00 00    	test   $0x1,%esi
  181c81:	74 0b                	je     181c8e <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
  181c83:	8b 58 1c             	mov    0x1c(%eax),%ebx
  181c86:	83 e3 fe             	and    $0xfffffffe,%ebx
  181c89:	89 58 1c             	mov    %ebx,0x1c(%eax)
  181c8c:	eb 0a                	jmp    181c98 <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
  181c8e:	f6 c1 40             	test   $0x40,%cl
  181c91:	75 05                	jne    181c98 <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
  181c93:	83 cb 20             	or     $0x20,%ebx
  181c96:	89 1a                	mov    %ebx,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
  181c98:	f6 c1 01             	test   $0x1,%cl
  181c9b:	74 03                	je     181ca0 <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
  181c9d:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
  181ca0:	b8 00 00 00 00       	mov    $0x0,%eax
  181ca5:	5b                   	pop    %ebx
  181ca6:	5e                   	pop    %esi
  181ca7:	c3                   	ret    

00181ca8 <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181ca8:	8b 04 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%eax

	while (regs->lsr & QM_UART_LSR_THRE) {
  181caf:	8b 48 14             	mov    0x14(%eax),%ecx
  181cb2:	f6 c1 20             	test   $0x20,%cl
  181cb5:	75 f8                	jne    181caf <qm_uart_write+0x7>
	}
	regs->rbr_thr_dll = data;
  181cb7:	0f b6 d2             	movzbl %dl,%edx
  181cba:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
  181cbc:	8b 50 14             	mov    0x14(%eax),%edx
  181cbf:	f6 c2 40             	test   $0x40,%dl
  181cc2:	74 f8                	je     181cbc <qm_uart_write+0x14>
	}

	return 0;
}
  181cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  181cc9:	c3                   	ret    

00181cca <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
  181cca:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181ccb:	8b 1c 85 c0 02 28 00 	mov    0x2802c0(,%eax,4),%ebx

	uint32_t lsr = regs->lsr;
  181cd2:	8b 43 14             	mov    0x14(%ebx),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
  181cd5:	eb 03                	jmp    181cda <qm_uart_read+0x10>
		lsr = regs->lsr;
  181cd7:	8b 43 14             	mov    0x14(%ebx),%eax
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
  181cda:	a8 01                	test   $0x1,%al
  181cdc:	74 f9                	je     181cd7 <qm_uart_read+0xd>
		lsr = regs->lsr;
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
  181cde:	83 e0 1e             	and    $0x1e,%eax
  181ce1:	74 0d                	je     181cf0 <qm_uart_read+0x26>
		if (status) {
  181ce3:	85 c9                	test   %ecx,%ecx
  181ce5:	74 14                	je     181cfb <qm_uart_read+0x31>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
  181ce7:	89 01                	mov    %eax,(%ecx)
		}
		return -EIO;
  181ce9:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  181cee:	eb 10                	jmp    181d00 <qm_uart_read+0x36>
	}
	*data = regs->rbr_thr_dll;
  181cf0:	8b 03                	mov    (%ebx),%eax
  181cf2:	88 02                	mov    %al,(%edx)

	return 0;
  181cf4:	b8 00 00 00 00       	mov    $0x0,%eax
  181cf9:	eb 05                	jmp    181d00 <qm_uart_read+0x36>
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
  181cfb:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}
	*data = regs->rbr_thr_dll;

	return 0;
}
  181d00:	5b                   	pop    %ebx
  181d01:	c3                   	ret    

00181d02 <pin_to_register>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The register index of the given pin.
 */
static uint32_t pin_to_register(uint32_t pin, uint32_t width)
{
  181d02:	56                   	push   %esi
  181d03:	53                   	push   %ebx
  181d04:	89 c3                	mov    %eax,%ebx
  181d06:	89 d6                	mov    %edx,%esi
	return (pin / (32 / width));
  181d08:	b8 20 00 00 00       	mov    $0x20,%eax
  181d0d:	ba 00 00 00 00       	mov    $0x0,%edx
  181d12:	f7 f6                	div    %esi
  181d14:	89 c1                	mov    %eax,%ecx
  181d16:	89 d8                	mov    %ebx,%eax
  181d18:	ba 00 00 00 00       	mov    $0x0,%edx
  181d1d:	f7 f1                	div    %ecx
}
  181d1f:	5b                   	pop    %ebx
  181d20:	5e                   	pop    %esi
  181d21:	c3                   	ret    

00181d22 <pin_to_offset>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
  181d22:	56                   	push   %esi
  181d23:	53                   	push   %ebx
  181d24:	89 c6                	mov    %eax,%esi
  181d26:	89 d3                	mov    %edx,%ebx
	return ((pin % (32 / width)) * width);
  181d28:	b8 20 00 00 00       	mov    $0x20,%eax
  181d2d:	ba 00 00 00 00       	mov    $0x0,%edx
  181d32:	f7 f3                	div    %ebx
  181d34:	89 c1                	mov    %eax,%ecx
  181d36:	89 f0                	mov    %esi,%eax
  181d38:	ba 00 00 00 00       	mov    $0x0,%edx
  181d3d:	f7 f1                	div    %ecx
  181d3f:	89 d8                	mov    %ebx,%eax
  181d41:	0f af c2             	imul   %edx,%eax
}
  181d44:	5b                   	pop    %ebx
  181d45:	5e                   	pop    %esi
  181d46:	c3                   	ret    

00181d47 <qm_pmux_select>:

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
  181d47:	57                   	push   %edi
  181d48:	56                   	push   %esi
  181d49:	53                   	push   %ebx
  181d4a:	89 c7                	mov    %eax,%edi
  181d4c:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
  181d4e:	ba 02 00 00 00       	mov    $0x2,%edx
  181d53:	e8 aa ff ff ff       	call   181d02 <pin_to_register>
  181d58:	89 c3                	mov    %eax,%ebx
	uint32_t offs = pin_to_offset(pin, 2);
  181d5a:	ba 02 00 00 00       	mov    $0x2,%edx
  181d5f:	89 f8                	mov    %edi,%eax
  181d61:	e8 bc ff ff ff       	call   181d22 <pin_to_offset>
  181d66:	89 c1                	mov    %eax,%ecx

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
  181d68:	83 c3 0c             	add    $0xc,%ebx
  181d6b:	8b 3c 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edi
  181d72:	ba 03 00 00 00       	mov    $0x3,%edx
  181d77:	d3 e2                	shl    %cl,%edx
  181d79:	f7 d2                	not    %edx
  181d7b:	21 fa                	and    %edi,%edx
  181d7d:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
  181d84:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181d8b:	d3 e6                	shl    %cl,%esi
  181d8d:	09 c6                	or     %eax,%esi
  181d8f:	89 34 9d 00 09 80 b0 	mov    %esi,-0x4f7ff700(,%ebx,4)

	return 0;
}
  181d96:	b8 00 00 00 00       	mov    $0x0,%eax
  181d9b:	5b                   	pop    %ebx
  181d9c:	5e                   	pop    %esi
  181d9d:	5f                   	pop    %edi
  181d9e:	c3                   	ret    

00181d9f <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
  181d9f:	57                   	push   %edi
  181da0:	56                   	push   %esi
  181da1:	53                   	push   %ebx
  181da2:	89 c7                	mov    %eax,%edi
  181da4:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  181da6:	ba 01 00 00 00       	mov    $0x1,%edx
  181dab:	e8 52 ff ff ff       	call   181d02 <pin_to_register>
  181db0:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  181db2:	ba 01 00 00 00       	mov    $0x1,%edx
  181db7:	89 f8                	mov    %edi,%eax
  181db9:	e8 64 ff ff ff       	call   181d22 <pin_to_offset>
  181dbe:	ba 01 00 00 00       	mov    $0x1,%edx
  181dc3:	88 c1                	mov    %al,%cl
  181dc5:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  181dc7:	89 f0                	mov    %esi,%eax
  181dc9:	84 c0                	test   %al,%al
  181dcb:	75 17                	jne    181de4 <qm_pmux_input_en+0x45>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
  181dcd:	83 c3 08             	add    $0x8,%ebx
  181dd0:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181dd7:	f7 d2                	not    %edx
  181dd9:	21 c2                	and    %eax,%edx
  181ddb:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  181de2:	eb 13                	jmp    181df7 <qm_pmux_input_en+0x58>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
  181de4:	83 c3 08             	add    $0x8,%ebx
  181de7:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181dee:	09 c2                	or     %eax,%edx
  181df0:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  181df7:	b8 00 00 00 00       	mov    $0x0,%eax
  181dfc:	5b                   	pop    %ebx
  181dfd:	5e                   	pop    %esi
  181dfe:	5f                   	pop    %edi
  181dff:	c3                   	ret    

00181e00 <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
  181e00:	57                   	push   %edi
  181e01:	56                   	push   %esi
  181e02:	53                   	push   %ebx
  181e03:	89 c7                	mov    %eax,%edi
  181e05:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  181e07:	ba 01 00 00 00       	mov    $0x1,%edx
  181e0c:	e8 f1 fe ff ff       	call   181d02 <pin_to_register>
  181e11:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  181e13:	ba 01 00 00 00       	mov    $0x1,%edx
  181e18:	89 f8                	mov    %edi,%eax
  181e1a:	e8 03 ff ff ff       	call   181d22 <pin_to_offset>
  181e1f:	ba 01 00 00 00       	mov    $0x1,%edx
  181e24:	88 c1                	mov    %al,%cl
  181e26:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  181e28:	89 f0                	mov    %esi,%eax
  181e2a:	84 c0                	test   %al,%al
  181e2c:	75 14                	jne    181e42 <qm_pmux_pullup_en+0x42>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
  181e2e:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181e35:	f7 d2                	not    %edx
  181e37:	21 c2                	and    %eax,%edx
  181e39:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  181e40:	eb 10                	jmp    181e52 <qm_pmux_pullup_en+0x52>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
  181e42:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181e49:	09 c2                	or     %eax,%edx
  181e4b:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  181e52:	b8 00 00 00 00       	mov    $0x0,%eax
  181e57:	5b                   	pop    %ebx
  181e58:	5e                   	pop    %esi
  181e59:	5f                   	pop    %edi
  181e5a:	c3                   	ret    

00181e5b <k_cpu_idle>:
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  181e5b:	fb                   	sti    
  181e5c:	f4                   	hlt    
  181e5d:	c3                   	ret    

00181e5e <_SysFatalErrorHandler>:
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
  181e5e:	e8 e5 11 00 00       	call   183048 <k_is_in_isr>
  181e63:	85 c0                	test   %eax,%eax
  181e65:	75 09                	jne    181e70 <_SysFatalErrorHandler+0x12>
  181e67:	e8 ea 11 00 00       	call   183056 <_is_thread_essential>
  181e6c:	85 c0                	test   %eax,%eax
  181e6e:	74 25                	je     181e95 <_SysFatalErrorHandler+0x37>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  181e70:	e8 d3 11 00 00       	call   183048 <k_is_in_isr>
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  181e75:	85 c0                	test   %eax,%eax
  181e77:	74 07                	je     181e80 <_SysFatalErrorHandler+0x22>
  181e79:	b8 d8 6c 18 00       	mov    $0x186cd8,%eax
  181e7e:	eb 05                	jmp    181e85 <_SysFatalErrorHandler+0x27>
  181e80:	b8 dc 6c 18 00       	mov    $0x186cdc,%eax
  181e85:	50                   	push   %eax
  181e86:	68 2c 6d 18 00       	push   $0x186d2c
  181e8b:	e8 19 f3 ff ff       	call   1811a9 <printk>
  181e90:	83 c4 08             	add    $0x8,%esp
  181e93:	eb fe                	jmp    181e93 <_SysFatalErrorHandler+0x35>
		       k_is_in_isr() ? "ISR" : "essential thread");
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  181e95:	ff 35 08 04 28 00    	pushl  0x280408
  181e9b:	68 4c 6d 18 00       	push   $0x186d4c
  181ea0:	e8 04 f3 ff ff       	call   1811a9 <printk>
  181ea5:	83 c4 08             	add    $0x8,%esp
	k_thread_abort(_current);
  181ea8:	a1 08 04 28 00       	mov    0x280408,%eax
  181ead:	e8 ee 13 00 00       	call   1832a0 <k_thread_abort>

00181eb2 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  181eb2:	53                   	push   %ebx
	movl $1, %eax
  181eb3:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  181eb8:	0f a2                	cpuid  
	movl %ebx, %eax
  181eba:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  181ebc:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  181ec1:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  181ec4:	5b                   	pop    %ebx
	ret
  181ec5:	c3                   	ret    

00181ec6 <init_cache_line_size>:

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  181ec6:	e8 e7 ff ff ff       	call   181eb2 <_cache_line_size_get>
  181ecb:	a3 84 05 28 00       	mov    %eax,0x280584
  181ed0:	c3                   	ret    

00181ed1 <init_cache>:
static int init_cache(struct device *unused)
{
	ARG_UNUSED(unused);

	init_cache_flush();
	init_cache_line_size();
  181ed1:	e8 f0 ff ff ff       	call   181ec6 <init_cache_line_size>

	return 0;
}
  181ed6:	b8 00 00 00 00       	mov    $0x0,%eax
  181edb:	c3                   	ret    

00181edc <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  181edc:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  181edd:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  181ee0:	50                   	push   %eax
	pushl	%edx
  181ee1:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  181ee2:	57                   	push   %edi
	pushl	%esi
  181ee3:	56                   	push   %esi
	pushl	%ebx
  181ee4:	53                   	push   %ebx
	pushl	%ebp
  181ee5:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  181ee6:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  181eea:	50                   	push   %eax

	/* ESP is pointing to the ESF at this point */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %edx
  181eeb:	8b 15 08 04 28 00    	mov    0x280408,%edx

	/* inc exception nest count */
	incl	_thread_offset_to_excNestCount(%edx)
  181ef1:	ff 42 44             	incl   0x44(%edx)
     * the current execution context if this is the outermost exception.
     * The ESF pointer is used by debug tools to locate the volatile
     * registers and the stack of the preempted thread.
     */

	testb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  181ef4:	f6 42 09 40          	testb  $0x40,0x9(%edx)
	jne	alreadyInException
  181ef8:	75 03                	jne    181efd <alreadyInException>
	movl	%esp, _thread_offset_to_esf(%edx)
  181efa:	89 62 40             	mov    %esp,0x40(%edx)

00181efd <alreadyInException>:
	 * (where needed) if the exception handler causes a context switch.
	 * It also indicates to debug tools that an exception is being
	 * handled in the event of a context switch.
	 */

	orb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  181efd:	80 4a 09 40          	orb    $0x40,0x9(%edx)
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  181f01:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  181f08:	00 
	je	allDone
  181f09:	74 01                	je     181f0c <allDone>
	sti
  181f0b:	fb                   	sti    

00181f0c <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
  181f0c:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
  181f0e:	ff d1                	call   *%ecx
	addl	$0x4, %esp
#endif

#if defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %ecx
  181f10:	8b 0d 08 04 28 00    	mov    0x280408,%ecx
	 * Must lock interrupts to prevent outside interference.
	 * (Using "lock" prefix would be nicer, but this won't work
	 * on platforms that don't respect the CPU's bus lock signal.)
	 */

	cli
  181f16:	fa                   	cli    

	/*
	 * Determine whether exiting from a nested interrupt.
	 */

	decl	_thread_offset_to_excNestCount(%ecx)
  181f17:	ff 49 44             	decl   0x44(%ecx)

	cmpl	$0, _thread_offset_to_excNestCount(%ecx)
  181f1a:	83 79 44 00          	cmpl   $0x0,0x44(%ecx)
	jne	nestedException
  181f1e:	75 04                	jne    181f24 <nestedException>
	 * Clear the _EXC_ACTIVE bit in the k_thread of the current execution
	 * context if we are not in a nested exception (ie, when we exit the
	 * outermost exception).
	 */

	andb	$~_EXC_ACTIVE, _thread_offset_to_thread_state(%ecx)
  181f20:	80 61 09 bf          	andb   $0xbf,0x9(%ecx)

00181f24 <nestedException>:
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  181f24:	5d                   	pop    %ebp
	popl	%ebp
  181f25:	5d                   	pop    %ebp
	popl	%ebx
  181f26:	5b                   	pop    %ebx
	popl	%esi
  181f27:	5e                   	pop    %esi
	popl	%edi
  181f28:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  181f29:	5a                   	pop    %edx
	popl	%eax
  181f2a:	58                   	pop    %eax
	popl	%ecx
  181f2b:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  181f2c:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181f2f:	cf                   	iret   

00181f30 <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  181f30:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  181f31:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  181f35:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  181f38:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  181f39:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  181f3a:	b9 00 04 28 00       	mov    $0x280400,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  181f3f:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  181f41:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  181f44:	75 06                	jne    181f4c <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  181f46:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  181f48:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  181f4b:	57                   	push   %edi

00181f4c <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  181f4c:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  181f4d:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  181f4f:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
  181f50:	31 c0                	xor    %eax,%eax
  181f52:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  181f57:	b9 00 04 28 00       	mov    $0x280400,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  181f5c:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  181f5e:	75 2b                	jne    181f8b <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  181f60:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
  181f63:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
  181f69:	73 1f                	jae    181f8a <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  181f6b:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
  181f6e:	74 1a                	je     181f8a <noReschedule>
	 * preserved using the lazy save/restore algorithm, or to indicate to
	 * debug tools that a preemptive context switch has occurred.
	 */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)
	orb	$_INT_ACTIVE, _thread_offset_to_thread_state(%edx)
  181f70:	80 4a 09 80          	orb    $0x80,0x9(%edx)
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  181f74:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  181f75:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
  181f76:	58                   	pop    %eax
#endif
	call	_Swap
  181f77:	e8 30 00 00 00       	call   181fac <_Swap>
	 * _Swap() has restored the floating point registers, if needed.
	 * Clear the _INT_ACTIVE bit in the interrupted thread's state
	 * since it has served its purpose.
	 */

	movl	_kernel + _kernel_offset_to_current, %eax
  181f7c:	a1 08 04 28 00       	mov    0x280408,%eax
	andb	$~_INT_ACTIVE, _thread_offset_to_thread_state(%eax)
  181f81:	80 60 09 7f          	andb   $0x7f,0x9(%eax)

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  181f85:	5f                   	pop    %edi
	popl	%ecx
  181f86:	59                   	pop    %ecx
	popl	%edx
  181f87:	5a                   	pop    %edx
	popl	%eax
  181f88:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181f89:	cf                   	iret   

00181f8a <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  181f8a:	5c                   	pop    %esp

00181f8b <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  181f8b:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  181f8c:	59                   	pop    %ecx
	popl	%edx
  181f8d:	5a                   	pop    %edx
	popl	%eax
  181f8e:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181f8f:	cf                   	iret   

00181f90 <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  181f90:	6a 00                	push   $0x0

00181f92 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  181f92:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  181f93:	50                   	push   %eax
	pushl %ecx
  181f94:	51                   	push   %ecx
	pushl %edx
  181f95:	52                   	push   %edx
	pushl %edi
  181f96:	57                   	push   %edi
	pushl %esi
  181f97:	56                   	push   %esi
	pushl %ebx
  181f98:	53                   	push   %ebx
	pushl %ebp
  181f99:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  181f9a:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  181f9e:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
  181f9f:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
  181fa1:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
  181fa2:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  181fa7:	e8 d5 00 00 00       	call   182081 <_NanoFatalErrorHandler>

00181fac <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
  181fac:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
  181faf:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  181fb3:	57                   	push   %edi

	movl	$_kernel, %edi
  181fb4:	bf 00 04 28 00       	mov    $0x280400,%edi

	pushl	%esi
  181fb9:	56                   	push   %esi
	pushl	%ebx
  181fba:	53                   	push   %ebx
	pushl	%ebp
  181fbb:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
  181fbc:	ff 35 24 6f 18 00    	pushl  0x186f24


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  181fc2:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  181fc5:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  181fc8:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  181fcb:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  181fce:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
  181fd1:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  181fd2:	5d                   	pop    %ebp
	popl	%ebx
  181fd3:	5b                   	pop    %ebx
	popl	%esi
  181fd4:	5e                   	pop    %esi
	popl	%edi
  181fd5:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  181fd6:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  181fda:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
  181fdb:	5a                   	pop    %edx
	movl	%edx, (%esp)
  181fdc:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
  181fdf:	c3                   	ret    

00181fe0 <_new_thread_internal>:
 * @return N/A
 */
static void _new_thread_internal(char *pStackMem, unsigned stackSize,
				 int priority,
				 unsigned options)
{
  181fe0:	56                   	push   %esi
  181fe1:	53                   	push   %ebx
  181fe2:	89 c3                	mov    %eax,%ebx
  181fe4:	89 d6                	mov    %edx,%esi
  181fe6:	89 ca                	mov    %ecx,%edx
	unsigned long *pInitialCtx;
	/* ptr to the new task's k_thread */
	struct k_thread *thread = (struct k_thread *)pStackMem;

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
  181fe8:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
  181fef:	ff 74 24 0c          	pushl  0xc(%esp)
  181ff3:	b9 04 00 00 00       	mov    $0x4,%ecx
  181ff8:	e8 73 12 00 00       	call   183270 <_init_thread_base>
  181ffd:	83 c4 04             	add    $0x4,%esp

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  182000:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	thread->fn_abort = NULL;
  182007:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
	 * the base address of the stack which is past the initial stack frame.
	 * Therefore some of the calculations done in the other routines that
	 * initialize the stack frame need to be repeated.
	 */

	pInitialCtx = (unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  18200e:	8d 14 33             	lea    (%ebx,%esi,1),%edx
  182011:	83 e2 fc             	and    $0xfffffffc,%edx
#ifdef CONFIG_THREAD_MONITOR
	/*
	 * In debug mode thread->entry give direct access to the thread entry
	 * and the corresponding parameters.
	 */
	thread->entry = (struct __thread_entry *)(pInitialCtx -
  182014:	8d 42 c0             	lea    -0x40(%edx),%eax
  182017:	89 43 34             	mov    %eax,0x34(%ebx)
	 *  - 4 thread entry routine parameters
	 *  - eflags
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;
  18201a:	83 ea 2c             	sub    $0x2c,%edx

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  18201d:	89 53 28             	mov    %edx,0x28(%ebx)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182020:	9c                   	pushf  
  182021:	fa                   	cli    
  182022:	58                   	pop    %eax
static ALWAYS_INLINE void thread_monitor_init(struct k_thread *thread)
{
	unsigned int key;

	key = irq_lock();
	thread->next_thread = _kernel.threads;
  182023:	8b 15 1c 05 28 00    	mov    0x28051c,%edx
  182029:	89 53 38             	mov    %edx,0x38(%ebx)
	_kernel.threads = thread;
  18202c:	89 1d 1c 05 28 00    	mov    %ebx,0x28051c
  182032:	f6 c4 02             	test   $0x2,%ah
  182035:	74 01                	je     182038 <_new_thread_internal+0x58>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182037:	fb                   	sti    
	PRINTK("\nInitial context ESP = 0x%x\n", thread->coopReg.esp);

	PRINTK("\nstruct thread * = 0x%x", thread);

	thread_monitor_init(thread);
}
  182038:	5b                   	pop    %ebx
  182039:	5e                   	pop    %esi
  18203a:	c3                   	ret    

0018203b <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  18203b:	56                   	push   %esi
  18203c:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  18203d:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  182040:	83 e3 fc             	and    $0xfffffffc,%ebx
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  182043:	8b 74 24 14          	mov    0x14(%esp),%esi
  182047:	89 73 fc             	mov    %esi,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  18204a:	8b 74 24 10          	mov    0x10(%esp),%esi
  18204e:	89 73 f8             	mov    %esi,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  182051:	8b 74 24 0c          	mov    0xc(%esp),%esi
  182055:	89 73 f4             	mov    %esi,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  182058:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  18205b:	9c                   	pushf  
  18205c:	59                   	pop    %ecx

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  18205d:	80 e5 cd             	and    $0xcd,%ch
  182060:	80 cd 02             	or     $0x2,%ch
  182063:	89 4b ec             	mov    %ecx,-0x14(%ebx)
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
  182066:	c7 43 e8 60 00 18 00 	movl   $0x180060,-0x18(%ebx)
	/*
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
  18206d:	ff 74 24 1c          	pushl  0x1c(%esp)
  182071:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  182075:	e8 66 ff ff ff       	call   181fe0 <_new_thread_internal>
  18207a:	83 c4 04             	add    $0x4,%esp
}
  18207d:	5b                   	pop    %ebx
  18207e:	5e                   	pop    %esi
  18207f:	c3                   	ret    

00182080 <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  182080:	c3                   	ret    

00182081 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  182081:	55                   	push   %ebp
  182082:	57                   	push   %edi
  182083:	56                   	push   %esi
  182084:	53                   	push   %ebx
  182085:	83 ec 24             	sub    $0x24,%esp
  182088:	89 c6                	mov    %eax,%esi
  18208a:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
  18208c:	89 d0                	mov    %edx,%eax
  18208e:	e8 ed ff ff ff       	call   182080 <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  182093:	83 fe 03             	cmp    $0x3,%esi
  182096:	74 4c                	je     1820e4 <_NanoFatalErrorHandler+0x63>
  182098:	83 fe 03             	cmp    $0x3,%esi
  18209b:	77 06                	ja     1820a3 <_NanoFatalErrorHandler+0x22>
  18209d:	85 f6                	test   %esi,%esi
  18209f:	74 0e                	je     1820af <_NanoFatalErrorHandler+0x2e>
  1820a1:	eb 5f                	jmp    182102 <_NanoFatalErrorHandler+0x81>
  1820a3:	83 fe 05             	cmp    $0x5,%esi
  1820a6:	74 4b                	je     1820f3 <_NanoFatalErrorHandler+0x72>
  1820a8:	83 fe 06             	cmp    $0x6,%esi
  1820ab:	74 63                	je     182110 <_NanoFatalErrorHandler+0x8f>
  1820ad:	eb 53                	jmp    182102 <_NanoFatalErrorHandler+0x81>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  1820af:	e8 7a ea ff ff       	call   180b2e <__irq_controller_isr_vector_get>
  1820b4:	89 c3                	mov    %eax,%ebx
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  1820b6:	68 74 6d 18 00       	push   $0x186d74
  1820bb:	e8 e9 f0 ff ff       	call   1811a9 <printk>
  1820c0:	83 c4 04             	add    $0x4,%esp
		if (vector >= 0) {
  1820c3:	85 db                	test   %ebx,%ebx
  1820c5:	78 0e                	js     1820d5 <_NanoFatalErrorHandler+0x54>
			printk("%d ", vector);
  1820c7:	53                   	push   %ebx
  1820c8:	68 ed 6c 18 00       	push   $0x186ced
  1820cd:	e8 d7 f0 ff ff       	call   1811a9 <printk>
  1820d2:	83 c4 08             	add    $0x8,%esp
		}
		printk("*****\n");
  1820d5:	68 f1 6c 18 00       	push   $0x186cf1
  1820da:	e8 ca f0 ff ff       	call   1811a9 <printk>
  1820df:	83 c4 04             	add    $0x4,%esp
		break;
  1820e2:	eb 2c                	jmp    182110 <_NanoFatalErrorHandler+0x8f>
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  1820e4:	68 98 6d 18 00       	push   $0x186d98
  1820e9:	e8 bb f0 ff ff       	call   1811a9 <printk>
  1820ee:	83 c4 04             	add    $0x4,%esp
		break;
  1820f1:	eb 1d                	jmp    182110 <_NanoFatalErrorHandler+0x8f>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  1820f3:	68 c4 6d 18 00       	push   $0x186dc4
  1820f8:	e8 ac f0 ff ff       	call   1811a9 <printk>
  1820fd:	83 c4 04             	add    $0x4,%esp
		break;
  182100:	eb 0e                	jmp    182110 <_NanoFatalErrorHandler+0x8f>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  182102:	56                   	push   %esi
  182103:	68 ec 6d 18 00       	push   $0x186dec
  182108:	e8 9c f0 ff ff       	call   1811a9 <printk>
  18210d:	83 c4 08             	add    $0x8,%esp
		break;
	}

	printk("Current thread ID = %p\n"
  182110:	8b 6f 2c             	mov    0x2c(%edi),%ebp
  182113:	8b 07                	mov    (%edi),%eax
  182115:	89 04 24             	mov    %eax,(%esp)
  182118:	8b 4f 04             	mov    0x4(%edi),%ecx
  18211b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  18211f:	8b 5f 10             	mov    0x10(%edi),%ebx
  182122:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  182126:	8b 57 0c             	mov    0xc(%edi),%edx
  182129:	89 54 24 0c          	mov    %edx,0xc(%esp)
  18212d:	8b 47 14             	mov    0x14(%edi),%eax
  182130:	89 44 24 10          	mov    %eax,0x10(%esp)
  182134:	8b 4f 1c             	mov    0x1c(%edi),%ecx
  182137:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  18213b:	8b 5f 08             	mov    0x8(%edi),%ebx
  18213e:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  182142:	8b 57 18             	mov    0x18(%edi),%edx
  182145:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  182149:	8b 47 24             	mov    0x24(%edi),%eax
  18214c:	89 44 24 20          	mov    %eax,0x20(%esp)
	       "Faulting segment:address = 0x%x:0x%x\n"
	       "eax: 0x%x, ebx: 0x%x, ecx: 0x%x, edx: 0x%x\n"
	       "esi: 0x%x, edi: 0x%x, ebp: 0%x, esp: 0x%x\n"
	       "eflags: 0x%x\n",
	       k_current_get(),
	       pEsf->cs & 0xFFFF, pEsf->eip,
  182150:	8b 5f 28             	mov    0x28(%edi),%ebx
	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}

	printk("Current thread ID = %p\n"
  182153:	e8 ae 07 00 00       	call   182906 <k_current_get>
  182158:	55                   	push   %ebp
  182159:	ff 74 24 04          	pushl  0x4(%esp)
  18215d:	ff 74 24 0c          	pushl  0xc(%esp)
  182161:	ff 74 24 14          	pushl  0x14(%esp)
  182165:	ff 74 24 1c          	pushl  0x1c(%esp)
  182169:	ff 74 24 24          	pushl  0x24(%esp)
  18216d:	ff 74 24 2c          	pushl  0x2c(%esp)
  182171:	ff 74 24 34          	pushl  0x34(%esp)
  182175:	ff 74 24 3c          	pushl  0x3c(%esp)
  182179:	ff 74 24 44          	pushl  0x44(%esp)
  18217d:	0f b7 d3             	movzwl %bx,%edx
  182180:	52                   	push   %edx
  182181:	50                   	push   %eax
  182182:	68 10 6e 18 00       	push   $0x186e10
  182187:	e8 1d f0 ff ff       	call   1811a9 <printk>
  18218c:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  18218f:	89 fa                	mov    %edi,%edx
  182191:	89 f0                	mov    %esi,%eax
  182193:	e8 c6 fc ff ff       	call   181e5e <_SysFatalErrorHandler>

00182198 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  182198:	56                   	push   %esi
  182199:	53                   	push   %ebx
  18219a:	89 c3                	mov    %eax,%ebx
  18219c:	89 d6                	mov    %edx,%esi
	printk("***** CPU exception %d\n", vector);
  18219e:	50                   	push   %eax
  18219f:	68 f8 6c 18 00       	push   $0x186cf8
  1821a4:	e8 00 f0 ff ff       	call   1811a9 <printk>
  1821a9:	83 c4 08             	add    $0x8,%esp
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  1821ac:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  1821b1:	88 d9                	mov    %bl,%cl
  1821b3:	d3 f8                	sar    %cl,%eax
  1821b5:	a8 01                	test   $0x1,%al
  1821b7:	74 10                	je     1821c9 <generic_exc_handle+0x31>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  1821b9:	ff 76 20             	pushl  0x20(%esi)
  1821bc:	68 10 6d 18 00       	push   $0x186d10
  1821c1:	e8 e3 ef ff ff       	call   1811a9 <printk>
  1821c6:	83 c4 08             	add    $0x8,%esp
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  1821c9:	89 f2                	mov    %esi,%edx
  1821cb:	b8 06 00 00 00       	mov    $0x6,%eax
  1821d0:	e8 ac fe ff ff       	call   182081 <_NanoFatalErrorHandler>

001821d5 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  1821d5:	89 c2                	mov    %eax,%edx
  1821d7:	b8 00 00 00 00       	mov    $0x0,%eax
  1821dc:	e8 b7 ff ff ff       	call   182198 <generic_exc_handle>

001821e1 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  1821e1:	89 c2                	mov    %eax,%edx
  1821e3:	b8 02 00 00 00       	mov    $0x2,%eax
  1821e8:	e8 ab ff ff ff       	call   182198 <generic_exc_handle>

001821ed <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  1821ed:	89 c2                	mov    %eax,%edx
  1821ef:	b8 04 00 00 00       	mov    $0x4,%eax
  1821f4:	e8 9f ff ff ff       	call   182198 <generic_exc_handle>

001821f9 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  1821f9:	89 c2                	mov    %eax,%edx
  1821fb:	b8 05 00 00 00       	mov    $0x5,%eax
  182200:	e8 93 ff ff ff       	call   182198 <generic_exc_handle>

00182205 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  182205:	89 c2                	mov    %eax,%edx
  182207:	b8 06 00 00 00       	mov    $0x6,%eax
  18220c:	e8 87 ff ff ff       	call   182198 <generic_exc_handle>

00182211 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  182211:	89 c2                	mov    %eax,%edx
  182213:	b8 07 00 00 00       	mov    $0x7,%eax
  182218:	e8 7b ff ff ff       	call   182198 <generic_exc_handle>

0018221d <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  18221d:	89 c2                	mov    %eax,%edx
  18221f:	b8 08 00 00 00       	mov    $0x8,%eax
  182224:	e8 6f ff ff ff       	call   182198 <generic_exc_handle>

00182229 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  182229:	89 c2                	mov    %eax,%edx
  18222b:	b8 0a 00 00 00       	mov    $0xa,%eax
  182230:	e8 63 ff ff ff       	call   182198 <generic_exc_handle>

00182235 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  182235:	89 c2                	mov    %eax,%edx
  182237:	b8 0b 00 00 00       	mov    $0xb,%eax
  18223c:	e8 57 ff ff ff       	call   182198 <generic_exc_handle>

00182241 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  182241:	89 c2                	mov    %eax,%edx
  182243:	b8 0c 00 00 00       	mov    $0xc,%eax
  182248:	e8 4b ff ff ff       	call   182198 <generic_exc_handle>

0018224d <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  18224d:	89 c2                	mov    %eax,%edx
  18224f:	b8 0d 00 00 00       	mov    $0xd,%eax
  182254:	e8 3f ff ff ff       	call   182198 <generic_exc_handle>

00182259 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  182259:	89 c2                	mov    %eax,%edx
  18225b:	b8 0e 00 00 00       	mov    $0xe,%eax
  182260:	e8 33 ff ff ff       	call   182198 <generic_exc_handle>

00182265 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  182265:	89 c2                	mov    %eax,%edx
  182267:	b8 10 00 00 00       	mov    $0x10,%eax
  18226c:	e8 27 ff ff ff       	call   182198 <generic_exc_handle>

00182271 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  182271:	89 c2                	mov    %eax,%edx
  182273:	b8 11 00 00 00       	mov    $0x11,%eax
  182278:	e8 1b ff ff ff       	call   182198 <generic_exc_handle>

0018227d <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  18227d:	89 c2                	mov    %eax,%edx
  18227f:	b8 12 00 00 00       	mov    $0x12,%eax
  182284:	e8 0f ff ff ff       	call   182198 <generic_exc_handle>

00182289 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  182289:	56                   	push   %esi
  18228a:	53                   	push   %ebx
  18228b:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  18228d:	8b 1c 85 00 6f 18 00 	mov    0x186f00(,%eax,4),%ebx
  182294:	eb 0a                	jmp    1822a0 <_sys_device_do_config_level+0x17>
		struct device_config *device = info->config;
  182296:	8b 13                	mov    (%ebx),%edx

		device->init(info);
  182298:	89 d8                	mov    %ebx,%eax
  18229a:	ff 52 04             	call   *0x4(%edx)
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  18229d:	83 c3 0c             	add    $0xc,%ebx
  1822a0:	3b 1c b5 04 6f 18 00 	cmp    0x186f04(,%esi,4),%ebx
  1822a7:	72 ed                	jb     182296 <_sys_device_do_config_level+0xd>
		struct device_config *device = info->config;

		device->init(info);
	}
}
  1822a9:	5b                   	pop    %ebx
  1822aa:	5e                   	pop    %esi
  1822ab:	c3                   	ret    

001822ac <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  1822ac:	56                   	push   %esi
  1822ad:	53                   	push   %ebx
  1822ae:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1822b0:	bb d0 02 28 00       	mov    $0x2802d0,%ebx
  1822b5:	eb 18                	jmp    1822cf <device_get_binding+0x23>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  1822b7:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  1822bb:	74 0f                	je     1822cc <device_get_binding+0x20>
  1822bd:	8b 03                	mov    (%ebx),%eax
  1822bf:	8b 10                	mov    (%eax),%edx
  1822c1:	89 f0                	mov    %esi,%eax
  1822c3:	e8 20 17 00 00       	call   1839e8 <strcmp>
  1822c8:	85 c0                	test   %eax,%eax
  1822ca:	74 12                	je     1822de <device_get_binding+0x32>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1822cc:	83 c3 0c             	add    $0xc,%ebx
  1822cf:	81 fb 48 03 28 00    	cmp    $0x280348,%ebx
  1822d5:	75 e0                	jne    1822b7 <device_get_binding+0xb>
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
  1822d7:	b8 00 00 00 00       	mov    $0x0,%eax
  1822dc:	eb 02                	jmp    1822e0 <device_get_binding+0x34>
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
  1822de:	89 d8                	mov    %ebx,%eax
		}
	}

	return NULL;
}
  1822e0:	5b                   	pop    %ebx
  1822e1:	5e                   	pop    %esi
  1822e2:	c3                   	ret    

001822e3 <device_busy_set>:
}

#endif

void device_busy_set(struct device *busy_dev)
{
  1822e3:	c3                   	ret    

001822e4 <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
  1822e4:	c3                   	ret    

001822e5 <prepare_multithreading>:
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  1822e5:	a3 08 04 28 00       	mov    %eax,0x280408

	dummy_thread->base.user_options = K_ESSENTIAL;
  1822ea:	c6 40 08 01          	movb   $0x1,0x8(%eax)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  1822ee:	b8 00 00 00 00       	mov    $0x0,%eax
  1822f3:	eb 1a                	jmp    18230f <prepare_multithreading+0x2a>
		sys_dlist_init(&_ready_q.q[ii]);
  1822f5:	8d 50 01             	lea    0x1(%eax),%edx
  1822f8:	8d 0c d5 14 04 28 00 	lea    0x280414(,%edx,8),%ecx
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  1822ff:	89 0c d5 14 04 28 00 	mov    %ecx,0x280414(,%edx,8)
	list->tail = (sys_dnode_t *)list;
  182306:	89 0c c5 20 04 28 00 	mov    %ecx,0x280420(,%eax,8)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  18230d:	89 d0                	mov    %edx,%eax
  18230f:	83 f8 1f             	cmp    $0x1f,%eax
  182312:	7e e1                	jle    1822f5 <prepare_multithreading+0x10>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
  182314:	c7 05 14 04 28 00 a0 	movl   $0x2807a0,0x280414
  18231b:	07 28 00 

	_new_thread(_main_stack, MAIN_STACK_SIZE,
  18231e:	6a 01                	push   $0x1
  182320:	6a 00                	push   $0x0
  182322:	6a 00                	push   $0x0
  182324:	6a 00                	push   $0x0
  182326:	6a 00                	push   $0x0
  182328:	b9 d4 23 18 00       	mov    $0x1823d4,%ecx
  18232d:	ba 00 02 00 00       	mov    $0x200,%edx
  182332:	b8 a0 07 28 00       	mov    $0x2807a0,%eax
  182337:	e8 ff fc ff ff       	call   18203b <_new_thread>
  18233c:	83 c4 14             	add    $0x14,%esp
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  18233f:	a0 a9 07 28 00       	mov    0x2807a9,%al
  182344:	83 e0 fb             	and    $0xfffffffb,%eax
  182347:	a2 a9 07 28 00       	mov    %al,0x2807a9
		    _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
  18234c:	b8 a0 07 28 00       	mov    $0x2807a0,%eax
  182351:	e8 3b 01 00 00       	call   182491 <_add_thread_to_ready_q>

#ifdef CONFIG_MULTITHREADING
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  182356:	6a 01                	push   $0x1
  182358:	6a 0f                	push   $0xf
  18235a:	6a 00                	push   $0x0
  18235c:	6a 00                	push   $0x0
  18235e:	6a 00                	push   $0x0
  182360:	b9 d2 32 18 00       	mov    $0x1832d2,%ecx
  182365:	ba 00 01 00 00       	mov    $0x100,%edx
  18236a:	b8 a0 06 28 00       	mov    $0x2806a0,%eax
  18236f:	e8 c7 fc ff ff       	call   18203b <_new_thread>
  182374:	83 c4 14             	add    $0x14,%esp
  182377:	a0 a9 06 28 00       	mov    0x2806a9,%al
  18237c:	83 e0 fb             	and    $0xfffffffb,%eax
  18237f:	a2 a9 06 28 00       	mov    %al,0x2806a9
		    idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
  182384:	b8 a0 06 28 00       	mov    $0x2806a0,%eax
  182389:	e8 03 01 00 00       	call   182491 <_add_thread_to_ready_q>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  18238e:	c7 05 0c 04 28 00 0c 	movl   $0x28040c,0x28040c
  182395:	04 28 00 
	list->tail = (sys_dnode_t *)list;
  182398:	c7 05 10 04 28 00 0c 	movl   $0x28040c,0x280410
  18239f:	04 28 00 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
  1823a2:	c7 05 00 04 28 00 00 	movl   $0x0,0x280400
  1823a9:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  1823ac:	c7 05 04 04 28 00 a0 	movl   $0x2806a0,0x280404
  1823b3:	06 28 00 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  1823b6:	c7 05 88 05 28 00 00 	movl   $0x200,0x280588
  1823bd:	02 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
  1823c0:	c7 05 80 05 28 00 dc 	movl   $0x181edc,0x280580
  1823c7:	1e 18 00 
  1823ca:	c3                   	ret    

001823cb <switch_to_main_thread>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1823cb:	9c                   	pushf  
  1823cc:	fa                   	cli    
  1823cd:	58                   	pop    %eax
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */

	_Swap(irq_lock());
  1823ce:	e8 d9 fb ff ff       	call   181fac <_Swap>
  1823d3:	c3                   	ret    

001823d4 <_main>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  1823d4:	b8 02 00 00 00       	mov    $0x2,%eax
  1823d9:	e8 ab fe ff ff       	call   182289 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  1823de:	b8 05 00 00 00       	mov    $0x5,%eax
  1823e3:	e8 a1 fe ff ff       	call   182289 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  1823e8:	b8 06 00 00 00       	mov    $0x6,%eax
  1823ed:	e8 97 fe ff ff       	call   182289 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  1823f2:	b8 07 00 00 00       	mov    $0x7,%eax
  1823f7:	e8 8d fe ff ff       	call   182289 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  1823fc:	b8 03 00 00 00       	mov    $0x3,%eax
  182401:	e8 83 fe ff ff       	call   182289 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  182406:	e8 dc 0d 00 00       	call   1831e7 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  18240b:	e8 41 e1 ff ff       	call   180551 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
  182410:	a0 a8 07 28 00       	mov    0x2807a8,%al
  182415:	83 e0 fe             	and    $0xfffffffe,%eax
  182418:	a2 a8 07 28 00       	mov    %al,0x2807a8
  18241d:	c3                   	ret    

0018241e <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  18241e:	83 ec 48             	sub    $0x48,%esp
	 * Initialize kernel data structures. This step includes
	 * initializing the interrupt subsystem, which must be performed
	 * before the hardware initialization phase.
	 */

	prepare_multithreading(dummy_thread);
  182421:	89 e0                	mov    %esp,%eax
  182423:	e8 bd fe ff ff       	call   1822e5 <prepare_multithreading>

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  182428:	b8 04 00 00 00       	mov    $0x4,%eax
  18242d:	e8 57 fe ff ff       	call   182289 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  182432:	b8 00 00 00 00       	mov    $0x0,%eax
  182437:	e8 4d fe ff ff       	call   182289 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  18243c:	b8 01 00 00 00       	mov    $0x1,%eax
  182441:	e8 43 fe ff ff       	call   182289 <_sys_device_do_config_level>

	/* display boot banner */

	PRINT_BOOT_BANNER();

	switch_to_main_thread();
  182446:	e8 80 ff ff ff       	call   1823cb <switch_to_main_thread>

0018244b <_set_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  18244b:	8d 48 10             	lea    0x10(%eax),%ecx
  18244e:	89 ca                	mov    %ecx,%edx
  182450:	c1 fa 05             	sar    $0x5,%edx
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  182453:	b8 01 00 00 00       	mov    $0x1,%eax
  182458:	d3 e0                	shl    %cl,%eax
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  18245a:	09 04 95 18 04 28 00 	or     %eax,0x280418(,%edx,4)
  182461:	c3                   	ret    

00182462 <_clear_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  182462:	8d 48 10             	lea    0x10(%eax),%ecx
  182465:	89 c8                	mov    %ecx,%eax
  182467:	c1 f8 05             	sar    $0x5,%eax
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  18246a:	ba 01 00 00 00       	mov    $0x1,%edx
  18246f:	d3 e2                	shl    %cl,%edx
static void _clear_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap &= ~_get_ready_q_prio_bit(prio);
  182471:	f7 d2                	not    %edx
  182473:	21 14 85 18 04 28 00 	and    %edx,0x280418(,%eax,4)
  18247a:	c3                   	ret    

0018247b <_get_ready_q_head>:

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  18247b:	0f bc 05 18 04 28 00 	bsf    0x280418,%eax
  182482:	75 05                	jne    182489 <_get_ready_q_head+0xe>
  182484:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 * @return a pointer to the head element
 */

static inline sys_dnode_t *sys_dlist_peek_head_not_empty(sys_dlist_t *list)
{
	return list->head;
  182489:	8b 04 c5 1c 04 28 00 	mov    0x28041c(,%eax,8),%eax

	struct k_thread *thread =
		(struct k_thread *)sys_dlist_peek_head_not_empty(list);

	return thread;
}
  182490:	c3                   	ret    

00182491 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  182491:	57                   	push   %edi
  182492:	56                   	push   %esi
  182493:	53                   	push   %ebx
  182494:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  182496:	0f be 58 0a          	movsbl 0xa(%eax),%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
  18249a:	8d 3c dd 9c 04 28 00 	lea    0x28049c(,%ebx,8),%edi

	_set_ready_q_prio_bit(thread->base.prio);
  1824a1:	89 d8                	mov    %ebx,%eax
  1824a3:	e8 a3 ff ff ff       	call   18244b <_set_ready_q_prio_bit>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1824a8:	89 3e                	mov    %edi,(%esi)
	node->prev = list->tail;
  1824aa:	83 c3 14             	add    $0x14,%ebx
  1824ad:	8b 04 dd 00 04 28 00 	mov    0x280400(,%ebx,8),%eax
  1824b4:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  1824b7:	8b 04 dd 00 04 28 00 	mov    0x280400(,%ebx,8),%eax
  1824be:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  1824c0:	89 34 dd 00 04 28 00 	mov    %esi,0x280400(,%ebx,8)
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
  1824c7:	a1 14 04 28 00       	mov    0x280414,%eax
  1824cc:	8a 50 0a             	mov    0xa(%eax),%dl
  1824cf:	38 56 0a             	cmp    %dl,0xa(%esi)
  1824d2:	7d 02                	jge    1824d6 <_add_thread_to_ready_q+0x45>
  1824d4:	89 f0                	mov    %esi,%eax
  1824d6:	a3 14 04 28 00       	mov    %eax,0x280414
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
  1824db:	5b                   	pop    %ebx
  1824dc:	5e                   	pop    %esi
  1824dd:	5f                   	pop    %edi
  1824de:	c3                   	ret    

001824df <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  1824df:	56                   	push   %esi
  1824e0:	53                   	push   %ebx
  1824e1:	89 c3                	mov    %eax,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  1824e3:	0f be 40 0a          	movsbl 0xa(%eax),%eax
	sys_dlist_t *q = &_ready_q.q[q_index];
  1824e7:	83 c0 11             	add    $0x11,%eax
  1824ea:	8d 14 c5 14 04 28 00 	lea    0x280414(,%eax,8),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1824f1:	8b 4b 04             	mov    0x4(%ebx),%ecx
  1824f4:	8b 33                	mov    (%ebx),%esi
  1824f6:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  1824f8:	8b 0b                	mov    (%ebx),%ecx
  1824fa:	8b 73 04             	mov    0x4(%ebx),%esi
  1824fd:	89 71 04             	mov    %esi,0x4(%ecx)

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  182500:	3b 14 c5 14 04 28 00 	cmp    0x280414(,%eax,8),%edx
  182507:	75 09                	jne    182512 <_remove_thread_from_ready_q+0x33>
		_clear_ready_q_prio_bit(thread->base.prio);
  182509:	0f be 43 0a          	movsbl 0xa(%ebx),%eax
  18250d:	e8 50 ff ff ff       	call   182462 <_clear_ready_q_prio_bit>
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  182512:	a1 14 04 28 00       	mov    0x280414,%eax
  182517:	39 c3                	cmp    %eax,%ebx
  182519:	75 05                	jne    182520 <_remove_thread_from_ready_q+0x41>
  18251b:	e8 5b ff ff ff       	call   18247b <_get_ready_q_head>
  182520:	a3 14 04 28 00       	mov    %eax,0x280414
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
  182525:	5b                   	pop    %ebx
  182526:	5e                   	pop    %esi
  182527:	c3                   	ret    

00182528 <_pend_thread>:
#endif

/* pend the specified thread: it must *not* be in the ready queue */
/* must be called with interrupts locked */
void _pend_thread(struct k_thread *thread, _wait_q_t *wait_q, int32_t timeout)
{
  182528:	57                   	push   %edi
  182529:	56                   	push   %esi
  18252a:	53                   	push   %ebx
  18252b:	89 c3                	mov    %eax,%ebx
  18252d:	89 d6                	mov    %edx,%esi
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  18252f:	8b 12                	mov    (%edx),%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182531:	39 d6                	cmp    %edx,%esi
  182533:	75 49                	jne    18257e <_pend_thread+0x56>
  182535:	ba 00 00 00 00       	mov    $0x0,%edx
  18253a:	eb 42                	jmp    18257e <_pend_thread+0x56>
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
		struct k_thread *pending = (struct k_thread *)node;

		if (_is_t1_higher_prio_than_t2(thread, pending)) {
  18253c:	8a 43 0a             	mov    0xa(%ebx),%al
  18253f:	38 42 0a             	cmp    %al,0xa(%edx)
  182542:	7e 28                	jle    18256c <_pend_thread+0x44>
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  182544:	85 d2                	test   %edx,%edx
  182546:	75 12                	jne    18255a <_pend_thread+0x32>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182548:	89 33                	mov    %esi,(%ebx)
	node->prev = list->tail;
  18254a:	8b 46 04             	mov    0x4(%esi),%eax
  18254d:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  182550:	8b 46 04             	mov    0x4(%esi),%eax
  182553:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  182555:	89 5e 04             	mov    %ebx,0x4(%esi)
  182558:	eb 38                	jmp    182592 <_pend_thread+0x6a>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  18255a:	8b 42 04             	mov    0x4(%edx),%eax
  18255d:	89 43 04             	mov    %eax,0x4(%ebx)
		node->next = insert_point;
  182560:	89 13                	mov    %edx,(%ebx)
		insert_point->prev->next = node;
  182562:	8b 42 04             	mov    0x4(%edx),%eax
  182565:	89 18                	mov    %ebx,(%eax)
		insert_point->prev = node;
  182567:	89 5a 04             	mov    %ebx,0x4(%edx)
  18256a:	eb 26                	jmp    182592 <_pend_thread+0x6a>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18256c:	85 d2                	test   %edx,%edx
  18256e:	74 0e                	je     18257e <_pend_thread+0x56>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182570:	3b 56 04             	cmp    0x4(%esi),%edx
  182573:	74 04                	je     182579 <_pend_thread+0x51>
  182575:	8b 12                	mov    (%edx),%edx
  182577:	eb 05                	jmp    18257e <_pend_thread+0x56>
  182579:	ba 00 00 00 00       	mov    $0x0,%edx
{
#ifdef CONFIG_MULTITHREADING
	sys_dlist_t *wait_q_list = (sys_dlist_t *)wait_q;
	sys_dnode_t *node;

	SYS_DLIST_FOR_EACH_NODE(wait_q_list, node) {
  18257e:	85 d2                	test   %edx,%edx
  182580:	75 ba                	jne    18253c <_pend_thread+0x14>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182582:	89 33                	mov    %esi,(%ebx)
	node->prev = list->tail;
  182584:	8b 46 04             	mov    0x4(%esi),%eax
  182587:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  18258a:	8b 46 04             	mov    0x4(%esi),%eax
  18258d:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  18258f:	89 5e 04             	mov    %ebx,0x4(%esi)
}

/* mark a thread as pending in its TCS */
static inline void _mark_thread_as_pending(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_PENDING;
  182592:	80 4b 09 02          	orb    $0x2,0x9(%ebx)
	sys_dlist_append(wait_q_list, &thread->base.k_q_node);

inserted:
	_mark_thread_as_pending(thread);

	if (timeout != K_FOREVER) {
  182596:	83 f9 ff             	cmp    $0xffffffff,%ecx
  182599:	0f 84 03 01 00 00    	je     1826a2 <_pend_thread+0x17a>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  18259f:	83 c1 09             	add    $0x9,%ecx
  1825a2:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  1825a7:	89 c8                	mov    %ecx,%eax
  1825a9:	f7 e2                	mul    %edx
  1825ab:	c1 ea 03             	shr    $0x3,%edx
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(timeout);
  1825ae:	42                   	inc    %edx

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  1825af:	8d 7b 10             	lea    0x10(%ebx),%edi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  1825b2:	89 57 10             	mov    %edx,0x10(%edi)
	timeout->thread = thread;
  1825b5:	89 5f 08             	mov    %ebx,0x8(%edi)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  1825b8:	89 77 0c             	mov    %esi,0xc(%edi)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1825bb:	a1 0c 04 28 00       	mov    0x28040c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1825c0:	3d 0c 04 28 00       	cmp    $0x28040c,%eax
  1825c5:	75 07                	jne    1825ce <_pend_thread+0xa6>
  1825c7:	ba 00 00 00 00       	mov    $0x0,%edx
  1825cc:	eb 02                	jmp    1825d0 <_pend_thread+0xa8>
  1825ce:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1825d0:	85 d2                	test   %edx,%edx
  1825d2:	74 15                	je     1825e9 <_pend_thread+0xc1>
  1825d4:	3d 0c 04 28 00       	cmp    $0x28040c,%eax
  1825d9:	0f 85 9f 00 00 00    	jne    18267e <_pend_thread+0x156>
  1825df:	b8 00 00 00 00       	mov    $0x0,%eax
  1825e4:	e9 95 00 00 00       	jmp    18267e <_pend_thread+0x156>
  1825e9:	b8 00 00 00 00       	mov    $0x0,%eax
  1825ee:	e9 8b 00 00 00       	jmp    18267e <_pend_thread+0x156>
		if (*delta <= in_q->delta_ticks_from_prev) {
  1825f3:	8b 57 10             	mov    0x10(%edi),%edx
  1825f6:	8b 48 10             	mov    0x10(%eax),%ecx
  1825f9:	39 ca                	cmp    %ecx,%edx
  1825fb:	7f 3a                	jg     182637 <_pend_thread+0x10f>
			in_q->delta_ticks_from_prev -= *delta;
  1825fd:	29 d1                	sub    %edx,%ecx
  1825ff:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  182602:	85 c0                	test   %eax,%eax
  182604:	75 1e                	jne    182624 <_pend_thread+0xfc>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182606:	c7 43 10 0c 04 28 00 	movl   $0x28040c,0x10(%ebx)
	node->prev = list->tail;
  18260d:	a1 10 04 28 00       	mov    0x280410,%eax
  182612:	89 47 04             	mov    %eax,0x4(%edi)

	list->tail->next = node;
  182615:	a1 10 04 28 00       	mov    0x280410,%eax
  18261a:	89 38                	mov    %edi,(%eax)
	list->tail = node;
  18261c:	89 3d 10 04 28 00    	mov    %edi,0x280410
  182622:	eb 7e                	jmp    1826a2 <_pend_thread+0x17a>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  182624:	8b 50 04             	mov    0x4(%eax),%edx
  182627:	89 57 04             	mov    %edx,0x4(%edi)
		node->next = insert_point;
  18262a:	89 43 10             	mov    %eax,0x10(%ebx)
		insert_point->prev->next = node;
  18262d:	8b 50 04             	mov    0x4(%eax),%edx
  182630:	89 3a                	mov    %edi,(%edx)
		insert_point->prev = node;
  182632:	89 78 04             	mov    %edi,0x4(%eax)
  182635:	eb 6b                	jmp    1826a2 <_pend_thread+0x17a>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  182637:	29 ca                	sub    %ecx,%edx
  182639:	89 57 10             	mov    %edx,0x10(%edi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  18263c:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18263e:	85 c0                	test   %eax,%eax
  182640:	74 0c                	je     18264e <_pend_thread+0x126>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182642:	3b 05 10 04 28 00    	cmp    0x280410,%eax
  182648:	74 08                	je     182652 <_pend_thread+0x12a>
  18264a:	8b 08                	mov    (%eax),%ecx
  18264c:	eb 09                	jmp    182657 <_pend_thread+0x12f>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18264e:	89 c1                	mov    %eax,%ecx
  182650:	eb 05                	jmp    182657 <_pend_thread+0x12f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182652:	b9 00 00 00 00       	mov    $0x0,%ecx
  182657:	85 c9                	test   %ecx,%ecx
  182659:	74 1e                	je     182679 <_pend_thread+0x151>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18265b:	85 d2                	test   %edx,%edx
  18265d:	74 0c                	je     18266b <_pend_thread+0x143>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18265f:	3b 15 10 04 28 00    	cmp    0x280410,%edx
  182665:	74 0b                	je     182672 <_pend_thread+0x14a>
  182667:	8b 00                	mov    (%eax),%eax
  182669:	eb 13                	jmp    18267e <_pend_thread+0x156>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18266b:	b8 00 00 00 00       	mov    $0x0,%eax
  182670:	eb 0c                	jmp    18267e <_pend_thread+0x156>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182672:	b8 00 00 00 00       	mov    $0x0,%eax
  182677:	eb 05                	jmp    18267e <_pend_thread+0x156>
  182679:	b8 00 00 00 00       	mov    $0x0,%eax
  18267e:	85 c0                	test   %eax,%eax
  182680:	0f 85 6d ff ff ff    	jne    1825f3 <_pend_thread+0xcb>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182686:	c7 43 10 0c 04 28 00 	movl   $0x28040c,0x10(%ebx)
	node->prev = list->tail;
  18268d:	a1 10 04 28 00       	mov    0x280410,%eax
  182692:	89 47 04             	mov    %eax,0x4(%edi)

	list->tail->next = node;
  182695:	a1 10 04 28 00       	mov    0x280410,%eax
  18269a:	89 38                	mov    %edi,(%eax)
	list->tail = node;
  18269c:	89 3d 10 04 28 00    	mov    %edi,0x280410

		_add_thread_timeout(thread, wait_q, ticks);
	}
#endif
}
  1826a2:	5b                   	pop    %ebx
  1826a3:	5e                   	pop    %esi
  1826a4:	5f                   	pop    %edi
  1826a5:	c3                   	ret    

001826a6 <_pend_current_thread>:

/* pend the current thread */
/* must be called with interrupts locked */
void _pend_current_thread(_wait_q_t *wait_q, int32_t timeout)
{
  1826a6:	56                   	push   %esi
  1826a7:	53                   	push   %ebx
  1826a8:	89 c3                	mov    %eax,%ebx
  1826aa:	89 d6                	mov    %edx,%esi
	_remove_thread_from_ready_q(_current);
  1826ac:	a1 08 04 28 00       	mov    0x280408,%eax
  1826b1:	e8 29 fe ff ff       	call   1824df <_remove_thread_from_ready_q>
	_pend_thread(_current, wait_q, timeout);
  1826b6:	89 f1                	mov    %esi,%ecx
  1826b8:	89 da                	mov    %ebx,%edx
  1826ba:	a1 08 04 28 00       	mov    0x280408,%eax
  1826bf:	e8 64 fe ff ff       	call   182528 <_pend_thread>
}
  1826c4:	5b                   	pop    %ebx
  1826c5:	5e                   	pop    %esi
  1826c6:	c3                   	ret    

001826c7 <__must_switch_threads>:
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  1826c7:	a1 08 04 28 00       	mov    0x280408,%eax
  1826cc:	0f be 50 0a          	movsbl 0xa(%eax),%edx
  1826d0:	0f bc 05 18 04 28 00 	bsf    0x280418,%eax
  1826d7:	75 05                	jne    1826de <__must_switch_threads+0x17>
  1826d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	int abs_prio = (find_lsb_set(ready_range) - 1) + (bitmap << 5);

	__ASSERT(abs_prio < K_NUM_PRIORITIES, "prio out-of-range\n");

	return abs_prio - _NUM_COOP_PRIO;
  1826de:	83 e8 10             	sub    $0x10,%eax
	return _is_prio1_higher_than_or_equal_to_prio2(prio1, prio2);
}

static inline int _is_prio1_higher_than_prio2(int prio1, int prio2)
{
	return prio1 < prio2;
  1826e1:	39 c2                	cmp    %eax,%edx
  1826e3:	0f 9f c0             	setg   %al
  1826e6:	0f b6 c0             	movzbl %al,%eax
#else
	return 0;
#endif
}
  1826e9:	c3                   	ret    

001826ea <_reschedule_threads>:

/* reschedule threads if the scheduler is not locked */
/* not callable from ISR */
/* must be called with interrupts locked */
void _reschedule_threads(int key)
{
  1826ea:	53                   	push   %ebx
  1826eb:	89 c3                	mov    %eax,%ebx
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  1826ed:	a1 08 04 28 00       	mov    0x280408,%eax
  1826f2:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  1826f7:	77 10                	ja     182709 <_reschedule_threads+0x1f>
  1826f9:	e8 c9 ff ff ff       	call   1826c7 <__must_switch_threads>
  1826fe:	85 c0                	test   %eax,%eax
  182700:	74 0c                	je     18270e <_reschedule_threads+0x24>
  182702:	b8 01 00 00 00       	mov    $0x1,%eax
  182707:	eb 05                	jmp    18270e <_reschedule_threads+0x24>
  182709:	b8 00 00 00 00       	mov    $0x0,%eax
#ifdef CONFIG_PREEMPT_ENABLED
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
  18270e:	85 c0                	test   %eax,%eax
  182710:	74 09                	je     18271b <_reschedule_threads+0x31>
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  182712:	89 d8                	mov    %ebx,%eax
  182714:	e8 93 f8 ff ff       	call   181fac <_Swap>
  182719:	eb 06                	jmp    182721 <_reschedule_threads+0x37>
  18271b:	f6 c7 02             	test   $0x2,%bh
  18271e:	74 01                	je     182721 <_reschedule_threads+0x37>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182720:	fb                   	sti    
		irq_unlock(key);
	}
#else
	irq_unlock(key);
#endif
}
  182721:	5b                   	pop    %ebx
  182722:	c3                   	ret    

00182723 <k_sched_unlock>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182723:	9c                   	pushf  
  182724:	fa                   	cli    
  182725:	58                   	pop    %eax

	int key = irq_lock();

	/* compiler_barrier() not needed, comes from irq_lock() */

	++_current->base.sched_locked;
  182726:	8b 0d 08 04 28 00    	mov    0x280408,%ecx
  18272c:	8a 51 0b             	mov    0xb(%ecx),%dl
  18272f:	42                   	inc    %edx
  182730:	88 51 0b             	mov    %dl,0xb(%ecx)

	K_DEBUG("scheduler unlocked (%p:%d)\n",
		_current, _current->base.sched_locked);

	_reschedule_threads(key);
  182733:	e8 b2 ff ff ff       	call   1826ea <_reschedule_threads>
  182738:	c3                   	ret    

00182739 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  182739:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	sys_dlist_t *q = &_ready_q.q[q_index];

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  18273d:	3b 04 cd a0 04 28 00 	cmp    0x2804a0(,%ecx,8),%eax
  182744:	74 53                	je     182799 <_move_thread_to_end_of_prio_q+0x60>
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  182746:	56                   	push   %esi
  182747:	53                   	push   %ebx
  182748:	8d 51 10             	lea    0x10(%ecx),%edx
  18274b:	8d 1c cd 9c 04 28 00 	lea    0x28049c(,%ecx,8),%ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182752:	8b 48 04             	mov    0x4(%eax),%ecx
  182755:	8b 30                	mov    (%eax),%esi
  182757:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  182759:	8b 08                	mov    (%eax),%ecx
  18275b:	8b 70 04             	mov    0x4(%eax),%esi
  18275e:	89 71 04             	mov    %esi,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182761:	89 18                	mov    %ebx,(%eax)
	node->prev = list->tail;
  182763:	83 c2 04             	add    $0x4,%edx
  182766:	8b 0c d5 00 04 28 00 	mov    0x280400(,%edx,8),%ecx
  18276d:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  182770:	8b 0c d5 00 04 28 00 	mov    0x280400(,%edx,8),%ecx
  182777:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  182779:	89 04 d5 00 04 28 00 	mov    %eax,0x280400(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  182780:	8b 15 14 04 28 00    	mov    0x280414,%edx
  182786:	39 d0                	cmp    %edx,%eax
  182788:	75 07                	jne    182791 <_move_thread_to_end_of_prio_q+0x58>
  18278a:	e8 ec fc ff ff       	call   18247b <_get_ready_q_head>
  18278f:	89 c2                	mov    %eax,%edx
  182791:	89 15 14 04 28 00    	mov    %edx,0x280414
#endif
}
  182797:	5b                   	pop    %ebx
  182798:	5e                   	pop    %esi
  182799:	c3                   	ret    

0018279a <k_yield>:

void k_yield(void)
{
  18279a:	53                   	push   %ebx
  18279b:	9c                   	pushf  
  18279c:	fa                   	cli    
  18279d:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	int key = irq_lock();

	_move_thread_to_end_of_prio_q(_current);
  18279e:	a1 08 04 28 00       	mov    0x280408,%eax
  1827a3:	e8 91 ff ff ff       	call   182739 <_move_thread_to_end_of_prio_q>

	if (_current == _get_next_ready_thread()) {
  1827a8:	a1 14 04 28 00       	mov    0x280414,%eax
  1827ad:	39 05 08 04 28 00    	cmp    %eax,0x280408
  1827b3:	75 08                	jne    1827bd <k_yield+0x23>
  1827b5:	f6 c7 02             	test   $0x2,%bh
  1827b8:	74 0a                	je     1827c4 <k_yield+0x2a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1827ba:	fb                   	sti    
  1827bb:	eb 07                	jmp    1827c4 <k_yield+0x2a>
		irq_unlock(key);
	} else {
		_Swap(key);
  1827bd:	89 d8                	mov    %ebx,%eax
  1827bf:	e8 e8 f7 ff ff       	call   181fac <_Swap>
	}
}
  1827c4:	5b                   	pop    %ebx
  1827c5:	c3                   	ret    

001827c6 <k_sleep>:

void k_sleep(int32_t duration)
{
  1827c6:	57                   	push   %edi
  1827c7:	56                   	push   %esi
  1827c8:	53                   	push   %ebx
  1827c9:	83 ec 04             	sub    $0x4,%esp
	__ASSERT(duration != K_FOREVER, "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
  1827cc:	85 c0                	test   %eax,%eax
  1827ce:	75 0a                	jne    1827da <k_sleep+0x14>
		k_yield();
  1827d0:	e8 c5 ff ff ff       	call   18279a <k_yield>
		return;
  1827d5:	e9 25 01 00 00       	jmp    1828ff <k_sleep+0x139>
  1827da:	83 c0 09             	add    $0x9,%eax
  1827dd:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  1827e2:	f7 e2                	mul    %edx
  1827e4:	c1 ea 03             	shr    $0x3,%edx
	}

	ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  1827e7:	42                   	inc    %edx
  1827e8:	89 14 24             	mov    %edx,(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1827eb:	9c                   	pushf  
  1827ec:	fa                   	cli    
  1827ed:	5b                   	pop    %ebx
	key = irq_lock();

	_remove_thread_from_ready_q(_current);
  1827ee:	a1 08 04 28 00       	mov    0x280408,%eax
  1827f3:	e8 e7 fc ff ff       	call   1824df <_remove_thread_from_ready_q>
	_add_thread_timeout(_current, NULL, ticks);
  1827f8:	8b 04 24             	mov    (%esp),%eax
  1827fb:	8b 3d 08 04 28 00    	mov    0x280408,%edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  182801:	8d 77 10             	lea    0x10(%edi),%esi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  182804:	89 46 10             	mov    %eax,0x10(%esi)
	timeout->thread = thread;
  182807:	89 7e 08             	mov    %edi,0x8(%esi)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  18280a:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182811:	a1 0c 04 28 00       	mov    0x28040c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182816:	3d 0c 04 28 00       	cmp    $0x28040c,%eax
  18281b:	75 07                	jne    182824 <k_sleep+0x5e>
  18281d:	ba 00 00 00 00       	mov    $0x0,%edx
  182822:	eb 02                	jmp    182826 <k_sleep+0x60>
  182824:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182826:	85 d2                	test   %edx,%edx
  182828:	74 15                	je     18283f <k_sleep+0x79>
  18282a:	3d 0c 04 28 00       	cmp    $0x28040c,%eax
  18282f:	0f 85 9f 00 00 00    	jne    1828d4 <k_sleep+0x10e>
  182835:	b8 00 00 00 00       	mov    $0x0,%eax
  18283a:	e9 95 00 00 00       	jmp    1828d4 <k_sleep+0x10e>
  18283f:	b8 00 00 00 00       	mov    $0x0,%eax
  182844:	e9 8b 00 00 00       	jmp    1828d4 <k_sleep+0x10e>
		if (*delta <= in_q->delta_ticks_from_prev) {
  182849:	8b 56 10             	mov    0x10(%esi),%edx
  18284c:	8b 48 10             	mov    0x10(%eax),%ecx
  18284f:	39 ca                	cmp    %ecx,%edx
  182851:	7f 3a                	jg     18288d <k_sleep+0xc7>
			in_q->delta_ticks_from_prev -= *delta;
  182853:	29 d1                	sub    %edx,%ecx
  182855:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  182858:	85 c0                	test   %eax,%eax
  18285a:	75 1e                	jne    18287a <k_sleep+0xb4>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  18285c:	c7 47 10 0c 04 28 00 	movl   $0x28040c,0x10(%edi)
	node->prev = list->tail;
  182863:	a1 10 04 28 00       	mov    0x280410,%eax
  182868:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  18286b:	a1 10 04 28 00       	mov    0x280410,%eax
  182870:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  182872:	89 35 10 04 28 00    	mov    %esi,0x280410
  182878:	eb 7e                	jmp    1828f8 <k_sleep+0x132>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  18287a:	8b 50 04             	mov    0x4(%eax),%edx
  18287d:	89 56 04             	mov    %edx,0x4(%esi)
		node->next = insert_point;
  182880:	89 47 10             	mov    %eax,0x10(%edi)
		insert_point->prev->next = node;
  182883:	8b 50 04             	mov    0x4(%eax),%edx
  182886:	89 32                	mov    %esi,(%edx)
		insert_point->prev = node;
  182888:	89 70 04             	mov    %esi,0x4(%eax)
  18288b:	eb 6b                	jmp    1828f8 <k_sleep+0x132>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  18288d:	29 ca                	sub    %ecx,%edx
  18288f:	89 56 10             	mov    %edx,0x10(%esi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182892:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182894:	85 c0                	test   %eax,%eax
  182896:	74 0c                	je     1828a4 <k_sleep+0xde>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182898:	3b 05 10 04 28 00    	cmp    0x280410,%eax
  18289e:	74 08                	je     1828a8 <k_sleep+0xe2>
  1828a0:	8b 08                	mov    (%eax),%ecx
  1828a2:	eb 09                	jmp    1828ad <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1828a4:	89 c1                	mov    %eax,%ecx
  1828a6:	eb 05                	jmp    1828ad <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1828a8:	b9 00 00 00 00       	mov    $0x0,%ecx
  1828ad:	85 c9                	test   %ecx,%ecx
  1828af:	74 1e                	je     1828cf <k_sleep+0x109>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1828b1:	85 d2                	test   %edx,%edx
  1828b3:	74 0c                	je     1828c1 <k_sleep+0xfb>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1828b5:	3b 15 10 04 28 00    	cmp    0x280410,%edx
  1828bb:	74 0b                	je     1828c8 <k_sleep+0x102>
  1828bd:	8b 00                	mov    (%eax),%eax
  1828bf:	eb 13                	jmp    1828d4 <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1828c1:	b8 00 00 00 00       	mov    $0x0,%eax
  1828c6:	eb 0c                	jmp    1828d4 <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1828c8:	b8 00 00 00 00       	mov    $0x0,%eax
  1828cd:	eb 05                	jmp    1828d4 <k_sleep+0x10e>
  1828cf:	b8 00 00 00 00       	mov    $0x0,%eax
  1828d4:	85 c0                	test   %eax,%eax
  1828d6:	0f 85 6d ff ff ff    	jne    182849 <k_sleep+0x83>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1828dc:	c7 47 10 0c 04 28 00 	movl   $0x28040c,0x10(%edi)
	node->prev = list->tail;
  1828e3:	a1 10 04 28 00       	mov    0x280410,%eax
  1828e8:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  1828eb:	a1 10 04 28 00       	mov    0x280410,%eax
  1828f0:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  1828f2:	89 35 10 04 28 00    	mov    %esi,0x280410

	_Swap(key);
  1828f8:	89 d8                	mov    %ebx,%eax
  1828fa:	e8 ad f6 ff ff       	call   181fac <_Swap>
#endif
}
  1828ff:	83 c4 04             	add    $0x4,%esp
  182902:	5b                   	pop    %ebx
  182903:	5e                   	pop    %esi
  182904:	5f                   	pop    %edi
  182905:	c3                   	ret    

00182906 <k_current_get>:
}

k_tid_t k_current_get(void)
{
	return _current;
}
  182906:	a1 08 04 28 00       	mov    0x280408,%eax
  18290b:	c3                   	ret    

0018290c <init_sem_module>:
{
	ARG_UNUSED(dev);

	struct k_sem *sem;

	for (sem = _k_sem_list_start; sem < _k_sem_list_end; sem++) {
  18290c:	b8 48 03 28 00       	mov    $0x280348,%eax
  182911:	eb 1a                	jmp    18292d <init_sem_module+0x21>
  182913:	9c                   	pushf  
  182914:	fa                   	cli    
  182915:	5a                   	pop    %edx
		SYS_TRACING_OBJ_INIT(k_sem, sem);
  182916:	8b 0d 8c 05 28 00    	mov    0x28058c,%ecx
  18291c:	89 48 10             	mov    %ecx,0x10(%eax)
  18291f:	a3 8c 05 28 00       	mov    %eax,0x28058c
  182924:	f6 c6 02             	test   $0x2,%dh
  182927:	74 01                	je     18292a <init_sem_module+0x1e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182929:	fb                   	sti    
{
	ARG_UNUSED(dev);

	struct k_sem *sem;

	for (sem = _k_sem_list_start; sem < _k_sem_list_end; sem++) {
  18292a:	83 c0 14             	add    $0x14,%eax
  18292d:	3d 48 03 28 00       	cmp    $0x280348,%eax
  182932:	72 df                	jb     182913 <init_sem_module+0x7>
		SYS_TRACING_OBJ_INIT(k_sem, sem);
	}
	return 0;
}
  182934:	b8 00 00 00 00       	mov    $0x0,%eax
  182939:	c3                   	ret    

0018293a <handle_sem_group>:
	return 0;
}

/* cancel all but specified semaphore in list if part of a semphore group */
static void handle_sem_group(struct k_sem *sem, struct sem_thread *sem_thread)
{
  18293a:	55                   	push   %ebp
  18293b:	57                   	push   %edi
  18293c:	56                   	push   %esi
  18293d:	53                   	push   %ebx
  18293e:	83 ec 04             	sub    $0x4,%esp
	struct sem_desc *desc = NULL;
	sys_dlist_t *list;
	sys_dnode_t *node;
	sys_dnode_t *next;

	list = (sys_dlist_t *)sem_thread->desc.thread->base.swap_data;
  182941:	8b 52 30             	mov    0x30(%edx),%edx
  182944:	8b 72 0c             	mov    0xc(%edx),%esi
  182947:	89 34 24             	mov    %esi,(%esp)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  18294a:	8b 1e                	mov    (%esi),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  18294c:	39 de                	cmp    %ebx,%esi
  18294e:	75 09                	jne    182959 <handle_sem_group+0x1f>
  182950:	bb 00 00 00 00       	mov    $0x0,%ebx
  182955:	eb 02                	jmp    182959 <handle_sem_group+0x1f>

		if (desc->sem != sem) {
			sys_dlist_remove(node);
		}

		node = next;
  182957:	89 f3                	mov    %esi,%ebx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182959:	85 db                	test   %ebx,%ebx
  18295b:	74 0c                	je     182969 <handle_sem_group+0x2f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18295d:	8b 34 24             	mov    (%esp),%esi
  182960:	3b 5e 04             	cmp    0x4(%esi),%ebx
  182963:	74 08                	je     18296d <handle_sem_group+0x33>
  182965:	8b 33                	mov    (%ebx),%esi
  182967:	eb 09                	jmp    182972 <handle_sem_group+0x38>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182969:	89 de                	mov    %ebx,%esi
  18296b:	eb 05                	jmp    182972 <handle_sem_group+0x38>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18296d:	be 00 00 00 00       	mov    $0x0,%esi
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  182972:	8d 53 e8             	lea    -0x18(%ebx),%edx
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  182975:	8b 7a 10             	mov    0x10(%edx),%edi
  182978:	83 ff ff             	cmp    $0xffffffff,%edi
  18297b:	74 36                	je     1829b3 <handle_sem_group+0x79>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  18297d:	89 d1                	mov    %edx,%ecx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  18297f:	8b 2d 10 04 28 00    	mov    0x280410,%ebp
  182985:	39 ea                	cmp    %ebp,%edx
  182987:	74 14                	je     18299d <handle_sem_group+0x63>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182989:	85 d2                	test   %edx,%edx
  18298b:	74 0d                	je     18299a <handle_sem_group+0x60>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18298d:	39 ea                	cmp    %ebp,%edx
  18298f:	74 04                	je     182995 <handle_sem_group+0x5b>
  182991:	8b 0a                	mov    (%edx),%ecx
  182993:	eb 05                	jmp    18299a <handle_sem_group+0x60>
  182995:	b9 00 00 00 00       	mov    $0x0,%ecx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  18299a:	01 79 10             	add    %edi,0x10(%ecx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18299d:	8b 4a 04             	mov    0x4(%edx),%ecx
  1829a0:	8b 3a                	mov    (%edx),%edi
  1829a2:	89 39                	mov    %edi,(%ecx)
	node->next->prev = node->prev;
  1829a4:	8b 0a                	mov    (%edx),%ecx
  1829a6:	8b 7a 04             	mov    0x4(%edx),%edi
  1829a9:	89 79 04             	mov    %edi,0x4(%ecx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  1829ac:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1829b3:	8b 53 dc             	mov    -0x24(%ebx),%edx
  1829b6:	8b 4b d8             	mov    -0x28(%ebx),%ecx
  1829b9:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1829bb:	8b 53 d8             	mov    -0x28(%ebx),%edx
  1829be:	8b 4b dc             	mov    -0x24(%ebx),%ecx
  1829c1:	89 4a 04             	mov    %ecx,0x4(%edx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  1829c4:	80 63 e1 fd          	andb   $0xfd,-0x1f(%ebx)
		 * where the timeout of the dummy thread might have expired.
		 */
		_abort_thread_timeout(dummy);
		_unpend_thread(dummy);

		if (desc->sem != sem) {
  1829c8:	39 43 0c             	cmp    %eax,0xc(%ebx)
  1829cb:	74 0f                	je     1829dc <handle_sem_group+0xa2>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1829cd:	8b 53 04             	mov    0x4(%ebx),%edx
  1829d0:	8b 0b                	mov    (%ebx),%ecx
  1829d2:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1829d4:	8b 13                	mov    (%ebx),%edx
  1829d6:	8b 4b 04             	mov    0x4(%ebx),%ecx
  1829d9:	89 4a 04             	mov    %ecx,0x4(%edx)
			sys_dlist_remove(node);
		}

		node = next;
	} while (node != NULL);
  1829dc:	85 f6                	test   %esi,%esi
  1829de:	0f 85 73 ff ff ff    	jne    182957 <handle_sem_group+0x1d>
	 * As this code may be executed several times by a semaphore group give
	 * operation, it is important to ensure that the attempt to ready the
	 * master thread is done only once.
	 */

	if (!_is_thread_ready(desc->thread)) {
  1829e4:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1829e7:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  1829eb:	75 0d                	jne    1829fa <handle_sem_group+0xc0>
  1829ed:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1829f1:	75 0e                	jne    182a01 <handle_sem_group+0xc7>
  1829f3:	b9 01 00 00 00       	mov    $0x1,%ecx
  1829f8:	eb 0c                	jmp    182a06 <handle_sem_group+0xcc>
  1829fa:	b9 00 00 00 00       	mov    $0x0,%ecx
  1829ff:	eb 05                	jmp    182a06 <handle_sem_group+0xcc>
  182a01:	b9 00 00 00 00       	mov    $0x0,%ecx
  182a06:	85 c9                	test   %ecx,%ecx
  182a08:	75 68                	jne    182a72 <handle_sem_group+0x138>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  182a0a:	8d 50 10             	lea    0x10(%eax),%edx
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  182a0d:	8b 7a 10             	mov    0x10(%edx),%edi
  182a10:	83 ff ff             	cmp    $0xffffffff,%edi
  182a13:	74 39                	je     182a4e <handle_sem_group+0x114>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  182a15:	89 d6                	mov    %edx,%esi
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  182a17:	8b 2d 10 04 28 00    	mov    0x280410,%ebp
  182a1d:	39 ea                	cmp    %ebp,%edx
  182a1f:	74 15                	je     182a36 <handle_sem_group+0xfc>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182a21:	85 d2                	test   %edx,%edx
  182a23:	74 0e                	je     182a33 <handle_sem_group+0xf9>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182a25:	39 ea                	cmp    %ebp,%edx
  182a27:	74 05                	je     182a2e <handle_sem_group+0xf4>
  182a29:	8b 70 10             	mov    0x10(%eax),%esi
  182a2c:	eb 05                	jmp    182a33 <handle_sem_group+0xf9>
  182a2e:	be 00 00 00 00       	mov    $0x0,%esi
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  182a33:	01 7e 10             	add    %edi,0x10(%esi)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182a36:	8b 72 04             	mov    0x4(%edx),%esi
  182a39:	8b 78 10             	mov    0x10(%eax),%edi
  182a3c:	89 3e                	mov    %edi,(%esi)
	node->next->prev = node->prev;
  182a3e:	8b 40 10             	mov    0x10(%eax),%eax
  182a41:	8b 72 04             	mov    0x4(%edx),%esi
  182a44:	89 70 04             	mov    %esi,0x4(%eax)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  182a47:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)
		_abort_thread_timeout(desc->thread);
		_mark_thread_as_not_pending(desc->thread);
  182a4e:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  182a51:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		if (_is_thread_ready(desc->thread)) {
  182a55:	8b 43 08             	mov    0x8(%ebx),%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182a58:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  182a5c:	75 0b                	jne    182a69 <handle_sem_group+0x12f>
  182a5e:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  182a62:	75 05                	jne    182a69 <handle_sem_group+0x12f>
  182a64:	b9 01 00 00 00       	mov    $0x1,%ecx
  182a69:	85 c9                	test   %ecx,%ecx
  182a6b:	74 05                	je     182a72 <handle_sem_group+0x138>
			_add_thread_to_ready_q(desc->thread);
  182a6d:	e8 1f fa ff ff       	call   182491 <_add_thread_to_ready_q>
		}
	}
	_set_thread_return_value(desc->thread, 0);
  182a72:	8b 43 08             	mov    0x8(%ebx),%eax
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  182a75:	8b 40 28             	mov    0x28(%eax),%eax
  182a78:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  182a7e:	83 c4 04             	add    $0x4,%esp
  182a81:	5b                   	pop    %ebx
  182a82:	5e                   	pop    %esi
  182a83:	5f                   	pop    %edi
  182a84:	5d                   	pop    %ebp
  182a85:	c3                   	ret    

00182a86 <do_sem_give>:
	sem->count += (sem->count != sem->limit);
}

/* returns 1 if _Swap() will need to be invoked, 0 otherwise */
static int do_sem_give(struct k_sem *sem)
{
  182a86:	57                   	push   %edi
  182a87:	56                   	push   %esi
  182a88:	53                   	push   %ebx
#ifdef CONFIG_SEMAPHORE_GROUPS
	struct k_thread *thread = NULL;
  182a89:	bb 00 00 00 00       	mov    $0x0,%ebx

again:
	thread = _find_first_thread_to_unpend(&sem->wait_q, thread);
  182a8e:	89 c1                	mov    %eax,%ecx
_find_first_thread_to_unpend(_wait_q_t *wait_q, struct k_thread *from)
{
#ifdef CONFIG_SYS_CLOCK_EXISTS
	extern volatile int _handling_timeouts;

	if (_handling_timeouts) {
  182a90:	8b 15 90 05 28 00    	mov    0x280590,%edx
  182a96:	85 d2                	test   %edx,%edx
  182a98:	74 3f                	je     182ad9 <do_sem_give+0x53>
		sys_dlist_t *q = (sys_dlist_t *)wait_q;
		sys_dnode_t *cur = from ? &from->base.k_q_node : NULL;

		/* skip threads that have an expired timeout */
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  182a9a:	85 db                	test   %ebx,%ebx
  182a9c:	74 10                	je     182aae <do_sem_give+0x28>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182a9e:	3b 58 04             	cmp    0x4(%eax),%ebx
  182aa1:	74 04                	je     182aa7 <do_sem_give+0x21>
  182aa3:	8b 1b                	mov    (%ebx),%ebx
  182aa5:	eb 2c                	jmp    182ad3 <do_sem_give+0x4d>
  182aa7:	bb 00 00 00 00       	mov    $0x0,%ebx
  182aac:	eb 25                	jmp    182ad3 <do_sem_give+0x4d>
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182aae:	8b 18                	mov    (%eax),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182ab0:	39 d8                	cmp    %ebx,%eax
  182ab2:	75 1f                	jne    182ad3 <do_sem_give+0x4d>
  182ab4:	bb 00 00 00 00       	mov    $0x0,%ebx
  182ab9:	eb 18                	jmp    182ad3 <do_sem_give+0x4d>
			struct k_thread *thread = (struct k_thread *)cur;

			if (_is_thread_timeout_expired(thread)) {
  182abb:	83 7b 20 fe          	cmpl   $0xfffffffe,0x20(%ebx)
  182abf:	75 23                	jne    182ae4 <do_sem_give+0x5e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182ac1:	85 db                	test   %ebx,%ebx
  182ac3:	74 0e                	je     182ad3 <do_sem_give+0x4d>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182ac5:	3b 59 04             	cmp    0x4(%ecx),%ebx
  182ac8:	74 04                	je     182ace <do_sem_give+0x48>
  182aca:	8b 1b                	mov    (%ebx),%ebx
  182acc:	eb 05                	jmp    182ad3 <do_sem_give+0x4d>
  182ace:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (_handling_timeouts) {
		sys_dlist_t *q = (sys_dlist_t *)wait_q;
		sys_dnode_t *cur = from ? &from->base.k_q_node : NULL;

		/* skip threads that have an expired timeout */
		SYS_DLIST_ITERATE_FROM_NODE(q, cur) {
  182ad3:	85 db                	test   %ebx,%ebx
  182ad5:	75 e4                	jne    182abb <do_sem_give+0x35>
  182ad7:	eb 0b                	jmp    182ae4 <do_sem_give+0x5e>
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182ad9:	8b 18                	mov    (%eax),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182adb:	39 d8                	cmp    %ebx,%eax
  182add:	75 05                	jne    182ae4 <do_sem_give+0x5e>
  182adf:	bb 00 00 00 00       	mov    $0x0,%ebx
	if (!thread) {
  182ae4:	85 db                	test   %ebx,%ebx
  182ae6:	75 1b                	jne    182b03 <do_sem_give+0x7d>
#endif
}

static inline void increment_count_up_to_limit(struct k_sem *sem)
{
	sem->count += (sem->count != sem->limit);
  182ae8:	8b 48 08             	mov    0x8(%eax),%ecx
  182aeb:	3b 48 0c             	cmp    0xc(%eax),%ecx
  182aee:	0f 95 c2             	setne  %dl
  182af1:	0f b6 d2             	movzbl %dl,%edx
  182af4:	01 ca                	add    %ecx,%edx
  182af6:	89 50 08             	mov    %edx,0x8(%eax)

again:
	thread = _find_first_thread_to_unpend(&sem->wait_q, thread);
	if (!thread) {
		increment_count_up_to_limit(sem);
		return handle_poll_event(sem);
  182af9:	b8 00 00 00 00       	mov    $0x0,%eax
  182afe:	e9 e2 00 00 00       	jmp    182be5 <do_sem_give+0x15f>
	thread->base.thread_state &= ~states;
}

static inline int _is_thread_state_set(struct k_thread *thread, uint32_t state)
{
	return !!(thread->base.thread_state & state);
  182b03:	0f b6 53 09          	movzbl 0x9(%ebx),%edx
  182b07:	83 e2 01             	and    $0x1,%edx
  182b0a:	89 d1                	mov    %edx,%ecx
	}

	if (unlikely(_is_thread_dummy(thread))) {
  182b0c:	85 d2                	test   %edx,%edx
  182b0e:	74 19                	je     182b29 <do_sem_give+0xa3>
		/*
		 * The awakened thread is a dummy struct sem_thread and thus
		 * was involved in a semaphore group operation.
		 */
		struct sem_thread *sem_thread = (struct sem_thread *)thread;
		struct k_thread *real_thread = sem_thread->desc.thread;
  182b10:	8b 53 30             	mov    0x30(%ebx),%edx
		 * care of signalling the waiter that its operation has
		 * timedout. In that case, we look for the next thread not part
		 * of the same k_sem_group_take operation to give it the
		 * semaphore.
		 */
		if (_is_thread_timeout_expired(real_thread)) {
  182b13:	83 7a 20 fe          	cmpl   $0xfffffffe,0x20(%edx)
  182b17:	0f 84 71 ff ff ff    	je     182a8e <do_sem_give+0x8>
		/*
		 * Do not dequeue the dummy thread: that will be done when
		 * looping through the list of dummy waiters in
		 * handle_sem_group().
		 */
		handle_sem_group(sem, sem_thread);
  182b1d:	89 da                	mov    %ebx,%edx
  182b1f:	e8 16 fe ff ff       	call   18293a <handle_sem_group>
  182b24:	e9 82 00 00 00       	jmp    182bab <do_sem_give+0x125>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182b29:	8b 43 04             	mov    0x4(%ebx),%eax
  182b2c:	8b 13                	mov    (%ebx),%edx
  182b2e:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  182b30:	8b 03                	mov    (%ebx),%eax
  182b32:	8b 53 04             	mov    0x4(%ebx),%edx
  182b35:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  182b38:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  182b3c:	8d 43 10             	lea    0x10(%ebx),%eax
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  182b3f:	8b 70 10             	mov    0x10(%eax),%esi
  182b42:	83 fe ff             	cmp    $0xffffffff,%esi
  182b45:	74 36                	je     182b7d <do_sem_give+0xf7>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  182b47:	89 c2                	mov    %eax,%edx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  182b49:	8b 3d 10 04 28 00    	mov    0x280410,%edi
  182b4f:	39 f8                	cmp    %edi,%eax
  182b51:	74 14                	je     182b67 <do_sem_give+0xe1>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182b53:	85 c0                	test   %eax,%eax
  182b55:	74 0d                	je     182b64 <do_sem_give+0xde>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182b57:	39 f8                	cmp    %edi,%eax
  182b59:	74 04                	je     182b5f <do_sem_give+0xd9>
  182b5b:	8b 10                	mov    (%eax),%edx
  182b5d:	eb 05                	jmp    182b64 <do_sem_give+0xde>
  182b5f:	ba 00 00 00 00       	mov    $0x0,%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  182b64:	01 72 10             	add    %esi,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182b67:	8b 50 04             	mov    0x4(%eax),%edx
  182b6a:	8b 30                	mov    (%eax),%esi
  182b6c:	89 32                	mov    %esi,(%edx)
	node->next->prev = node->prev;
  182b6e:	8b 10                	mov    (%eax),%edx
  182b70:	8b 70 04             	mov    0x4(%eax),%esi
  182b73:	89 72 04             	mov    %esi,0x4(%edx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  182b76:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182b7d:	8a 43 09             	mov    0x9(%ebx),%al
  182b80:	88 c2                	mov    %al,%dl
  182b82:	83 e2 fb             	and    $0xfffffffb,%edx
  182b85:	88 53 09             	mov    %dl,0x9(%ebx)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182b88:	a8 1b                	test   $0x1b,%al
  182b8a:	75 0b                	jne    182b97 <do_sem_give+0x111>
  182b8c:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  182b90:	75 05                	jne    182b97 <do_sem_give+0x111>
  182b92:	b9 01 00 00 00       	mov    $0x1,%ecx
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182b97:	85 c9                	test   %ecx,%ecx
  182b99:	74 07                	je     182ba2 <do_sem_give+0x11c>
		_add_thread_to_ready_q(thread);
  182b9b:	89 d8                	mov    %ebx,%eax
  182b9d:	e8 ef f8 ff ff       	call   182491 <_add_thread_to_ready_q>
  182ba2:	8b 43 28             	mov    0x28(%ebx),%eax
  182ba5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(void)_abort_thread_timeout(thread);
	_ready_thread(thread);
	_set_thread_return_value(thread, 0);
#endif

	return !_is_in_isr() && _must_switch_threads();
  182bab:	83 3d 00 04 28 00 00 	cmpl   $0x0,0x280400
  182bb2:	75 2c                	jne    182be0 <do_sem_give+0x15a>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  182bb4:	a1 08 04 28 00       	mov    0x280408,%eax
  182bb9:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  182bbe:	77 10                	ja     182bd0 <do_sem_give+0x14a>
  182bc0:	e8 02 fb ff ff       	call   1826c7 <__must_switch_threads>
  182bc5:	85 c0                	test   %eax,%eax
  182bc7:	74 0c                	je     182bd5 <do_sem_give+0x14f>
  182bc9:	b8 01 00 00 00       	mov    $0x1,%eax
  182bce:	eb 05                	jmp    182bd5 <do_sem_give+0x14f>
  182bd0:	b8 00 00 00 00       	mov    $0x0,%eax
  182bd5:	85 c0                	test   %eax,%eax
  182bd7:	74 0c                	je     182be5 <do_sem_give+0x15f>
  182bd9:	b8 01 00 00 00       	mov    $0x1,%eax
  182bde:	eb 05                	jmp    182be5 <do_sem_give+0x15f>
  182be0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  182be5:	5b                   	pop    %ebx
  182be6:	5e                   	pop    %esi
  182be7:	5f                   	pop    %edi
  182be8:	c3                   	ret    

00182be9 <k_sem_init>:
void k_sem_init(struct k_sem *sem, unsigned int initial_count,
		unsigned int limit)
{
	__ASSERT(limit != 0, "limit cannot be zero");

	sem->count = initial_count;
  182be9:	89 50 08             	mov    %edx,0x8(%eax)
	sem->limit = limit;
  182bec:	89 48 0c             	mov    %ecx,0xc(%eax)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  182bef:	89 00                	mov    %eax,(%eax)
	list->tail = (sys_dnode_t *)list;
  182bf1:	89 40 04             	mov    %eax,0x4(%eax)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182bf4:	9c                   	pushf  
  182bf5:	fa                   	cli    
  182bf6:	5a                   	pop    %edx
	sys_dlist_init(&sem->wait_q);

	_INIT_OBJ_POLL_EVENT(sem);

	SYS_TRACING_OBJ_INIT(k_sem, sem);
  182bf7:	8b 0d 8c 05 28 00    	mov    0x28058c,%ecx
  182bfd:	89 48 10             	mov    %ecx,0x10(%eax)
  182c00:	a3 8c 05 28 00       	mov    %eax,0x28058c
  182c05:	f6 c6 02             	test   $0x2,%dh
  182c08:	74 01                	je     182c0b <k_sem_init+0x22>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182c0a:	fb                   	sti    
  182c0b:	c3                   	ret    

00182c0c <k_sem_give>:
	irq_unlock(key);
}
#endif

void k_sem_give(struct k_sem *sem)
{
  182c0c:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182c0d:	9c                   	pushf  
  182c0e:	fa                   	cli    
  182c0f:	5b                   	pop    %ebx
	unsigned int key;

	key = irq_lock();

	if (do_sem_give(sem)) {
  182c10:	e8 71 fe ff ff       	call   182a86 <do_sem_give>
  182c15:	85 c0                	test   %eax,%eax
  182c17:	74 09                	je     182c22 <k_sem_give+0x16>
		_Swap(key);
  182c19:	89 d8                	mov    %ebx,%eax
  182c1b:	e8 8c f3 ff ff       	call   181fac <_Swap>
  182c20:	eb 06                	jmp    182c28 <k_sem_give+0x1c>
  182c22:	f6 c7 02             	test   $0x2,%bh
  182c25:	74 01                	je     182c28 <k_sem_give+0x1c>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182c27:	fb                   	sti    
	} else {
		irq_unlock(key);
	}
}
  182c28:	5b                   	pop    %ebx
  182c29:	c3                   	ret    

00182c2a <k_sem_take>:

int k_sem_take(struct k_sem *sem, int32_t timeout)
{
  182c2a:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182c2b:	9c                   	pushf  
  182c2c:	fa                   	cli    
  182c2d:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr() || timeout == K_NO_WAIT, "");

	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
  182c2e:	8b 48 08             	mov    0x8(%eax),%ecx
  182c31:	85 c9                	test   %ecx,%ecx
  182c33:	74 11                	je     182c46 <k_sem_take+0x1c>
		sem->count--;
  182c35:	49                   	dec    %ecx
  182c36:	89 48 08             	mov    %ecx,0x8(%eax)
  182c39:	f6 c7 02             	test   $0x2,%bh
  182c3c:	74 27                	je     182c65 <k_sem_take+0x3b>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182c3e:	fb                   	sti    
		irq_unlock(key);
		return 0;
  182c3f:	b8 00 00 00 00       	mov    $0x0,%eax
  182c44:	eb 2b                	jmp    182c71 <k_sem_take+0x47>
	}

	if (timeout == K_NO_WAIT) {
  182c46:	85 d2                	test   %edx,%edx
  182c48:	75 0d                	jne    182c57 <k_sem_take+0x2d>
  182c4a:	f6 c7 02             	test   $0x2,%bh
  182c4d:	74 1d                	je     182c6c <k_sem_take+0x42>
  182c4f:	fb                   	sti    
		irq_unlock(key);
		return -EBUSY;
  182c50:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  182c55:	eb 1a                	jmp    182c71 <k_sem_take+0x47>
	}

	_pend_current_thread(&sem->wait_q, timeout);
  182c57:	e8 4a fa ff ff       	call   1826a6 <_pend_current_thread>

	return _Swap(key);
  182c5c:	89 d8                	mov    %ebx,%eax
  182c5e:	e8 49 f3 ff ff       	call   181fac <_Swap>
  182c63:	eb 0c                	jmp    182c71 <k_sem_take+0x47>
	unsigned int key = irq_lock();

	if (likely(sem->count > 0)) {
		sem->count--;
		irq_unlock(key);
		return 0;
  182c65:	b8 00 00 00 00       	mov    $0x0,%eax
  182c6a:	eb 05                	jmp    182c71 <k_sem_take+0x47>
	}

	if (timeout == K_NO_WAIT) {
		irq_unlock(key);
		return -EBUSY;
  182c6c:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
	}

	_pend_current_thread(&sem->wait_q, timeout);

	return _Swap(key);
}
  182c71:	5b                   	pop    %ebx
  182c72:	c3                   	ret    

00182c73 <handle_time_slicing>:
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
	if (_time_slice_duration == 0) {
  182c73:	8b 15 24 05 28 00    	mov    0x280524,%edx
  182c79:	85 d2                	test   %edx,%edx
  182c7b:	74 50                	je     182ccd <handle_time_slicing+0x5a>
		return;
	}

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  182c7d:	8b 0d 08 04 28 00    	mov    0x280408,%ecx
  182c83:	0f be 49 0a          	movsbl 0xa(%ecx),%ecx
  182c87:	39 0d 20 05 28 00    	cmp    %ecx,0x280520
  182c8d:	7f 3e                	jg     182ccd <handle_time_slicing+0x5a>
 *   in this function and at thread level
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
  182c8f:	57                   	push   %edi
  182c90:	56                   	push   %esi
  182c91:	53                   	push   %ebx
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
  182c92:	89 c1                	mov    %eax,%ecx
  182c94:	89 c6                	mov    %eax,%esi
  182c96:	01 c6                	add    %eax,%esi
  182c98:	c1 e1 03             	shl    $0x3,%ecx
  182c9b:	01 f1                	add    %esi,%ecx

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
  182c9d:	03 0d 94 05 28 00    	add    0x280594,%ecx
  182ca3:	89 0d 94 05 28 00    	mov    %ecx,0x280594
	if (_time_slice_elapsed >= _time_slice_duration) {
  182ca9:	39 ca                	cmp    %ecx,%edx
  182cab:	7f 1d                	jg     182cca <handle_time_slicing+0x57>

		unsigned int key;

		_time_slice_elapsed = 0;
  182cad:	c7 05 94 05 28 00 00 	movl   $0x0,0x280594
  182cb4:	00 00 00 

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182cb7:	9c                   	pushf  
  182cb8:	fa                   	cli    
  182cb9:	5b                   	pop    %ebx

		key = irq_lock();
		_move_thread_to_end_of_prio_q(_current);
  182cba:	a1 08 04 28 00       	mov    0x280408,%eax
  182cbf:	e8 75 fa ff ff       	call   182739 <_move_thread_to_end_of_prio_q>
  182cc4:	f6 c7 02             	test   $0x2,%bh
  182cc7:	74 01                	je     182cca <handle_time_slicing+0x57>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182cc9:	fb                   	sti    
		irq_unlock(key);
	}
}
  182cca:	5b                   	pop    %ebx
  182ccb:	5e                   	pop    %esi
  182ccc:	5f                   	pop    %edi
  182ccd:	c3                   	ret    

00182cce <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  182cce:	57                   	push   %edi
  182ccf:	56                   	push   %esi
  182cd0:	53                   	push   %ebx
  182cd1:	83 ec 08             	sub    $0x8,%esp
  182cd4:	89 c6                	mov    %eax,%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182cd6:	9c                   	pushf  
  182cd7:	fa                   	cli    
  182cd8:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
  182cd9:	89 f3                	mov    %esi,%ebx
  182cdb:	c1 fb 1f             	sar    $0x1f,%ebx
  182cde:	01 35 98 05 28 00    	add    %esi,0x280598
  182ce4:	11 1d 9c 05 28 00    	adc    %ebx,0x28059c
  182cea:	f6 c4 02             	test   $0x2,%ah
  182ced:	74 01                	je     182cf0 <_nano_sys_clock_tick_announce+0x22>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182cef:	fb                   	sti    
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  182cf0:	89 24 24             	mov    %esp,(%esp)
	list->tail = (sys_dnode_t *)list;
  182cf3:	89 64 24 04          	mov    %esp,0x4(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182cf7:	9c                   	pushf  
  182cf8:	fa                   	cli    
  182cf9:	59                   	pop    %ecx
  182cfa:	89 ca                	mov    %ecx,%edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182cfc:	a1 0c 04 28 00       	mov    0x28040c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182d01:	3d 0c 04 28 00       	cmp    $0x28040c,%eax
  182d06:	75 05                	jne    182d0d <_nano_sys_clock_tick_announce+0x3f>
  182d08:	b8 00 00 00 00       	mov    $0x0,%eax
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (!head) {
  182d0d:	85 c0                	test   %eax,%eax
  182d0f:	75 0f                	jne    182d20 <_nano_sys_clock_tick_announce+0x52>
  182d11:	f6 c5 02             	test   $0x2,%ch
  182d14:	0f 84 52 01 00 00    	je     182e6c <_nano_sys_clock_tick_announce+0x19e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182d1a:	fb                   	sti    
  182d1b:	e9 4c 01 00 00       	jmp    182e6c <_nano_sys_clock_tick_announce+0x19e>
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
  182d20:	29 70 10             	sub    %esi,0x10(%eax)
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
  182d23:	c7 05 90 05 28 00 01 	movl   $0x1,0x280590
  182d2a:	00 00 00 
  182d2d:	eb 41                	jmp    182d70 <_nano_sys_clock_tick_announce+0xa2>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182d2f:	8b 48 04             	mov    0x4(%eax),%ecx
  182d32:	8b 18                	mov    (%eax),%ebx
  182d34:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  182d36:	8b 08                	mov    (%eax),%ecx
  182d38:	8b 58 04             	mov    0x4(%eax),%ebx
  182d3b:	89 59 04             	mov    %ebx,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
  182d3e:	8b 0c 24             	mov    (%esp),%ecx
  182d41:	89 08                	mov    %ecx,(%eax)
	node->prev = list;
  182d43:	89 60 04             	mov    %esp,0x4(%eax)

	list->head->prev = node;
  182d46:	8b 0c 24             	mov    (%esp),%ecx
  182d49:	89 41 04             	mov    %eax,0x4(%ecx)
	list->head = node;
  182d4c:	89 04 24             	mov    %eax,(%esp)
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
  182d4f:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
  182d56:	f6 c6 02             	test   $0x2,%dh
  182d59:	74 01                	je     182d5c <_nano_sys_clock_tick_announce+0x8e>
  182d5b:	fb                   	sti    

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182d5c:	9c                   	pushf  
  182d5d:	fa                   	cli    
  182d5e:	5a                   	pop    %edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182d5f:	a1 0c 04 28 00       	mov    0x28040c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182d64:	3d 0c 04 28 00       	cmp    $0x28040c,%eax
  182d69:	75 05                	jne    182d70 <_nano_sys_clock_tick_announce+0xa2>
  182d6b:	b8 00 00 00 00       	mov    $0x0,%eax
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
  182d70:	85 c0                	test   %eax,%eax
  182d72:	74 06                	je     182d7a <_nano_sys_clock_tick_announce+0xac>
  182d74:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  182d78:	74 b5                	je     182d2f <_nano_sys_clock_tick_announce+0x61>
  182d7a:	f6 c6 02             	test   $0x2,%dh
  182d7d:	74 01                	je     182d80 <_nano_sys_clock_tick_announce+0xb2>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182d7f:	fb                   	sti    
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182d80:	8b 14 24             	mov    (%esp),%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182d83:	39 e2                	cmp    %esp,%edx
  182d85:	75 05                	jne    182d8c <_nano_sys_clock_tick_announce+0xbe>
  182d87:	ba 00 00 00 00       	mov    $0x0,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182d8c:	85 d2                	test   %edx,%edx
  182d8e:	74 0d                	je     182d9d <_nano_sys_clock_tick_announce+0xcf>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182d90:	3b 54 24 04          	cmp    0x4(%esp),%edx
  182d94:	74 0e                	je     182da4 <_nano_sys_clock_tick_announce+0xd6>
  182d96:	8b 1a                	mov    (%edx),%ebx
  182d98:	e9 bd 00 00 00       	jmp    182e5a <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182d9d:	89 d3                	mov    %edx,%ebx
  182d9f:	e9 b6 00 00 00       	jmp    182e5a <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182da4:	bb 00 00 00 00       	mov    $0x0,%ebx
  182da9:	e9 ac 00 00 00       	jmp    182e5a <_nano_sys_clock_tick_announce+0x18c>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182dae:	8b 42 04             	mov    0x4(%edx),%eax
  182db1:	8b 0a                	mov    (%edx),%ecx
  182db3:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  182db5:	8b 02                	mov    (%edx),%eax
  182db7:	8b 4a 04             	mov    0x4(%edx),%ecx
  182dba:	89 48 04             	mov    %ecx,0x4(%eax)
 * kept as -EAGAIN, set previously in _Swap().
 */

static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
  182dbd:	8b 42 08             	mov    0x8(%edx),%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182dc0:	9c                   	pushf  
  182dc1:	fa                   	cli    
  182dc2:	5f                   	pop    %edi
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
  182dc3:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	K_DEBUG("timeout %p\n", timeout);
	if (thread) {
  182dca:	85 c0                	test   %eax,%eax
  182dcc:	74 5d                	je     182e2b <_nano_sys_clock_tick_announce+0x15d>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
  182dce:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  182dd2:	74 1a                	je     182dee <_nano_sys_clock_tick_announce+0x120>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182dd4:	8b 50 04             	mov    0x4(%eax),%edx
  182dd7:	8b 08                	mov    (%eax),%ecx
  182dd9:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  182ddb:	8b 10                	mov    (%eax),%edx
  182ddd:	8b 48 04             	mov    0x4(%eax),%ecx
  182de0:	89 4a 04             	mov    %ecx,0x4(%edx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  182de3:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
  182de7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182dee:	8a 50 09             	mov    0x9(%eax),%dl
  182df1:	88 d1                	mov    %dl,%cl
  182df3:	83 e1 fb             	and    $0xfffffffb,%ecx
  182df6:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182df9:	f6 c2 1b             	test   $0x1b,%dl
  182dfc:	75 0d                	jne    182e0b <_nano_sys_clock_tick_announce+0x13d>
  182dfe:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  182e02:	75 0e                	jne    182e12 <_nano_sys_clock_tick_announce+0x144>
  182e04:	ba 01 00 00 00       	mov    $0x1,%edx
  182e09:	eb 0c                	jmp    182e17 <_nano_sys_clock_tick_announce+0x149>
  182e0b:	ba 00 00 00 00       	mov    $0x0,%edx
  182e10:	eb 05                	jmp    182e17 <_nano_sys_clock_tick_announce+0x149>
  182e12:	ba 00 00 00 00       	mov    $0x0,%edx
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182e17:	85 d2                	test   %edx,%edx
  182e19:	74 05                	je     182e20 <_nano_sys_clock_tick_announce+0x152>
		_add_thread_to_ready_q(thread);
  182e1b:	e8 71 f6 ff ff       	call   182491 <_add_thread_to_ready_q>
  182e20:	f7 c7 00 02 00 00    	test   $0x200,%edi
  182e26:	74 17                	je     182e3f <_nano_sys_clock_tick_announce+0x171>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182e28:	fb                   	sti    
  182e29:	eb 14                	jmp    182e3f <_nano_sys_clock_tick_announce+0x171>
  182e2b:	f7 c7 00 02 00 00    	test   $0x200,%edi
  182e31:	74 01                	je     182e34 <_nano_sys_clock_tick_announce+0x166>
  182e33:	fb                   	sti    
		_unpend_thread_timing_out(thread, timeout);
		_ready_thread(thread);
		irq_unlock(key);
	} else {
		irq_unlock(key);
		if (timeout->func) {
  182e34:	8b 4a 14             	mov    0x14(%edx),%ecx
  182e37:	85 c9                	test   %ecx,%ecx
  182e39:	74 04                	je     182e3f <_nano_sys_clock_tick_announce+0x171>
			timeout->func(timeout);
  182e3b:	89 d0                	mov    %edx,%eax
  182e3d:	ff d1                	call   *%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182e3f:	85 db                	test   %ebx,%ebx
  182e41:	74 0a                	je     182e4d <_nano_sys_clock_tick_announce+0x17f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182e43:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
  182e47:	74 08                	je     182e51 <_nano_sys_clock_tick_announce+0x183>
  182e49:	8b 03                	mov    (%ebx),%eax
  182e4b:	eb 09                	jmp    182e56 <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182e4d:	89 d8                	mov    %ebx,%eax
  182e4f:	eb 05                	jmp    182e56 <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182e51:	b8 00 00 00 00       	mov    $0x0,%eax

static inline void _handle_expired_timeouts(sys_dlist_t *expired)
{
	sys_dnode_t *timeout, *next;

	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
  182e56:	89 da                	mov    %ebx,%edx
  182e58:	89 c3                	mov    %eax,%ebx
  182e5a:	85 d2                	test   %edx,%edx
  182e5c:	0f 85 4c ff ff ff    	jne    182dae <_nano_sys_clock_tick_announce+0xe0>

	irq_unlock(key);

	_handle_expired_timeouts(&expired);

	_handling_timeouts = 0;
  182e62:	c7 05 90 05 28 00 00 	movl   $0x0,0x280590
  182e69:	00 00 00 
	irq_unlock(key);

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
  182e6c:	89 f0                	mov    %esi,%eax
  182e6e:	e8 00 fe ff ff       	call   182c73 <handle_time_slicing>
}
  182e73:	83 c4 08             	add    $0x8,%esp
  182e76:	5b                   	pop    %ebx
  182e77:	5e                   	pop    %esi
  182e78:	5f                   	pop    %edi
  182e79:	c3                   	ret    

00182e7a <_k_thread_single_start>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182e7a:	8a 50 09             	mov    0x9(%eax),%dl
  182e7d:	88 d1                	mov    %dl,%cl
  182e7f:	83 e1 fb             	and    $0xfffffffb,%ecx
  182e82:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182e85:	f6 c2 1b             	test   $0x1b,%dl
  182e88:	75 0d                	jne    182e97 <_k_thread_single_start+0x1d>
  182e8a:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  182e8e:	75 0e                	jne    182e9e <_k_thread_single_start+0x24>
  182e90:	ba 01 00 00 00       	mov    $0x1,%edx
  182e95:	eb 0c                	jmp    182ea3 <_k_thread_single_start+0x29>
  182e97:	ba 00 00 00 00       	mov    $0x0,%edx
  182e9c:	eb 05                	jmp    182ea3 <_k_thread_single_start+0x29>
  182e9e:	ba 00 00 00 00       	mov    $0x0,%edx

void _k_thread_single_start(struct k_thread *thread)
{
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182ea3:	85 d2                	test   %edx,%edx
  182ea5:	74 05                	je     182eac <_k_thread_single_start+0x32>
		_add_thread_to_ready_q(thread);
  182ea7:	e8 e5 f5 ff ff       	call   182491 <_add_thread_to_ready_q>
  182eac:	c3                   	ret    

00182ead <start_thread>:
	CODE_UNREACHABLE;
}

#ifdef CONFIG_MULTITHREADING
static void start_thread(struct k_thread *thread)
{
  182ead:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182eae:	9c                   	pushf  
  182eaf:	fa                   	cli    
  182eb0:	5b                   	pop    %ebx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182eb1:	8a 50 09             	mov    0x9(%eax),%dl
  182eb4:	88 d1                	mov    %dl,%cl
  182eb6:	83 e1 fb             	and    $0xfffffffb,%ecx
  182eb9:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182ebc:	f6 c2 1b             	test   $0x1b,%dl
  182ebf:	75 0d                	jne    182ece <start_thread+0x21>
  182ec1:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  182ec5:	75 0e                	jne    182ed5 <start_thread+0x28>
  182ec7:	ba 01 00 00 00       	mov    $0x1,%edx
  182ecc:	eb 0c                	jmp    182eda <start_thread+0x2d>
  182ece:	ba 00 00 00 00       	mov    $0x0,%edx
  182ed3:	eb 05                	jmp    182eda <start_thread+0x2d>
  182ed5:	ba 00 00 00 00       	mov    $0x0,%edx
	int key = irq_lock(); /* protect kernel queues */

	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182eda:	85 d2                	test   %edx,%edx
  182edc:	74 33                	je     182f11 <start_thread+0x64>
		_add_thread_to_ready_q(thread);
  182ede:	e8 ae f5 ff ff       	call   182491 <_add_thread_to_ready_q>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  182ee3:	a1 08 04 28 00       	mov    0x280408,%eax
  182ee8:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  182eed:	77 10                	ja     182eff <start_thread+0x52>
  182eef:	e8 d3 f7 ff ff       	call   1826c7 <__must_switch_threads>
  182ef4:	85 c0                	test   %eax,%eax
  182ef6:	74 0c                	je     182f04 <start_thread+0x57>
  182ef8:	b8 01 00 00 00       	mov    $0x1,%eax
  182efd:	eb 05                	jmp    182f04 <start_thread+0x57>
  182eff:	b8 00 00 00 00       	mov    $0x0,%eax
		if (_must_switch_threads()) {
  182f04:	85 c0                	test   %eax,%eax
  182f06:	74 09                	je     182f11 <start_thread+0x64>
			_Swap(key);
  182f08:	89 d8                	mov    %ebx,%eax
  182f0a:	e8 9d f0 ff ff       	call   181fac <_Swap>
			return;
  182f0f:	eb 06                	jmp    182f17 <start_thread+0x6a>
  182f11:	f6 c7 02             	test   $0x2,%bh
  182f14:	74 01                	je     182f17 <start_thread+0x6a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182f16:	fb                   	sti    
		}
	}

	irq_unlock(key);
}
  182f17:	5b                   	pop    %ebx
  182f18:	c3                   	ret    

00182f19 <schedule_new_thread>:
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
  182f19:	57                   	push   %edi
  182f1a:	56                   	push   %esi
  182f1b:	53                   	push   %ebx
  182f1c:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  182f1e:	85 d2                	test   %edx,%edx
  182f20:	75 0a                	jne    182f2c <schedule_new_thread+0x13>
		start_thread(thread);
  182f22:	e8 86 ff ff ff       	call   182ead <start_thread>
  182f27:	e9 18 01 00 00       	jmp    183044 <schedule_new_thread+0x12b>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  182f2c:	83 c2 09             	add    $0x9,%edx
  182f2f:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  182f34:	89 d0                	mov    %edx,%eax
  182f36:	f7 e1                	mul    %ecx
  182f38:	c1 ea 03             	shr    $0x3,%edx
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  182f3b:	42                   	inc    %edx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182f3c:	9c                   	pushf  
  182f3d:	fa                   	cli    
  182f3e:	5f                   	pop    %edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  182f3f:	8d 46 10             	lea    0x10(%esi),%eax
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  182f42:	89 50 10             	mov    %edx,0x10(%eax)
	timeout->thread = thread;
  182f45:	89 70 08             	mov    %esi,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  182f48:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182f4f:	8b 15 0c 04 28 00    	mov    0x28040c,%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182f55:	81 fa 0c 04 28 00    	cmp    $0x28040c,%edx
  182f5b:	75 07                	jne    182f64 <schedule_new_thread+0x4b>
  182f5d:	b9 00 00 00 00       	mov    $0x0,%ecx
  182f62:	eb 02                	jmp    182f66 <schedule_new_thread+0x4d>
  182f64:	89 d1                	mov    %edx,%ecx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182f66:	85 c9                	test   %ecx,%ecx
  182f68:	74 16                	je     182f80 <schedule_new_thread+0x67>
  182f6a:	81 fa 0c 04 28 00    	cmp    $0x28040c,%edx
  182f70:	0f 85 a0 00 00 00    	jne    183016 <schedule_new_thread+0xfd>
  182f76:	ba 00 00 00 00       	mov    $0x0,%edx
  182f7b:	e9 96 00 00 00       	jmp    183016 <schedule_new_thread+0xfd>
  182f80:	ba 00 00 00 00       	mov    $0x0,%edx
  182f85:	e9 8c 00 00 00       	jmp    183016 <schedule_new_thread+0xfd>
		if (*delta <= in_q->delta_ticks_from_prev) {
  182f8a:	8b 48 10             	mov    0x10(%eax),%ecx
  182f8d:	8b 5a 10             	mov    0x10(%edx),%ebx
  182f90:	39 d9                	cmp    %ebx,%ecx
  182f92:	7f 3b                	jg     182fcf <schedule_new_thread+0xb6>
			in_q->delta_ticks_from_prev -= *delta;
  182f94:	29 cb                	sub    %ecx,%ebx
  182f96:	89 5a 10             	mov    %ebx,0x10(%edx)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  182f99:	85 d2                	test   %edx,%edx
  182f9b:	75 1f                	jne    182fbc <schedule_new_thread+0xa3>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182f9d:	c7 46 10 0c 04 28 00 	movl   $0x28040c,0x10(%esi)
	node->prev = list->tail;
  182fa4:	8b 15 10 04 28 00    	mov    0x280410,%edx
  182faa:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  182fad:	8b 15 10 04 28 00    	mov    0x280410,%edx
  182fb3:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  182fb5:	a3 10 04 28 00       	mov    %eax,0x280410
  182fba:	eb 7f                	jmp    18303b <schedule_new_thread+0x122>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  182fbc:	8b 4a 04             	mov    0x4(%edx),%ecx
  182fbf:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
  182fc2:	89 56 10             	mov    %edx,0x10(%esi)
		insert_point->prev->next = node;
  182fc5:	8b 4a 04             	mov    0x4(%edx),%ecx
  182fc8:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
  182fca:	89 42 04             	mov    %eax,0x4(%edx)
  182fcd:	eb 6c                	jmp    18303b <schedule_new_thread+0x122>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  182fcf:	29 d9                	sub    %ebx,%ecx
  182fd1:	89 48 10             	mov    %ecx,0x10(%eax)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182fd4:	89 d1                	mov    %edx,%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182fd6:	85 d2                	test   %edx,%edx
  182fd8:	74 0c                	je     182fe6 <schedule_new_thread+0xcd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182fda:	3b 15 10 04 28 00    	cmp    0x280410,%edx
  182fe0:	74 08                	je     182fea <schedule_new_thread+0xd1>
  182fe2:	8b 1a                	mov    (%edx),%ebx
  182fe4:	eb 09                	jmp    182fef <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182fe6:	89 d3                	mov    %edx,%ebx
  182fe8:	eb 05                	jmp    182fef <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182fea:	bb 00 00 00 00       	mov    $0x0,%ebx
  182fef:	85 db                	test   %ebx,%ebx
  182ff1:	74 1e                	je     183011 <schedule_new_thread+0xf8>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182ff3:	85 c9                	test   %ecx,%ecx
  182ff5:	74 0c                	je     183003 <schedule_new_thread+0xea>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182ff7:	3b 0d 10 04 28 00    	cmp    0x280410,%ecx
  182ffd:	74 0b                	je     18300a <schedule_new_thread+0xf1>
  182fff:	8b 12                	mov    (%edx),%edx
  183001:	eb 13                	jmp    183016 <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  183003:	ba 00 00 00 00       	mov    $0x0,%edx
  183008:	eb 0c                	jmp    183016 <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18300a:	ba 00 00 00 00       	mov    $0x0,%edx
  18300f:	eb 05                	jmp    183016 <schedule_new_thread+0xfd>
  183011:	ba 00 00 00 00       	mov    $0x0,%edx
  183016:	85 d2                	test   %edx,%edx
  183018:	0f 85 6c ff ff ff    	jne    182f8a <schedule_new_thread+0x71>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  18301e:	c7 46 10 0c 04 28 00 	movl   $0x28040c,0x10(%esi)
	node->prev = list->tail;
  183025:	8b 15 10 04 28 00    	mov    0x280410,%edx
  18302b:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  18302e:	8b 15 10 04 28 00    	mov    0x280410,%edx
  183034:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  183036:	a3 10 04 28 00       	mov    %eax,0x280410
  18303b:	f7 c7 00 02 00 00    	test   $0x200,%edi
  183041:	74 01                	je     183044 <schedule_new_thread+0x12b>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183043:	fb                   	sti    
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  183044:	5b                   	pop    %ebx
  183045:	5e                   	pop    %esi
  183046:	5f                   	pop    %edi
  183047:	c3                   	ret    

00183048 <k_is_in_isr>:
}
#endif

int k_is_in_isr(void)
{
	return _is_in_isr();
  183048:	83 3d 00 04 28 00 00 	cmpl   $0x0,0x280400
  18304f:	0f 95 c0             	setne  %al
  183052:	0f b6 c0             	movzbl %al,%eax
}
  183055:	c3                   	ret    

00183056 <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.user_options & K_ESSENTIAL;
  183056:	a1 08 04 28 00       	mov    0x280408,%eax
  18305b:	8a 40 08             	mov    0x8(%eax),%al
  18305e:	83 e0 01             	and    $0x1,%eax
}
  183061:	c3                   	ret    

00183062 <_thread_monitor_exit>:
#if defined(CONFIG_THREAD_MONITOR)
/*
 * Remove a thread from the kernel's list of active threads.
 */
void _thread_monitor_exit(struct k_thread *thread)
{
  183062:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  183063:	9c                   	pushf  
  183064:	fa                   	cli    
  183065:	5b                   	pop    %ebx
	unsigned int key = irq_lock();

	if (thread == _kernel.threads) {
  183066:	8b 0d 1c 05 28 00    	mov    0x28051c,%ecx
  18306c:	39 c1                	cmp    %eax,%ecx
  18306e:	75 0c                	jne    18307c <_thread_monitor_exit+0x1a>
		_kernel.threads = _kernel.threads->next_thread;
  183070:	8b 41 38             	mov    0x38(%ecx),%eax
  183073:	a3 1c 05 28 00       	mov    %eax,0x28051c
  183078:	eb 0f                	jmp    183089 <_thread_monitor_exit+0x27>
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
			prev_thread = prev_thread->next_thread;
  18307a:	89 d1                	mov    %edx,%ecx
		_kernel.threads = _kernel.threads->next_thread;
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
  18307c:	8b 51 38             	mov    0x38(%ecx),%edx
  18307f:	39 d0                	cmp    %edx,%eax
  183081:	75 f7                	jne    18307a <_thread_monitor_exit+0x18>
			prev_thread = prev_thread->next_thread;
		}
		prev_thread->next_thread = thread->next_thread;
  183083:	8b 40 38             	mov    0x38(%eax),%eax
  183086:	89 41 38             	mov    %eax,0x38(%ecx)
  183089:	f6 c7 02             	test   $0x2,%bh
  18308c:	74 01                	je     18308f <_thread_monitor_exit+0x2d>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18308e:	fb                   	sti    
	}

	irq_unlock(key);
}
  18308f:	5b                   	pop    %ebx
  183090:	c3                   	ret    

00183091 <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
  183091:	53                   	push   %ebx
  183092:	89 c3                	mov    %eax,%ebx
  183094:	89 d0                	mov    %edx,%eax
  183096:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
  183098:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  18309c:	ff d3                	call   *%ebx

#ifdef CONFIG_MULTITHREADING
	if (_is_thread_essential()) {
  18309e:	e8 b3 ff ff ff       	call   183056 <_is_thread_essential>
  1830a3:	85 c0                	test   %eax,%eax
  1830a5:	74 0f                	je     1830b6 <_thread_entry+0x25>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  1830a7:	ba c0 6e 18 00       	mov    $0x186ec0,%edx
  1830ac:	b8 03 00 00 00       	mov    $0x3,%eax
  1830b1:	e8 cb ef ff ff       	call   182081 <_NanoFatalErrorHandler>
				       &_default_esf);
	}

	k_thread_abort(_current);
  1830b6:	a1 08 04 28 00       	mov    0x280408,%eax
  1830bb:	e8 e0 01 00 00       	call   1832a0 <k_thread_abort>

001830c0 <_k_thread_group_op>:
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  1830c0:	55                   	push   %ebp
  1830c1:	57                   	push   %edi
  1830c2:	56                   	push   %esi
  1830c3:	53                   	push   %ebx
  1830c4:	89 c6                	mov    %eax,%esi
  1830c6:	89 d5                	mov    %edx,%ebp
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  1830c8:	8b 15 08 04 28 00    	mov    0x280408,%edx
  1830ce:	8a 42 0b             	mov    0xb(%edx),%al
  1830d1:	48                   	dec    %eax
  1830d2:	88 42 0b             	mov    %al,0xb(%edx)

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  1830d5:	bb 48 03 28 00       	mov    $0x280348,%ebx
  1830da:	eb 18                	jmp    1830f4 <_k_thread_group_op+0x34>
		if (is_in_any_group(thread_data, groups)) {
  1830dc:	85 73 28             	test   %esi,0x28(%ebx)
  1830df:	74 10                	je     1830f1 <_k_thread_group_op+0x31>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1830e1:	9c                   	pushf  
  1830e2:	fa                   	cli    
  1830e3:	5f                   	pop    %edi
			key = irq_lock();
			func(thread_data->thread);
  1830e4:	8b 03                	mov    (%ebx),%eax
  1830e6:	ff d5                	call   *%ebp
  1830e8:	f7 c7 00 02 00 00    	test   $0x200,%edi
  1830ee:	74 01                	je     1830f1 <_k_thread_group_op+0x31>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1830f0:	fb                   	sti    

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  1830f1:	83 c3 2c             	add    $0x2c,%ebx
  1830f4:	81 fb 48 03 28 00    	cmp    $0x280348,%ebx
  1830fa:	72 e0                	jb     1830dc <_k_thread_group_op+0x1c>

	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
  1830fc:	a1 08 04 28 00       	mov    0x280408,%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  183101:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  183105:	75 0d                	jne    183114 <_k_thread_group_op+0x54>
  183107:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  18310b:	75 0e                	jne    18311b <_k_thread_group_op+0x5b>
  18310d:	b8 01 00 00 00       	mov    $0x1,%eax
  183112:	eb 0c                	jmp    183120 <_k_thread_group_op+0x60>
  183114:	b8 00 00 00 00       	mov    $0x0,%eax
  183119:	eb 05                	jmp    183120 <_k_thread_group_op+0x60>
  18311b:	b8 00 00 00 00       	mov    $0x0,%eax
  183120:	85 c0                	test   %eax,%eax
  183122:	74 07                	je     18312b <_k_thread_group_op+0x6b>
		k_sched_unlock();
  183124:	e8 fa f5 ff ff       	call   182723 <k_sched_unlock>
		return;
  183129:	eb 15                	jmp    183140 <_k_thread_group_op+0x80>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18312b:	9c                   	pushf  
  18312c:	fa                   	cli    
  18312d:	58                   	pop    %eax
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 0, "");

	compiler_barrier();

	++_current->base.sched_locked;
  18312e:	8b 0d 08 04 28 00    	mov    0x280408,%ecx
  183134:	8a 51 0b             	mov    0xb(%ecx),%dl
  183137:	42                   	inc    %edx
  183138:	88 51 0b             	mov    %dl,0xb(%ecx)
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  18313b:	e8 6c ee ff ff       	call   181fac <_Swap>
}
  183140:	5b                   	pop    %ebx
  183141:	5e                   	pop    %esi
  183142:	5f                   	pop    %edi
  183143:	5d                   	pop    %ebp
  183144:	c3                   	ret    

00183145 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  183145:	56                   	push   %esi
  183146:	53                   	push   %ebx
  183147:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
  183149:	8b 40 30             	mov    0x30(%eax),%eax
  18314c:	85 c0                	test   %eax,%eax
  18314e:	74 02                	je     183152 <_k_thread_single_abort+0xd>
		thread->fn_abort();
  183150:	ff d0                	call   *%eax
	return !(thread->base.thread_state & _THREAD_PRESTART);
}

static inline int _is_thread_prevented_from_running(struct k_thread *thread)
{
	uint8_t state = thread->base.thread_state;
  183152:	8a 43 09             	mov    0x9(%ebx),%al
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  183155:	a8 1f                	test   $0x1f,%al
  183157:	75 0d                	jne    183166 <_k_thread_single_abort+0x21>
  183159:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  18315d:	75 0e                	jne    18316d <_k_thread_single_abort+0x28>
  18315f:	ba 01 00 00 00       	mov    $0x1,%edx
  183164:	eb 0c                	jmp    183172 <_k_thread_single_abort+0x2d>
  183166:	ba 00 00 00 00       	mov    $0x0,%edx
  18316b:	eb 05                	jmp    183172 <_k_thread_single_abort+0x2d>
  18316d:	ba 00 00 00 00       	mov    $0x0,%edx
	}

	if (_is_thread_ready(thread)) {
  183172:	85 d2                	test   %edx,%edx
  183174:	74 09                	je     18317f <_k_thread_single_abort+0x3a>
		_remove_thread_from_ready_q(thread);
  183176:	89 d8                	mov    %ebx,%eax
  183178:	e8 62 f3 ff ff       	call   1824df <_remove_thread_from_ready_q>
  18317d:	eb 61                	jmp    1831e0 <_k_thread_single_abort+0x9b>
	} else {
		if (_is_thread_pending(thread)) {
  18317f:	a8 02                	test   $0x2,%al
  183181:	74 13                	je     183196 <_k_thread_single_abort+0x51>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  183183:	8b 43 04             	mov    0x4(%ebx),%eax
  183186:	8b 13                	mov    (%ebx),%edx
  183188:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  18318a:	8b 03                	mov    (%ebx),%eax
  18318c:	8b 53 04             	mov    0x4(%ebx),%edx
  18318f:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  183192:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  183196:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  18319a:	74 44                	je     1831e0 <_k_thread_single_abort+0x9b>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  18319c:	8d 43 10             	lea    0x10(%ebx),%eax
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  18319f:	8b 48 10             	mov    0x10(%eax),%ecx
  1831a2:	83 f9 ff             	cmp    $0xffffffff,%ecx
  1831a5:	74 39                	je     1831e0 <_k_thread_single_abort+0x9b>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  1831a7:	89 c2                	mov    %eax,%edx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  1831a9:	8b 35 10 04 28 00    	mov    0x280410,%esi
  1831af:	39 f0                	cmp    %esi,%eax
  1831b1:	74 15                	je     1831c8 <_k_thread_single_abort+0x83>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1831b3:	85 c0                	test   %eax,%eax
  1831b5:	74 0e                	je     1831c5 <_k_thread_single_abort+0x80>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1831b7:	39 f0                	cmp    %esi,%eax
  1831b9:	74 05                	je     1831c0 <_k_thread_single_abort+0x7b>
  1831bb:	8b 53 10             	mov    0x10(%ebx),%edx
  1831be:	eb 05                	jmp    1831c5 <_k_thread_single_abort+0x80>
  1831c0:	ba 00 00 00 00       	mov    $0x0,%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  1831c5:	01 4a 10             	add    %ecx,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1831c8:	8b 50 04             	mov    0x4(%eax),%edx
  1831cb:	8b 4b 10             	mov    0x10(%ebx),%ecx
  1831ce:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1831d0:	8b 53 10             	mov    0x10(%ebx),%edx
  1831d3:	8b 48 04             	mov    0x4(%eax),%ecx
  1831d6:	89 4a 04             	mov    %ecx,0x4(%edx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  1831d9:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_DEAD;
  1831e0:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  1831e4:	5b                   	pop    %ebx
  1831e5:	5e                   	pop    %esi
  1831e6:	c3                   	ret    

001831e7 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
  1831e7:	56                   	push   %esi
  1831e8:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  1831e9:	bb 48 03 28 00       	mov    $0x280348,%ebx
  1831ee:	eb 27                	jmp    183217 <_init_static_threads+0x30>
		_task_group_adjust(thread_data);
		_new_thread(
  1831f0:	8b 4b 08             	mov    0x8(%ebx),%ecx
  1831f3:	8b 53 04             	mov    0x4(%ebx),%edx
  1831f6:	ff 73 1c             	pushl  0x1c(%ebx)
  1831f9:	ff 73 18             	pushl  0x18(%ebx)
  1831fc:	ff 73 14             	pushl  0x14(%ebx)
  1831ff:	ff 73 10             	pushl  0x10(%ebx)
  183202:	ff 73 0c             	pushl  0xc(%ebx)
  183205:	8b 03                	mov    (%ebx),%eax
  183207:	e8 2f ee ff ff       	call   18203b <_new_thread>
  18320c:	83 c4 14             	add    $0x14,%esp
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  18320f:	8b 03                	mov    (%ebx),%eax
  183211:	89 58 2c             	mov    %ebx,0x2c(%eax)
#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  183214:	83 c3 2c             	add    $0x2c,%ebx
  183217:	81 fb 48 03 28 00    	cmp    $0x280348,%ebx
  18321d:	72 d1                	jb     1831f0 <_init_static_threads+0x9>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  18321f:	8b 15 08 04 28 00    	mov    0x280408,%edx
  183225:	8a 42 0b             	mov    0xb(%edx),%al
  183228:	48                   	dec    %eax
  183229:	88 42 0b             	mov    %al,0xb(%edx)
	}

	_sched_lock();
#if defined(CONFIG_LEGACY_KERNEL)
	/* Start all (legacy) threads that are part of the EXE task group */
	_k_thread_group_op(K_TASK_GROUP_EXE, _k_thread_single_start);
  18322c:	ba 7a 2e 18 00       	mov    $0x182e7a,%edx
  183231:	b8 01 00 00 00       	mov    $0x1,%eax
  183236:	e8 85 fe ff ff       	call   1830c0 <_k_thread_group_op>
  18323b:	9c                   	pushf  
  18323c:	fa                   	cli    
  18323d:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  18323e:	bb 48 03 28 00       	mov    $0x280348,%ebx
  183243:	eb 12                	jmp    183257 <_init_static_threads+0x70>
		if (thread_data->init_delay != K_FOREVER) {
  183245:	8b 53 20             	mov    0x20(%ebx),%edx
  183248:	83 fa ff             	cmp    $0xffffffff,%edx
  18324b:	74 07                	je     183254 <_init_static_threads+0x6d>
			schedule_new_thread(thread_data->thread,
  18324d:	8b 03                	mov    (%ebx),%eax
  18324f:	e8 c5 fc ff ff       	call   182f19 <schedule_new_thread>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  183254:	83 c3 2c             	add    $0x2c,%ebx
  183257:	81 fb 48 03 28 00    	cmp    $0x280348,%ebx
  18325d:	72 e6                	jb     183245 <_init_static_threads+0x5e>
  18325f:	f7 c6 00 02 00 00    	test   $0x200,%esi
  183265:	74 01                	je     183268 <_init_static_threads+0x81>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  183267:	fb                   	sti    
			schedule_new_thread(thread_data->thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
  183268:	e8 b6 f4 ff ff       	call   182723 <k_sched_unlock>
}
  18326d:	5b                   	pop    %ebx
  18326e:	5e                   	pop    %esi
  18326f:	c3                   	ret    

00183270 <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  183270:	53                   	push   %ebx
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
  183271:	8a 5c 24 08          	mov    0x8(%esp),%bl
  183275:	88 58 08             	mov    %bl,0x8(%eax)
	thread_base->thread_state = (uint8_t)initial_state;
  183278:	88 48 09             	mov    %cl,0x9(%eax)

	thread_base->prio = priority;
  18327b:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
  18327e:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
  183282:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  183289:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  183290:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  183297:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  18329e:	5b                   	pop    %ebx
  18329f:	c3                   	ret    

001832a0 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
  1832a0:	56                   	push   %esi
  1832a1:	53                   	push   %ebx
  1832a2:	89 c3                	mov    %eax,%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1832a4:	9c                   	pushf  
  1832a5:	fa                   	cli    
  1832a6:	5e                   	pop    %esi
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  1832a7:	e8 99 fe ff ff       	call   183145 <_k_thread_single_abort>
	_thread_monitor_exit(thread);
  1832ac:	89 d8                	mov    %ebx,%eax
  1832ae:	e8 af fd ff ff       	call   183062 <_thread_monitor_exit>

	if (_current == thread) {
  1832b3:	3b 1d 08 04 28 00    	cmp    0x280408,%ebx
  1832b9:	75 07                	jne    1832c2 <k_thread_abort+0x22>
		_Swap(key);
  1832bb:	89 f0                	mov    %esi,%eax
  1832bd:	e8 ea ec ff ff       	call   181fac <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  1832c2:	89 f0                	mov    %esi,%eax
  1832c4:	e8 21 f4 ff ff       	call   1826ea <_reschedule_threads>
}
  1832c9:	5b                   	pop    %ebx
  1832ca:	5e                   	pop    %esi
  1832cb:	c3                   	ret    

001832cc <_sys_power_save_idle>:
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
  1832cc:	e8 8a eb ff ff       	call   181e5b <k_cpu_idle>
  1832d1:	c3                   	ret    

001832d2 <idle>:
  1832d2:	9c                   	pushf  
  1832d3:	fa                   	cli    
  1832d4:	58                   	pop    %eax
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1832d5:	a1 0c 04 28 00       	mov    0x28040c,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1832da:	3d 0c 04 28 00       	cmp    $0x28040c,%eax
  1832df:	75 05                	jne    1832e6 <idle+0x14>
  1832e1:	b8 00 00 00 00       	mov    $0x0,%eax
static inline int32_t _get_next_timeout_expiry(void)
{
	struct _timeout *t = (struct _timeout *)
			     sys_dlist_peek_head(&_timeout_q);

	return t ? t->delta_ticks_from_prev : K_FOREVER;
  1832e6:	85 c0                	test   %eax,%eax
  1832e8:	74 05                	je     1832ef <idle+0x1d>
  1832ea:	8b 40 10             	mov    0x10(%eax),%eax
  1832ed:	eb 05                	jmp    1832f4 <idle+0x22>
  1832ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	__idle_tsc = _tsc_read();
#endif

	for (;;) {
		(void)irq_lock();
		_sys_power_save_idle(_get_next_timeout_expiry());
  1832f4:	e8 d3 ff ff ff       	call   1832cc <_sys_power_save_idle>

		IDLE_YIELD_IF_COOP();
	}
  1832f9:	eb d7                	jmp    1832d2 <idle>

001832fb <_OffsetAbsSyms>:
/* tTaskStateSegment structure member offsets */


/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));
  1832fb:	c3                   	ret    

001832fc <atan2>:
  1832fc:	e9 00 00 00 00       	jmp    183301 <__ieee754_atan2>

00183301 <__ieee754_atan2>:
  183301:	55                   	push   %ebp
  183302:	57                   	push   %edi
  183303:	56                   	push   %esi
  183304:	53                   	push   %ebx
  183305:	83 ec 14             	sub    $0x14,%esp
  183308:	89 c6                	mov    %eax,%esi
  18330a:	89 d7                	mov    %edx,%edi
  18330c:	8b 44 24 28          	mov    0x28(%esp),%eax
  183310:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  183314:	89 04 24             	mov    %eax,(%esp)
  183317:	89 54 24 04          	mov    %edx,0x4(%esp)
  18331b:	8b 04 24             	mov    (%esp),%eax
  18331e:	89 74 24 10          	mov    %esi,0x10(%esp)
  183322:	89 44 24 08          	mov    %eax,0x8(%esp)
  183326:	8b 44 24 04          	mov    0x4(%esp),%eax
  18332a:	89 c3                	mov    %eax,%ebx
  18332c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  183330:	81 e3 ff ff ff 7f    	and    $0x7fffffff,%ebx
  183336:	89 da                	mov    %ebx,%edx
  183338:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  18333c:	f7 db                	neg    %ebx
  18333e:	0b 5c 24 08          	or     0x8(%esp),%ebx
  183342:	c1 eb 1f             	shr    $0x1f,%ebx
  183345:	09 d3                	or     %edx,%ebx
  183347:	81 fb 00 00 f0 7f    	cmp    $0x7ff00000,%ebx
  18334d:	77 1d                	ja     18336c <__ieee754_atan2+0x6b>
  18334f:	89 f5                	mov    %esi,%ebp
  183351:	89 fb                	mov    %edi,%ebx
  183353:	f7 dd                	neg    %ebp
  183355:	09 f5                	or     %esi,%ebp
  183357:	81 e3 ff ff ff 7f    	and    $0x7fffffff,%ebx
  18335d:	c1 ed 1f             	shr    $0x1f,%ebp
  183360:	89 f9                	mov    %edi,%ecx
  183362:	09 dd                	or     %ebx,%ebp
  183364:	81 fd 00 00 f0 7f    	cmp    $0x7ff00000,%ebp
  18336a:	76 14                	jbe    183380 <__ieee754_atan2+0x7f>
  18336c:	57                   	push   %edi
  18336d:	56                   	push   %esi
  18336e:	8b 44 24 08          	mov    0x8(%esp),%eax
  183372:	8b 54 24 0c          	mov    0xc(%esp),%edx
  183376:	e8 d1 16 00 00       	call   184a4c <__adddf3>
  18337b:	e9 ec 01 00 00       	jmp    18356c <__ieee754_atan2+0x26b>
  183380:	8b 44 24 0c          	mov    0xc(%esp),%eax
  183384:	8d a8 00 00 10 c0    	lea    -0x3ff00000(%eax),%ebp
  18338a:	0b 6c 24 08          	or     0x8(%esp),%ebp
  18338e:	75 10                	jne    1833a0 <__ieee754_atan2+0x9f>
  183390:	83 c4 14             	add    $0x14,%esp
  183393:	89 f0                	mov    %esi,%eax
  183395:	89 fa                	mov    %edi,%edx
  183397:	5b                   	pop    %ebx
  183398:	5e                   	pop    %esi
  183399:	5f                   	pop    %edi
  18339a:	5d                   	pop    %ebp
  18339b:	e9 d6 01 00 00       	jmp    183576 <atan>
  1833a0:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  1833a4:	89 f8                	mov    %edi,%eax
  1833a6:	c1 fd 1e             	sar    $0x1e,%ebp
  1833a9:	c1 e8 1f             	shr    $0x1f,%eax
  1833ac:	83 e5 02             	and    $0x2,%ebp
  1833af:	09 c5                	or     %eax,%ebp
  1833b1:	89 f0                	mov    %esi,%eax
  1833b3:	09 d8                	or     %ebx,%eax
  1833b5:	75 2f                	jne    1833e6 <__ieee754_atan2+0xe5>
  1833b7:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  1833bc:	ba fb 21 09 40       	mov    $0x400921fb,%edx
  1833c1:	83 fd 02             	cmp    $0x2,%ebp
  1833c4:	0f 84 a4 01 00 00    	je     18356e <__ieee754_atan2+0x26d>
  1833ca:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  1833cf:	ba fb 21 09 c0       	mov    $0xc00921fb,%edx
  1833d4:	83 fd 03             	cmp    $0x3,%ebp
  1833d7:	0f 84 91 01 00 00    	je     18356e <__ieee754_atan2+0x26d>
  1833dd:	89 f0                	mov    %esi,%eax
  1833df:	89 fa                	mov    %edi,%edx
  1833e1:	e9 88 01 00 00       	jmp    18356e <__ieee754_atan2+0x26d>
  1833e6:	8b 44 24 08          	mov    0x8(%esp),%eax
  1833ea:	09 d0                	or     %edx,%eax
  1833ec:	0f 84 9f 00 00 00    	je     183491 <__ieee754_atan2+0x190>
  1833f2:	81 fa 00 00 f0 7f    	cmp    $0x7ff00000,%edx
  1833f8:	0f 85 8b 00 00 00    	jne    183489 <__ieee754_atan2+0x188>
  1833fe:	81 fb 00 00 f0 7f    	cmp    $0x7ff00000,%ebx
  183404:	75 46                	jne    18344c <__ieee754_atan2+0x14b>
  183406:	b8 d2 21 33 7f       	mov    $0x7f3321d2,%eax
  18340b:	ba 7c d9 02 40       	mov    $0x4002d97c,%edx
  183410:	83 fd 02             	cmp    $0x2,%ebp
  183413:	0f 84 55 01 00 00    	je     18356e <__ieee754_atan2+0x26d>
  183419:	b8 d2 21 33 7f       	mov    $0x7f3321d2,%eax
  18341e:	ba 7c d9 02 c0       	mov    $0xc002d97c,%edx
  183423:	83 fd 03             	cmp    $0x3,%ebp
  183426:	0f 84 42 01 00 00    	je     18356e <__ieee754_atan2+0x26d>
  18342c:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  183431:	ba fb 21 e9 bf       	mov    $0xbfe921fb,%edx
  183436:	4d                   	dec    %ebp
  183437:	0f 84 31 01 00 00    	je     18356e <__ieee754_atan2+0x26d>
  18343d:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  183442:	ba fb 21 e9 3f       	mov    $0x3fe921fb,%edx
  183447:	e9 22 01 00 00       	jmp    18356e <__ieee754_atan2+0x26d>
  18344c:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  183451:	ba fb 21 09 40       	mov    $0x400921fb,%edx
  183456:	83 fd 02             	cmp    $0x2,%ebp
  183459:	0f 84 0f 01 00 00    	je     18356e <__ieee754_atan2+0x26d>
  18345f:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  183464:	ba fb 21 09 c0       	mov    $0xc00921fb,%edx
  183469:	83 fd 03             	cmp    $0x3,%ebp
  18346c:	0f 84 fc 00 00 00    	je     18356e <__ieee754_atan2+0x26d>
  183472:	31 c0                	xor    %eax,%eax
  183474:	ba 00 00 00 80       	mov    $0x80000000,%edx
  183479:	4d                   	dec    %ebp
  18347a:	0f 84 ee 00 00 00    	je     18356e <__ieee754_atan2+0x26d>
  183480:	31 c0                	xor    %eax,%eax
  183482:	31 d2                	xor    %edx,%edx
  183484:	e9 e5 00 00 00       	jmp    18356e <__ieee754_atan2+0x26d>
  183489:	81 fb 00 00 f0 7f    	cmp    $0x7ff00000,%ebx
  18348f:	75 21                	jne    1834b2 <__ieee754_atan2+0x1b1>
  183491:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  183496:	ba fb 21 f9 3f       	mov    $0x3ff921fb,%edx
  18349b:	85 c9                	test   %ecx,%ecx
  18349d:	0f 89 cb 00 00 00    	jns    18356e <__ieee754_atan2+0x26d>
  1834a3:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  1834a8:	ba fb 21 f9 bf       	mov    $0xbff921fb,%edx
  1834ad:	e9 bc 00 00 00       	jmp    18356e <__ieee754_atan2+0x26d>
  1834b2:	89 d9                	mov    %ebx,%ecx
  1834b4:	bb fb 21 f9 3f       	mov    $0x3ff921fb,%ebx
  1834b9:	29 d1                	sub    %edx,%ecx
  1834bb:	c1 f9 14             	sar    $0x14,%ecx
  1834be:	89 ca                	mov    %ecx,%edx
  1834c0:	b9 18 2d 44 54       	mov    $0x54442d18,%ecx
  1834c5:	83 fa 3c             	cmp    $0x3c,%edx
  1834c8:	7f 33                	jg     1834fd <__ieee754_atan2+0x1fc>
  1834ca:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1834ce:	c1 e8 1f             	shr    $0x1f,%eax
  1834d1:	74 09                	je     1834dc <__ieee754_atan2+0x1db>
  1834d3:	31 c9                	xor    %ecx,%ecx
  1834d5:	31 db                	xor    %ebx,%ebx
  1834d7:	83 fa c4             	cmp    $0xffffffc4,%edx
  1834da:	7c 21                	jl     1834fd <__ieee754_atan2+0x1fc>
  1834dc:	ff 74 24 04          	pushl  0x4(%esp)
  1834e0:	ff 74 24 04          	pushl  0x4(%esp)
  1834e4:	89 f0                	mov    %esi,%eax
  1834e6:	89 fa                	mov    %edi,%edx
  1834e8:	e8 b1 1d 00 00       	call   18529e <__divdf3>
  1834ed:	5b                   	pop    %ebx
  1834ee:	5e                   	pop    %esi
  1834ef:	e8 90 04 00 00       	call   183984 <fabs>
  1834f4:	e8 7d 00 00 00       	call   183576 <atan>
  1834f9:	89 c1                	mov    %eax,%ecx
  1834fb:	89 d3                	mov    %edx,%ebx
  1834fd:	83 fd 01             	cmp    $0x1,%ebp
  183500:	74 33                	je     183535 <__ieee754_atan2+0x234>
  183502:	83 fd 02             	cmp    $0x2,%ebp
  183505:	74 38                	je     18353f <__ieee754_atan2+0x23e>
  183507:	89 c8                	mov    %ecx,%eax
  183509:	89 da                	mov    %ebx,%edx
  18350b:	85 ed                	test   %ebp,%ebp
  18350d:	74 5f                	je     18356e <__ieee754_atan2+0x26d>
  18350f:	89 c8                	mov    %ecx,%eax
  183511:	89 da                	mov    %ebx,%edx
  183513:	68 26 a6 a1 3c       	push   $0x3ca1a626
  183518:	68 07 5c 14 33       	push   $0x33145c07
  18351d:	e8 44 29 00 00       	call   185e66 <__subdf3>
  183522:	59                   	pop    %ecx
  183523:	5b                   	pop    %ebx
  183524:	68 fb 21 09 40       	push   $0x400921fb
  183529:	68 18 2d 44 54       	push   $0x54442d18
  18352e:	e8 33 29 00 00       	call   185e66 <__subdf3>
  183533:	eb 37                	jmp    18356c <__ieee754_atan2+0x26b>
  183535:	89 c8                	mov    %ecx,%eax
  183537:	8d 93 00 00 00 80    	lea    -0x80000000(%ebx),%edx
  18353d:	eb 2f                	jmp    18356e <__ieee754_atan2+0x26d>
  18353f:	89 c8                	mov    %ecx,%eax
  183541:	89 da                	mov    %ebx,%edx
  183543:	68 26 a6 a1 3c       	push   $0x3ca1a626
  183548:	68 07 5c 14 33       	push   $0x33145c07
  18354d:	e8 14 29 00 00       	call   185e66 <__subdf3>
  183552:	5d                   	pop    %ebp
  183553:	59                   	pop    %ecx
  183554:	89 04 24             	mov    %eax,(%esp)
  183557:	89 54 24 04          	mov    %edx,0x4(%esp)
  18355b:	52                   	push   %edx
  18355c:	ba fb 21 09 40       	mov    $0x400921fb,%edx
  183561:	50                   	push   %eax
  183562:	b8 18 2d 44 54       	mov    $0x54442d18,%eax
  183567:	e8 fa 28 00 00       	call   185e66 <__subdf3>
  18356c:	5e                   	pop    %esi
  18356d:	5f                   	pop    %edi
  18356e:	83 c4 14             	add    $0x14,%esp
  183571:	5b                   	pop    %ebx
  183572:	5e                   	pop    %esi
  183573:	5f                   	pop    %edi
  183574:	5d                   	pop    %ebp
  183575:	c3                   	ret    

00183576 <atan>:
  183576:	55                   	push   %ebp
  183577:	89 d5                	mov    %edx,%ebp
  183579:	57                   	push   %edi
  18357a:	81 e5 ff ff ff 7f    	and    $0x7fffffff,%ebp
  183580:	56                   	push   %esi
  183581:	53                   	push   %ebx
  183582:	83 ec 10             	sub    $0x10,%esp
  183585:	89 c6                	mov    %eax,%esi
  183587:	89 d7                	mov    %edx,%edi
  183589:	89 d3                	mov    %edx,%ebx
  18358b:	81 fd ff ff 0f 44    	cmp    $0x440fffff,%ebp
  183591:	7e 39                	jle    1835cc <atan+0x56>
  183593:	81 fd 00 00 f0 7f    	cmp    $0x7ff00000,%ebp
  183599:	7f 06                	jg     1835a1 <atan+0x2b>
  18359b:	75 14                	jne    1835b1 <atan+0x3b>
  18359d:	85 c0                	test   %eax,%eax
  18359f:	74 10                	je     1835b1 <atan+0x3b>
  1835a1:	89 f0                	mov    %esi,%eax
  1835a3:	89 fa                	mov    %edi,%edx
  1835a5:	57                   	push   %edi
  1835a6:	56                   	push   %esi
  1835a7:	e8 a0 14 00 00       	call   184a4c <__adddf3>
  1835ac:	e9 57 03 00 00       	jmp    183908 <atan+0x392>
  1835b1:	85 db                	test   %ebx,%ebx
  1835b3:	be 18 2d 44 54       	mov    $0x54442d18,%esi
  1835b8:	0f 9e c1             	setle  %cl
  1835bb:	0f b6 c9             	movzbl %cl,%ecx
  1835be:	c1 e1 1f             	shl    $0x1f,%ecx
  1835c1:	81 c1 fb 21 f9 3f    	add    $0x3ff921fb,%ecx
  1835c7:	e9 ac 03 00 00       	jmp    183978 <atan+0x402>
  1835cc:	81 fd ff ff db 3f    	cmp    $0x3fdbffff,%ebp
  1835d2:	7f 3a                	jg     18360e <atan+0x98>
  1835d4:	81 fd ff ff 1f 3e    	cmp    $0x3e1fffff,%ebp
  1835da:	0f 8f 66 01 00 00    	jg     183746 <atan+0x1d0>
  1835e0:	68 3c e4 37 7e       	push   $0x7e37e43c
  1835e5:	68 9c 75 00 88       	push   $0x8800759c
  1835ea:	e8 5d 14 00 00       	call   184a4c <__adddf3>
  1835ef:	5d                   	pop    %ebp
  1835f0:	59                   	pop    %ecx
  1835f1:	68 00 00 f0 3f       	push   $0x3ff00000
  1835f6:	6a 00                	push   $0x0
  1835f8:	e8 b1 21 00 00       	call   1857ae <__gedf2>
  1835fd:	5d                   	pop    %ebp
  1835fe:	89 f9                	mov    %edi,%ecx
  183600:	5a                   	pop    %edx
  183601:	85 c0                	test   %eax,%eax
  183603:	0f 8f 6f 03 00 00    	jg     183978 <atan+0x402>
  183609:	e9 38 01 00 00       	jmp    183746 <atan+0x1d0>
  18360e:	e8 71 03 00 00       	call   183984 <fabs>
  183613:	81 fd ff ff f2 3f    	cmp    $0x3ff2ffff,%ebp
  183619:	89 c6                	mov    %eax,%esi
  18361b:	89 d7                	mov    %edx,%edi
  18361d:	0f 8f a7 00 00 00    	jg     1836ca <atan+0x154>
  183623:	81 fd ff ff e5 3f    	cmp    $0x3fe5ffff,%ebp
  183629:	7f 54                	jg     18367f <atan+0x109>
  18362b:	52                   	push   %edx
  18362c:	50                   	push   %eax
  18362d:	e8 1a 14 00 00       	call   184a4c <__adddf3>
  183632:	5d                   	pop    %ebp
  183633:	59                   	pop    %ecx
  183634:	68 00 00 f0 3f       	push   $0x3ff00000
  183639:	6a 00                	push   $0x0
  18363b:	e8 26 28 00 00       	call   185e66 <__subdf3>
  183640:	5d                   	pop    %ebp
  183641:	59                   	pop    %ecx
  183642:	89 04 24             	mov    %eax,(%esp)
  183645:	89 54 24 04          	mov    %edx,0x4(%esp)
  183649:	89 f0                	mov    %esi,%eax
  18364b:	89 fa                	mov    %edi,%edx
  18364d:	68 00 00 00 40       	push   $0x40000000
  183652:	6a 00                	push   $0x0
  183654:	e8 f3 13 00 00       	call   184a4c <__adddf3>
  183659:	5e                   	pop    %esi
  18365a:	5f                   	pop    %edi
  18365b:	89 44 24 08          	mov    %eax,0x8(%esp)
  18365f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  183663:	52                   	push   %edx
  183664:	50                   	push   %eax
  183665:	8b 44 24 08          	mov    0x8(%esp),%eax
  183669:	8b 54 24 0c          	mov    0xc(%esp),%edx
  18366d:	e8 2c 1c 00 00       	call   18529e <__divdf3>
  183672:	5d                   	pop    %ebp
  183673:	89 c6                	mov    %eax,%esi
  183675:	59                   	pop    %ecx
  183676:	89 d7                	mov    %edx,%edi
  183678:	31 ed                	xor    %ebp,%ebp
  18367a:	e9 ca 00 00 00       	jmp    183749 <atan+0x1d3>
  18367f:	68 00 00 f0 3f       	push   $0x3ff00000
  183684:	6a 00                	push   $0x0
  183686:	e8 db 27 00 00       	call   185e66 <__subdf3>
  18368b:	5d                   	pop    %ebp
  18368c:	59                   	pop    %ecx
  18368d:	89 04 24             	mov    %eax,(%esp)
  183690:	89 54 24 04          	mov    %edx,0x4(%esp)
  183694:	89 f0                	mov    %esi,%eax
  183696:	89 fa                	mov    %edi,%edx
  183698:	68 00 00 f0 3f       	push   $0x3ff00000
  18369d:	6a 00                	push   $0x0
  18369f:	e8 a8 13 00 00       	call   184a4c <__adddf3>
  1836a4:	5e                   	pop    %esi
  1836a5:	5f                   	pop    %edi
  1836a6:	89 44 24 08          	mov    %eax,0x8(%esp)
  1836aa:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1836ae:	52                   	push   %edx
  1836af:	50                   	push   %eax
  1836b0:	8b 44 24 08          	mov    0x8(%esp),%eax
  1836b4:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1836b8:	e8 e1 1b 00 00       	call   18529e <__divdf3>
  1836bd:	5d                   	pop    %ebp
  1836be:	89 c6                	mov    %eax,%esi
  1836c0:	59                   	pop    %ecx
  1836c1:	89 d7                	mov    %edx,%edi
  1836c3:	bd 01 00 00 00       	mov    $0x1,%ebp
  1836c8:	eb 7f                	jmp    183749 <atan+0x1d3>
  1836ca:	81 fd ff 7f 03 40    	cmp    $0x40037fff,%ebp
  1836d0:	7f 59                	jg     18372b <atan+0x1b5>
  1836d2:	68 00 00 f8 3f       	push   $0x3ff80000
  1836d7:	6a 00                	push   $0x0
  1836d9:	e8 88 27 00 00       	call   185e66 <__subdf3>
  1836de:	5d                   	pop    %ebp
  1836df:	59                   	pop    %ecx
  1836e0:	89 04 24             	mov    %eax,(%esp)
  1836e3:	89 54 24 04          	mov    %edx,0x4(%esp)
  1836e7:	89 f0                	mov    %esi,%eax
  1836e9:	89 fa                	mov    %edi,%edx
  1836eb:	68 00 00 f8 3f       	push   $0x3ff80000
  1836f0:	6a 00                	push   $0x0
  1836f2:	e8 d7 22 00 00       	call   1859ce <__muldf3>
  1836f7:	5e                   	pop    %esi
  1836f8:	5f                   	pop    %edi
  1836f9:	68 00 00 f0 3f       	push   $0x3ff00000
  1836fe:	6a 00                	push   $0x0
  183700:	e8 47 13 00 00       	call   184a4c <__adddf3>
  183705:	5d                   	pop    %ebp
  183706:	59                   	pop    %ecx
  183707:	89 44 24 08          	mov    %eax,0x8(%esp)
  18370b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  18370f:	52                   	push   %edx
  183710:	50                   	push   %eax
  183711:	8b 44 24 08          	mov    0x8(%esp),%eax
  183715:	8b 54 24 0c          	mov    0xc(%esp),%edx
  183719:	e8 80 1b 00 00       	call   18529e <__divdf3>
  18371e:	bd 02 00 00 00       	mov    $0x2,%ebp
  183723:	5e                   	pop    %esi
  183724:	89 c6                	mov    %eax,%esi
  183726:	5f                   	pop    %edi
  183727:	89 d7                	mov    %edx,%edi
  183729:	eb 1e                	jmp    183749 <atan+0x1d3>
  18372b:	52                   	push   %edx
  18372c:	ba 00 00 f0 bf       	mov    $0xbff00000,%edx
  183731:	50                   	push   %eax
  183732:	31 c0                	xor    %eax,%eax
  183734:	e8 65 1b 00 00       	call   18529e <__divdf3>
  183739:	bd 03 00 00 00       	mov    $0x3,%ebp
  18373e:	5e                   	pop    %esi
  18373f:	89 c6                	mov    %eax,%esi
  183741:	5f                   	pop    %edi
  183742:	89 d7                	mov    %edx,%edi
  183744:	eb 03                	jmp    183749 <atan+0x1d3>
  183746:	83 cd ff             	or     $0xffffffff,%ebp
  183749:	89 f0                	mov    %esi,%eax
  18374b:	89 fa                	mov    %edi,%edx
  18374d:	57                   	push   %edi
  18374e:	56                   	push   %esi
  18374f:	e8 7a 22 00 00       	call   1859ce <__muldf3>
  183754:	59                   	pop    %ecx
  183755:	59                   	pop    %ecx
  183756:	89 44 24 08          	mov    %eax,0x8(%esp)
  18375a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  18375e:	52                   	push   %edx
  18375f:	50                   	push   %eax
  183760:	8b 44 24 10          	mov    0x10(%esp),%eax
  183764:	8b 54 24 14          	mov    0x14(%esp),%edx
  183768:	e8 61 22 00 00       	call   1859ce <__muldf3>
  18376d:	59                   	pop    %ecx
  18376e:	59                   	pop    %ecx
  18376f:	89 04 24             	mov    %eax,(%esp)
  183772:	89 54 24 04          	mov    %edx,0x4(%esp)
  183776:	68 3a ad 90 3f       	push   $0x3f90ad3a
  18377b:	68 11 da 22 e3       	push   $0xe322da11
  183780:	8b 44 24 08          	mov    0x8(%esp),%eax
  183784:	8b 54 24 0c          	mov    0xc(%esp),%edx
  183788:	e8 41 22 00 00       	call   1859ce <__muldf3>
  18378d:	59                   	pop    %ecx
  18378e:	59                   	pop    %ecx
  18378f:	68 4b 7b a9 3f       	push   $0x3fa97b4b
  183794:	68 eb 0d 76 24       	push   $0x24760deb
  183799:	e8 ae 12 00 00       	call   184a4c <__adddf3>
  18379e:	59                   	pop    %ecx
  18379f:	59                   	pop    %ecx
  1837a0:	ff 74 24 04          	pushl  0x4(%esp)
  1837a4:	ff 74 24 04          	pushl  0x4(%esp)
  1837a8:	e8 21 22 00 00       	call   1859ce <__muldf3>
  1837ad:	59                   	pop    %ecx
  1837ae:	59                   	pop    %ecx
  1837af:	68 66 0d b1 3f       	push   $0x3fb10d66
  1837b4:	68 51 3d d0 a0       	push   $0xa0d03d51
  1837b9:	e8 8e 12 00 00       	call   184a4c <__adddf3>
  1837be:	59                   	pop    %ecx
  1837bf:	59                   	pop    %ecx
  1837c0:	ff 74 24 04          	pushl  0x4(%esp)
  1837c4:	ff 74 24 04          	pushl  0x4(%esp)
  1837c8:	e8 01 22 00 00       	call   1859ce <__muldf3>
  1837cd:	59                   	pop    %ecx
  1837ce:	59                   	pop    %ecx
  1837cf:	68 cd 45 b7 3f       	push   $0x3fb745cd
  1837d4:	68 6e 20 4c c5       	push   $0xc54c206e
  1837d9:	e8 6e 12 00 00       	call   184a4c <__adddf3>
  1837de:	59                   	pop    %ecx
  1837df:	59                   	pop    %ecx
  1837e0:	ff 74 24 04          	pushl  0x4(%esp)
  1837e4:	ff 74 24 04          	pushl  0x4(%esp)
  1837e8:	e8 e1 21 00 00       	call   1859ce <__muldf3>
  1837ed:	59                   	pop    %ecx
  1837ee:	59                   	pop    %ecx
  1837ef:	68 24 49 c2 3f       	push   $0x3fc24924
  1837f4:	68 ff 83 00 92       	push   $0x920083ff
  1837f9:	e8 4e 12 00 00       	call   184a4c <__adddf3>
  1837fe:	59                   	pop    %ecx
  1837ff:	59                   	pop    %ecx
  183800:	ff 74 24 04          	pushl  0x4(%esp)
  183804:	ff 74 24 04          	pushl  0x4(%esp)
  183808:	e8 c1 21 00 00       	call   1859ce <__muldf3>
  18380d:	59                   	pop    %ecx
  18380e:	59                   	pop    %ecx
  18380f:	68 55 55 d5 3f       	push   $0x3fd55555
  183814:	68 0d 55 55 55       	push   $0x5555550d
  183819:	e8 2e 12 00 00       	call   184a4c <__adddf3>
  18381e:	59                   	pop    %ecx
  18381f:	59                   	pop    %ecx
  183820:	ff 74 24 0c          	pushl  0xc(%esp)
  183824:	ff 74 24 0c          	pushl  0xc(%esp)
  183828:	e8 a1 21 00 00       	call   1859ce <__muldf3>
  18382d:	59                   	pop    %ecx
  18382e:	59                   	pop    %ecx
  18382f:	89 44 24 08          	mov    %eax,0x8(%esp)
  183833:	89 54 24 0c          	mov    %edx,0xc(%esp)
  183837:	68 44 b4 a2 bf       	push   $0xbfa2b444
  18383c:	68 2f 6c 6a 2c       	push   $0x2c6a6c2f
  183841:	8b 44 24 08          	mov    0x8(%esp),%eax
  183845:	8b 54 24 0c          	mov    0xc(%esp),%edx
  183849:	e8 80 21 00 00       	call   1859ce <__muldf3>
  18384e:	59                   	pop    %ecx
  18384f:	59                   	pop    %ecx
  183850:	68 2d de ad 3f       	push   $0x3fadde2d
  183855:	68 9a fd de 52       	push   $0x52defd9a
  18385a:	e8 07 26 00 00       	call   185e66 <__subdf3>
  18385f:	59                   	pop    %ecx
  183860:	59                   	pop    %ecx
  183861:	ff 74 24 04          	pushl  0x4(%esp)
  183865:	ff 74 24 04          	pushl  0x4(%esp)
  183869:	e8 60 21 00 00       	call   1859ce <__muldf3>
  18386e:	59                   	pop    %ecx
  18386f:	59                   	pop    %ecx
  183870:	68 f2 b0 b3 3f       	push   $0x3fb3b0f2
  183875:	68 6d 9a 74 af       	push   $0xaf749a6d
  18387a:	e8 e7 25 00 00       	call   185e66 <__subdf3>
  18387f:	59                   	pop    %ecx
  183880:	59                   	pop    %ecx
  183881:	ff 74 24 04          	pushl  0x4(%esp)
  183885:	ff 74 24 04          	pushl  0x4(%esp)
  183889:	e8 40 21 00 00       	call   1859ce <__muldf3>
  18388e:	59                   	pop    %ecx
  18388f:	59                   	pop    %ecx
  183890:	68 c6 71 bc 3f       	push   $0x3fbc71c6
  183895:	68 71 16 23 fe       	push   $0xfe231671
  18389a:	e8 c7 25 00 00       	call   185e66 <__subdf3>
  18389f:	59                   	pop    %ecx
  1838a0:	59                   	pop    %ecx
  1838a1:	ff 74 24 04          	pushl  0x4(%esp)
  1838a5:	ff 74 24 04          	pushl  0x4(%esp)
  1838a9:	e8 20 21 00 00       	call   1859ce <__muldf3>
  1838ae:	59                   	pop    %ecx
  1838af:	59                   	pop    %ecx
  1838b0:	68 99 99 c9 3f       	push   $0x3fc99999
  1838b5:	68 c4 eb 98 99       	push   $0x9998ebc4
  1838ba:	e8 a7 25 00 00       	call   185e66 <__subdf3>
  1838bf:	59                   	pop    %ecx
  1838c0:	59                   	pop    %ecx
  1838c1:	ff 74 24 04          	pushl  0x4(%esp)
  1838c5:	ff 74 24 04          	pushl  0x4(%esp)
  1838c9:	e8 00 21 00 00       	call   1859ce <__muldf3>
  1838ce:	59                   	pop    %ecx
  1838cf:	59                   	pop    %ecx
  1838d0:	83 fd ff             	cmp    $0xffffffff,%ebp
  1838d3:	89 04 24             	mov    %eax,(%esp)
  1838d6:	89 54 24 04          	mov    %edx,0x4(%esp)
  1838da:	75 32                	jne    18390e <atan+0x398>
  1838dc:	52                   	push   %edx
  1838dd:	50                   	push   %eax
  1838de:	8b 44 24 10          	mov    0x10(%esp),%eax
  1838e2:	8b 54 24 14          	mov    0x14(%esp),%edx
  1838e6:	e8 61 11 00 00       	call   184a4c <__adddf3>
  1838eb:	5d                   	pop    %ebp
  1838ec:	59                   	pop    %ecx
  1838ed:	57                   	push   %edi
  1838ee:	56                   	push   %esi
  1838ef:	e8 da 20 00 00       	call   1859ce <__muldf3>
  1838f4:	5b                   	pop    %ebx
  1838f5:	5d                   	pop    %ebp
  1838f6:	89 04 24             	mov    %eax,(%esp)
  1838f9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1838fd:	52                   	push   %edx
  1838fe:	89 fa                	mov    %edi,%edx
  183900:	50                   	push   %eax
  183901:	89 f0                	mov    %esi,%eax
  183903:	e8 5e 25 00 00       	call   185e66 <__subdf3>
  183908:	5b                   	pop    %ebx
  183909:	5e                   	pop    %esi
  18390a:	89 c6                	mov    %eax,%esi
  18390c:	eb 68                	jmp    183976 <atan+0x400>
  18390e:	ff 74 24 04          	pushl  0x4(%esp)
  183912:	ff 74 24 04          	pushl  0x4(%esp)
  183916:	8b 44 24 10          	mov    0x10(%esp),%eax
  18391a:	8b 54 24 14          	mov    0x14(%esp),%edx
  18391e:	e8 29 11 00 00       	call   184a4c <__adddf3>
  183923:	59                   	pop    %ecx
  183924:	59                   	pop    %ecx
  183925:	57                   	push   %edi
  183926:	56                   	push   %esi
  183927:	e8 a2 20 00 00       	call   1859ce <__muldf3>
  18392c:	59                   	pop    %ecx
  18392d:	59                   	pop    %ecx
  18392e:	ff 34 ed e4 68 18 00 	pushl  0x1868e4(,%ebp,8)
  183935:	ff 34 ed e0 68 18 00 	pushl  0x1868e0(,%ebp,8)
  18393c:	e8 25 25 00 00       	call   185e66 <__subdf3>
  183941:	59                   	pop    %ecx
  183942:	59                   	pop    %ecx
  183943:	57                   	push   %edi
  183944:	56                   	push   %esi
  183945:	e8 1c 25 00 00       	call   185e66 <__subdf3>
  18394a:	5e                   	pop    %esi
  18394b:	5f                   	pop    %edi
  18394c:	89 04 24             	mov    %eax,(%esp)
  18394f:	89 54 24 04          	mov    %edx,0x4(%esp)
  183953:	52                   	push   %edx
  183954:	8b 14 ed 04 69 18 00 	mov    0x186904(,%ebp,8),%edx
  18395b:	50                   	push   %eax
  18395c:	8b 04 ed 00 69 18 00 	mov    0x186900(,%ebp,8),%eax
  183963:	e8 fe 24 00 00       	call   185e66 <__subdf3>
  183968:	5d                   	pop    %ebp
  183969:	89 c6                	mov    %eax,%esi
  18396b:	59                   	pop    %ecx
  18396c:	85 db                	test   %ebx,%ebx
  18396e:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
  183974:	78 02                	js     183978 <atan+0x402>
  183976:	89 d1                	mov    %edx,%ecx
  183978:	83 c4 10             	add    $0x10,%esp
  18397b:	89 f0                	mov    %esi,%eax
  18397d:	89 ca                	mov    %ecx,%edx
  18397f:	5b                   	pop    %ebx
  183980:	5e                   	pop    %esi
  183981:	5f                   	pop    %edi
  183982:	5d                   	pop    %ebp
  183983:	c3                   	ret    

00183984 <fabs>:
  183984:	89 d1                	mov    %edx,%ecx
  183986:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  18398c:	89 ca                	mov    %ecx,%edx
  18398e:	c3                   	ret    

0018398f <memcpy>:
  18398f:	56                   	push   %esi
  183990:	57                   	push   %edi
  183991:	89 c7                	mov    %eax,%edi
  183993:	89 d6                	mov    %edx,%esi
  183995:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  183997:	5f                   	pop    %edi
  183998:	5e                   	pop    %esi
  183999:	c3                   	ret    

0018399a <siprintf>:
  18399a:	83 ec 64             	sub    $0x64,%esp
  18399d:	8b 44 24 68          	mov    0x68(%esp),%eax
  1839a1:	66 c7 44 24 0c 08 02 	movw   $0x208,0xc(%esp)
  1839a8:	89 04 24             	mov    %eax,(%esp)
  1839ab:	89 44 24 10          	mov    %eax,0x10(%esp)
  1839af:	8d 44 24 70          	lea    0x70(%esp),%eax
  1839b3:	c7 44 24 08 ff ff ff 	movl   $0x7fffffff,0x8(%esp)
  1839ba:	7f 
  1839bb:	c7 44 24 14 ff ff ff 	movl   $0x7fffffff,0x14(%esp)
  1839c2:	7f 
  1839c3:	66 c7 44 24 0e ff ff 	movw   $0xffff,0xe(%esp)
  1839ca:	50                   	push   %eax
  1839cb:	a1 00 00 28 00       	mov    0x280000,%eax
  1839d0:	8d 54 24 04          	lea    0x4(%esp),%edx
  1839d4:	8b 4c 24 70          	mov    0x70(%esp),%ecx
  1839d8:	e8 0a 01 00 00       	call   183ae7 <_svfiprintf_r>
  1839dd:	8b 54 24 04          	mov    0x4(%esp),%edx
  1839e1:	c6 02 00             	movb   $0x0,(%edx)
  1839e4:	83 c4 68             	add    $0x68,%esp
  1839e7:	c3                   	ret    

001839e8 <strcmp>:
  1839e8:	8a 08                	mov    (%eax),%cl
  1839ea:	84 c9                	test   %cl,%cl
  1839ec:	74 08                	je     1839f6 <strcmp+0xe>
  1839ee:	3a 0a                	cmp    (%edx),%cl
  1839f0:	75 04                	jne    1839f6 <strcmp+0xe>
  1839f2:	40                   	inc    %eax
  1839f3:	42                   	inc    %edx
  1839f4:	eb f2                	jmp    1839e8 <strcmp>
  1839f6:	0f b6 12             	movzbl (%edx),%edx
  1839f9:	0f b6 c1             	movzbl %cl,%eax
  1839fc:	29 d0                	sub    %edx,%eax
  1839fe:	c3                   	ret    

001839ff <__ssputs_r>:
  1839ff:	55                   	push   %ebp
  183a00:	57                   	push   %edi
  183a01:	56                   	push   %esi
  183a02:	53                   	push   %ebx
  183a03:	83 ec 08             	sub    $0x8,%esp
  183a06:	89 d3                	mov    %edx,%ebx
  183a08:	8b 7a 08             	mov    0x8(%edx),%edi
  183a0b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  183a0f:	3b 7c 24 1c          	cmp    0x1c(%esp),%edi
  183a13:	0f 87 a8 00 00 00    	ja     183ac1 <__ssputs_r+0xc2>
  183a19:	8b 4a 0c             	mov    0xc(%edx),%ecx
  183a1c:	66 f7 c1 80 04       	test   $0x480,%cx
  183a21:	0f 84 9a 00 00 00    	je     183ac1 <__ssputs_r+0xc2>
  183a27:	8b 7a 10             	mov    0x10(%edx),%edi
  183a2a:	89 c5                	mov    %eax,%ebp
  183a2c:	8b 02                	mov    (%edx),%eax
  183a2e:	be 02 00 00 00       	mov    $0x2,%esi
  183a33:	29 f8                	sub    %edi,%eax
  183a35:	89 04 24             	mov    %eax,(%esp)
  183a38:	6b 42 14 03          	imul   $0x3,0x14(%edx),%eax
  183a3c:	99                   	cltd   
  183a3d:	f7 fe                	idiv   %esi
  183a3f:	89 c6                	mov    %eax,%esi
  183a41:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  183a45:	8b 04 24             	mov    (%esp),%eax
  183a48:	8d 44 10 01          	lea    0x1(%eax,%edx,1),%eax
  183a4c:	39 f0                	cmp    %esi,%eax
  183a4e:	76 02                	jbe    183a52 <__ssputs_r+0x53>
  183a50:	89 c6                	mov    %eax,%esi
  183a52:	80 e5 04             	and    $0x4,%ch
  183a55:	74 29                	je     183a80 <__ssputs_r+0x81>
  183a57:	89 f2                	mov    %esi,%edx
  183a59:	89 e8                	mov    %ebp,%eax
  183a5b:	e8 4c 07 00 00       	call   1841ac <_malloc_r>
  183a60:	89 c7                	mov    %eax,%edi
  183a62:	85 c0                	test   %eax,%eax
  183a64:	74 35                	je     183a9b <__ssputs_r+0x9c>
  183a66:	8b 53 10             	mov    0x10(%ebx),%edx
  183a69:	8b 0c 24             	mov    (%esp),%ecx
  183a6c:	e8 1e ff ff ff       	call   18398f <memcpy>
  183a71:	8b 43 0c             	mov    0xc(%ebx),%eax
  183a74:	66 25 7f fb          	and    $0xfb7f,%ax
  183a78:	0c 80                	or     $0x80,%al
  183a7a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  183a7e:	eb 2c                	jmp    183aac <__ssputs_r+0xad>
  183a80:	89 fa                	mov    %edi,%edx
  183a82:	89 f1                	mov    %esi,%ecx
  183a84:	89 e8                	mov    %ebp,%eax
  183a86:	e8 f1 07 00 00       	call   18427c <_realloc_r>
  183a8b:	89 c7                	mov    %eax,%edi
  183a8d:	85 c0                	test   %eax,%eax
  183a8f:	75 1b                	jne    183aac <__ssputs_r+0xad>
  183a91:	8b 53 10             	mov    0x10(%ebx),%edx
  183a94:	89 e8                	mov    %ebp,%eax
  183a96:	e8 58 06 00 00       	call   1840f3 <_free_r>
  183a9b:	c7 45 00 0c 00 00 00 	movl   $0xc,0x0(%ebp)
  183aa2:	83 c8 ff             	or     $0xffffffff,%eax
  183aa5:	66 83 4b 0c 40       	orw    $0x40,0xc(%ebx)
  183aaa:	eb 33                	jmp    183adf <__ssputs_r+0xe0>
  183aac:	89 7b 10             	mov    %edi,0x10(%ebx)
  183aaf:	89 73 14             	mov    %esi,0x14(%ebx)
  183ab2:	03 3c 24             	add    (%esp),%edi
  183ab5:	2b 34 24             	sub    (%esp),%esi
  183ab8:	89 3b                	mov    %edi,(%ebx)
  183aba:	89 73 08             	mov    %esi,0x8(%ebx)
  183abd:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  183ac1:	39 7c 24 1c          	cmp    %edi,0x1c(%esp)
  183ac5:	73 04                	jae    183acb <__ssputs_r+0xcc>
  183ac7:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  183acb:	89 f9                	mov    %edi,%ecx
  183acd:	8b 54 24 04          	mov    0x4(%esp),%edx
  183ad1:	8b 03                	mov    (%ebx),%eax
  183ad3:	e8 fb 05 00 00       	call   1840d3 <memmove>
  183ad8:	29 7b 08             	sub    %edi,0x8(%ebx)
  183adb:	01 3b                	add    %edi,(%ebx)
  183add:	31 c0                	xor    %eax,%eax
  183adf:	83 c4 08             	add    $0x8,%esp
  183ae2:	5b                   	pop    %ebx
  183ae3:	5e                   	pop    %esi
  183ae4:	5f                   	pop    %edi
  183ae5:	5d                   	pop    %ebp
  183ae6:	c3                   	ret    

00183ae7 <_svfiprintf_r>:
  183ae7:	55                   	push   %ebp
  183ae8:	57                   	push   %edi
  183ae9:	56                   	push   %esi
  183aea:	53                   	push   %ebx
  183aeb:	83 ec 68             	sub    $0x68,%esp
  183aee:	89 c7                	mov    %eax,%edi
  183af0:	89 d6                	mov    %edx,%esi
  183af2:	f6 42 0c 80          	testb  $0x80,0xc(%edx)
  183af6:	89 0c 24             	mov    %ecx,(%esp)
  183af9:	74 2e                	je     183b29 <_svfiprintf_r+0x42>
  183afb:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  183aff:	75 28                	jne    183b29 <_svfiprintf_r+0x42>
  183b01:	ba 40 00 00 00       	mov    $0x40,%edx
  183b06:	e8 a1 06 00 00       	call   1841ac <_malloc_r>
  183b0b:	89 06                	mov    %eax,(%esi)
  183b0d:	89 46 10             	mov    %eax,0x10(%esi)
  183b10:	85 c0                	test   %eax,%eax
  183b12:	75 0e                	jne    183b22 <_svfiprintf_r+0x3b>
  183b14:	c7 07 0c 00 00 00    	movl   $0xc,(%edi)
  183b1a:	83 c8 ff             	or     $0xffffffff,%eax
  183b1d:	e9 24 02 00 00       	jmp    183d46 <_svfiprintf_r+0x25f>
  183b22:	c7 46 14 40 00 00 00 	movl   $0x40,0x14(%esi)
  183b29:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
  183b30:	00 
  183b31:	c6 44 24 25 20       	movb   $0x20,0x25(%esp)
  183b36:	c6 44 24 26 30       	movb   $0x30,0x26(%esp)
  183b3b:	8b 1c 24             	mov    (%esp),%ebx
  183b3e:	8a 03                	mov    (%ebx),%al
  183b40:	84 c0                	test   %al,%al
  183b42:	0f 95 c2             	setne  %dl
  183b45:	3c 25                	cmp    $0x25,%al
  183b47:	0f 95 c0             	setne  %al
  183b4a:	20 c2                	and    %al,%dl
  183b4c:	88 54 24 07          	mov    %dl,0x7(%esp)
  183b50:	74 03                	je     183b55 <_svfiprintf_r+0x6e>
  183b52:	43                   	inc    %ebx
  183b53:	eb e9                	jmp    183b3e <_svfiprintf_r+0x57>
  183b55:	89 d8                	mov    %ebx,%eax
  183b57:	2b 04 24             	sub    (%esp),%eax
  183b5a:	89 44 24 08          	mov    %eax,0x8(%esp)
  183b5e:	74 1e                	je     183b7e <_svfiprintf_r+0x97>
  183b60:	50                   	push   %eax
  183b61:	89 f2                	mov    %esi,%edx
  183b63:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  183b67:	89 f8                	mov    %edi,%eax
  183b69:	e8 91 fe ff ff       	call   1839ff <__ssputs_r>
  183b6e:	59                   	pop    %ecx
  183b6f:	40                   	inc    %eax
  183b70:	0f 84 c3 01 00 00    	je     183d39 <_svfiprintf_r+0x252>
  183b76:	8b 44 24 08          	mov    0x8(%esp),%eax
  183b7a:	01 44 24 20          	add    %eax,0x20(%esp)
  183b7e:	80 3b 00             	cmpb   $0x0,(%ebx)
  183b81:	0f 84 b2 01 00 00    	je     183d39 <_svfiprintf_r+0x252>
  183b87:	43                   	inc    %ebx
  183b88:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  183b8f:	00 
  183b90:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  183b97:	00 
  183b98:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
  183b9f:	ff 
  183ba0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  183ba7:	00 
  183ba8:	c6 44 24 4f 00       	movb   $0x0,0x4f(%esp)
  183bad:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
  183bb4:	00 
  183bb5:	0f be 13             	movsbl (%ebx),%edx
  183bb8:	b9 05 00 00 00       	mov    $0x5,%ecx
  183bbd:	b8 2a 6f 18 00       	mov    $0x186f2a,%eax
  183bc2:	e8 f4 04 00 00       	call   1840bb <memchr>
  183bc7:	85 c0                	test   %eax,%eax
  183bc9:	74 15                	je     183be0 <_svfiprintf_r+0xf9>
  183bcb:	2d 2a 6f 18 00       	sub    $0x186f2a,%eax
  183bd0:	ba 01 00 00 00       	mov    $0x1,%edx
  183bd5:	89 c1                	mov    %eax,%ecx
  183bd7:	43                   	inc    %ebx
  183bd8:	d3 e2                	shl    %cl,%edx
  183bda:	09 54 24 0c          	or     %edx,0xc(%esp)
  183bde:	eb d5                	jmp    183bb5 <_svfiprintf_r+0xce>
  183be0:	8b 44 24 0c          	mov    0xc(%esp),%eax
  183be4:	a8 10                	test   $0x10,%al
  183be6:	74 05                	je     183bed <_svfiprintf_r+0x106>
  183be8:	c6 44 24 4f 20       	movb   $0x20,0x4f(%esp)
  183bed:	a8 08                	test   $0x8,%al
  183bef:	74 05                	je     183bf6 <_svfiprintf_r+0x10f>
  183bf1:	c6 44 24 4f 2b       	movb   $0x2b,0x4f(%esp)
  183bf6:	80 3b 2a             	cmpb   $0x2a,(%ebx)
  183bf9:	74 08                	je     183c03 <_svfiprintf_r+0x11c>
  183bfb:	8b 44 24 18          	mov    0x18(%esp),%eax
  183bff:	31 c9                	xor    %ecx,%ecx
  183c01:	eb 27                	jmp    183c2a <_svfiprintf_r+0x143>
  183c03:	8b 54 24 7c          	mov    0x7c(%esp),%edx
  183c07:	8d 4a 04             	lea    0x4(%edx),%ecx
  183c0a:	8b 12                	mov    (%edx),%edx
  183c0c:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
  183c10:	85 d2                	test   %edx,%edx
  183c12:	78 06                	js     183c1a <_svfiprintf_r+0x133>
  183c14:	89 54 24 18          	mov    %edx,0x18(%esp)
  183c18:	eb 0d                	jmp    183c27 <_svfiprintf_r+0x140>
  183c1a:	f7 da                	neg    %edx
  183c1c:	83 c8 02             	or     $0x2,%eax
  183c1f:	89 54 24 18          	mov    %edx,0x18(%esp)
  183c23:	89 44 24 0c          	mov    %eax,0xc(%esp)
  183c27:	43                   	inc    %ebx
  183c28:	eb 1d                	jmp    183c47 <_svfiprintf_r+0x160>
  183c2a:	0f be 13             	movsbl (%ebx),%edx
  183c2d:	83 ea 30             	sub    $0x30,%edx
  183c30:	83 fa 09             	cmp    $0x9,%edx
  183c33:	77 0a                	ja     183c3f <_svfiprintf_r+0x158>
  183c35:	6b c0 0a             	imul   $0xa,%eax,%eax
  183c38:	43                   	inc    %ebx
  183c39:	01 d0                	add    %edx,%eax
  183c3b:	b1 01                	mov    $0x1,%cl
  183c3d:	eb eb                	jmp    183c2a <_svfiprintf_r+0x143>
  183c3f:	84 c9                	test   %cl,%cl
  183c41:	74 04                	je     183c47 <_svfiprintf_r+0x160>
  183c43:	89 44 24 18          	mov    %eax,0x18(%esp)
  183c47:	80 3b 2e             	cmpb   $0x2e,(%ebx)
  183c4a:	75 52                	jne    183c9e <_svfiprintf_r+0x1b7>
  183c4c:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
  183c50:	75 1e                	jne    183c70 <_svfiprintf_r+0x189>
  183c52:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  183c56:	83 c3 02             	add    $0x2,%ebx
  183c59:	8d 50 04             	lea    0x4(%eax),%edx
  183c5c:	8b 00                	mov    (%eax),%eax
  183c5e:	89 54 24 7c          	mov    %edx,0x7c(%esp)
  183c62:	85 c0                	test   %eax,%eax
  183c64:	79 34                	jns    183c9a <_svfiprintf_r+0x1b3>
  183c66:	c7 44 24 10 ff ff ff 	movl   $0xffffffff,0x10(%esp)
  183c6d:	ff 
  183c6e:	eb 2e                	jmp    183c9e <_svfiprintf_r+0x1b7>
  183c70:	43                   	inc    %ebx
  183c71:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  183c78:	00 
  183c79:	31 c0                	xor    %eax,%eax
  183c7b:	0f be 13             	movsbl (%ebx),%edx
  183c7e:	83 ea 30             	sub    $0x30,%edx
  183c81:	83 fa 09             	cmp    $0x9,%edx
  183c84:	77 0d                	ja     183c93 <_svfiprintf_r+0x1ac>
  183c86:	6b c0 0a             	imul   $0xa,%eax,%eax
  183c89:	43                   	inc    %ebx
  183c8a:	01 d0                	add    %edx,%eax
  183c8c:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
  183c91:	eb e8                	jmp    183c7b <_svfiprintf_r+0x194>
  183c93:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
  183c98:	74 04                	je     183c9e <_svfiprintf_r+0x1b7>
  183c9a:	89 44 24 10          	mov    %eax,0x10(%esp)
  183c9e:	0f be 13             	movsbl (%ebx),%edx
  183ca1:	b9 03 00 00 00       	mov    $0x3,%ecx
  183ca6:	b8 30 6f 18 00       	mov    $0x186f30,%eax
  183cab:	e8 0b 04 00 00       	call   1840bb <memchr>
  183cb0:	85 c0                	test   %eax,%eax
  183cb2:	74 13                	je     183cc7 <_svfiprintf_r+0x1e0>
  183cb4:	2d 30 6f 18 00       	sub    $0x186f30,%eax
  183cb9:	ba 40 00 00 00       	mov    $0x40,%edx
  183cbe:	89 c1                	mov    %eax,%ecx
  183cc0:	43                   	inc    %ebx
  183cc1:	d3 e2                	shl    %cl,%edx
  183cc3:	09 54 24 0c          	or     %edx,0xc(%esp)
  183cc7:	8d 43 01             	lea    0x1(%ebx),%eax
  183cca:	b9 06 00 00 00       	mov    $0x6,%ecx
  183ccf:	0f be 13             	movsbl (%ebx),%edx
  183cd2:	89 04 24             	mov    %eax,(%esp)
  183cd5:	b8 34 6f 18 00       	mov    $0x186f34,%eax
  183cda:	88 54 24 24          	mov    %dl,0x24(%esp)
  183cde:	e8 d8 03 00 00       	call   1840bb <memchr>
  183ce3:	85 c0                	test   %eax,%eax
  183ce5:	74 29                	je     183d10 <_svfiprintf_r+0x229>
  183ce7:	b8 00 00 00 00       	mov    $0x0,%eax
  183cec:	85 c0                	test   %eax,%eax
  183cee:	75 07                	jne    183cf7 <_svfiprintf_r+0x210>
  183cf0:	83 44 24 7c 08       	addl   $0x8,0x7c(%esp)
  183cf5:	eb 39                	jmp    183d30 <_svfiprintf_r+0x249>
  183cf7:	8d 44 24 7c          	lea    0x7c(%esp),%eax
  183cfb:	89 f1                	mov    %esi,%ecx
  183cfd:	50                   	push   %eax
  183cfe:	68 ff 39 18 00       	push   $0x1839ff
  183d03:	8d 54 24 14          	lea    0x14(%esp),%edx
  183d07:	89 f8                	mov    %edi,%eax
  183d09:	e8 f2 c2 e7 ff       	call   0 <CONFIG_CACHE_LINE_SIZE>
  183d0e:	eb 17                	jmp    183d27 <_svfiprintf_r+0x240>
  183d10:	8d 44 24 7c          	lea    0x7c(%esp),%eax
  183d14:	89 f1                	mov    %esi,%ecx
  183d16:	50                   	push   %eax
  183d17:	68 ff 39 18 00       	push   $0x1839ff
  183d1c:	8d 54 24 14          	lea    0x14(%esp),%edx
  183d20:	89 f8                	mov    %edi,%eax
  183d22:	e8 03 01 00 00       	call   183e2a <_printf_i>
  183d27:	89 c5                	mov    %eax,%ebp
  183d29:	58                   	pop    %eax
  183d2a:	83 fd ff             	cmp    $0xffffffff,%ebp
  183d2d:	5a                   	pop    %edx
  183d2e:	74 09                	je     183d39 <_svfiprintf_r+0x252>
  183d30:	01 6c 24 20          	add    %ebp,0x20(%esp)
  183d34:	e9 02 fe ff ff       	jmp    183b3b <_svfiprintf_r+0x54>
  183d39:	83 c8 ff             	or     $0xffffffff,%eax
  183d3c:	f6 46 0c 40          	testb  $0x40,0xc(%esi)
  183d40:	75 04                	jne    183d46 <_svfiprintf_r+0x25f>
  183d42:	8b 44 24 20          	mov    0x20(%esp),%eax
  183d46:	83 c4 68             	add    $0x68,%esp
  183d49:	5b                   	pop    %ebx
  183d4a:	5e                   	pop    %esi
  183d4b:	5f                   	pop    %edi
  183d4c:	5d                   	pop    %ebp
  183d4d:	c3                   	ret    

00183d4e <_printf_common>:
  183d4e:	55                   	push   %ebp
  183d4f:	57                   	push   %edi
  183d50:	56                   	push   %esi
  183d51:	53                   	push   %ebx
  183d52:	53                   	push   %ebx
  183d53:	89 d3                	mov    %edx,%ebx
  183d55:	89 c7                	mov    %eax,%edi
  183d57:	8b 52 08             	mov    0x8(%edx),%edx
  183d5a:	8b 43 10             	mov    0x10(%ebx),%eax
  183d5d:	89 ce                	mov    %ecx,%esi
  183d5f:	39 d0                	cmp    %edx,%eax
  183d61:	7d 02                	jge    183d65 <_printf_common+0x17>
  183d63:	89 d0                	mov    %edx,%eax
  183d65:	89 06                	mov    %eax,(%esi)
  183d67:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
  183d6b:	74 03                	je     183d70 <_printf_common+0x22>
  183d6d:	40                   	inc    %eax
  183d6e:	89 06                	mov    %eax,(%esi)
  183d70:	f6 03 20             	testb  $0x20,(%ebx)
  183d73:	74 03                	je     183d78 <_printf_common+0x2a>
  183d75:	83 06 02             	addl   $0x2,(%esi)
  183d78:	f6 03 06             	testb  $0x6,(%ebx)
  183d7b:	75 28                	jne    183da5 <_printf_common+0x57>
  183d7d:	8d 43 19             	lea    0x19(%ebx),%eax
  183d80:	31 ed                	xor    %ebp,%ebp
  183d82:	89 04 24             	mov    %eax,(%esp)
  183d85:	eb 15                	jmp    183d9c <_printf_common+0x4e>
  183d87:	6a 01                	push   $0x1
  183d89:	89 f8                	mov    %edi,%eax
  183d8b:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  183d8f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  183d93:	ff 54 24 20          	call   *0x20(%esp)
  183d97:	5a                   	pop    %edx
  183d98:	40                   	inc    %eax
  183d99:	74 3c                	je     183dd7 <_printf_common+0x89>
  183d9b:	45                   	inc    %ebp
  183d9c:	8b 43 0c             	mov    0xc(%ebx),%eax
  183d9f:	2b 06                	sub    (%esi),%eax
  183da1:	39 c5                	cmp    %eax,%ebp
  183da3:	7c e2                	jl     183d87 <_printf_common+0x39>
  183da5:	31 c0                	xor    %eax,%eax
  183da7:	80 7b 43 00          	cmpb   $0x0,0x43(%ebx)
  183dab:	0f 95 c0             	setne  %al
  183dae:	f6 03 20             	testb  $0x20,(%ebx)
  183db1:	74 12                	je     183dc5 <_printf_common+0x77>
  183db3:	c6 44 03 43 30       	movb   $0x30,0x43(%ebx,%eax,1)
  183db8:	8d 50 01             	lea    0x1(%eax),%edx
  183dbb:	8a 4b 45             	mov    0x45(%ebx),%cl
  183dbe:	83 c0 02             	add    $0x2,%eax
  183dc1:	88 4c 13 43          	mov    %cl,0x43(%ebx,%edx,1)
  183dc5:	50                   	push   %eax
  183dc6:	8d 4b 43             	lea    0x43(%ebx),%ecx
  183dc9:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  183dcd:	89 f8                	mov    %edi,%eax
  183dcf:	ff 54 24 20          	call   *0x20(%esp)
  183dd3:	5d                   	pop    %ebp
  183dd4:	40                   	inc    %eax
  183dd5:	75 05                	jne    183ddc <_printf_common+0x8e>
  183dd7:	83 c8 ff             	or     $0xffffffff,%eax
  183dda:	eb 48                	jmp    183e24 <_printf_common+0xd6>
  183ddc:	8b 43 0c             	mov    0xc(%ebx),%eax
  183ddf:	2b 06                	sub    (%esi),%eax
  183de1:	89 c6                	mov    %eax,%esi
  183de3:	8b 03                	mov    (%ebx),%eax
  183de5:	83 e0 06             	and    $0x6,%eax
  183de8:	83 f8 04             	cmp    $0x4,%eax
  183deb:	75 07                	jne    183df4 <_printf_common+0xa6>
  183ded:	89 f0                	mov    %esi,%eax
  183def:	c1 e8 1f             	shr    $0x1f,%eax
  183df2:	74 02                	je     183df6 <_printf_common+0xa8>
  183df4:	31 f6                	xor    %esi,%esi
  183df6:	8b 43 08             	mov    0x8(%ebx),%eax
  183df9:	8b 53 10             	mov    0x10(%ebx),%edx
  183dfc:	39 d0                	cmp    %edx,%eax
  183dfe:	7e 04                	jle    183e04 <_printf_common+0xb6>
  183e00:	29 d0                	sub    %edx,%eax
  183e02:	01 c6                	add    %eax,%esi
  183e04:	31 ed                	xor    %ebp,%ebp
  183e06:	83 c3 1a             	add    $0x1a,%ebx
  183e09:	39 ee                	cmp    %ebp,%esi
  183e0b:	74 15                	je     183e22 <_printf_common+0xd4>
  183e0d:	6a 01                	push   $0x1
  183e0f:	89 d9                	mov    %ebx,%ecx
  183e11:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  183e15:	89 f8                	mov    %edi,%eax
  183e17:	ff 54 24 20          	call   *0x20(%esp)
  183e1b:	59                   	pop    %ecx
  183e1c:	40                   	inc    %eax
  183e1d:	74 b8                	je     183dd7 <_printf_common+0x89>
  183e1f:	45                   	inc    %ebp
  183e20:	eb e7                	jmp    183e09 <_printf_common+0xbb>
  183e22:	31 c0                	xor    %eax,%eax
  183e24:	5a                   	pop    %edx
  183e25:	5b                   	pop    %ebx
  183e26:	5e                   	pop    %esi
  183e27:	5f                   	pop    %edi
  183e28:	5d                   	pop    %ebp
  183e29:	c3                   	ret    

00183e2a <_printf_i>:
  183e2a:	55                   	push   %ebp
  183e2b:	57                   	push   %edi
  183e2c:	56                   	push   %esi
  183e2d:	53                   	push   %ebx
  183e2e:	83 ec 0c             	sub    $0xc,%esp
  183e31:	89 d3                	mov    %edx,%ebx
  183e33:	8d 6a 43             	lea    0x43(%edx),%ebp
  183e36:	8a 52 18             	mov    0x18(%edx),%dl
  183e39:	89 04 24             	mov    %eax,(%esp)
  183e3c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  183e40:	8b 44 24 24          	mov    0x24(%esp),%eax
  183e44:	80 fa 6e             	cmp    $0x6e,%dl
  183e47:	0f 84 7b 01 00 00    	je     183fc8 <_printf_i+0x19e>
  183e4d:	7f 35                	jg     183e84 <_printf_i+0x5a>
  183e4f:	80 fa 63             	cmp    $0x63,%dl
  183e52:	74 60                	je     183eb4 <_printf_i+0x8a>
  183e54:	7f 1f                	jg     183e75 <_printf_i+0x4b>
  183e56:	84 d2                	test   %dl,%dl
  183e58:	0f 84 95 01 00 00    	je     183ff3 <_printf_i+0x1c9>
  183e5e:	80 fa 58             	cmp    $0x58,%dl
  183e61:	0f 85 bd 01 00 00    	jne    184024 <_printf_i+0x1fa>
  183e67:	c6 43 45 58          	movb   $0x58,0x45(%ebx)
  183e6b:	bf 3b 6f 18 00       	mov    $0x186f3b,%edi
  183e70:	e9 c1 00 00 00       	jmp    183f36 <_printf_i+0x10c>
  183e75:	80 fa 64             	cmp    $0x64,%dl
  183e78:	74 4e                	je     183ec8 <_printf_i+0x9e>
  183e7a:	80 fa 69             	cmp    $0x69,%dl
  183e7d:	74 49                	je     183ec8 <_printf_i+0x9e>
  183e7f:	e9 a0 01 00 00       	jmp    184024 <_printf_i+0x1fa>
  183e84:	80 fa 73             	cmp    $0x73,%dl
  183e87:	0f 84 71 01 00 00    	je     183ffe <_printf_i+0x1d4>
  183e8d:	7f 16                	jg     183ea5 <_printf_i+0x7b>
  183e8f:	80 fa 6f             	cmp    $0x6f,%dl
  183e92:	74 61                	je     183ef5 <_printf_i+0xcb>
  183e94:	80 fa 70             	cmp    $0x70,%dl
  183e97:	0f 85 87 01 00 00    	jne    184024 <_printf_i+0x1fa>
  183e9d:	83 0b 20             	orl    $0x20,(%ebx)
  183ea0:	e9 88 00 00 00       	jmp    183f2d <_printf_i+0x103>
  183ea5:	80 fa 75             	cmp    $0x75,%dl
  183ea8:	74 4b                	je     183ef5 <_printf_i+0xcb>
  183eaa:	80 fa 78             	cmp    $0x78,%dl
  183ead:	74 7e                	je     183f2d <_printf_i+0x103>
  183eaf:	e9 70 01 00 00       	jmp    184024 <_printf_i+0x1fa>
  183eb4:	8b 10                	mov    (%eax),%edx
  183eb6:	8d 73 42             	lea    0x42(%ebx),%esi
  183eb9:	8d 4a 04             	lea    0x4(%edx),%ecx
  183ebc:	89 08                	mov    %ecx,(%eax)
  183ebe:	8b 02                	mov    (%edx),%eax
  183ec0:	88 43 42             	mov    %al,0x42(%ebx)
  183ec3:	e9 62 01 00 00       	jmp    18402a <_printf_i+0x200>
  183ec8:	8b 0b                	mov    (%ebx),%ecx
  183eca:	8b 10                	mov    (%eax),%edx
  183ecc:	f6 c1 80             	test   $0x80,%cl
  183ecf:	74 07                	je     183ed8 <_printf_i+0xae>
  183ed1:	8d 4a 04             	lea    0x4(%edx),%ecx
  183ed4:	89 08                	mov    %ecx,(%eax)
  183ed6:	eb 0f                	jmp    183ee7 <_printf_i+0xbd>
  183ed8:	80 e1 40             	and    $0x40,%cl
  183edb:	8d 4a 04             	lea    0x4(%edx),%ecx
  183ede:	89 08                	mov    %ecx,(%eax)
  183ee0:	74 05                	je     183ee7 <_printf_i+0xbd>
  183ee2:	0f bf 02             	movswl (%edx),%eax
  183ee5:	eb 02                	jmp    183ee9 <_printf_i+0xbf>
  183ee7:	8b 02                	mov    (%edx),%eax
  183ee9:	85 c0                	test   %eax,%eax
  183eeb:	79 7f                	jns    183f6c <_printf_i+0x142>
  183eed:	f7 d8                	neg    %eax
  183eef:	c6 43 43 2d          	movb   $0x2d,0x43(%ebx)
  183ef3:	eb 77                	jmp    183f6c <_printf_i+0x142>
  183ef5:	8b 0b                	mov    (%ebx),%ecx
  183ef7:	8b 10                	mov    (%eax),%edx
  183ef9:	f6 c1 80             	test   $0x80,%cl
  183efc:	74 07                	je     183f05 <_printf_i+0xdb>
  183efe:	8d 4a 04             	lea    0x4(%edx),%ecx
  183f01:	89 08                	mov    %ecx,(%eax)
  183f03:	eb 0f                	jmp    183f14 <_printf_i+0xea>
  183f05:	80 e1 40             	and    $0x40,%cl
  183f08:	8d 4a 04             	lea    0x4(%edx),%ecx
  183f0b:	89 08                	mov    %ecx,(%eax)
  183f0d:	74 05                	je     183f14 <_printf_i+0xea>
  183f0f:	0f b7 02             	movzwl (%edx),%eax
  183f12:	eb 02                	jmp    183f16 <_printf_i+0xec>
  183f14:	8b 02                	mov    (%edx),%eax
  183f16:	bf 3b 6f 18 00       	mov    $0x186f3b,%edi
  183f1b:	b9 08 00 00 00       	mov    $0x8,%ecx
  183f20:	80 7b 18 6f          	cmpb   $0x6f,0x18(%ebx)
  183f24:	74 40                	je     183f66 <_printf_i+0x13c>
  183f26:	b9 0a 00 00 00       	mov    $0xa,%ecx
  183f2b:	eb 39                	jmp    183f66 <_printf_i+0x13c>
  183f2d:	c6 43 45 78          	movb   $0x78,0x45(%ebx)
  183f31:	bf 4c 6f 18 00       	mov    $0x186f4c,%edi
  183f36:	8b 10                	mov    (%eax),%edx
  183f38:	8b 0b                	mov    (%ebx),%ecx
  183f3a:	f6 c1 80             	test   $0x80,%cl
  183f3d:	8d 72 04             	lea    0x4(%edx),%esi
  183f40:	89 30                	mov    %esi,(%eax)
  183f42:	75 0a                	jne    183f4e <_printf_i+0x124>
  183f44:	f6 c1 40             	test   $0x40,%cl
  183f47:	74 05                	je     183f4e <_printf_i+0x124>
  183f49:	0f b7 02             	movzwl (%edx),%eax
  183f4c:	eb 02                	jmp    183f50 <_printf_i+0x126>
  183f4e:	8b 02                	mov    (%edx),%eax
  183f50:	f6 c1 01             	test   $0x1,%cl
  183f53:	74 05                	je     183f5a <_printf_i+0x130>
  183f55:	83 c9 20             	or     $0x20,%ecx
  183f58:	89 0b                	mov    %ecx,(%ebx)
  183f5a:	b9 10 00 00 00       	mov    $0x10,%ecx
  183f5f:	85 c0                	test   %eax,%eax
  183f61:	75 03                	jne    183f66 <_printf_i+0x13c>
  183f63:	83 23 df             	andl   $0xffffffdf,(%ebx)
  183f66:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
  183f6a:	eb 0a                	jmp    183f76 <_printf_i+0x14c>
  183f6c:	bf 3b 6f 18 00       	mov    $0x186f3b,%edi
  183f71:	b9 0a 00 00 00       	mov    $0xa,%ecx
  183f76:	8b 53 04             	mov    0x4(%ebx),%edx
  183f79:	89 53 08             	mov    %edx,0x8(%ebx)
  183f7c:	85 d2                	test   %edx,%edx
  183f7e:	78 12                	js     183f92 <_printf_i+0x168>
  183f80:	83 23 fb             	andl   $0xfffffffb,(%ebx)
  183f83:	85 c0                	test   %eax,%eax
  183f85:	75 13                	jne    183f9a <_printf_i+0x170>
  183f87:	89 ee                	mov    %ebp,%esi
  183f89:	85 d2                	test   %edx,%edx
  183f8b:	74 1d                	je     183faa <_printf_i+0x180>
  183f8d:	e9 14 01 00 00       	jmp    1840a6 <_printf_i+0x27c>
  183f92:	85 c0                	test   %eax,%eax
  183f94:	0f 84 0c 01 00 00    	je     1840a6 <_printf_i+0x27c>
  183f9a:	89 ee                	mov    %ebp,%esi
  183f9c:	31 d2                	xor    %edx,%edx
  183f9e:	4e                   	dec    %esi
  183f9f:	f7 f1                	div    %ecx
  183fa1:	85 c0                	test   %eax,%eax
  183fa3:	8a 14 17             	mov    (%edi,%edx,1),%dl
  183fa6:	88 16                	mov    %dl,(%esi)
  183fa8:	75 f2                	jne    183f9c <_printf_i+0x172>
  183faa:	83 f9 08             	cmp    $0x8,%ecx
  183fad:	75 12                	jne    183fc1 <_printf_i+0x197>
  183faf:	f6 03 01             	testb  $0x1,(%ebx)
  183fb2:	74 0d                	je     183fc1 <_printf_i+0x197>
  183fb4:	8b 43 10             	mov    0x10(%ebx),%eax
  183fb7:	39 43 04             	cmp    %eax,0x4(%ebx)
  183fba:	7f 05                	jg     183fc1 <_printf_i+0x197>
  183fbc:	c6 46 ff 30          	movb   $0x30,-0x1(%esi)
  183fc0:	4e                   	dec    %esi
  183fc1:	29 f5                	sub    %esi,%ebp
  183fc3:	89 6b 10             	mov    %ebp,0x10(%ebx)
  183fc6:	eb 6d                	jmp    184035 <_printf_i+0x20b>
  183fc8:	8b 33                	mov    (%ebx),%esi
  183fca:	8b 10                	mov    (%eax),%edx
  183fcc:	f7 c6 80 00 00 00    	test   $0x80,%esi
  183fd2:	8b 4b 14             	mov    0x14(%ebx),%ecx
  183fd5:	74 09                	je     183fe0 <_printf_i+0x1b6>
  183fd7:	8d 72 04             	lea    0x4(%edx),%esi
  183fda:	89 30                	mov    %esi,(%eax)
  183fdc:	8b 02                	mov    (%edx),%eax
  183fde:	eb 11                	jmp    183ff1 <_printf_i+0x1c7>
  183fe0:	83 e6 40             	and    $0x40,%esi
  183fe3:	8d 72 04             	lea    0x4(%edx),%esi
  183fe6:	89 30                	mov    %esi,(%eax)
  183fe8:	8b 02                	mov    (%edx),%eax
  183fea:	74 05                	je     183ff1 <_printf_i+0x1c7>
  183fec:	66 89 08             	mov    %cx,(%eax)
  183fef:	eb 02                	jmp    183ff3 <_printf_i+0x1c9>
  183ff1:	89 08                	mov    %ecx,(%eax)
  183ff3:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  183ffa:	89 ee                	mov    %ebp,%esi
  183ffc:	eb 37                	jmp    184035 <_printf_i+0x20b>
  183ffe:	8b 10                	mov    (%eax),%edx
  184000:	8d 4a 04             	lea    0x4(%edx),%ecx
  184003:	89 08                	mov    %ecx,(%eax)
  184005:	8b 4b 04             	mov    0x4(%ebx),%ecx
  184008:	8b 32                	mov    (%edx),%esi
  18400a:	31 d2                	xor    %edx,%edx
  18400c:	89 f0                	mov    %esi,%eax
  18400e:	e8 a8 00 00 00       	call   1840bb <memchr>
  184013:	85 c0                	test   %eax,%eax
  184015:	74 05                	je     18401c <_printf_i+0x1f2>
  184017:	29 f0                	sub    %esi,%eax
  184019:	89 43 04             	mov    %eax,0x4(%ebx)
  18401c:	8b 43 04             	mov    0x4(%ebx),%eax
  18401f:	89 43 10             	mov    %eax,0x10(%ebx)
  184022:	eb 0d                	jmp    184031 <_printf_i+0x207>
  184024:	8d 73 42             	lea    0x42(%ebx),%esi
  184027:	88 53 42             	mov    %dl,0x42(%ebx)
  18402a:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
  184031:	c6 43 43 00          	movb   $0x0,0x43(%ebx)
  184035:	ff 74 24 20          	pushl  0x20(%esp)
  184039:	ff 74 24 08          	pushl  0x8(%esp)
  18403d:	89 da                	mov    %ebx,%edx
  18403f:	8d 4c 24 10          	lea    0x10(%esp),%ecx
  184043:	8b 44 24 08          	mov    0x8(%esp),%eax
  184047:	e8 02 fd ff ff       	call   183d4e <_printf_common>
  18404c:	5f                   	pop    %edi
  18404d:	40                   	inc    %eax
  18404e:	5d                   	pop    %ebp
  18404f:	75 05                	jne    184056 <_printf_i+0x22c>
  184051:	83 c8 ff             	or     $0xffffffff,%eax
  184054:	eb 5d                	jmp    1840b3 <_printf_i+0x289>
  184056:	ff 73 10             	pushl  0x10(%ebx)
  184059:	89 f1                	mov    %esi,%ecx
  18405b:	8b 54 24 08          	mov    0x8(%esp),%edx
  18405f:	8b 44 24 04          	mov    0x4(%esp),%eax
  184063:	ff 54 24 24          	call   *0x24(%esp)
  184067:	59                   	pop    %ecx
  184068:	40                   	inc    %eax
  184069:	74 e6                	je     184051 <_printf_i+0x227>
  18406b:	f6 03 02             	testb  $0x2,(%ebx)
  18406e:	74 27                	je     184097 <_printf_i+0x26d>
  184070:	31 f6                	xor    %esi,%esi
  184072:	8d 7b 19             	lea    0x19(%ebx),%edi
  184075:	eb 15                	jmp    18408c <_printf_i+0x262>
  184077:	6a 01                	push   $0x1
  184079:	89 f9                	mov    %edi,%ecx
  18407b:	8b 54 24 08          	mov    0x8(%esp),%edx
  18407f:	8b 44 24 04          	mov    0x4(%esp),%eax
  184083:	ff 54 24 24          	call   *0x24(%esp)
  184087:	5a                   	pop    %edx
  184088:	40                   	inc    %eax
  184089:	74 c6                	je     184051 <_printf_i+0x227>
  18408b:	46                   	inc    %esi
  18408c:	8b 43 0c             	mov    0xc(%ebx),%eax
  18408f:	2b 44 24 08          	sub    0x8(%esp),%eax
  184093:	39 c6                	cmp    %eax,%esi
  184095:	7c e0                	jl     184077 <_printf_i+0x24d>
  184097:	8b 54 24 08          	mov    0x8(%esp),%edx
  18409b:	8b 43 0c             	mov    0xc(%ebx),%eax
  18409e:	39 d0                	cmp    %edx,%eax
  1840a0:	7d 11                	jge    1840b3 <_printf_i+0x289>
  1840a2:	89 d0                	mov    %edx,%eax
  1840a4:	eb 0d                	jmp    1840b3 <_printf_i+0x289>
  1840a6:	8a 07                	mov    (%edi),%al
  1840a8:	8d 73 42             	lea    0x42(%ebx),%esi
  1840ab:	88 43 42             	mov    %al,0x42(%ebx)
  1840ae:	e9 f7 fe ff ff       	jmp    183faa <_printf_i+0x180>
  1840b3:	83 c4 0c             	add    $0xc,%esp
  1840b6:	5b                   	pop    %ebx
  1840b7:	5e                   	pop    %esi
  1840b8:	5f                   	pop    %edi
  1840b9:	5d                   	pop    %ebp
  1840ba:	c3                   	ret    

001840bb <memchr>:
  1840bb:	57                   	push   %edi
  1840bc:	89 c7                	mov    %eax,%edi
  1840be:	89 d0                	mov    %edx,%eax
  1840c0:	31 d2                	xor    %edx,%edx
  1840c2:	85 c9                	test   %ecx,%ecx
  1840c4:	74 09                	je     1840cf <L20>
  1840c6:	f2 ae                	repnz scas %es:(%edi),%al
  1840c8:	0f 95 c2             	setne  %dl
  1840cb:	4f                   	dec    %edi
  1840cc:	4a                   	dec    %edx
  1840cd:	21 fa                	and    %edi,%edx

001840cf <L20>:
  1840cf:	89 d0                	mov    %edx,%eax
  1840d1:	5f                   	pop    %edi
  1840d2:	c3                   	ret    

001840d3 <memmove>:
  1840d3:	56                   	push   %esi
  1840d4:	57                   	push   %edi
  1840d5:	89 c7                	mov    %eax,%edi
  1840d7:	89 d6                	mov    %edx,%esi
  1840d9:	39 f7                	cmp    %esi,%edi
  1840db:	77 07                	ja     1840e4 <memmove+0x11>
  1840dd:	74 11                	je     1840f0 <memmove+0x1d>
  1840df:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  1840e1:	5f                   	pop    %edi
  1840e2:	5e                   	pop    %esi
  1840e3:	c3                   	ret    
  1840e4:	8d 7c 0f ff          	lea    -0x1(%edi,%ecx,1),%edi
  1840e8:	8d 74 0e ff          	lea    -0x1(%esi,%ecx,1),%esi
  1840ec:	fd                   	std    
  1840ed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
  1840ef:	fc                   	cld    
  1840f0:	5f                   	pop    %edi
  1840f1:	5e                   	pop    %esi
  1840f2:	c3                   	ret    

001840f3 <_free_r>:
  1840f3:	85 d2                	test   %edx,%edx
  1840f5:	0f 84 b0 00 00 00    	je     1841ab <_free_r+0xb8>
  1840fb:	8d 4a fc             	lea    -0x4(%edx),%ecx
  1840fe:	8b 52 fc             	mov    -0x4(%edx),%edx
  184101:	85 d2                	test   %edx,%edx
  184103:	79 02                	jns    184107 <_free_r+0x14>
  184105:	01 d1                	add    %edx,%ecx
  184107:	8b 15 64 03 28 00    	mov    0x280364,%edx
  18410d:	85 d2                	test   %edx,%edx
  18410f:	75 0e                	jne    18411f <_free_r+0x2c>
  184111:	c7 41 04 00 00 00 00 	movl   $0x0,0x4(%ecx)
  184118:	89 0d 64 03 28 00    	mov    %ecx,0x280364
  18411e:	c3                   	ret    
  18411f:	57                   	push   %edi
  184120:	39 ca                	cmp    %ecx,%edx
  184122:	56                   	push   %esi
  184123:	53                   	push   %ebx
  184124:	53                   	push   %ebx
  184125:	76 20                	jbe    184147 <_free_r+0x54>
  184127:	8b 01                	mov    (%ecx),%eax
  184129:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  18412c:	39 da                	cmp    %ebx,%edx
  18412e:	75 0c                	jne    18413c <_free_r+0x49>
  184130:	03 02                	add    (%edx),%eax
  184132:	89 01                	mov    %eax,(%ecx)
  184134:	8b 42 04             	mov    0x4(%edx),%eax
  184137:	89 41 04             	mov    %eax,0x4(%ecx)
  18413a:	eb 03                	jmp    18413f <_free_r+0x4c>
  18413c:	89 51 04             	mov    %edx,0x4(%ecx)
  18413f:	89 0d 64 03 28 00    	mov    %ecx,0x280364
  184145:	eb 60                	jmp    1841a7 <_free_r+0xb4>
  184147:	8b 72 04             	mov    0x4(%edx),%esi
  18414a:	85 f6                	test   %esi,%esi
  18414c:	0f 95 44 24 03       	setne  0x3(%esp)
  184151:	39 ce                	cmp    %ecx,%esi
  184153:	0f 96 c3             	setbe  %bl
  184156:	84 5c 24 03          	test   %bl,0x3(%esp)
  18415a:	74 04                	je     184160 <_free_r+0x6d>
  18415c:	89 f2                	mov    %esi,%edx
  18415e:	eb e7                	jmp    184147 <_free_r+0x54>
  184160:	8b 1a                	mov    (%edx),%ebx
  184162:	8d 3c 1a             	lea    (%edx,%ebx,1),%edi
  184165:	39 cf                	cmp    %ecx,%edi
  184167:	75 19                	jne    184182 <_free_r+0x8f>
  184169:	8b 01                	mov    (%ecx),%eax
  18416b:	01 d8                	add    %ebx,%eax
  18416d:	89 02                	mov    %eax,(%edx)
  18416f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  184172:	39 ce                	cmp    %ecx,%esi
  184174:	75 31                	jne    1841a7 <_free_r+0xb4>
  184176:	03 06                	add    (%esi),%eax
  184178:	89 02                	mov    %eax,(%edx)
  18417a:	8b 46 04             	mov    0x4(%esi),%eax
  18417d:	89 42 04             	mov    %eax,0x4(%edx)
  184180:	eb 25                	jmp    1841a7 <_free_r+0xb4>
  184182:	76 08                	jbe    18418c <_free_r+0x99>
  184184:	c7 00 0c 00 00 00    	movl   $0xc,(%eax)
  18418a:	eb 1b                	jmp    1841a7 <_free_r+0xb4>
  18418c:	8b 01                	mov    (%ecx),%eax
  18418e:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  184191:	39 de                	cmp    %ebx,%esi
  184193:	75 0c                	jne    1841a1 <_free_r+0xae>
  184195:	03 06                	add    (%esi),%eax
  184197:	89 01                	mov    %eax,(%ecx)
  184199:	8b 46 04             	mov    0x4(%esi),%eax
  18419c:	89 41 04             	mov    %eax,0x4(%ecx)
  18419f:	eb 03                	jmp    1841a4 <_free_r+0xb1>
  1841a1:	89 71 04             	mov    %esi,0x4(%ecx)
  1841a4:	89 4a 04             	mov    %ecx,0x4(%edx)
  1841a7:	58                   	pop    %eax
  1841a8:	5b                   	pop    %ebx
  1841a9:	5e                   	pop    %esi
  1841aa:	5f                   	pop    %edi
  1841ab:	c3                   	ret    

001841ac <_malloc_r>:
  1841ac:	55                   	push   %ebp
  1841ad:	57                   	push   %edi
  1841ae:	56                   	push   %esi
  1841af:	53                   	push   %ebx
  1841b0:	8d 5a 03             	lea    0x3(%edx),%ebx
  1841b3:	89 c7                	mov    %eax,%edi
  1841b5:	83 e3 fc             	and    $0xfffffffc,%ebx
  1841b8:	83 c3 08             	add    $0x8,%ebx
  1841bb:	83 fb 0c             	cmp    $0xc,%ebx
  1841be:	73 05                	jae    1841c5 <_malloc_r+0x19>
  1841c0:	bb 0c 00 00 00       	mov    $0xc,%ebx
  1841c5:	89 d8                	mov    %ebx,%eax
  1841c7:	c1 e8 1f             	shr    $0x1f,%eax
  1841ca:	75 0c                	jne    1841d8 <_malloc_r+0x2c>
  1841cc:	8b 35 64 03 28 00    	mov    0x280364,%esi
  1841d2:	39 da                	cmp    %ebx,%edx
  1841d4:	89 f0                	mov    %esi,%eax
  1841d6:	76 18                	jbe    1841f0 <_malloc_r+0x44>
  1841d8:	c7 07 0c 00 00 00    	movl   $0xc,(%edi)
  1841de:	31 c0                	xor    %eax,%eax
  1841e0:	e9 92 00 00 00       	jmp    184277 <_malloc_r+0xcb>
  1841e5:	8b 10                	mov    (%eax),%edx
  1841e7:	29 da                	sub    %ebx,%edx
  1841e9:	79 0b                	jns    1841f6 <_malloc_r+0x4a>
  1841eb:	89 c6                	mov    %eax,%esi
  1841ed:	8b 40 04             	mov    0x4(%eax),%eax
  1841f0:	85 c0                	test   %eax,%eax
  1841f2:	75 f1                	jne    1841e5 <_malloc_r+0x39>
  1841f4:	eb 26                	jmp    18421c <_malloc_r+0x70>
  1841f6:	83 fa 0b             	cmp    $0xb,%edx
  1841f9:	76 09                	jbe    184204 <_malloc_r+0x58>
  1841fb:	8d 34 10             	lea    (%eax,%edx,1),%esi
  1841fe:	89 10                	mov    %edx,(%eax)
  184200:	89 1e                	mov    %ebx,(%esi)
  184202:	eb 48                	jmp    18424c <_malloc_r+0xa0>
  184204:	39 c6                	cmp    %eax,%esi
  184206:	75 0a                	jne    184212 <_malloc_r+0x66>
  184208:	8b 46 04             	mov    0x4(%esi),%eax
  18420b:	a3 64 03 28 00       	mov    %eax,0x280364
  184210:	eb 3a                	jmp    18424c <_malloc_r+0xa0>
  184212:	8b 50 04             	mov    0x4(%eax),%edx
  184215:	89 56 04             	mov    %edx,0x4(%esi)
  184218:	89 c6                	mov    %eax,%esi
  18421a:	eb 30                	jmp    18424c <_malloc_r+0xa0>
  18421c:	83 3d 60 03 28 00 00 	cmpl   $0x0,0x280360
  184223:	75 0c                	jne    184231 <_malloc_r+0x85>
  184225:	31 c0                	xor    %eax,%eax
  184227:	e8 08 cc ff ff       	call   180e34 <_sbrk>
  18422c:	a3 60 03 28 00       	mov    %eax,0x280360
  184231:	89 d8                	mov    %ebx,%eax
  184233:	e8 fc cb ff ff       	call   180e34 <_sbrk>
  184238:	83 f8 ff             	cmp    $0xffffffff,%eax
  18423b:	74 9b                	je     1841d8 <_malloc_r+0x2c>
  18423d:	8d 68 03             	lea    0x3(%eax),%ebp
  184240:	83 e5 fc             	and    $0xfffffffc,%ebp
  184243:	89 ee                	mov    %ebp,%esi
  184245:	39 e8                	cmp    %ebp,%eax
  184247:	75 1b                	jne    184264 <_malloc_r+0xb8>
  184249:	89 5d 00             	mov    %ebx,0x0(%ebp)
  18424c:	8d 46 0b             	lea    0xb(%esi),%eax
  18424f:	8d 56 04             	lea    0x4(%esi),%edx
  184252:	83 e0 f8             	and    $0xfffffff8,%eax
  184255:	89 c7                	mov    %eax,%edi
  184257:	29 d7                	sub    %edx,%edi
  184259:	74 1c                	je     184277 <_malloc_r+0xcb>
  18425b:	89 f9                	mov    %edi,%ecx
  18425d:	f7 d9                	neg    %ecx
  18425f:	89 0c 3e             	mov    %ecx,(%esi,%edi,1)
  184262:	eb 13                	jmp    184277 <_malloc_r+0xcb>
  184264:	89 e9                	mov    %ebp,%ecx
  184266:	29 c1                	sub    %eax,%ecx
  184268:	89 c8                	mov    %ecx,%eax
  18426a:	e8 c5 cb ff ff       	call   180e34 <_sbrk>
  18426f:	40                   	inc    %eax
  184270:	75 d7                	jne    184249 <_malloc_r+0x9d>
  184272:	e9 61 ff ff ff       	jmp    1841d8 <_malloc_r+0x2c>
  184277:	5b                   	pop    %ebx
  184278:	5e                   	pop    %esi
  184279:	5f                   	pop    %edi
  18427a:	5d                   	pop    %ebp
  18427b:	c3                   	ret    

0018427c <_realloc_r>:
  18427c:	85 d2                	test   %edx,%edx
  18427e:	75 07                	jne    184287 <_realloc_r+0xb>
  184280:	89 ca                	mov    %ecx,%edx
  184282:	e9 25 ff ff ff       	jmp    1841ac <_malloc_r>
  184287:	55                   	push   %ebp
  184288:	85 c9                	test   %ecx,%ecx
  18428a:	57                   	push   %edi
  18428b:	89 cf                	mov    %ecx,%edi
  18428d:	56                   	push   %esi
  18428e:	89 c6                	mov    %eax,%esi
  184290:	53                   	push   %ebx
  184291:	89 d3                	mov    %edx,%ebx
  184293:	75 07                	jne    18429c <_realloc_r+0x20>
  184295:	e8 59 fe ff ff       	call   1840f3 <_free_r>
  18429a:	eb 2e                	jmp    1842ca <_realloc_r+0x4e>
  18429c:	e8 32 00 00 00       	call   1842d3 <_malloc_usable_size_r>
  1842a1:	39 c7                	cmp    %eax,%edi
  1842a3:	76 27                	jbe    1842cc <_realloc_r+0x50>
  1842a5:	89 fa                	mov    %edi,%edx
  1842a7:	89 f0                	mov    %esi,%eax
  1842a9:	e8 fe fe ff ff       	call   1841ac <_malloc_r>
  1842ae:	89 c5                	mov    %eax,%ebp
  1842b0:	85 c0                	test   %eax,%eax
  1842b2:	74 16                	je     1842ca <_realloc_r+0x4e>
  1842b4:	89 da                	mov    %ebx,%edx
  1842b6:	89 f9                	mov    %edi,%ecx
  1842b8:	e8 d2 f6 ff ff       	call   18398f <memcpy>
  1842bd:	89 da                	mov    %ebx,%edx
  1842bf:	89 f0                	mov    %esi,%eax
  1842c1:	89 eb                	mov    %ebp,%ebx
  1842c3:	e8 2b fe ff ff       	call   1840f3 <_free_r>
  1842c8:	eb 02                	jmp    1842cc <_realloc_r+0x50>
  1842ca:	31 db                	xor    %ebx,%ebx
  1842cc:	89 d8                	mov    %ebx,%eax
  1842ce:	5b                   	pop    %ebx
  1842cf:	5e                   	pop    %esi
  1842d0:	5f                   	pop    %edi
  1842d1:	5d                   	pop    %ebp
  1842d2:	c3                   	ret    

001842d3 <_malloc_usable_size_r>:
  1842d3:	8b 4a fc             	mov    -0x4(%edx),%ecx
  1842d6:	85 c9                	test   %ecx,%ecx
  1842d8:	8d 41 fc             	lea    -0x4(%ecx),%eax
  1842db:	79 07                	jns    1842e4 <_malloc_usable_size_r+0x11>
  1842dd:	03 4c 0a fc          	add    -0x4(%edx,%ecx,1),%ecx
  1842e1:	8d 41 fc             	lea    -0x4(%ecx),%eax
  1842e4:	c3                   	ret    

001842e5 <__addsf3>:
  1842e5:	55                   	push   %ebp
  1842e6:	89 d1                	mov    %edx,%ecx
  1842e8:	c1 e9 17             	shr    $0x17,%ecx
  1842eb:	57                   	push   %edi
  1842ec:	89 c7                	mov    %eax,%edi
  1842ee:	56                   	push   %esi
  1842ef:	53                   	push   %ebx
  1842f0:	89 c3                	mov    %eax,%ebx
  1842f2:	c1 e8 17             	shr    $0x17,%eax
  1842f5:	89 d6                	mov    %edx,%esi
  1842f7:	0f b6 c0             	movzbl %al,%eax
  1842fa:	81 e3 ff ff 7f 00    	and    $0x7fffff,%ebx
  184300:	81 e6 ff ff 7f 00    	and    $0x7fffff,%esi
  184306:	0f b6 e9             	movzbl %cl,%ebp
  184309:	c1 ef 1f             	shr    $0x1f,%edi
  18430c:	89 c1                	mov    %eax,%ecx
  18430e:	c1 ea 1f             	shr    $0x1f,%edx
  184311:	29 e9                	sub    %ebp,%ecx
  184313:	c1 e3 03             	shl    $0x3,%ebx
  184316:	c1 e6 03             	shl    $0x3,%esi
  184319:	39 d7                	cmp    %edx,%edi
  18431b:	0f 85 6c 01 00 00    	jne    18448d <__addsf3+0x1a8>
  184321:	83 f9 00             	cmp    $0x0,%ecx
  184324:	7e 3c                	jle    184362 <__addsf3+0x7d>
  184326:	85 ed                	test   %ebp,%ebp
  184328:	75 22                	jne    18434c <__addsf3+0x67>
  18432a:	85 f6                	test   %esi,%esi
  18432c:	0f 84 60 03 00 00    	je     184692 <__addsf3+0x3ad>
  184332:	49                   	dec    %ecx
  184333:	75 07                	jne    18433c <__addsf3+0x57>
  184335:	01 f3                	add    %esi,%ebx
  184337:	e9 25 01 00 00       	jmp    184461 <__addsf3+0x17c>
  18433c:	3d ff 00 00 00       	cmp    $0xff,%eax
  184341:	0f 85 f6 00 00 00    	jne    18443d <__addsf3+0x158>
  184347:	e9 46 03 00 00       	jmp    184692 <__addsf3+0x3ad>
  18434c:	81 ce 00 00 00 04    	or     $0x4000000,%esi
  184352:	3d ff 00 00 00       	cmp    $0xff,%eax
  184357:	0f 85 e0 00 00 00    	jne    18443d <__addsf3+0x158>
  18435d:	e9 30 03 00 00       	jmp    184692 <__addsf3+0x3ad>
  184362:	74 5d                	je     1843c1 <__addsf3+0xdc>
  184364:	85 c0                	test   %eax,%eax
  184366:	75 1a                	jne    184382 <__addsf3+0x9d>
  184368:	85 db                	test   %ebx,%ebx
  18436a:	0f 84 d8 02 00 00    	je     184648 <__addsf3+0x363>
  184370:	83 f1 ff             	xor    $0xffffffff,%ecx
  184373:	74 43                	je     1843b8 <__addsf3+0xd3>
  184375:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  18437b:	75 19                	jne    184396 <__addsf3+0xb1>
  18437d:	e9 d0 02 00 00       	jmp    184652 <__addsf3+0x36d>
  184382:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  184388:	0f 84 c4 02 00 00    	je     184652 <__addsf3+0x36d>
  18438e:	f7 d9                	neg    %ecx
  184390:	81 cb 00 00 00 04    	or     $0x4000000,%ebx
  184396:	83 f9 1b             	cmp    $0x1b,%ecx
  184399:	0f 8f 33 03 00 00    	jg     1846d2 <__addsf3+0x3ed>
  18439f:	b8 20 00 00 00       	mov    $0x20,%eax
  1843a4:	89 da                	mov    %ebx,%edx
  1843a6:	29 c8                	sub    %ecx,%eax
  1843a8:	d3 ea                	shr    %cl,%edx
  1843aa:	89 c1                	mov    %eax,%ecx
  1843ac:	d3 e3                	shl    %cl,%ebx
  1843ae:	85 db                	test   %ebx,%ebx
  1843b0:	0f 95 c3             	setne  %bl
  1843b3:	0f b6 db             	movzbl %bl,%ebx
  1843b6:	09 d3                	or     %edx,%ebx
  1843b8:	01 f3                	add    %esi,%ebx
  1843ba:	89 e8                	mov    %ebp,%eax
  1843bc:	e9 a0 00 00 00       	jmp    184461 <__addsf3+0x17c>
  1843c1:	8d 50 01             	lea    0x1(%eax),%edx
  1843c4:	0f b6 ca             	movzbl %dl,%ecx
  1843c7:	49                   	dec    %ecx
  1843c8:	7f 5c                	jg     184426 <__addsf3+0x141>
  1843ca:	85 c0                	test   %eax,%eax
  1843cc:	75 2e                	jne    1843fc <__addsf3+0x117>
  1843ce:	85 db                	test   %ebx,%ebx
  1843d0:	0f 84 78 02 00 00    	je     18464e <__addsf3+0x369>
  1843d6:	85 f6                	test   %esi,%esi
  1843d8:	0f 84 b4 02 00 00    	je     184692 <__addsf3+0x3ad>
  1843de:	01 f3                	add    %esi,%ebx
  1843e0:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  1843e6:	0f 84 a6 02 00 00    	je     184692 <__addsf3+0x3ad>
  1843ec:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  1843f2:	b8 01 00 00 00       	mov    $0x1,%eax
  1843f7:	e9 96 02 00 00       	jmp    184692 <__addsf3+0x3ad>
  1843fc:	85 db                	test   %ebx,%ebx
  1843fe:	0f 84 4e 02 00 00    	je     184652 <__addsf3+0x36d>
  184404:	b8 ff 00 00 00       	mov    $0xff,%eax
  184409:	85 f6                	test   %esi,%esi
  18440b:	0f 84 81 02 00 00    	je     184692 <__addsf3+0x3ad>
  184411:	c1 ee 03             	shr    $0x3,%esi
  184414:	c1 eb 03             	shr    $0x3,%ebx
  184417:	39 f3                	cmp    %esi,%ebx
  184419:	0f 83 94 01 00 00    	jae    1845b3 <__addsf3+0x2ce>
  18441f:	89 f3                	mov    %esi,%ebx
  184421:	e9 8d 01 00 00       	jmp    1845b3 <__addsf3+0x2ce>
  184426:	81 fa ff 00 00 00    	cmp    $0xff,%edx
  18442c:	0f 84 27 02 00 00    	je     184659 <__addsf3+0x374>
  184432:	01 f3                	add    %esi,%ebx
  184434:	89 d0                	mov    %edx,%eax
  184436:	d1 eb                	shr    %ebx
  184438:	e9 55 02 00 00       	jmp    184692 <__addsf3+0x3ad>
  18443d:	ba 01 00 00 00       	mov    $0x1,%edx
  184442:	83 f9 1b             	cmp    $0x1b,%ecx
  184445:	7f 18                	jg     18445f <__addsf3+0x17a>
  184447:	bd 20 00 00 00       	mov    $0x20,%ebp
  18444c:	89 f2                	mov    %esi,%edx
  18444e:	29 cd                	sub    %ecx,%ebp
  184450:	d3 ea                	shr    %cl,%edx
  184452:	89 e9                	mov    %ebp,%ecx
  184454:	d3 e6                	shl    %cl,%esi
  184456:	31 c9                	xor    %ecx,%ecx
  184458:	85 f6                	test   %esi,%esi
  18445a:	0f 95 c1             	setne  %cl
  18445d:	09 ca                	or     %ecx,%edx
  18445f:	01 d3                	add    %edx,%ebx
  184461:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  184467:	0f 84 25 02 00 00    	je     184692 <__addsf3+0x3ad>
  18446d:	40                   	inc    %eax
  18446e:	3d ff 00 00 00       	cmp    $0xff,%eax
  184473:	0f 84 e5 01 00 00    	je     18465e <__addsf3+0x379>
  184479:	89 da                	mov    %ebx,%edx
  18447b:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  184481:	d1 eb                	shr    %ebx
  184483:	83 e2 01             	and    $0x1,%edx
  184486:	09 d3                	or     %edx,%ebx
  184488:	e9 05 02 00 00       	jmp    184692 <__addsf3+0x3ad>
  18448d:	83 f9 00             	cmp    $0x0,%ecx
  184490:	7e 3c                	jle    1844ce <__addsf3+0x1e9>
  184492:	85 ed                	test   %ebp,%ebp
  184494:	75 22                	jne    1844b8 <__addsf3+0x1d3>
  184496:	85 f6                	test   %esi,%esi
  184498:	0f 84 f4 01 00 00    	je     184692 <__addsf3+0x3ad>
  18449e:	49                   	dec    %ecx
  18449f:	75 07                	jne    1844a8 <__addsf3+0x1c3>
  1844a1:	29 f3                	sub    %esi,%ebx
  1844a3:	e9 52 01 00 00       	jmp    1845fa <__addsf3+0x315>
  1844a8:	3d ff 00 00 00       	cmp    $0xff,%eax
  1844ad:	0f 85 23 01 00 00    	jne    1845d6 <__addsf3+0x2f1>
  1844b3:	e9 da 01 00 00       	jmp    184692 <__addsf3+0x3ad>
  1844b8:	81 ce 00 00 00 04    	or     $0x4000000,%esi
  1844be:	3d ff 00 00 00       	cmp    $0xff,%eax
  1844c3:	0f 85 0d 01 00 00    	jne    1845d6 <__addsf3+0x2f1>
  1844c9:	e9 c4 01 00 00       	jmp    184692 <__addsf3+0x3ad>
  1844ce:	74 65                	je     184535 <__addsf3+0x250>
  1844d0:	85 c0                	test   %eax,%eax
  1844d2:	75 1e                	jne    1844f2 <__addsf3+0x20d>
  1844d4:	85 db                	test   %ebx,%ebx
  1844d6:	0f 84 86 01 00 00    	je     184662 <__addsf3+0x37d>
  1844dc:	83 f1 ff             	xor    $0xffffffff,%ecx
  1844df:	75 04                	jne    1844e5 <__addsf3+0x200>
  1844e1:	29 de                	sub    %ebx,%esi
  1844e3:	eb 45                	jmp    18452a <__addsf3+0x245>
  1844e5:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  1844eb:	75 19                	jne    184506 <__addsf3+0x221>
  1844ed:	e9 79 01 00 00       	jmp    18466b <__addsf3+0x386>
  1844f2:	81 fd ff 00 00 00    	cmp    $0xff,%ebp
  1844f8:	0f 84 6d 01 00 00    	je     18466b <__addsf3+0x386>
  1844fe:	f7 d9                	neg    %ecx
  184500:	81 cb 00 00 00 04    	or     $0x4000000,%ebx
  184506:	b8 01 00 00 00       	mov    $0x1,%eax
  18450b:	83 f9 1b             	cmp    $0x1b,%ecx
  18450e:	7f 18                	jg     184528 <__addsf3+0x243>
  184510:	b8 20 00 00 00       	mov    $0x20,%eax
  184515:	89 df                	mov    %ebx,%edi
  184517:	29 c8                	sub    %ecx,%eax
  184519:	d3 ef                	shr    %cl,%edi
  18451b:	89 c1                	mov    %eax,%ecx
  18451d:	31 c0                	xor    %eax,%eax
  18451f:	d3 e3                	shl    %cl,%ebx
  184521:	85 db                	test   %ebx,%ebx
  184523:	0f 95 c0             	setne  %al
  184526:	09 f8                	or     %edi,%eax
  184528:	29 c6                	sub    %eax,%esi
  18452a:	89 f3                	mov    %esi,%ebx
  18452c:	89 e8                	mov    %ebp,%eax
  18452e:	89 d7                	mov    %edx,%edi
  184530:	e9 c5 00 00 00       	jmp    1845fa <__addsf3+0x315>
  184535:	8d 48 01             	lea    0x1(%eax),%ecx
  184538:	0f b6 c9             	movzbl %cl,%ecx
  18453b:	49                   	dec    %ecx
  18453c:	7f 7a                	jg     1845b8 <__addsf3+0x2d3>
  18453e:	85 c0                	test   %eax,%eax
  184540:	75 3c                	jne    18457e <__addsf3+0x299>
  184542:	85 db                	test   %ebx,%ebx
  184544:	75 0a                	jne    184550 <__addsf3+0x26b>
  184546:	85 f6                	test   %esi,%esi
  184548:	0f 84 29 01 00 00    	je     184677 <__addsf3+0x392>
  18454e:	eb 16                	jmp    184566 <__addsf3+0x281>
  184550:	85 f6                	test   %esi,%esi
  184552:	0f 84 3a 01 00 00    	je     184692 <__addsf3+0x3ad>
  184558:	89 d9                	mov    %ebx,%ecx
  18455a:	29 f1                	sub    %esi,%ecx
  18455c:	f7 c1 00 00 00 04    	test   $0x4000000,%ecx
  184562:	74 0b                	je     18456f <__addsf3+0x28a>
  184564:	29 de                	sub    %ebx,%esi
  184566:	89 f3                	mov    %esi,%ebx
  184568:	89 d7                	mov    %edx,%edi
  18456a:	e9 23 01 00 00       	jmp    184692 <__addsf3+0x3ad>
  18456f:	89 cb                	mov    %ecx,%ebx
  184571:	85 c9                	test   %ecx,%ecx
  184573:	0f 85 19 01 00 00    	jne    184692 <__addsf3+0x3ad>
  184579:	e9 12 01 00 00       	jmp    184690 <__addsf3+0x3ab>
  18457e:	85 db                	test   %ebx,%ebx
  184580:	75 16                	jne    184598 <__addsf3+0x2b3>
  184582:	85 f6                	test   %esi,%esi
  184584:	0f 84 f1 00 00 00    	je     18467b <__addsf3+0x396>
  18458a:	89 f3                	mov    %esi,%ebx
  18458c:	89 d7                	mov    %edx,%edi
  18458e:	b8 ff 00 00 00       	mov    $0xff,%eax
  184593:	e9 fa 00 00 00       	jmp    184692 <__addsf3+0x3ad>
  184598:	b8 ff 00 00 00       	mov    $0xff,%eax
  18459d:	85 f6                	test   %esi,%esi
  18459f:	0f 84 ed 00 00 00    	je     184692 <__addsf3+0x3ad>
  1845a5:	c1 eb 03             	shr    $0x3,%ebx
  1845a8:	c1 ee 03             	shr    $0x3,%esi
  1845ab:	39 f3                	cmp    %esi,%ebx
  1845ad:	73 04                	jae    1845b3 <__addsf3+0x2ce>
  1845af:	89 f3                	mov    %esi,%ebx
  1845b1:	89 d7                	mov    %edx,%edi
  1845b3:	c1 e3 03             	shl    $0x3,%ebx
  1845b6:	eb d6                	jmp    18458e <__addsf3+0x2a9>
  1845b8:	89 dd                	mov    %ebx,%ebp
  1845ba:	29 f5                	sub    %esi,%ebp
  1845bc:	f7 c5 00 00 00 04    	test   $0x4000000,%ebp
  1845c2:	74 08                	je     1845cc <__addsf3+0x2e7>
  1845c4:	29 de                	sub    %ebx,%esi
  1845c6:	89 d7                	mov    %edx,%edi
  1845c8:	89 f5                	mov    %esi,%ebp
  1845ca:	eb 42                	jmp    18460e <__addsf3+0x329>
  1845cc:	85 ed                	test   %ebp,%ebp
  1845ce:	0f 84 b8 00 00 00    	je     18468c <__addsf3+0x3a7>
  1845d4:	eb 38                	jmp    18460e <__addsf3+0x329>
  1845d6:	ba 01 00 00 00       	mov    $0x1,%edx
  1845db:	83 f9 1b             	cmp    $0x1b,%ecx
  1845de:	7f 18                	jg     1845f8 <__addsf3+0x313>
  1845e0:	bd 20 00 00 00       	mov    $0x20,%ebp
  1845e5:	89 f2                	mov    %esi,%edx
  1845e7:	29 cd                	sub    %ecx,%ebp
  1845e9:	d3 ea                	shr    %cl,%edx
  1845eb:	89 e9                	mov    %ebp,%ecx
  1845ed:	d3 e6                	shl    %cl,%esi
  1845ef:	31 c9                	xor    %ecx,%ecx
  1845f1:	85 f6                	test   %esi,%esi
  1845f3:	0f 95 c1             	setne  %cl
  1845f6:	09 ca                	or     %ecx,%edx
  1845f8:	29 d3                	sub    %edx,%ebx
  1845fa:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  184600:	0f 84 8c 00 00 00    	je     184692 <__addsf3+0x3ad>
  184606:	81 e3 ff ff ff 03    	and    $0x3ffffff,%ebx
  18460c:	89 dd                	mov    %ebx,%ebp
  18460e:	0f bd cd             	bsr    %ebp,%ecx
  184611:	83 f1 1f             	xor    $0x1f,%ecx
  184614:	83 e9 05             	sub    $0x5,%ecx
  184617:	d3 e5                	shl    %cl,%ebp
  184619:	39 c8                	cmp    %ecx,%eax
  18461b:	7f 1f                	jg     18463c <__addsf3+0x357>
  18461d:	29 c1                	sub    %eax,%ecx
  18461f:	ba 20 00 00 00       	mov    $0x20,%edx
  184624:	41                   	inc    %ecx
  184625:	89 e8                	mov    %ebp,%eax
  184627:	29 ca                	sub    %ecx,%edx
  184629:	31 db                	xor    %ebx,%ebx
  18462b:	d3 e8                	shr    %cl,%eax
  18462d:	89 d1                	mov    %edx,%ecx
  18462f:	d3 e5                	shl    %cl,%ebp
  184631:	85 ed                	test   %ebp,%ebp
  184633:	0f 95 c3             	setne  %bl
  184636:	09 c3                	or     %eax,%ebx
  184638:	31 c0                	xor    %eax,%eax
  18463a:	eb 56                	jmp    184692 <__addsf3+0x3ad>
  18463c:	89 eb                	mov    %ebp,%ebx
  18463e:	29 c8                	sub    %ecx,%eax
  184640:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  184646:	eb 4a                	jmp    184692 <__addsf3+0x3ad>
  184648:	89 f3                	mov    %esi,%ebx
  18464a:	89 e8                	mov    %ebp,%eax
  18464c:	eb 44                	jmp    184692 <__addsf3+0x3ad>
  18464e:	89 f3                	mov    %esi,%ebx
  184650:	eb 40                	jmp    184692 <__addsf3+0x3ad>
  184652:	89 f3                	mov    %esi,%ebx
  184654:	e9 35 ff ff ff       	jmp    18458e <__addsf3+0x2a9>
  184659:	b8 ff 00 00 00       	mov    $0xff,%eax
  18465e:	31 db                	xor    %ebx,%ebx
  184660:	eb 30                	jmp    184692 <__addsf3+0x3ad>
  184662:	89 f3                	mov    %esi,%ebx
  184664:	89 e8                	mov    %ebp,%eax
  184666:	e9 fd fe ff ff       	jmp    184568 <__addsf3+0x283>
  18466b:	89 f3                	mov    %esi,%ebx
  18466d:	b8 ff 00 00 00       	mov    $0xff,%eax
  184672:	e9 f1 fe ff ff       	jmp    184568 <__addsf3+0x283>
  184677:	89 c3                	mov    %eax,%ebx
  184679:	eb 15                	jmp    184690 <__addsf3+0x3ab>
  18467b:	bb 00 00 00 02       	mov    $0x2000000,%ebx
  184680:	b8 ff 00 00 00       	mov    $0xff,%eax
  184685:	bf 01 00 00 00       	mov    $0x1,%edi
  18468a:	eb 06                	jmp    184692 <__addsf3+0x3ad>
  18468c:	31 db                	xor    %ebx,%ebx
  18468e:	31 c0                	xor    %eax,%eax
  184690:	31 ff                	xor    %edi,%edi
  184692:	f6 c3 07             	test   $0x7,%bl
  184695:	74 0d                	je     1846a4 <__addsf3+0x3bf>
  184697:	89 da                	mov    %ebx,%edx
  184699:	83 e2 0f             	and    $0xf,%edx
  18469c:	83 fa 04             	cmp    $0x4,%edx
  18469f:	74 03                	je     1846a4 <__addsf3+0x3bf>
  1846a1:	83 c3 04             	add    $0x4,%ebx
  1846a4:	f7 c3 00 00 00 04    	test   $0x4000000,%ebx
  1846aa:	74 10                	je     1846bc <__addsf3+0x3d7>
  1846ac:	40                   	inc    %eax
  1846ad:	81 e3 ff ff ff fb    	and    $0xfbffffff,%ebx
  1846b3:	3d ff 00 00 00       	cmp    $0xff,%eax
  1846b8:	75 02                	jne    1846bc <__addsf3+0x3d7>
  1846ba:	31 db                	xor    %ebx,%ebx
  1846bc:	c1 eb 03             	shr    $0x3,%ebx
  1846bf:	3d ff 00 00 00       	cmp    $0xff,%eax
  1846c4:	75 16                	jne    1846dc <__addsf3+0x3f7>
  1846c6:	85 db                	test   %ebx,%ebx
  1846c8:	74 12                	je     1846dc <__addsf3+0x3f7>
  1846ca:	81 cb 00 00 40 00    	or     $0x400000,%ebx
  1846d0:	eb 0a                	jmp    1846dc <__addsf3+0x3f7>
  1846d2:	bb 01 00 00 00       	mov    $0x1,%ebx
  1846d7:	e9 dc fc ff ff       	jmp    1843b8 <__addsf3+0xd3>
  1846dc:	0f b6 c0             	movzbl %al,%eax
  1846df:	c1 e0 17             	shl    $0x17,%eax
  1846e2:	81 e3 ff ff 7f 00    	and    $0x7fffff,%ebx
  1846e8:	c1 e7 1f             	shl    $0x1f,%edi
  1846eb:	09 c3                	or     %eax,%ebx
  1846ed:	89 d8                	mov    %ebx,%eax
  1846ef:	5b                   	pop    %ebx
  1846f0:	09 f8                	or     %edi,%eax
  1846f2:	5e                   	pop    %esi
  1846f3:	5f                   	pop    %edi
  1846f4:	5d                   	pop    %ebp
  1846f5:	c3                   	ret    

001846f6 <__mulsf3>:
  1846f6:	55                   	push   %ebp
  1846f7:	57                   	push   %edi
  1846f8:	56                   	push   %esi
  1846f9:	53                   	push   %ebx
  1846fa:	83 ec 10             	sub    $0x10,%esp
  1846fd:	89 c1                	mov    %eax,%ecx
  1846ff:	c1 e9 1f             	shr    $0x1f,%ecx
  184702:	89 c3                	mov    %eax,%ebx
  184704:	89 0c 24             	mov    %ecx,(%esp)
  184707:	81 e3 ff ff 7f 00    	and    $0x7fffff,%ebx
  18470d:	0f b6 3c 24          	movzbl (%esp),%edi
  184711:	c1 e8 17             	shr    $0x17,%eax
  184714:	89 7c 24 04          	mov    %edi,0x4(%esp)
  184718:	0f b6 e8             	movzbl %al,%ebp
  18471b:	84 c0                	test   %al,%al
  18471d:	74 12                	je     184731 <__mulsf3+0x3b>
  18471f:	fe c0                	inc    %al
  184721:	74 2d                	je     184750 <__mulsf3+0x5a>
  184723:	81 cb 00 00 80 00    	or     $0x800000,%ebx
  184729:	83 ed 7f             	sub    $0x7f,%ebp
  18472c:	c1 e3 03             	shl    $0x3,%ebx
  18472f:	eb 1b                	jmp    18474c <__mulsf3+0x56>
  184731:	bf 01 00 00 00       	mov    $0x1,%edi
  184736:	85 db                	test   %ebx,%ebx
  184738:	74 1e                	je     184758 <__mulsf3+0x62>
  18473a:	0f bd c3             	bsr    %ebx,%eax
  18473d:	83 f0 1f             	xor    $0x1f,%eax
  184740:	8d 48 fb             	lea    -0x5(%eax),%ecx
  184743:	d3 e3                	shl    %cl,%ebx
  184745:	89 e9                	mov    %ebp,%ecx
  184747:	29 c1                	sub    %eax,%ecx
  184749:	8d 69 8a             	lea    -0x76(%ecx),%ebp
  18474c:	31 ff                	xor    %edi,%edi
  18474e:	eb 08                	jmp    184758 <__mulsf3+0x62>
  184750:	83 fb 01             	cmp    $0x1,%ebx
  184753:	19 ff                	sbb    %edi,%edi
  184755:	83 c7 03             	add    $0x3,%edi
  184758:	89 d6                	mov    %edx,%esi
  18475a:	89 d1                	mov    %edx,%ecx
  18475c:	c1 ea 1f             	shr    $0x1f,%edx
  18475f:	81 e6 ff ff 7f 00    	and    $0x7fffff,%esi
  184765:	c1 e9 17             	shr    $0x17,%ecx
  184768:	89 54 24 0c          	mov    %edx,0xc(%esp)
  18476c:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
  184771:	0f b6 c1             	movzbl %cl,%eax
  184774:	89 54 24 08          	mov    %edx,0x8(%esp)
  184778:	84 c9                	test   %cl,%cl
  18477a:	74 16                	je     184792 <__mulsf3+0x9c>
  18477c:	fe c1                	inc    %cl
  18477e:	74 2f                	je     1847af <__mulsf3+0xb9>
  184780:	81 ce 00 00 80 00    	or     $0x800000,%esi
  184786:	83 e8 7f             	sub    $0x7f,%eax
  184789:	8d 34 f5 00 00 00 00 	lea    0x0(,%esi,8),%esi
  184790:	eb 19                	jmp    1847ab <__mulsf3+0xb5>
  184792:	ba 01 00 00 00       	mov    $0x1,%edx
  184797:	85 f6                	test   %esi,%esi
  184799:	74 1c                	je     1847b7 <__mulsf3+0xc1>
  18479b:	0f bd d6             	bsr    %esi,%edx
  18479e:	83 f2 1f             	xor    $0x1f,%edx
  1847a1:	29 d0                	sub    %edx,%eax
  1847a3:	8d 4a fb             	lea    -0x5(%edx),%ecx
  1847a6:	d3 e6                	shl    %cl,%esi
  1847a8:	8d 40 8a             	lea    -0x76(%eax),%eax
  1847ab:	31 d2                	xor    %edx,%edx
  1847ad:	eb 08                	jmp    1847b7 <__mulsf3+0xc1>
  1847af:	83 fe 01             	cmp    $0x1,%esi
  1847b2:	19 d2                	sbb    %edx,%edx
  1847b4:	83 c2 03             	add    $0x3,%edx
  1847b7:	8a 4c 24 0c          	mov    0xc(%esp),%cl
  1847bb:	33 0c 24             	xor    (%esp),%ecx
  1847be:	0f b6 c9             	movzbl %cl,%ecx
  1847c1:	89 0c 24             	mov    %ecx,(%esp)
  1847c4:	8d 4c 05 00          	lea    0x0(%ebp,%eax,1),%ecx
  1847c8:	8d 04 bd 00 00 00 00 	lea    0x0(,%edi,4),%eax
  1847cf:	09 d0                	or     %edx,%eax
  1847d1:	8d 69 01             	lea    0x1(%ecx),%ebp
  1847d4:	48                   	dec    %eax
  1847d5:	83 f8 0e             	cmp    $0xe,%eax
  1847d8:	77 0b                	ja     1847e5 <__mulsf3+0xef>
  1847da:	ff 24 85 60 6f 18 00 	jmp    *0x186f60(,%eax,4)
  1847e1:	89 f3                	mov    %esi,%ebx
  1847e3:	eb 5d                	jmp    184842 <__mulsf3+0x14c>
  1847e5:	89 d8                	mov    %ebx,%eax
  1847e7:	31 db                	xor    %ebx,%ebx
  1847e9:	f7 e6                	mul    %esi
  1847eb:	c1 e2 06             	shl    $0x6,%edx
  1847ee:	89 c7                	mov    %eax,%edi
  1847f0:	c1 ef 1a             	shr    $0x1a,%edi
  1847f3:	09 fa                	or     %edi,%edx
  1847f5:	c1 e0 06             	shl    $0x6,%eax
  1847f8:	0f 95 c3             	setne  %bl
  1847fb:	09 d3                	or     %edx,%ebx
  1847fd:	f7 c3 00 00 00 08    	test   $0x8000000,%ebx
  184803:	0f 84 0f 01 00 00    	je     184918 <__mulsf3+0x222>
  184809:	89 d8                	mov    %ebx,%eax
  18480b:	83 e3 01             	and    $0x1,%ebx
  18480e:	d1 e8                	shr    %eax
  184810:	89 e9                	mov    %ebp,%ecx
  184812:	09 c3                	or     %eax,%ebx
  184814:	e9 ff 00 00 00       	jmp    184918 <__mulsf3+0x222>
  184819:	39 f3                	cmp    %esi,%ebx
  18481b:	0f 83 ce 00 00 00    	jae    1848ef <__mulsf3+0x1f9>
  184821:	8b 44 24 08          	mov    0x8(%esp),%eax
  184825:	89 f3                	mov    %esi,%ebx
  184827:	89 44 24 04          	mov    %eax,0x4(%esp)
  18482b:	e9 bf 00 00 00       	jmp    1848ef <__mulsf3+0x1f9>
  184830:	8b 44 24 04          	mov    0x4(%esp),%eax
  184834:	89 04 24             	mov    %eax,(%esp)
  184837:	eb 0b                	jmp    184844 <__mulsf3+0x14e>
  184839:	8b 44 24 08          	mov    0x8(%esp),%eax
  18483d:	89 f3                	mov    %esi,%ebx
  18483f:	89 04 24             	mov    %eax,(%esp)
  184842:	89 d7                	mov    %edx,%edi
  184844:	83 ff 02             	cmp    $0x2,%edi
  184847:	0f 84 b3 00 00 00    	je     184900 <__mulsf3+0x20a>
  18484d:	83 ff 03             	cmp    $0x3,%edi
  184850:	0f 84 a0 00 00 00    	je     1848f6 <__mulsf3+0x200>
  184856:	31 d2                	xor    %edx,%edx
  184858:	31 c0                	xor    %eax,%eax
  18485a:	4f                   	dec    %edi
  18485b:	0f 84 be 00 00 00    	je     18491f <__mulsf3+0x229>
  184861:	8d 45 7f             	lea    0x7f(%ebp),%eax
  184864:	85 c0                	test   %eax,%eax
  184866:	7e 37                	jle    18489f <__mulsf3+0x1a9>
  184868:	f6 c3 07             	test   $0x7,%bl
  18486b:	74 0d                	je     18487a <__mulsf3+0x184>
  18486d:	89 da                	mov    %ebx,%edx
  18486f:	83 e2 0f             	and    $0xf,%edx
  184872:	83 fa 04             	cmp    $0x4,%edx
  184875:	74 03                	je     18487a <__mulsf3+0x184>
  184877:	83 c3 04             	add    $0x4,%ebx
  18487a:	f7 c3 00 00 00 08    	test   $0x8000000,%ebx
  184880:	74 0c                	je     18488e <__mulsf3+0x198>
  184882:	81 e3 ff ff ff f7    	and    $0xf7ffffff,%ebx
  184888:	8d 85 80 00 00 00    	lea    0x80(%ebp),%eax
  18488e:	3d fe 00 00 00       	cmp    $0xfe,%eax
  184893:	7f 6b                	jg     184900 <__mulsf3+0x20a>
  184895:	c1 eb 03             	shr    $0x3,%ebx
  184898:	89 da                	mov    %ebx,%edx
  18489a:	e9 80 00 00 00       	jmp    18491f <__mulsf3+0x229>
  18489f:	b9 01 00 00 00       	mov    $0x1,%ecx
  1848a4:	29 c1                	sub    %eax,%ecx
  1848a6:	83 f9 1b             	cmp    $0x1b,%ecx
  1848a9:	7f 5e                	jg     184909 <__mulsf3+0x213>
  1848ab:	b8 20 00 00 00       	mov    $0x20,%eax
  1848b0:	89 da                	mov    %ebx,%edx
  1848b2:	29 c8                	sub    %ecx,%eax
  1848b4:	d3 ea                	shr    %cl,%edx
  1848b6:	89 c1                	mov    %eax,%ecx
  1848b8:	31 c0                	xor    %eax,%eax
  1848ba:	d3 e3                	shl    %cl,%ebx
  1848bc:	85 db                	test   %ebx,%ebx
  1848be:	0f 95 c0             	setne  %al
  1848c1:	09 c2                	or     %eax,%edx
  1848c3:	f6 c2 07             	test   $0x7,%dl
  1848c6:	74 0d                	je     1848d5 <__mulsf3+0x1df>
  1848c8:	89 d0                	mov    %edx,%eax
  1848ca:	83 e0 0f             	and    $0xf,%eax
  1848cd:	83 f8 04             	cmp    $0x4,%eax
  1848d0:	74 03                	je     1848d5 <__mulsf3+0x1df>
  1848d2:	83 c2 04             	add    $0x4,%edx
  1848d5:	f7 c2 00 00 00 04    	test   $0x4000000,%edx
  1848db:	75 32                	jne    18490f <__mulsf3+0x219>
  1848dd:	c1 ea 03             	shr    $0x3,%edx
  1848e0:	eb 29                	jmp    18490b <__mulsf3+0x215>
  1848e2:	bb 00 00 40 00       	mov    $0x400000,%ebx
  1848e7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1848ee:	00 
  1848ef:	8b 44 24 04          	mov    0x4(%esp),%eax
  1848f3:	89 04 24             	mov    %eax,(%esp)
  1848f6:	81 cb 00 00 40 00    	or     $0x400000,%ebx
  1848fc:	89 da                	mov    %ebx,%edx
  1848fe:	eb 02                	jmp    184902 <__mulsf3+0x20c>
  184900:	31 d2                	xor    %edx,%edx
  184902:	b8 ff 00 00 00       	mov    $0xff,%eax
  184907:	eb 16                	jmp    18491f <__mulsf3+0x229>
  184909:	31 d2                	xor    %edx,%edx
  18490b:	31 c0                	xor    %eax,%eax
  18490d:	eb 10                	jmp    18491f <__mulsf3+0x229>
  18490f:	31 d2                	xor    %edx,%edx
  184911:	b8 01 00 00 00       	mov    $0x1,%eax
  184916:	eb 07                	jmp    18491f <__mulsf3+0x229>
  184918:	89 cd                	mov    %ecx,%ebp
  18491a:	e9 42 ff ff ff       	jmp    184861 <__mulsf3+0x16b>
  18491f:	0f b6 c0             	movzbl %al,%eax
  184922:	c1 e0 17             	shl    $0x17,%eax
  184925:	8b 34 24             	mov    (%esp),%esi
  184928:	81 e2 ff ff 7f 00    	and    $0x7fffff,%edx
  18492e:	83 c4 10             	add    $0x10,%esp
  184931:	c1 e6 1f             	shl    $0x1f,%esi
  184934:	09 c2                	or     %eax,%edx
  184936:	09 f2                	or     %esi,%edx
  184938:	5b                   	pop    %ebx
  184939:	89 d0                	mov    %edx,%eax
  18493b:	5e                   	pop    %esi
  18493c:	5f                   	pop    %edi
  18493d:	5d                   	pop    %ebp
  18493e:	c3                   	ret    

0018493f <__fixsfsi>:
  18493f:	89 c1                	mov    %eax,%ecx
  184941:	53                   	push   %ebx
  184942:	89 ca                	mov    %ecx,%edx
  184944:	89 cb                	mov    %ecx,%ebx
  184946:	c1 ea 17             	shr    $0x17,%edx
  184949:	25 ff ff 7f 00       	and    $0x7fffff,%eax
  18494e:	0f b6 d2             	movzbl %dl,%edx
  184951:	c1 eb 1f             	shr    $0x1f,%ebx
  184954:	83 fa 7e             	cmp    $0x7e,%edx
  184957:	7e 38                	jle    184991 <__fixsfsi+0x52>
  184959:	81 fa 9d 00 00 00    	cmp    $0x9d,%edx
  18495f:	7e 08                	jle    184969 <__fixsfsi+0x2a>
  184961:	8d 83 ff ff ff 7f    	lea    0x7fffffff(%ebx),%eax
  184967:	eb 2a                	jmp    184993 <__fixsfsi+0x54>
  184969:	0d 00 00 80 00       	or     $0x800000,%eax
  18496e:	81 fa 95 00 00 00    	cmp    $0x95,%edx
  184974:	7e 0a                	jle    184980 <__fixsfsi+0x41>
  184976:	8d 8a 6a ff ff ff    	lea    -0x96(%edx),%ecx
  18497c:	d3 e0                	shl    %cl,%eax
  18497e:	eb 09                	jmp    184989 <__fixsfsi+0x4a>
  184980:	b9 96 00 00 00       	mov    $0x96,%ecx
  184985:	29 d1                	sub    %edx,%ecx
  184987:	d3 e8                	shr    %cl,%eax
  184989:	84 db                	test   %bl,%bl
  18498b:	74 06                	je     184993 <__fixsfsi+0x54>
  18498d:	f7 d8                	neg    %eax
  18498f:	eb 02                	jmp    184993 <__fixsfsi+0x54>
  184991:	31 c0                	xor    %eax,%eax
  184993:	5b                   	pop    %ebx
  184994:	c3                   	ret    

00184995 <__floatsisf>:
  184995:	57                   	push   %edi
  184996:	85 c0                	test   %eax,%eax
  184998:	56                   	push   %esi
  184999:	53                   	push   %ebx
  18499a:	0f 84 90 00 00 00    	je     184a30 <__floatsisf+0x9b>
  1849a0:	99                   	cltd   
  1849a1:	89 c3                	mov    %eax,%ebx
  1849a3:	31 d0                	xor    %edx,%eax
  1849a5:	c1 eb 1f             	shr    $0x1f,%ebx
  1849a8:	29 d0                	sub    %edx,%eax
  1849aa:	0f bd f8             	bsr    %eax,%edi
  1849ad:	ba 9e 00 00 00       	mov    $0x9e,%edx
  1849b2:	83 f7 1f             	xor    $0x1f,%edi
  1849b5:	89 c6                	mov    %eax,%esi
  1849b7:	29 fa                	sub    %edi,%edx
  1849b9:	81 fa 96 00 00 00    	cmp    $0x96,%edx
  1849bf:	7f 0b                	jg     1849cc <__floatsisf+0x37>
  1849c1:	b9 96 00 00 00       	mov    $0x96,%ecx
  1849c6:	29 d1                	sub    %edx,%ecx
  1849c8:	d3 e0                	shl    %cl,%eax
  1849ca:	eb 6a                	jmp    184a36 <__floatsisf+0xa1>
  1849cc:	81 fa 99 00 00 00    	cmp    $0x99,%edx
  1849d2:	7e 1d                	jle    1849f1 <__floatsisf+0x5c>
  1849d4:	b9 05 00 00 00       	mov    $0x5,%ecx
  1849d9:	29 f9                	sub    %edi,%ecx
  1849db:	d3 e8                	shr    %cl,%eax
  1849dd:	b9 b9 00 00 00       	mov    $0xb9,%ecx
  1849e2:	29 d1                	sub    %edx,%ecx
  1849e4:	d3 e6                	shl    %cl,%esi
  1849e6:	31 c9                	xor    %ecx,%ecx
  1849e8:	85 f6                	test   %esi,%esi
  1849ea:	0f 95 c1             	setne  %cl
  1849ed:	09 c8                	or     %ecx,%eax
  1849ef:	89 c6                	mov    %eax,%esi
  1849f1:	b9 99 00 00 00       	mov    $0x99,%ecx
  1849f6:	29 d1                	sub    %edx,%ecx
  1849f8:	85 c9                	test   %ecx,%ecx
  1849fa:	7e 02                	jle    1849fe <__floatsisf+0x69>
  1849fc:	d3 e6                	shl    %cl,%esi
  1849fe:	89 f0                	mov    %esi,%eax
  184a00:	25 ff ff ff fb       	and    $0xfbffffff,%eax
  184a05:	f7 c6 07 00 00 00    	test   $0x7,%esi
  184a0b:	74 0b                	je     184a18 <__floatsisf+0x83>
  184a0d:	83 e6 0f             	and    $0xf,%esi
  184a10:	83 fe 04             	cmp    $0x4,%esi
  184a13:	74 03                	je     184a18 <__floatsisf+0x83>
  184a15:	83 c0 04             	add    $0x4,%eax
  184a18:	a9 00 00 00 04       	test   $0x4000000,%eax
  184a1d:	74 0c                	je     184a2b <__floatsisf+0x96>
  184a1f:	ba 9f 00 00 00       	mov    $0x9f,%edx
  184a24:	25 ff ff ff fb       	and    $0xfbffffff,%eax
  184a29:	29 fa                	sub    %edi,%edx
  184a2b:	c1 e8 03             	shr    $0x3,%eax
  184a2e:	eb 06                	jmp    184a36 <__floatsisf+0xa1>
  184a30:	31 c0                	xor    %eax,%eax
  184a32:	31 d2                	xor    %edx,%edx
  184a34:	31 db                	xor    %ebx,%ebx
  184a36:	0f b6 d2             	movzbl %dl,%edx
  184a39:	c1 e2 17             	shl    $0x17,%edx
  184a3c:	25 ff ff 7f 00       	and    $0x7fffff,%eax
  184a41:	c1 e3 1f             	shl    $0x1f,%ebx
  184a44:	09 d0                	or     %edx,%eax
  184a46:	09 d8                	or     %ebx,%eax
  184a48:	5b                   	pop    %ebx
  184a49:	5e                   	pop    %esi
  184a4a:	5f                   	pop    %edi
  184a4b:	c3                   	ret    

00184a4c <__adddf3>:
  184a4c:	55                   	push   %ebp
  184a4d:	89 d1                	mov    %edx,%ecx
  184a4f:	57                   	push   %edi
  184a50:	56                   	push   %esi
  184a51:	53                   	push   %ebx
  184a52:	81 e1 ff ff 0f 00    	and    $0xfffff,%ecx
  184a58:	83 ec 10             	sub    $0x10,%esp
  184a5b:	89 d3                	mov    %edx,%ebx
  184a5d:	c1 ea 1f             	shr    $0x1f,%edx
  184a60:	89 14 24             	mov    %edx,(%esp)
  184a63:	8d 14 cd 00 00 00 00 	lea    0x0(,%ecx,8),%edx
  184a6a:	89 c1                	mov    %eax,%ecx
  184a6c:	8b 7c 24 24          	mov    0x24(%esp),%edi
  184a70:	c1 e9 1d             	shr    $0x1d,%ecx
  184a73:	c1 eb 14             	shr    $0x14,%ebx
  184a76:	09 ca                	or     %ecx,%edx
  184a78:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  184a7c:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
  184a82:	89 ce                	mov    %ecx,%esi
  184a84:	89 cd                	mov    %ecx,%ebp
  184a86:	c1 e9 1f             	shr    $0x1f,%ecx
  184a89:	81 e6 ff ff 0f 00    	and    $0xfffff,%esi
  184a8f:	c1 ed 14             	shr    $0x14,%ebp
  184a92:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  184a96:	89 f9                	mov    %edi,%ecx
  184a98:	81 e5 ff 07 00 00    	and    $0x7ff,%ebp
  184a9e:	c1 e9 1d             	shr    $0x1d,%ecx
  184aa1:	89 6c 24 04          	mov    %ebp,0x4(%esp)
  184aa5:	c1 e6 03             	shl    $0x3,%esi
  184aa8:	c1 e0 03             	shl    $0x3,%eax
  184aab:	09 ce                	or     %ecx,%esi
  184aad:	89 f5                	mov    %esi,%ebp
  184aaf:	89 de                	mov    %ebx,%esi
  184ab1:	2b 74 24 04          	sub    0x4(%esp),%esi
  184ab5:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  184ab9:	c1 e7 03             	shl    $0x3,%edi
  184abc:	89 74 24 08          	mov    %esi,0x8(%esp)
  184ac0:	39 0c 24             	cmp    %ecx,(%esp)
  184ac3:	0f 85 db 02 00 00    	jne    184da4 <__adddf3+0x358>
  184ac9:	83 fe 00             	cmp    $0x0,%esi
  184acc:	0f 8e d8 00 00 00    	jle    184baa <__adddf3+0x15e>
  184ad2:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  184ad7:	75 26                	jne    184aff <__adddf3+0xb3>
  184ad9:	89 ee                	mov    %ebp,%esi
  184adb:	09 fe                	or     %edi,%esi
  184add:	0f 84 d7 02 00 00    	je     184dba <__adddf3+0x36e>
  184ae3:	ff 4c 24 08          	decl   0x8(%esp)
  184ae7:	75 09                	jne    184af2 <__adddf3+0xa6>
  184ae9:	01 f8                	add    %edi,%eax
  184aeb:	11 ea                	adc    %ebp,%edx
  184aed:	e9 7c 02 00 00       	jmp    184d6e <__adddf3+0x322>
  184af2:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  184af8:	75 17                	jne    184b11 <__adddf3+0xc5>
  184afa:	e9 b5 06 00 00       	jmp    1851b4 <__adddf3+0x768>
  184aff:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  184b05:	0f 84 a9 06 00 00    	je     1851b4 <__adddf3+0x768>
  184b0b:	81 cd 00 00 80 00    	or     $0x800000,%ebp
  184b11:	83 7c 24 08 38       	cmpl   $0x38,0x8(%esp)
  184b16:	7f 7e                	jg     184b96 <__adddf3+0x14a>
  184b18:	83 7c 24 08 1f       	cmpl   $0x1f,0x8(%esp)
  184b1d:	7f 48                	jg     184b67 <__adddf3+0x11b>
  184b1f:	b9 20 00 00 00       	mov    $0x20,%ecx
  184b24:	89 44 24 0c          	mov    %eax,0xc(%esp)
  184b28:	2b 4c 24 08          	sub    0x8(%esp),%ecx
  184b2c:	89 e8                	mov    %ebp,%eax
  184b2e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  184b32:	8a 4c 24 04          	mov    0x4(%esp),%cl
  184b36:	d3 e0                	shl    %cl,%eax
  184b38:	89 c6                	mov    %eax,%esi
  184b3a:	8a 4c 24 08          	mov    0x8(%esp),%cl
  184b3e:	89 f8                	mov    %edi,%eax
  184b40:	d3 e8                	shr    %cl,%eax
  184b42:	89 c1                	mov    %eax,%ecx
  184b44:	8b 44 24 0c          	mov    0xc(%esp),%eax
  184b48:	09 f1                	or     %esi,%ecx
  184b4a:	89 ce                	mov    %ecx,%esi
  184b4c:	8a 4c 24 04          	mov    0x4(%esp),%cl
  184b50:	d3 e7                	shl    %cl,%edi
  184b52:	31 c9                	xor    %ecx,%ecx
  184b54:	85 ff                	test   %edi,%edi
  184b56:	89 f7                	mov    %esi,%edi
  184b58:	0f 95 c1             	setne  %cl
  184b5b:	09 cf                	or     %ecx,%edi
  184b5d:	8a 4c 24 08          	mov    0x8(%esp),%cl
  184b61:	d3 ed                	shr    %cl,%ebp
  184b63:	89 ee                	mov    %ebp,%esi
  184b65:	eb 3a                	jmp    184ba1 <__adddf3+0x155>
  184b67:	8b 74 24 08          	mov    0x8(%esp),%esi
  184b6b:	8d 4e e0             	lea    -0x20(%esi),%ecx
  184b6e:	89 ee                	mov    %ebp,%esi
  184b70:	d3 ee                	shr    %cl,%esi
  184b72:	31 c9                	xor    %ecx,%ecx
  184b74:	83 7c 24 08 20       	cmpl   $0x20,0x8(%esp)
  184b79:	74 0d                	je     184b88 <__adddf3+0x13c>
  184b7b:	b9 40 00 00 00       	mov    $0x40,%ecx
  184b80:	2b 4c 24 08          	sub    0x8(%esp),%ecx
  184b84:	d3 e5                	shl    %cl,%ebp
  184b86:	89 e9                	mov    %ebp,%ecx
  184b88:	09 f9                	or     %edi,%ecx
  184b8a:	89 f7                	mov    %esi,%edi
  184b8c:	0f 95 c1             	setne  %cl
  184b8f:	0f b6 c9             	movzbl %cl,%ecx
  184b92:	09 cf                	or     %ecx,%edi
  184b94:	eb 09                	jmp    184b9f <__adddf3+0x153>
  184b96:	31 c9                	xor    %ecx,%ecx
  184b98:	09 fd                	or     %edi,%ebp
  184b9a:	0f 95 c1             	setne  %cl
  184b9d:	89 cf                	mov    %ecx,%edi
  184b9f:	31 f6                	xor    %esi,%esi
  184ba1:	01 f8                	add    %edi,%eax
  184ba3:	11 f2                	adc    %esi,%edx
  184ba5:	e9 c4 01 00 00       	jmp    184d6e <__adddf3+0x322>
  184baa:	0f 84 f1 00 00 00    	je     184ca1 <__adddf3+0x255>
  184bb0:	85 db                	test   %ebx,%ebx
  184bb2:	75 48                	jne    184bfc <__adddf3+0x1b0>
  184bb4:	89 d6                	mov    %edx,%esi
  184bb6:	09 c6                	or     %eax,%esi
  184bb8:	75 1b                	jne    184bd5 <__adddf3+0x189>
  184bba:	89 ea                	mov    %ebp,%edx
  184bbc:	89 f8                	mov    %edi,%eax
  184bbe:	81 7c 24 04 ff 07 00 	cmpl   $0x7ff,0x4(%esp)
  184bc5:	00 
  184bc6:	0f 84 58 04 00 00    	je     185024 <__adddf3+0x5d8>
  184bcc:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  184bd0:	e9 c4 05 00 00       	jmp    185199 <__adddf3+0x74d>
  184bd5:	8b 74 24 08          	mov    0x8(%esp),%esi
  184bd9:	83 f6 ff             	xor    $0xffffffff,%esi
  184bdc:	75 0f                	jne    184bed <__adddf3+0x1a1>
  184bde:	89 ee                	mov    %ebp,%esi
  184be0:	01 c7                	add    %eax,%edi
  184be2:	11 d6                	adc    %edx,%esi
  184be4:	89 f2                	mov    %esi,%edx
  184be6:	89 f8                	mov    %edi,%eax
  184be8:	e9 ab 00 00 00       	jmp    184c98 <__adddf3+0x24c>
  184bed:	81 7c 24 04 ff 07 00 	cmpl   $0x7ff,0x4(%esp)
  184bf4:	00 
  184bf5:	75 1f                	jne    184c16 <__adddf3+0x1ca>
  184bf7:	e9 28 06 00 00       	jmp    185224 <__adddf3+0x7d8>
  184bfc:	81 7c 24 04 ff 07 00 	cmpl   $0x7ff,0x4(%esp)
  184c03:	00 
  184c04:	0f 84 1a 06 00 00    	je     185224 <__adddf3+0x7d8>
  184c0a:	8b 74 24 08          	mov    0x8(%esp),%esi
  184c0e:	81 ca 00 00 80 00    	or     $0x800000,%edx
  184c14:	f7 de                	neg    %esi
  184c16:	83 fe 38             	cmp    $0x38,%esi
  184c19:	7f 6c                	jg     184c87 <__adddf3+0x23b>
  184c1b:	83 fe 1f             	cmp    $0x1f,%esi
  184c1e:	7f 42                	jg     184c62 <__adddf3+0x216>
  184c20:	bb 20 00 00 00       	mov    $0x20,%ebx
  184c25:	29 f3                	sub    %esi,%ebx
  184c27:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  184c2b:	89 d3                	mov    %edx,%ebx
  184c2d:	8a 4c 24 08          	mov    0x8(%esp),%cl
  184c31:	d3 e3                	shl    %cl,%ebx
  184c33:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  184c37:	89 f1                	mov    %esi,%ecx
  184c39:	89 c3                	mov    %eax,%ebx
  184c3b:	d3 eb                	shr    %cl,%ebx
  184c3d:	89 d9                	mov    %ebx,%ecx
  184c3f:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  184c43:	09 cb                	or     %ecx,%ebx
  184c45:	8a 4c 24 08          	mov    0x8(%esp),%cl
  184c49:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  184c4d:	31 db                	xor    %ebx,%ebx
  184c4f:	d3 e0                	shl    %cl,%eax
  184c51:	89 f1                	mov    %esi,%ecx
  184c53:	85 c0                	test   %eax,%eax
  184c55:	0f 95 c3             	setne  %bl
  184c58:	d3 ea                	shr    %cl,%edx
  184c5a:	0b 5c 24 0c          	or     0xc(%esp),%ebx
  184c5e:	89 d1                	mov    %edx,%ecx
  184c60:	eb 2e                	jmp    184c90 <__adddf3+0x244>
  184c62:	8d 4e e0             	lea    -0x20(%esi),%ecx
  184c65:	89 d3                	mov    %edx,%ebx
  184c67:	d3 eb                	shr    %cl,%ebx
  184c69:	31 c9                	xor    %ecx,%ecx
  184c6b:	83 fe 20             	cmp    $0x20,%esi
  184c6e:	74 0b                	je     184c7b <__adddf3+0x22f>
  184c70:	b9 40 00 00 00       	mov    $0x40,%ecx
  184c75:	29 f1                	sub    %esi,%ecx
  184c77:	d3 e2                	shl    %cl,%edx
  184c79:	89 d1                	mov    %edx,%ecx
  184c7b:	09 c1                	or     %eax,%ecx
  184c7d:	0f 95 c0             	setne  %al
  184c80:	0f b6 c0             	movzbl %al,%eax
  184c83:	09 c3                	or     %eax,%ebx
  184c85:	eb 07                	jmp    184c8e <__adddf3+0x242>
  184c87:	31 db                	xor    %ebx,%ebx
  184c89:	09 c2                	or     %eax,%edx
  184c8b:	0f 95 c3             	setne  %bl
  184c8e:	31 c9                	xor    %ecx,%ecx
  184c90:	89 ea                	mov    %ebp,%edx
  184c92:	89 f8                	mov    %edi,%eax
  184c94:	01 d8                	add    %ebx,%eax
  184c96:	11 ca                	adc    %ecx,%edx
  184c98:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  184c9c:	e9 cd 00 00 00       	jmp    184d6e <__adddf3+0x322>
  184ca1:	8d 4b 01             	lea    0x1(%ebx),%ecx
  184ca4:	89 ce                	mov    %ecx,%esi
  184ca6:	81 e6 ff 07 00 00    	and    $0x7ff,%esi
  184cac:	4e                   	dec    %esi
  184cad:	0f 8f 92 00 00 00    	jg     184d45 <__adddf3+0x2f9>
  184cb3:	89 d6                	mov    %edx,%esi
  184cb5:	85 db                	test   %ebx,%ebx
  184cb7:	75 36                	jne    184cef <__adddf3+0x2a3>
  184cb9:	09 c6                	or     %eax,%esi
  184cbb:	0f 84 5a 05 00 00    	je     18521b <__adddf3+0x7cf>
  184cc1:	89 ee                	mov    %ebp,%esi
  184cc3:	09 fe                	or     %edi,%esi
  184cc5:	0f 84 8f 05 00 00    	je     18525a <__adddf3+0x80e>
  184ccb:	01 f8                	add    %edi,%eax
  184ccd:	11 ea                	adc    %ebp,%edx
  184ccf:	89 d5                	mov    %edx,%ebp
  184cd1:	89 c7                	mov    %eax,%edi
  184cd3:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  184cd9:	0f 84 3c 05 00 00    	je     18521b <__adddf3+0x7cf>
  184cdf:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  184ce5:	bb 01 00 00 00       	mov    $0x1,%ebx
  184cea:	e9 c5 04 00 00       	jmp    1851b4 <__adddf3+0x768>
  184cef:	09 c6                	or     %eax,%esi
  184cf1:	0f 84 2d 05 00 00    	je     185224 <__adddf3+0x7d8>
  184cf7:	89 ee                	mov    %ebp,%esi
  184cf9:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  184cfe:	09 fe                	or     %edi,%esi
  184d00:	0f 84 ae 04 00 00    	je     1851b4 <__adddf3+0x768>
  184d06:	89 d1                	mov    %edx,%ecx
  184d08:	89 ee                	mov    %ebp,%esi
  184d0a:	c1 e8 03             	shr    $0x3,%eax
  184d0d:	c1 e1 1d             	shl    $0x1d,%ecx
  184d10:	c1 ea 03             	shr    $0x3,%edx
  184d13:	09 c1                	or     %eax,%ecx
  184d15:	c1 ee 03             	shr    $0x3,%esi
  184d18:	39 f2                	cmp    %esi,%edx
  184d1a:	0f 87 58 03 00 00    	ja     185078 <__adddf3+0x62c>
  184d20:	89 f8                	mov    %edi,%eax
  184d22:	89 ef                	mov    %ebp,%edi
  184d24:	c1 e8 03             	shr    $0x3,%eax
  184d27:	c1 e7 1d             	shl    $0x1d,%edi
  184d2a:	09 c7                	or     %eax,%edi
  184d2c:	39 f2                	cmp    %esi,%edx
  184d2e:	0f 94 c0             	sete   %al
  184d31:	39 f9                	cmp    %edi,%ecx
  184d33:	0f 93 c3             	setae  %bl
  184d36:	84 d8                	test   %bl,%al
  184d38:	0f 85 3c 03 00 00    	jne    18507a <__adddf3+0x62e>
  184d3e:	89 f9                	mov    %edi,%ecx
  184d40:	e9 35 03 00 00       	jmp    18507a <__adddf3+0x62e>
  184d45:	01 f8                	add    %edi,%eax
  184d47:	11 ea                	adc    %ebp,%edx
  184d49:	81 f9 ff 07 00 00    	cmp    $0x7ff,%ecx
  184d4f:	0f 84 56 04 00 00    	je     1851ab <__adddf3+0x75f>
  184d55:	89 c3                	mov    %eax,%ebx
  184d57:	83 e0 01             	and    $0x1,%eax
  184d5a:	d1 eb                	shr    %ebx
  184d5c:	09 d8                	or     %ebx,%eax
  184d5e:	89 d3                	mov    %edx,%ebx
  184d60:	c1 e3 1f             	shl    $0x1f,%ebx
  184d63:	d1 ea                	shr    %edx
  184d65:	09 d8                	or     %ebx,%eax
  184d67:	89 cb                	mov    %ecx,%ebx
  184d69:	e9 46 04 00 00       	jmp    1851b4 <__adddf3+0x768>
  184d6e:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  184d74:	0f 84 1f 04 00 00    	je     185199 <__adddf3+0x74d>
  184d7a:	43                   	inc    %ebx
  184d7b:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  184d81:	0f 84 29 04 00 00    	je     1851b0 <__adddf3+0x764>
  184d87:	89 c1                	mov    %eax,%ecx
  184d89:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  184d8f:	d1 e9                	shr    %ecx
  184d91:	83 e0 01             	and    $0x1,%eax
  184d94:	09 c8                	or     %ecx,%eax
  184d96:	89 d1                	mov    %edx,%ecx
  184d98:	c1 e1 1f             	shl    $0x1f,%ecx
  184d9b:	d1 ea                	shr    %edx
  184d9d:	09 c8                	or     %ecx,%eax
  184d9f:	e9 10 04 00 00       	jmp    1851b4 <__adddf3+0x768>
  184da4:	83 fe 00             	cmp    $0x0,%esi
  184da7:	0f 8e e5 00 00 00    	jle    184e92 <__adddf3+0x446>
  184dad:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  184db2:	75 33                	jne    184de7 <__adddf3+0x39b>
  184db4:	89 ee                	mov    %ebp,%esi
  184db6:	09 fe                	or     %edi,%esi
  184db8:	75 11                	jne    184dcb <__adddf3+0x37f>
  184dba:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  184dc0:	0f 85 d3 03 00 00    	jne    185199 <__adddf3+0x74d>
  184dc6:	e9 e9 03 00 00       	jmp    1851b4 <__adddf3+0x768>
  184dcb:	ff 4c 24 08          	decl   0x8(%esp)
  184dcf:	75 09                	jne    184dda <__adddf3+0x38e>
  184dd1:	29 f8                	sub    %edi,%eax
  184dd3:	19 ea                	sbb    %ebp,%edx
  184dd5:	e9 f0 02 00 00       	jmp    1850ca <__adddf3+0x67e>
  184dda:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  184de0:	75 17                	jne    184df9 <__adddf3+0x3ad>
  184de2:	e9 cd 03 00 00       	jmp    1851b4 <__adddf3+0x768>
  184de7:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  184ded:	0f 84 c1 03 00 00    	je     1851b4 <__adddf3+0x768>
  184df3:	81 cd 00 00 80 00    	or     $0x800000,%ebp
  184df9:	83 7c 24 08 38       	cmpl   $0x38,0x8(%esp)
  184dfe:	7f 7e                	jg     184e7e <__adddf3+0x432>
  184e00:	83 7c 24 08 1f       	cmpl   $0x1f,0x8(%esp)
  184e05:	7f 48                	jg     184e4f <__adddf3+0x403>
  184e07:	b9 20 00 00 00       	mov    $0x20,%ecx
  184e0c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  184e10:	2b 4c 24 08          	sub    0x8(%esp),%ecx
  184e14:	89 e8                	mov    %ebp,%eax
  184e16:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  184e1a:	8a 4c 24 04          	mov    0x4(%esp),%cl
  184e1e:	d3 e0                	shl    %cl,%eax
  184e20:	89 c6                	mov    %eax,%esi
  184e22:	8a 4c 24 08          	mov    0x8(%esp),%cl
  184e26:	89 f8                	mov    %edi,%eax
  184e28:	d3 e8                	shr    %cl,%eax
  184e2a:	89 c1                	mov    %eax,%ecx
  184e2c:	8b 44 24 0c          	mov    0xc(%esp),%eax
  184e30:	09 f1                	or     %esi,%ecx
  184e32:	89 ce                	mov    %ecx,%esi
  184e34:	8a 4c 24 04          	mov    0x4(%esp),%cl
  184e38:	d3 e7                	shl    %cl,%edi
  184e3a:	31 c9                	xor    %ecx,%ecx
  184e3c:	85 ff                	test   %edi,%edi
  184e3e:	89 f7                	mov    %esi,%edi
  184e40:	0f 95 c1             	setne  %cl
  184e43:	09 cf                	or     %ecx,%edi
  184e45:	8a 4c 24 08          	mov    0x8(%esp),%cl
  184e49:	d3 ed                	shr    %cl,%ebp
  184e4b:	89 ee                	mov    %ebp,%esi
  184e4d:	eb 3a                	jmp    184e89 <__adddf3+0x43d>
  184e4f:	8b 74 24 08          	mov    0x8(%esp),%esi
  184e53:	8d 4e e0             	lea    -0x20(%esi),%ecx
  184e56:	89 ee                	mov    %ebp,%esi
  184e58:	d3 ee                	shr    %cl,%esi
  184e5a:	31 c9                	xor    %ecx,%ecx
  184e5c:	83 7c 24 08 20       	cmpl   $0x20,0x8(%esp)
  184e61:	74 0d                	je     184e70 <__adddf3+0x424>
  184e63:	b9 40 00 00 00       	mov    $0x40,%ecx
  184e68:	2b 4c 24 08          	sub    0x8(%esp),%ecx
  184e6c:	d3 e5                	shl    %cl,%ebp
  184e6e:	89 e9                	mov    %ebp,%ecx
  184e70:	09 f9                	or     %edi,%ecx
  184e72:	89 f7                	mov    %esi,%edi
  184e74:	0f 95 c1             	setne  %cl
  184e77:	0f b6 c9             	movzbl %cl,%ecx
  184e7a:	09 cf                	or     %ecx,%edi
  184e7c:	eb 09                	jmp    184e87 <__adddf3+0x43b>
  184e7e:	31 c9                	xor    %ecx,%ecx
  184e80:	09 fd                	or     %edi,%ebp
  184e82:	0f 95 c1             	setne  %cl
  184e85:	89 cf                	mov    %ecx,%edi
  184e87:	31 f6                	xor    %esi,%esi
  184e89:	29 f8                	sub    %edi,%eax
  184e8b:	19 f2                	sbb    %esi,%edx
  184e8d:	e9 38 02 00 00       	jmp    1850ca <__adddf3+0x67e>
  184e92:	0f 84 fc 00 00 00    	je     184f94 <__adddf3+0x548>
  184e98:	85 db                	test   %ebx,%ebx
  184e9a:	75 4f                	jne    184eeb <__adddf3+0x49f>
  184e9c:	89 d3                	mov    %edx,%ebx
  184e9e:	09 c3                	or     %eax,%ebx
  184ea0:	75 22                	jne    184ec4 <__adddf3+0x478>
  184ea2:	89 ea                	mov    %ebp,%edx
  184ea4:	89 f8                	mov    %edi,%eax
  184ea6:	81 7c 24 04 ff 07 00 	cmpl   $0x7ff,0x4(%esp)
  184ead:	00 
  184eae:	0f 84 7d 03 00 00    	je     185231 <__adddf3+0x7e5>
  184eb4:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  184eb8:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  184ebc:	89 3c 24             	mov    %edi,(%esp)
  184ebf:	e9 d5 02 00 00       	jmp    185199 <__adddf3+0x74d>
  184ec4:	8b 74 24 08          	mov    0x8(%esp),%esi
  184ec8:	83 f6 ff             	xor    $0xffffffff,%esi
  184ecb:	75 0f                	jne    184edc <__adddf3+0x490>
  184ecd:	89 ee                	mov    %ebp,%esi
  184ecf:	29 c7                	sub    %eax,%edi
  184ed1:	19 d6                	sbb    %edx,%esi
  184ed3:	89 f2                	mov    %esi,%edx
  184ed5:	89 f8                	mov    %edi,%eax
  184ed7:	e9 a8 00 00 00       	jmp    184f84 <__adddf3+0x538>
  184edc:	81 7c 24 04 ff 07 00 	cmpl   $0x7ff,0x4(%esp)
  184ee3:	00 
  184ee4:	75 1f                	jne    184f05 <__adddf3+0x4b9>
  184ee6:	e9 42 03 00 00       	jmp    18522d <__adddf3+0x7e1>
  184eeb:	81 7c 24 04 ff 07 00 	cmpl   $0x7ff,0x4(%esp)
  184ef2:	00 
  184ef3:	0f 84 34 03 00 00    	je     18522d <__adddf3+0x7e1>
  184ef9:	8b 74 24 08          	mov    0x8(%esp),%esi
  184efd:	81 ca 00 00 80 00    	or     $0x800000,%edx
  184f03:	f7 de                	neg    %esi
  184f05:	83 fe 38             	cmp    $0x38,%esi
  184f08:	7f 69                	jg     184f73 <__adddf3+0x527>
  184f0a:	83 fe 1f             	cmp    $0x1f,%esi
  184f0d:	7f 3f                	jg     184f4e <__adddf3+0x502>
  184f0f:	bb 20 00 00 00       	mov    $0x20,%ebx
  184f14:	29 f3                	sub    %esi,%ebx
  184f16:	89 1c 24             	mov    %ebx,(%esp)
  184f19:	89 d3                	mov    %edx,%ebx
  184f1b:	8a 0c 24             	mov    (%esp),%cl
  184f1e:	d3 e3                	shl    %cl,%ebx
  184f20:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  184f24:	89 f1                	mov    %esi,%ecx
  184f26:	89 c3                	mov    %eax,%ebx
  184f28:	d3 eb                	shr    %cl,%ebx
  184f2a:	89 d9                	mov    %ebx,%ecx
  184f2c:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  184f30:	09 cb                	or     %ecx,%ebx
  184f32:	8a 0c 24             	mov    (%esp),%cl
  184f35:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  184f39:	31 db                	xor    %ebx,%ebx
  184f3b:	d3 e0                	shl    %cl,%eax
  184f3d:	89 f1                	mov    %esi,%ecx
  184f3f:	85 c0                	test   %eax,%eax
  184f41:	0f 95 c3             	setne  %bl
  184f44:	d3 ea                	shr    %cl,%edx
  184f46:	0b 5c 24 08          	or     0x8(%esp),%ebx
  184f4a:	89 d1                	mov    %edx,%ecx
  184f4c:	eb 2e                	jmp    184f7c <__adddf3+0x530>
  184f4e:	8d 4e e0             	lea    -0x20(%esi),%ecx
  184f51:	89 d3                	mov    %edx,%ebx
  184f53:	d3 eb                	shr    %cl,%ebx
  184f55:	31 c9                	xor    %ecx,%ecx
  184f57:	83 fe 20             	cmp    $0x20,%esi
  184f5a:	74 0b                	je     184f67 <__adddf3+0x51b>
  184f5c:	b9 40 00 00 00       	mov    $0x40,%ecx
  184f61:	29 f1                	sub    %esi,%ecx
  184f63:	d3 e2                	shl    %cl,%edx
  184f65:	89 d1                	mov    %edx,%ecx
  184f67:	09 c1                	or     %eax,%ecx
  184f69:	0f 95 c0             	setne  %al
  184f6c:	0f b6 c0             	movzbl %al,%eax
  184f6f:	09 c3                	or     %eax,%ebx
  184f71:	eb 07                	jmp    184f7a <__adddf3+0x52e>
  184f73:	31 db                	xor    %ebx,%ebx
  184f75:	09 c2                	or     %eax,%edx
  184f77:	0f 95 c3             	setne  %bl
  184f7a:	31 c9                	xor    %ecx,%ecx
  184f7c:	89 ea                	mov    %ebp,%edx
  184f7e:	89 f8                	mov    %edi,%eax
  184f80:	29 d8                	sub    %ebx,%eax
  184f82:	19 ca                	sbb    %ecx,%edx
  184f84:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  184f88:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  184f8c:	89 3c 24             	mov    %edi,(%esp)
  184f8f:	e9 36 01 00 00       	jmp    1850ca <__adddf3+0x67e>
  184f94:	8d 4b 01             	lea    0x1(%ebx),%ecx
  184f97:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  184f9d:	49                   	dec    %ecx
  184f9e:	0f 8f ed 00 00 00    	jg     185091 <__adddf3+0x645>
  184fa4:	85 db                	test   %ebx,%ebx
  184fa6:	75 61                	jne    185009 <__adddf3+0x5bd>
  184fa8:	89 d6                	mov    %edx,%esi
  184faa:	09 c6                	or     %eax,%esi
  184fac:	75 1a                	jne    184fc8 <__adddf3+0x57c>
  184fae:	89 e8                	mov    %ebp,%eax
  184fb0:	09 f8                	or     %edi,%eax
  184fb2:	0f 84 14 02 00 00    	je     1851cc <__adddf3+0x780>
  184fb8:	89 f8                	mov    %edi,%eax
  184fba:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  184fbe:	89 ea                	mov    %ebp,%edx
  184fc0:	89 3c 24             	mov    %edi,(%esp)
  184fc3:	e9 92 02 00 00       	jmp    18525a <__adddf3+0x80e>
  184fc8:	89 ee                	mov    %ebp,%esi
  184fca:	09 fe                	or     %edi,%esi
  184fcc:	0f 84 88 02 00 00    	je     18525a <__adddf3+0x80e>
  184fd2:	89 d1                	mov    %edx,%ecx
  184fd4:	89 c6                	mov    %eax,%esi
  184fd6:	29 fe                	sub    %edi,%esi
  184fd8:	19 e9                	sbb    %ebp,%ecx
  184fda:	f7 c1 00 00 80 00    	test   $0x800000,%ecx
  184fe0:	74 14                	je     184ff6 <__adddf3+0x5aa>
  184fe2:	89 ee                	mov    %ebp,%esi
  184fe4:	29 c7                	sub    %eax,%edi
  184fe6:	19 d6                	sbb    %edx,%esi
  184fe8:	8b 44 24 0c          	mov    0xc(%esp),%eax
  184fec:	89 f5                	mov    %esi,%ebp
  184fee:	89 04 24             	mov    %eax,(%esp)
  184ff1:	e9 25 02 00 00       	jmp    18521b <__adddf3+0x7cf>
  184ff6:	89 c8                	mov    %ecx,%eax
  184ff8:	09 f0                	or     %esi,%eax
  184ffa:	0f 84 cc 01 00 00    	je     1851cc <__adddf3+0x780>
  185000:	89 ca                	mov    %ecx,%edx
  185002:	89 f0                	mov    %esi,%eax
  185004:	e9 51 02 00 00       	jmp    18525a <__adddf3+0x80e>
  185009:	89 d3                	mov    %edx,%ebx
  18500b:	09 c3                	or     %eax,%ebx
  18500d:	75 1f                	jne    18502e <__adddf3+0x5e2>
  18500f:	89 e8                	mov    %ebp,%eax
  185011:	09 f8                	or     %edi,%eax
  185013:	0f 84 29 02 00 00    	je     185242 <__adddf3+0x7f6>
  185019:	89 f8                	mov    %edi,%eax
  18501b:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  18501f:	89 ea                	mov    %ebp,%edx
  185021:	89 3c 24             	mov    %edi,(%esp)
  185024:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  185029:	e9 86 01 00 00       	jmp    1851b4 <__adddf3+0x768>
  18502e:	89 ee                	mov    %ebp,%esi
  185030:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  185035:	09 fe                	or     %edi,%esi
  185037:	0f 84 77 01 00 00    	je     1851b4 <__adddf3+0x768>
  18503d:	89 d1                	mov    %edx,%ecx
  18503f:	89 ee                	mov    %ebp,%esi
  185041:	c1 e8 03             	shr    $0x3,%eax
  185044:	c1 e1 1d             	shl    $0x1d,%ecx
  185047:	c1 ea 03             	shr    $0x3,%edx
  18504a:	09 c1                	or     %eax,%ecx
  18504c:	c1 ee 03             	shr    $0x3,%esi
  18504f:	39 f2                	cmp    %esi,%edx
  185051:	77 25                	ja     185078 <__adddf3+0x62c>
  185053:	89 f8                	mov    %edi,%eax
  185055:	89 ef                	mov    %ebp,%edi
  185057:	c1 e8 03             	shr    $0x3,%eax
  18505a:	c1 e7 1d             	shl    $0x1d,%edi
  18505d:	09 c7                	or     %eax,%edi
  18505f:	39 f2                	cmp    %esi,%edx
  185061:	0f 94 c0             	sete   %al
  185064:	39 f9                	cmp    %edi,%ecx
  185066:	0f 93 c3             	setae  %bl
  185069:	84 d8                	test   %bl,%al
  18506b:	75 0d                	jne    18507a <__adddf3+0x62e>
  18506d:	8b 44 24 0c          	mov    0xc(%esp),%eax
  185071:	89 f9                	mov    %edi,%ecx
  185073:	89 04 24             	mov    %eax,(%esp)
  185076:	eb 02                	jmp    18507a <__adddf3+0x62e>
  185078:	89 d6                	mov    %edx,%esi
  18507a:	89 ca                	mov    %ecx,%edx
  18507c:	8d 2c f5 00 00 00 00 	lea    0x0(,%esi,8),%ebp
  185083:	c1 ea 1d             	shr    $0x1d,%edx
  185086:	8d 04 cd 00 00 00 00 	lea    0x0(,%ecx,8),%eax
  18508d:	09 ea                	or     %ebp,%edx
  18508f:	eb 93                	jmp    185024 <__adddf3+0x5d8>
  185091:	89 c1                	mov    %eax,%ecx
  185093:	89 d6                	mov    %edx,%esi
  185095:	29 f9                	sub    %edi,%ecx
  185097:	19 ee                	sbb    %ebp,%esi
  185099:	89 74 24 08          	mov    %esi,0x8(%esp)
  18509d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1850a1:	f7 c6 00 00 80 00    	test   $0x800000,%esi
  1850a7:	74 13                	je     1850bc <__adddf3+0x670>
  1850a9:	89 ee                	mov    %ebp,%esi
  1850ab:	29 c7                	sub    %eax,%edi
  1850ad:	19 d6                	sbb    %edx,%esi
  1850af:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1850b3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1850b7:	89 04 24             	mov    %eax,(%esp)
  1850ba:	eb 26                	jmp    1850e2 <__adddf3+0x696>
  1850bc:	8b 44 24 08          	mov    0x8(%esp),%eax
  1850c0:	09 c8                	or     %ecx,%eax
  1850c2:	0f 84 02 01 00 00    	je     1851ca <__adddf3+0x77e>
  1850c8:	eb 18                	jmp    1850e2 <__adddf3+0x696>
  1850ca:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  1850d0:	0f 84 c3 00 00 00    	je     185199 <__adddf3+0x74d>
  1850d6:	89 d6                	mov    %edx,%esi
  1850d8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1850dc:	81 e6 ff ff 7f 00    	and    $0x7fffff,%esi
  1850e2:	85 f6                	test   %esi,%esi
  1850e4:	74 08                	je     1850ee <__adddf3+0x6a2>
  1850e6:	0f bd ce             	bsr    %esi,%ecx
  1850e9:	83 f1 1f             	xor    $0x1f,%ecx
  1850ec:	eb 0b                	jmp    1850f9 <__adddf3+0x6ad>
  1850ee:	0f bd 4c 24 04       	bsr    0x4(%esp),%ecx
  1850f3:	83 f1 1f             	xor    $0x1f,%ecx
  1850f6:	83 c1 20             	add    $0x20,%ecx
  1850f9:	8d 69 f8             	lea    -0x8(%ecx),%ebp
  1850fc:	83 fd 1f             	cmp    $0x1f,%ebp
  1850ff:	7f 1d                	jg     18511e <__adddf3+0x6d2>
  185101:	89 e9                	mov    %ebp,%ecx
  185103:	8b 54 24 04          	mov    0x4(%esp),%edx
  185107:	d3 e6                	shl    %cl,%esi
  185109:	b9 20 00 00 00       	mov    $0x20,%ecx
  18510e:	8b 44 24 04          	mov    0x4(%esp),%eax
  185112:	29 e9                	sub    %ebp,%ecx
  185114:	d3 ea                	shr    %cl,%edx
  185116:	89 e9                	mov    %ebp,%ecx
  185118:	09 f2                	or     %esi,%edx
  18511a:	d3 e0                	shl    %cl,%eax
  18511c:	eb 0b                	jmp    185129 <__adddf3+0x6dd>
  18511e:	83 e9 28             	sub    $0x28,%ecx
  185121:	8b 54 24 04          	mov    0x4(%esp),%edx
  185125:	d3 e2                	shl    %cl,%edx
  185127:	31 c0                	xor    %eax,%eax
  185129:	39 eb                	cmp    %ebp,%ebx
  18512b:	7f 64                	jg     185191 <__adddf3+0x745>
  18512d:	29 dd                	sub    %ebx,%ebp
  18512f:	8d 5d 01             	lea    0x1(%ebp),%ebx
  185132:	83 fb 1f             	cmp    $0x1f,%ebx
  185135:	7f 2e                	jg     185165 <__adddf3+0x719>
  185137:	bd 20 00 00 00       	mov    $0x20,%ebp
  18513c:	89 d6                	mov    %edx,%esi
  18513e:	29 dd                	sub    %ebx,%ebp
  185140:	89 c7                	mov    %eax,%edi
  185142:	89 e9                	mov    %ebp,%ecx
  185144:	d3 e6                	shl    %cl,%esi
  185146:	88 d9                	mov    %bl,%cl
  185148:	d3 ef                	shr    %cl,%edi
  18514a:	89 e9                	mov    %ebp,%ecx
  18514c:	09 f7                	or     %esi,%edi
  18514e:	d3 e0                	shl    %cl,%eax
  185150:	85 c0                	test   %eax,%eax
  185152:	88 d9                	mov    %bl,%cl
  185154:	0f 95 c0             	setne  %al
  185157:	0f b6 c0             	movzbl %al,%eax
  18515a:	d3 ea                	shr    %cl,%edx
  18515c:	09 c7                	or     %eax,%edi
  18515e:	89 d5                	mov    %edx,%ebp
  185160:	e9 b6 00 00 00       	jmp    18521b <__adddf3+0x7cf>
  185165:	8d 4d e1             	lea    -0x1f(%ebp),%ecx
  185168:	89 d6                	mov    %edx,%esi
  18516a:	d3 ee                	shr    %cl,%esi
  18516c:	31 c9                	xor    %ecx,%ecx
  18516e:	83 fb 20             	cmp    $0x20,%ebx
  185171:	74 0b                	je     18517e <__adddf3+0x732>
  185173:	b9 40 00 00 00       	mov    $0x40,%ecx
  185178:	29 d9                	sub    %ebx,%ecx
  18517a:	d3 e2                	shl    %cl,%edx
  18517c:	89 d1                	mov    %edx,%ecx
  18517e:	09 c8                	or     %ecx,%eax
  185180:	89 f7                	mov    %esi,%edi
  185182:	0f 95 c0             	setne  %al
  185185:	0f b6 c0             	movzbl %al,%eax
  185188:	09 c7                	or     %eax,%edi
  18518a:	31 ed                	xor    %ebp,%ebp
  18518c:	e9 8a 00 00 00       	jmp    18521b <__adddf3+0x7cf>
  185191:	29 eb                	sub    %ebp,%ebx
  185193:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  185199:	85 db                	test   %ebx,%ebx
  18519b:	75 17                	jne    1851b4 <__adddf3+0x768>
  18519d:	89 c7                	mov    %eax,%edi
  18519f:	09 d7                	or     %edx,%edi
  1851a1:	0f 85 b3 00 00 00    	jne    18525a <__adddf3+0x80e>
  1851a7:	31 db                	xor    %ebx,%ebx
  1851a9:	eb 28                	jmp    1851d3 <__adddf3+0x787>
  1851ab:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  1851b0:	31 d2                	xor    %edx,%edx
  1851b2:	31 c0                	xor    %eax,%eax
  1851b4:	a8 07                	test   $0x7,%al
  1851b6:	74 1f                	je     1851d7 <__adddf3+0x78b>
  1851b8:	89 c1                	mov    %eax,%ecx
  1851ba:	83 e1 0f             	and    $0xf,%ecx
  1851bd:	83 f9 04             	cmp    $0x4,%ecx
  1851c0:	74 15                	je     1851d7 <__adddf3+0x78b>
  1851c2:	83 c0 04             	add    $0x4,%eax
  1851c5:	83 d2 00             	adc    $0x0,%edx
  1851c8:	eb 0d                	jmp    1851d7 <__adddf3+0x78b>
  1851ca:	31 db                	xor    %ebx,%ebx
  1851cc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1851d3:	31 d2                	xor    %edx,%edx
  1851d5:	31 c0                	xor    %eax,%eax
  1851d7:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  1851dd:	74 13                	je     1851f2 <__adddf3+0x7a6>
  1851df:	43                   	inc    %ebx
  1851e0:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  1851e6:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  1851ec:	75 04                	jne    1851f2 <__adddf3+0x7a6>
  1851ee:	31 d2                	xor    %edx,%edx
  1851f0:	31 c0                	xor    %eax,%eax
  1851f2:	c1 e8 03             	shr    $0x3,%eax
  1851f5:	89 d6                	mov    %edx,%esi
  1851f7:	c1 e6 1d             	shl    $0x1d,%esi
  1851fa:	c1 ea 03             	shr    $0x3,%edx
  1851fd:	09 c6                	or     %eax,%esi
  1851ff:	89 d1                	mov    %edx,%ecx
  185201:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  185207:	75 58                	jne    185261 <__adddf3+0x815>
  185209:	89 f0                	mov    %esi,%eax
  18520b:	09 d0                	or     %edx,%eax
  18520d:	74 08                	je     185217 <__adddf3+0x7cb>
  18520f:	81 c9 00 00 08 00    	or     $0x80000,%ecx
  185215:	eb 4a                	jmp    185261 <__adddf3+0x815>
  185217:	31 c9                	xor    %ecx,%ecx
  185219:	eb 46                	jmp    185261 <__adddf3+0x815>
  18521b:	89 ea                	mov    %ebp,%edx
  18521d:	89 f8                	mov    %edi,%eax
  18521f:	e9 79 ff ff ff       	jmp    18519d <__adddf3+0x751>
  185224:	89 ea                	mov    %ebp,%edx
  185226:	89 f8                	mov    %edi,%eax
  185228:	e9 f7 fd ff ff       	jmp    185024 <__adddf3+0x5d8>
  18522d:	89 ea                	mov    %ebp,%edx
  18522f:	89 f8                	mov    %edi,%eax
  185231:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  185235:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  18523a:	89 3c 24             	mov    %edi,(%esp)
  18523d:	e9 72 ff ff ff       	jmp    1851b4 <__adddf3+0x768>
  185242:	ba 00 00 40 00       	mov    $0x400000,%edx
  185247:	31 c0                	xor    %eax,%eax
  185249:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  18524e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  185255:	e9 5a ff ff ff       	jmp    1851b4 <__adddf3+0x768>
  18525a:	31 db                	xor    %ebx,%ebx
  18525c:	e9 53 ff ff ff       	jmp    1851b4 <__adddf3+0x768>
  185261:	31 d2                	xor    %edx,%edx
  185263:	89 f0                	mov    %esi,%eax
  185265:	89 d6                	mov    %edx,%esi
  185267:	81 e1 ff ff 0f 00    	and    $0xfffff,%ecx
  18526d:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
  185273:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
  185279:	c1 e3 14             	shl    $0x14,%ebx
  18527c:	09 f1                	or     %esi,%ecx
  18527e:	81 e1 ff ff 0f 80    	and    $0x800fffff,%ecx
  185284:	09 d9                	or     %ebx,%ecx
  185286:	8b 1c 24             	mov    (%esp),%ebx
  185289:	c1 e3 1f             	shl    $0x1f,%ebx
  18528c:	83 c4 10             	add    $0x10,%esp
  18528f:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  185295:	09 d9                	or     %ebx,%ecx
  185297:	5b                   	pop    %ebx
  185298:	89 ca                	mov    %ecx,%edx
  18529a:	5e                   	pop    %esi
  18529b:	5f                   	pop    %edi
  18529c:	5d                   	pop    %ebp
  18529d:	c3                   	ret    

0018529e <__divdf3>:
  18529e:	55                   	push   %ebp
  18529f:	57                   	push   %edi
  1852a0:	56                   	push   %esi
  1852a1:	53                   	push   %ebx
  1852a2:	83 ec 20             	sub    $0x20,%esp
  1852a5:	89 d3                	mov    %edx,%ebx
  1852a7:	89 d1                	mov    %edx,%ecx
  1852a9:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
  1852af:	c1 ea 1f             	shr    $0x1f,%edx
  1852b2:	8b 74 24 38          	mov    0x38(%esp),%esi
  1852b6:	c1 e9 14             	shr    $0x14,%ecx
  1852b9:	89 54 24 18          	mov    %edx,0x18(%esp)
  1852bd:	66 81 e1 ff 07       	and    $0x7ff,%cx
  1852c2:	8b 7c 24 34          	mov    0x34(%esp),%edi
  1852c6:	0f b6 54 24 18       	movzbl 0x18(%esp),%edx
  1852cb:	0f b7 e9             	movzwl %cx,%ebp
  1852ce:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1852d2:	89 6c 24 08          	mov    %ebp,0x8(%esp)
  1852d6:	66 85 c9             	test   %cx,%cx
  1852d9:	89 14 24             	mov    %edx,(%esp)
  1852dc:	74 24                	je     185302 <__divdf3+0x64>
  1852de:	66 81 f9 ff 07       	cmp    $0x7ff,%cx
  1852e3:	89 c6                	mov    %eax,%esi
  1852e5:	74 76                	je     18535d <__divdf3+0xbf>
  1852e7:	c1 e8 1d             	shr    $0x1d,%eax
  1852ea:	81 cb 00 00 10 00    	or     $0x100000,%ebx
  1852f0:	c1 e3 03             	shl    $0x3,%ebx
  1852f3:	c1 e6 03             	shl    $0x3,%esi
  1852f6:	09 c3                	or     %eax,%ebx
  1852f8:	81 6c 24 08 ff 03 00 	subl   $0x3ff,0x8(%esp)
  1852ff:	00 
  185300:	eb 57                	jmp    185359 <__divdf3+0xbb>
  185302:	89 c2                	mov    %eax,%edx
  185304:	09 da                	or     %ebx,%edx
  185306:	74 69                	je     185371 <__divdf3+0xd3>
  185308:	85 db                	test   %ebx,%ebx
  18530a:	74 08                	je     185314 <__divdf3+0x76>
  18530c:	0f bd f3             	bsr    %ebx,%esi
  18530f:	83 f6 1f             	xor    $0x1f,%esi
  185312:	eb 09                	jmp    18531d <__divdf3+0x7f>
  185314:	0f bd f0             	bsr    %eax,%esi
  185317:	83 f6 1f             	xor    $0x1f,%esi
  18531a:	83 c6 20             	add    $0x20,%esi
  18531d:	8d 56 f5             	lea    -0xb(%esi),%edx
  185320:	83 fa 1c             	cmp    $0x1c,%edx
  185323:	7f 1c                	jg     185341 <__divdf3+0xa3>
  185325:	83 ee 08             	sub    $0x8,%esi
  185328:	89 c5                	mov    %eax,%ebp
  18532a:	89 f1                	mov    %esi,%ecx
  18532c:	d3 e3                	shl    %cl,%ebx
  18532e:	b9 1d 00 00 00       	mov    $0x1d,%ecx
  185333:	29 d1                	sub    %edx,%ecx
  185335:	d3 ed                	shr    %cl,%ebp
  185337:	89 f1                	mov    %esi,%ecx
  185339:	09 eb                	or     %ebp,%ebx
  18533b:	d3 e0                	shl    %cl,%eax
  18533d:	89 c6                	mov    %eax,%esi
  18533f:	eb 09                	jmp    18534a <__divdf3+0xac>
  185341:	8d 4e d8             	lea    -0x28(%esi),%ecx
  185344:	31 f6                	xor    %esi,%esi
  185346:	d3 e0                	shl    %cl,%eax
  185348:	89 c3                	mov    %eax,%ebx
  18534a:	8b 44 24 08          	mov    0x8(%esp),%eax
  18534e:	29 d0                	sub    %edx,%eax
  185350:	2d fe 03 00 00       	sub    $0x3fe,%eax
  185355:	89 44 24 08          	mov    %eax,0x8(%esp)
  185359:	31 ed                	xor    %ebp,%ebp
  18535b:	eb 1d                	jmp    18537a <__divdf3+0xdc>
  18535d:	09 d8                	or     %ebx,%eax
  18535f:	bd 03 00 00 00       	mov    $0x3,%ebp
  185364:	75 14                	jne    18537a <__divdf3+0xdc>
  185366:	31 db                	xor    %ebx,%ebx
  185368:	31 f6                	xor    %esi,%esi
  18536a:	bd 02 00 00 00       	mov    $0x2,%ebp
  18536f:	eb 09                	jmp    18537a <__divdf3+0xdc>
  185371:	31 db                	xor    %ebx,%ebx
  185373:	31 f6                	xor    %esi,%esi
  185375:	bd 01 00 00 00       	mov    $0x1,%ebp
  18537a:	8b 44 24 0c          	mov    0xc(%esp),%eax
  18537e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  185382:	89 44 24 10          	mov    %eax,0x10(%esp)
  185386:	89 f9                	mov    %edi,%ecx
  185388:	89 c7                	mov    %eax,%edi
  18538a:	c1 e8 14             	shr    $0x14,%eax
  18538d:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
  185393:	66 25 ff 07          	and    $0x7ff,%ax
  185397:	0f b7 d0             	movzwl %ax,%edx
  18539a:	89 54 24 0c          	mov    %edx,0xc(%esp)
  18539e:	8b 54 24 10          	mov    0x10(%esp),%edx
  1853a2:	c1 ea 1f             	shr    $0x1f,%edx
  1853a5:	66 85 c0             	test   %ax,%ax
  1853a8:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  1853ac:	0f b6 54 24 1c       	movzbl 0x1c(%esp),%edx
  1853b1:	89 54 24 14          	mov    %edx,0x14(%esp)
  1853b5:	74 27                	je     1853de <__divdf3+0x140>
  1853b7:	66 3d ff 07          	cmp    $0x7ff,%ax
  1853bb:	0f 84 8c 00 00 00    	je     18544d <__divdf3+0x1af>
  1853c1:	89 c8                	mov    %ecx,%eax
  1853c3:	81 cf 00 00 10 00    	or     $0x100000,%edi
  1853c9:	c1 e7 03             	shl    $0x3,%edi
  1853cc:	c1 e8 1d             	shr    $0x1d,%eax
  1853cf:	c1 e1 03             	shl    $0x3,%ecx
  1853d2:	09 c7                	or     %eax,%edi
  1853d4:	81 6c 24 0c ff 03 00 	subl   $0x3ff,0xc(%esp)
  1853db:	00 
  1853dc:	eb 6b                	jmp    185449 <__divdf3+0x1ab>
  1853de:	8b 44 24 04          	mov    0x4(%esp),%eax
  1853e2:	09 f8                	or     %edi,%eax
  1853e4:	74 7d                	je     185463 <__divdf3+0x1c5>
  1853e6:	85 ff                	test   %edi,%edi
  1853e8:	74 08                	je     1853f2 <__divdf3+0x154>
  1853ea:	0f bd c7             	bsr    %edi,%eax
  1853ed:	83 f0 1f             	xor    $0x1f,%eax
  1853f0:	eb 0b                	jmp    1853fd <__divdf3+0x15f>
  1853f2:	0f bd 44 24 04       	bsr    0x4(%esp),%eax
  1853f7:	83 f0 1f             	xor    $0x1f,%eax
  1853fa:	83 c0 20             	add    $0x20,%eax
  1853fd:	8d 50 f5             	lea    -0xb(%eax),%edx
  185400:	89 54 24 10          	mov    %edx,0x10(%esp)
  185404:	83 fa 1c             	cmp    $0x1c,%edx
  185407:	7f 22                	jg     18542b <__divdf3+0x18d>
  185409:	83 e8 08             	sub    $0x8,%eax
  18540c:	88 c1                	mov    %al,%cl
  18540e:	d3 e7                	shl    %cl,%edi
  185410:	b9 1d 00 00 00       	mov    $0x1d,%ecx
  185415:	29 d1                	sub    %edx,%ecx
  185417:	8b 54 24 04          	mov    0x4(%esp),%edx
  18541b:	d3 ea                	shr    %cl,%edx
  18541d:	09 d7                	or     %edx,%edi
  18541f:	88 c1                	mov    %al,%cl
  185421:	8b 54 24 04          	mov    0x4(%esp),%edx
  185425:	d3 e2                	shl    %cl,%edx
  185427:	89 d1                	mov    %edx,%ecx
  185429:	eb 0d                	jmp    185438 <__divdf3+0x19a>
  18542b:	8d 48 d8             	lea    -0x28(%eax),%ecx
  18542e:	8b 54 24 04          	mov    0x4(%esp),%edx
  185432:	d3 e2                	shl    %cl,%edx
  185434:	89 d7                	mov    %edx,%edi
  185436:	31 c9                	xor    %ecx,%ecx
  185438:	8b 44 24 0c          	mov    0xc(%esp),%eax
  18543c:	2b 44 24 10          	sub    0x10(%esp),%eax
  185440:	2d fe 03 00 00       	sub    $0x3fe,%eax
  185445:	89 44 24 0c          	mov    %eax,0xc(%esp)
  185449:	31 c0                	xor    %eax,%eax
  18544b:	eb 1f                	jmp    18546c <__divdf3+0x1ce>
  18544d:	89 c8                	mov    %ecx,%eax
  18544f:	09 f8                	or     %edi,%eax
  185451:	b8 03 00 00 00       	mov    $0x3,%eax
  185456:	75 14                	jne    18546c <__divdf3+0x1ce>
  185458:	31 ff                	xor    %edi,%edi
  18545a:	31 c9                	xor    %ecx,%ecx
  18545c:	b8 02 00 00 00       	mov    $0x2,%eax
  185461:	eb 09                	jmp    18546c <__divdf3+0x1ce>
  185463:	31 ff                	xor    %edi,%edi
  185465:	31 c9                	xor    %ecx,%ecx
  185467:	b8 01 00 00 00       	mov    $0x1,%eax
  18546c:	8a 54 24 1c          	mov    0x1c(%esp),%dl
  185470:	33 54 24 18          	xor    0x18(%esp),%edx
  185474:	0f b6 d2             	movzbl %dl,%edx
  185477:	89 54 24 10          	mov    %edx,0x10(%esp)
  18547b:	8b 54 24 08          	mov    0x8(%esp),%edx
  18547f:	2b 54 24 0c          	sub    0xc(%esp),%edx
  185483:	89 54 24 0c          	mov    %edx,0xc(%esp)
  185487:	8d 14 ad 00 00 00 00 	lea    0x0(,%ebp,4),%edx
  18548e:	09 c2                	or     %eax,%edx
  185490:	4a                   	dec    %edx
  185491:	83 fa 0e             	cmp    $0xe,%edx
  185494:	77 07                	ja     18549d <__divdf3+0x1ff>
  185496:	ff 24 95 9c 6f 18 00 	jmp    *0x186f9c(,%edx,4)
  18549d:	39 fb                	cmp    %edi,%ebx
  18549f:	77 06                	ja     1854a7 <__divdf3+0x209>
  1854a1:	75 1a                	jne    1854bd <__divdf3+0x21f>
  1854a3:	39 ce                	cmp    %ecx,%esi
  1854a5:	72 16                	jb     1854bd <__divdf3+0x21f>
  1854a7:	89 f0                	mov    %esi,%eax
  1854a9:	89 da                	mov    %ebx,%edx
  1854ab:	d1 e8                	shr    %eax
  1854ad:	c1 e2 1f             	shl    $0x1f,%edx
  1854b0:	c1 e6 1f             	shl    $0x1f,%esi
  1854b3:	09 c2                	or     %eax,%edx
  1854b5:	d1 eb                	shr    %ebx
  1854b7:	89 f5                	mov    %esi,%ebp
  1854b9:	89 d6                	mov    %edx,%esi
  1854bb:	eb 06                	jmp    1854c3 <__divdf3+0x225>
  1854bd:	ff 4c 24 0c          	decl   0xc(%esp)
  1854c1:	31 ed                	xor    %ebp,%ebp
  1854c3:	89 c8                	mov    %ecx,%eax
  1854c5:	89 da                	mov    %ebx,%edx
  1854c7:	c1 e8 18             	shr    $0x18,%eax
  1854ca:	c1 e7 08             	shl    $0x8,%edi
  1854cd:	c1 e1 08             	shl    $0x8,%ecx
  1854d0:	09 c7                	or     %eax,%edi
  1854d2:	89 3c 24             	mov    %edi,(%esp)
  1854d5:	89 f0                	mov    %esi,%eax
  1854d7:	f7 f7                	div    %edi
  1854d9:	89 d7                	mov    %edx,%edi
  1854db:	89 54 24 08          	mov    %edx,0x8(%esp)
  1854df:	89 c6                	mov    %eax,%esi
  1854e1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1854e5:	f7 e1                	mul    %ecx
  1854e7:	89 54 24 14          	mov    %edx,0x14(%esp)
  1854eb:	39 d7                	cmp    %edx,%edi
  1854ed:	72 06                	jb     1854f5 <__divdf3+0x257>
  1854ef:	75 41                	jne    185532 <__divdf3+0x294>
  1854f1:	39 c5                	cmp    %eax,%ebp
  1854f3:	73 3d                	jae    185532 <__divdf3+0x294>
  1854f5:	8b 14 24             	mov    (%esp),%edx
  1854f8:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  1854fc:	8d 5e ff             	lea    -0x1(%esi),%ebx
  1854ff:	01 e9                	add    %ebp,%ecx
  185501:	13 54 24 08          	adc    0x8(%esp),%edx
  185505:	89 d7                	mov    %edx,%edi
  185507:	89 cd                	mov    %ecx,%ebp
  185509:	39 14 24             	cmp    %edx,(%esp)
  18550c:	72 08                	jb     185516 <__divdf3+0x278>
  18550e:	75 24                	jne    185534 <__divdf3+0x296>
  185510:	39 4c 24 04          	cmp    %ecx,0x4(%esp)
  185514:	77 1e                	ja     185534 <__divdf3+0x296>
  185516:	39 54 24 14          	cmp    %edx,0x14(%esp)
  18551a:	77 06                	ja     185522 <__divdf3+0x284>
  18551c:	75 16                	jne    185534 <__divdf3+0x296>
  18551e:	39 c8                	cmp    %ecx,%eax
  185520:	76 12                	jbe    185534 <__divdf3+0x296>
  185522:	8b 3c 24             	mov    (%esp),%edi
  185525:	8b 6c 24 04          	mov    0x4(%esp),%ebp
  185529:	8d 5e fe             	lea    -0x2(%esi),%ebx
  18552c:	01 cd                	add    %ecx,%ebp
  18552e:	11 d7                	adc    %edx,%edi
  185530:	eb 02                	jmp    185534 <__divdf3+0x296>
  185532:	89 f3                	mov    %esi,%ebx
  185534:	29 c5                	sub    %eax,%ebp
  185536:	1b 7c 24 14          	sbb    0x14(%esp),%edi
  18553a:	83 ce ff             	or     $0xffffffff,%esi
  18553d:	39 3c 24             	cmp    %edi,(%esp)
  185540:	0f 84 1b 02 00 00    	je     185761 <__divdf3+0x4c3>
  185546:	89 fa                	mov    %edi,%edx
  185548:	89 e8                	mov    %ebp,%eax
  18554a:	f7 34 24             	divl   (%esp)
  18554d:	89 d1                	mov    %edx,%ecx
  18554f:	89 44 24 08          	mov    %eax,0x8(%esp)
  185553:	89 d7                	mov    %edx,%edi
  185555:	f7 64 24 04          	mull   0x4(%esp)
  185559:	89 54 24 14          	mov    %edx,0x14(%esp)
  18555d:	39 d1                	cmp    %edx,%ecx
  18555f:	72 06                	jb     185567 <__divdf3+0x2c9>
  185561:	75 48                	jne    1855ab <__divdf3+0x30d>
  185563:	85 c0                	test   %eax,%eax
  185565:	74 44                	je     1855ab <__divdf3+0x30d>
  185567:	8b 7c 24 08          	mov    0x8(%esp),%edi
  18556b:	8b 14 24             	mov    (%esp),%edx
  18556e:	8b 6c 24 04          	mov    0x4(%esp),%ebp
  185572:	8d 77 ff             	lea    -0x1(%edi),%esi
  185575:	83 c5 00             	add    $0x0,%ebp
  185578:	11 ca                	adc    %ecx,%edx
  18557a:	89 d7                	mov    %edx,%edi
  18557c:	89 e9                	mov    %ebp,%ecx
  18557e:	39 14 24             	cmp    %edx,(%esp)
  185581:	72 08                	jb     18558b <__divdf3+0x2ed>
  185583:	75 2c                	jne    1855b1 <__divdf3+0x313>
  185585:	39 6c 24 04          	cmp    %ebp,0x4(%esp)
  185589:	77 26                	ja     1855b1 <__divdf3+0x313>
  18558b:	39 54 24 14          	cmp    %edx,0x14(%esp)
  18558f:	77 06                	ja     185597 <__divdf3+0x2f9>
  185591:	75 1e                	jne    1855b1 <__divdf3+0x313>
  185593:	39 e8                	cmp    %ebp,%eax
  185595:	76 1a                	jbe    1855b1 <__divdf3+0x313>
  185597:	8b 74 24 08          	mov    0x8(%esp),%esi
  18559b:	8b 3c 24             	mov    (%esp),%edi
  18559e:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  1855a2:	83 ee 02             	sub    $0x2,%esi
  1855a5:	01 e9                	add    %ebp,%ecx
  1855a7:	11 d7                	adc    %edx,%edi
  1855a9:	eb 06                	jmp    1855b1 <__divdf3+0x313>
  1855ab:	8b 74 24 08          	mov    0x8(%esp),%esi
  1855af:	31 c9                	xor    %ecx,%ecx
  1855b1:	3b 7c 24 14          	cmp    0x14(%esp),%edi
  1855b5:	75 08                	jne    1855bf <__divdf3+0x321>
  1855b7:	39 c1                	cmp    %eax,%ecx
  1855b9:	0f 84 a2 01 00 00    	je     185761 <__divdf3+0x4c3>
  1855bf:	83 ce 01             	or     $0x1,%esi
  1855c2:	e9 9a 01 00 00       	jmp    185761 <__divdf3+0x4c3>
  1855c7:	39 fb                	cmp    %edi,%ebx
  1855c9:	0f 87 9e 01 00 00    	ja     18576d <__divdf3+0x4cf>
  1855cf:	75 08                	jne    1855d9 <__divdf3+0x33b>
  1855d1:	39 ce                	cmp    %ecx,%esi
  1855d3:	0f 87 57 01 00 00    	ja     185730 <__divdf3+0x492>
  1855d9:	8b 44 24 14          	mov    0x14(%esp),%eax
  1855dd:	89 ce                	mov    %ecx,%esi
  1855df:	89 04 24             	mov    %eax,(%esp)
  1855e2:	e9 49 01 00 00       	jmp    185730 <__divdf3+0x492>
  1855e7:	89 fb                	mov    %edi,%ebx
  1855e9:	8b 7c 24 14          	mov    0x14(%esp),%edi
  1855ed:	89 ce                	mov    %ecx,%esi
  1855ef:	89 3c 24             	mov    %edi,(%esp)
  1855f2:	89 c5                	mov    %eax,%ebp
  1855f4:	83 fd 02             	cmp    $0x2,%ebp
  1855f7:	0f 84 4d 01 00 00    	je     18574a <__divdf3+0x4ac>
  1855fd:	83 fd 03             	cmp    $0x3,%ebp
  185600:	0f 84 2c 01 00 00    	je     185732 <__divdf3+0x494>
  185606:	4d                   	dec    %ebp
  185607:	0f 84 39 01 00 00    	je     185746 <__divdf3+0x4a8>
  18560d:	8b 44 24 0c          	mov    0xc(%esp),%eax
  185611:	8d b8 ff 03 00 00    	lea    0x3ff(%eax),%edi
  185617:	85 ff                	test   %edi,%edi
  185619:	7e 4e                	jle    185669 <__divdf3+0x3cb>
  18561b:	f7 c6 07 00 00 00    	test   $0x7,%esi
  185621:	74 10                	je     185633 <__divdf3+0x395>
  185623:	89 f0                	mov    %esi,%eax
  185625:	83 e0 0f             	and    $0xf,%eax
  185628:	83 f8 04             	cmp    $0x4,%eax
  18562b:	74 06                	je     185633 <__divdf3+0x395>
  18562d:	83 c6 04             	add    $0x4,%esi
  185630:	83 d3 00             	adc    $0x0,%ebx
  185633:	f7 c3 00 00 00 01    	test   $0x1000000,%ebx
  185639:	74 10                	je     18564b <__divdf3+0x3ad>
  18563b:	8b 7c 24 0c          	mov    0xc(%esp),%edi
  18563f:	81 e3 ff ff ff fe    	and    $0xfeffffff,%ebx
  185645:	81 c7 00 04 00 00    	add    $0x400,%edi
  18564b:	81 ff fe 07 00 00    	cmp    $0x7fe,%edi
  185651:	0f 8f f3 00 00 00    	jg     18574a <__divdf3+0x4ac>
  185657:	c1 ee 03             	shr    $0x3,%esi
  18565a:	89 d8                	mov    %ebx,%eax
  18565c:	c1 e0 1d             	shl    $0x1d,%eax
  18565f:	c1 eb 03             	shr    $0x3,%ebx
  185662:	09 c6                	or     %eax,%esi
  185664:	e9 08 01 00 00       	jmp    185771 <__divdf3+0x4d3>
  185669:	b8 01 00 00 00       	mov    $0x1,%eax
  18566e:	89 c2                	mov    %eax,%edx
  185670:	29 fa                	sub    %edi,%edx
  185672:	83 fa 38             	cmp    $0x38,%edx
  185675:	0f 8f 88 00 00 00    	jg     185703 <__divdf3+0x465>
  18567b:	83 fa 1f             	cmp    $0x1f,%edx
  18567e:	7f 2a                	jg     1856aa <__divdf3+0x40c>
  185680:	b8 20 00 00 00       	mov    $0x20,%eax
  185685:	89 df                	mov    %ebx,%edi
  185687:	29 d0                	sub    %edx,%eax
  185689:	89 f5                	mov    %esi,%ebp
  18568b:	88 c1                	mov    %al,%cl
  18568d:	d3 e7                	shl    %cl,%edi
  18568f:	88 d1                	mov    %dl,%cl
  185691:	d3 ed                	shr    %cl,%ebp
  185693:	88 c1                	mov    %al,%cl
  185695:	31 c0                	xor    %eax,%eax
  185697:	d3 e6                	shl    %cl,%esi
  185699:	09 ef                	or     %ebp,%edi
  18569b:	85 f6                	test   %esi,%esi
  18569d:	0f 95 c0             	setne  %al
  1856a0:	09 c7                	or     %eax,%edi
  1856a2:	88 d1                	mov    %dl,%cl
  1856a4:	89 fe                	mov    %edi,%esi
  1856a6:	d3 eb                	shr    %cl,%ebx
  1856a8:	eb 2a                	jmp    1856d4 <__divdf3+0x436>
  1856aa:	b9 e1 ff ff ff       	mov    $0xffffffe1,%ecx
  1856af:	89 d8                	mov    %ebx,%eax
  1856b1:	29 f9                	sub    %edi,%ecx
  1856b3:	d3 e8                	shr    %cl,%eax
  1856b5:	31 c9                	xor    %ecx,%ecx
  1856b7:	83 fa 20             	cmp    $0x20,%edx
  1856ba:	74 0b                	je     1856c7 <__divdf3+0x429>
  1856bc:	b9 40 00 00 00       	mov    $0x40,%ecx
  1856c1:	29 d1                	sub    %edx,%ecx
  1856c3:	d3 e3                	shl    %cl,%ebx
  1856c5:	89 d9                	mov    %ebx,%ecx
  1856c7:	31 d2                	xor    %edx,%edx
  1856c9:	09 f1                	or     %esi,%ecx
  1856cb:	0f 95 c2             	setne  %dl
  1856ce:	09 d0                	or     %edx,%eax
  1856d0:	31 db                	xor    %ebx,%ebx
  1856d2:	89 c6                	mov    %eax,%esi
  1856d4:	f7 c6 07 00 00 00    	test   $0x7,%esi
  1856da:	74 10                	je     1856ec <__divdf3+0x44e>
  1856dc:	89 f0                	mov    %esi,%eax
  1856de:	83 e0 0f             	and    $0xf,%eax
  1856e1:	83 f8 04             	cmp    $0x4,%eax
  1856e4:	74 06                	je     1856ec <__divdf3+0x44e>
  1856e6:	83 c6 04             	add    $0x4,%esi
  1856e9:	83 d3 00             	adc    $0x0,%ebx
  1856ec:	f7 c3 00 00 80 00    	test   $0x800000,%ebx
  1856f2:	75 5c                	jne    185750 <__divdf3+0x4b2>
  1856f4:	c1 ee 03             	shr    $0x3,%esi
  1856f7:	89 d8                	mov    %ebx,%eax
  1856f9:	c1 e0 1d             	shl    $0x1d,%eax
  1856fc:	c1 eb 03             	shr    $0x3,%ebx
  1856ff:	09 c6                	or     %eax,%esi
  185701:	eb 5a                	jmp    18575d <__divdf3+0x4bf>
  185703:	09 f3                	or     %esi,%ebx
  185705:	bb 00 00 00 00       	mov    $0x0,%ebx
  18570a:	74 4f                	je     18575b <__divdf3+0x4bd>
  18570c:	89 c6                	mov    %eax,%esi
  18570e:	83 c6 04             	add    $0x4,%esi
  185711:	83 d3 00             	adc    $0x0,%ebx
  185714:	c1 ee 03             	shr    $0x3,%esi
  185717:	eb 44                	jmp    18575d <__divdf3+0x4bf>
  185719:	8b 44 24 10          	mov    0x10(%esp),%eax
  18571d:	89 04 24             	mov    %eax,(%esp)
  185720:	eb 28                	jmp    18574a <__divdf3+0x4ac>
  185722:	bf 00 00 08 00       	mov    $0x80000,%edi
  185727:	31 f6                	xor    %esi,%esi
  185729:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  185730:	89 fb                	mov    %edi,%ebx
  185732:	81 cb 00 00 08 00    	or     $0x80000,%ebx
  185738:	bf ff 07 00 00       	mov    $0x7ff,%edi
  18573d:	eb 32                	jmp    185771 <__divdf3+0x4d3>
  18573f:	8b 44 24 10          	mov    0x10(%esp),%eax
  185743:	89 04 24             	mov    %eax,(%esp)
  185746:	31 db                	xor    %ebx,%ebx
  185748:	eb 11                	jmp    18575b <__divdf3+0x4bd>
  18574a:	31 db                	xor    %ebx,%ebx
  18574c:	31 f6                	xor    %esi,%esi
  18574e:	eb e8                	jmp    185738 <__divdf3+0x49a>
  185750:	31 db                	xor    %ebx,%ebx
  185752:	31 f6                	xor    %esi,%esi
  185754:	bf 01 00 00 00       	mov    $0x1,%edi
  185759:	eb 16                	jmp    185771 <__divdf3+0x4d3>
  18575b:	31 f6                	xor    %esi,%esi
  18575d:	31 ff                	xor    %edi,%edi
  18575f:	eb 10                	jmp    185771 <__divdf3+0x4d3>
  185761:	8b 44 24 10          	mov    0x10(%esp),%eax
  185765:	89 04 24             	mov    %eax,(%esp)
  185768:	e9 a0 fe ff ff       	jmp    18560d <__divdf3+0x36f>
  18576d:	89 df                	mov    %ebx,%edi
  18576f:	eb bf                	jmp    185730 <__divdf3+0x492>
  185771:	31 d2                	xor    %edx,%edx
  185773:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
  185779:	89 d1                	mov    %edx,%ecx
  18577b:	81 e7 ff 07 00 00    	and    $0x7ff,%edi
  185781:	81 e1 00 00 f0 ff    	and    $0xfff00000,%ecx
  185787:	89 f0                	mov    %esi,%eax
  185789:	c1 e7 14             	shl    $0x14,%edi
  18578c:	09 cb                	or     %ecx,%ebx
  18578e:	81 e3 ff ff 0f 80    	and    $0x800fffff,%ebx
  185794:	8b 0c 24             	mov    (%esp),%ecx
  185797:	09 fb                	or     %edi,%ebx
  185799:	83 c4 20             	add    $0x20,%esp
  18579c:	c1 e1 1f             	shl    $0x1f,%ecx
  18579f:	81 e3 ff ff ff 7f    	and    $0x7fffffff,%ebx
  1857a5:	09 cb                	or     %ecx,%ebx
  1857a7:	89 da                	mov    %ebx,%edx
  1857a9:	5b                   	pop    %ebx
  1857aa:	5e                   	pop    %esi
  1857ab:	5f                   	pop    %edi
  1857ac:	5d                   	pop    %ebp
  1857ad:	c3                   	ret    

001857ae <__gedf2>:
  1857ae:	55                   	push   %ebp
  1857af:	57                   	push   %edi
  1857b0:	56                   	push   %esi
  1857b1:	53                   	push   %ebx
  1857b2:	83 ec 10             	sub    $0x10,%esp
  1857b5:	89 c1                	mov    %eax,%ecx
  1857b7:	89 d0                	mov    %edx,%eax
  1857b9:	89 d3                	mov    %edx,%ebx
  1857bb:	25 ff ff 0f 00       	and    $0xfffff,%eax
  1857c0:	89 d5                	mov    %edx,%ebp
  1857c2:	89 04 24             	mov    %eax,(%esp)
  1857c5:	8b 44 24 28          	mov    0x28(%esp),%eax
  1857c9:	c1 eb 14             	shr    $0x14,%ebx
  1857cc:	89 c7                	mov    %eax,%edi
  1857ce:	89 c2                	mov    %eax,%edx
  1857d0:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
  1857d6:	c1 ed 1f             	shr    $0x1f,%ebp
  1857d9:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
  1857df:	c1 ea 14             	shr    $0x14,%edx
  1857e2:	89 6c 24 08          	mov    %ebp,0x8(%esp)
  1857e6:	c1 e8 1f             	shr    $0x1f,%eax
  1857e9:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
  1857ef:	8b 74 24 24          	mov    0x24(%esp),%esi
  1857f3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  1857f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1857fb:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  185801:	75 10                	jne    185813 <__gedf2+0x65>
  185803:	8b 3c 24             	mov    (%esp),%edi
  185806:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  18580b:	09 cf                	or     %ecx,%edi
  18580d:	0f 85 a3 00 00 00    	jne    1858b6 <__gedf2+0x108>
  185813:	81 fa ff 07 00 00    	cmp    $0x7ff,%edx
  185819:	75 11                	jne    18582c <__gedf2+0x7e>
  18581b:	8b 7c 24 04          	mov    0x4(%esp),%edi
  18581f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  185824:	09 f7                	or     %esi,%edi
  185826:	0f 85 8a 00 00 00    	jne    1858b6 <__gedf2+0x108>
  18582c:	31 ed                	xor    %ebp,%ebp
  18582e:	85 db                	test   %ebx,%ebx
  185830:	75 0d                	jne    18583f <__gedf2+0x91>
  185832:	8b 04 24             	mov    (%esp),%eax
  185835:	09 c8                	or     %ecx,%eax
  185837:	0f 94 c0             	sete   %al
  18583a:	0f b6 c0             	movzbl %al,%eax
  18583d:	89 c5                	mov    %eax,%ebp
  18583f:	31 ff                	xor    %edi,%edi
  185841:	85 d2                	test   %edx,%edx
  185843:	75 0e                	jne    185853 <__gedf2+0xa5>
  185845:	8b 44 24 04          	mov    0x4(%esp),%eax
  185849:	09 f0                	or     %esi,%eax
  18584b:	0f 94 c0             	sete   %al
  18584e:	0f b6 c0             	movzbl %al,%eax
  185851:	89 c7                	mov    %eax,%edi
  185853:	31 c0                	xor    %eax,%eax
  185855:	85 fd                	test   %edi,%ebp
  185857:	75 5d                	jne    1858b6 <__gedf2+0x108>
  185859:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  18585e:	85 ed                	test   %ebp,%ebp
  185860:	74 05                	je     185867 <__gedf2+0xb9>
  185862:	83 f8 01             	cmp    $0x1,%eax
  185865:	eb 46                	jmp    1858ad <__gedf2+0xff>
  185867:	0f b6 6c 24 08       	movzbl 0x8(%esp),%ebp
  18586c:	85 ff                	test   %edi,%edi
  18586e:	75 1e                	jne    18588e <__gedf2+0xe0>
  185870:	39 c5                	cmp    %eax,%ebp
  185872:	75 1a                	jne    18588e <__gedf2+0xe0>
  185874:	39 d3                	cmp    %edx,%ebx
  185876:	7f 16                	jg     18588e <__gedf2+0xe0>
  185878:	7c 30                	jl     1858aa <__gedf2+0xfc>
  18587a:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  18587e:	39 1c 24             	cmp    %ebx,(%esp)
  185881:	77 0b                	ja     18588e <__gedf2+0xe0>
  185883:	0f 94 c0             	sete   %al
  185886:	39 f1                	cmp    %esi,%ecx
  185888:	76 0f                	jbe    185899 <__gedf2+0xeb>
  18588a:	84 c0                	test   %al,%al
  18588c:	74 0b                	je     185899 <__gedf2+0xeb>
  18588e:	83 fd 01             	cmp    $0x1,%ebp
  185891:	19 c0                	sbb    %eax,%eax
  185893:	83 e0 02             	and    $0x2,%eax
  185896:	48                   	dec    %eax
  185897:	eb 1d                	jmp    1858b6 <__gedf2+0x108>
  185899:	8b 7c 24 04          	mov    0x4(%esp),%edi
  18589d:	39 3c 24             	cmp    %edi,(%esp)
  1858a0:	72 08                	jb     1858aa <__gedf2+0xfc>
  1858a2:	39 f1                	cmp    %esi,%ecx
  1858a4:	73 0e                	jae    1858b4 <__gedf2+0x106>
  1858a6:	84 c0                	test   %al,%al
  1858a8:	74 0a                	je     1858b4 <__gedf2+0x106>
  1858aa:	83 fd 01             	cmp    $0x1,%ebp
  1858ad:	19 c0                	sbb    %eax,%eax
  1858af:	83 c8 01             	or     $0x1,%eax
  1858b2:	eb 02                	jmp    1858b6 <__gedf2+0x108>
  1858b4:	31 c0                	xor    %eax,%eax
  1858b6:	83 c4 10             	add    $0x10,%esp
  1858b9:	5b                   	pop    %ebx
  1858ba:	5e                   	pop    %esi
  1858bb:	5f                   	pop    %edi
  1858bc:	5d                   	pop    %ebp
  1858bd:	c3                   	ret    

001858be <__ledf2>:
  1858be:	55                   	push   %ebp
  1858bf:	57                   	push   %edi
  1858c0:	56                   	push   %esi
  1858c1:	53                   	push   %ebx
  1858c2:	83 ec 10             	sub    $0x10,%esp
  1858c5:	89 c1                	mov    %eax,%ecx
  1858c7:	89 d0                	mov    %edx,%eax
  1858c9:	89 d3                	mov    %edx,%ebx
  1858cb:	25 ff ff 0f 00       	and    $0xfffff,%eax
  1858d0:	89 d5                	mov    %edx,%ebp
  1858d2:	89 04 24             	mov    %eax,(%esp)
  1858d5:	8b 44 24 28          	mov    0x28(%esp),%eax
  1858d9:	c1 eb 14             	shr    $0x14,%ebx
  1858dc:	89 c7                	mov    %eax,%edi
  1858de:	89 c2                	mov    %eax,%edx
  1858e0:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
  1858e6:	c1 ed 1f             	shr    $0x1f,%ebp
  1858e9:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
  1858ef:	c1 ea 14             	shr    $0x14,%edx
  1858f2:	89 6c 24 08          	mov    %ebp,0x8(%esp)
  1858f6:	c1 e8 1f             	shr    $0x1f,%eax
  1858f9:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
  1858ff:	8b 74 24 24          	mov    0x24(%esp),%esi
  185903:	89 7c 24 04          	mov    %edi,0x4(%esp)
  185907:	89 44 24 0c          	mov    %eax,0xc(%esp)
  18590b:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  185911:	75 10                	jne    185923 <__ledf2+0x65>
  185913:	8b 3c 24             	mov    (%esp),%edi
  185916:	b8 02 00 00 00       	mov    $0x2,%eax
  18591b:	09 cf                	or     %ecx,%edi
  18591d:	0f 85 a3 00 00 00    	jne    1859c6 <__ledf2+0x108>
  185923:	81 fa ff 07 00 00    	cmp    $0x7ff,%edx
  185929:	75 11                	jne    18593c <__ledf2+0x7e>
  18592b:	8b 7c 24 04          	mov    0x4(%esp),%edi
  18592f:	b8 02 00 00 00       	mov    $0x2,%eax
  185934:	09 f7                	or     %esi,%edi
  185936:	0f 85 8a 00 00 00    	jne    1859c6 <__ledf2+0x108>
  18593c:	31 ed                	xor    %ebp,%ebp
  18593e:	85 db                	test   %ebx,%ebx
  185940:	75 0d                	jne    18594f <__ledf2+0x91>
  185942:	8b 04 24             	mov    (%esp),%eax
  185945:	09 c8                	or     %ecx,%eax
  185947:	0f 94 c0             	sete   %al
  18594a:	0f b6 c0             	movzbl %al,%eax
  18594d:	89 c5                	mov    %eax,%ebp
  18594f:	31 ff                	xor    %edi,%edi
  185951:	85 d2                	test   %edx,%edx
  185953:	75 0e                	jne    185963 <__ledf2+0xa5>
  185955:	8b 44 24 04          	mov    0x4(%esp),%eax
  185959:	09 f0                	or     %esi,%eax
  18595b:	0f 94 c0             	sete   %al
  18595e:	0f b6 c0             	movzbl %al,%eax
  185961:	89 c7                	mov    %eax,%edi
  185963:	31 c0                	xor    %eax,%eax
  185965:	85 fd                	test   %edi,%ebp
  185967:	75 5d                	jne    1859c6 <__ledf2+0x108>
  185969:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  18596e:	85 ed                	test   %ebp,%ebp
  185970:	74 05                	je     185977 <__ledf2+0xb9>
  185972:	83 f8 01             	cmp    $0x1,%eax
  185975:	eb 46                	jmp    1859bd <__ledf2+0xff>
  185977:	0f b6 6c 24 08       	movzbl 0x8(%esp),%ebp
  18597c:	85 ff                	test   %edi,%edi
  18597e:	75 1e                	jne    18599e <__ledf2+0xe0>
  185980:	39 c5                	cmp    %eax,%ebp
  185982:	75 1a                	jne    18599e <__ledf2+0xe0>
  185984:	39 d3                	cmp    %edx,%ebx
  185986:	7f 16                	jg     18599e <__ledf2+0xe0>
  185988:	7c 30                	jl     1859ba <__ledf2+0xfc>
  18598a:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  18598e:	39 1c 24             	cmp    %ebx,(%esp)
  185991:	77 0b                	ja     18599e <__ledf2+0xe0>
  185993:	0f 94 c0             	sete   %al
  185996:	39 f1                	cmp    %esi,%ecx
  185998:	76 0f                	jbe    1859a9 <__ledf2+0xeb>
  18599a:	84 c0                	test   %al,%al
  18599c:	74 0b                	je     1859a9 <__ledf2+0xeb>
  18599e:	83 fd 01             	cmp    $0x1,%ebp
  1859a1:	19 c0                	sbb    %eax,%eax
  1859a3:	83 e0 02             	and    $0x2,%eax
  1859a6:	48                   	dec    %eax
  1859a7:	eb 1d                	jmp    1859c6 <__ledf2+0x108>
  1859a9:	8b 7c 24 04          	mov    0x4(%esp),%edi
  1859ad:	39 3c 24             	cmp    %edi,(%esp)
  1859b0:	72 08                	jb     1859ba <__ledf2+0xfc>
  1859b2:	39 f1                	cmp    %esi,%ecx
  1859b4:	73 0e                	jae    1859c4 <__ledf2+0x106>
  1859b6:	84 c0                	test   %al,%al
  1859b8:	74 0a                	je     1859c4 <__ledf2+0x106>
  1859ba:	83 fd 01             	cmp    $0x1,%ebp
  1859bd:	19 c0                	sbb    %eax,%eax
  1859bf:	83 c8 01             	or     $0x1,%eax
  1859c2:	eb 02                	jmp    1859c6 <__ledf2+0x108>
  1859c4:	31 c0                	xor    %eax,%eax
  1859c6:	83 c4 10             	add    $0x10,%esp
  1859c9:	5b                   	pop    %ebx
  1859ca:	5e                   	pop    %esi
  1859cb:	5f                   	pop    %edi
  1859cc:	5d                   	pop    %ebp
  1859cd:	c3                   	ret    

001859ce <__muldf3>:
  1859ce:	55                   	push   %ebp
  1859cf:	57                   	push   %edi
  1859d0:	56                   	push   %esi
  1859d1:	53                   	push   %ebx
  1859d2:	83 ec 20             	sub    $0x20,%esp
  1859d5:	89 d3                	mov    %edx,%ebx
  1859d7:	89 c7                	mov    %eax,%edi
  1859d9:	89 c6                	mov    %eax,%esi
  1859db:	89 d0                	mov    %edx,%eax
  1859dd:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  1859e1:	c1 ea 1f             	shr    $0x1f,%edx
  1859e4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  1859e8:	c1 e8 14             	shr    $0x14,%eax
  1859eb:	89 54 24 18          	mov    %edx,0x18(%esp)
  1859ef:	66 25 ff 07          	and    $0x7ff,%ax
  1859f3:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
  1859f9:	0f b6 54 24 18       	movzbl 0x18(%esp),%edx
  1859fe:	0f b7 c8             	movzwl %ax,%ecx
  185a01:	8b 6c 24 38          	mov    0x38(%esp),%ebp
  185a05:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  185a09:	66 85 c0             	test   %ax,%ax
  185a0c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  185a10:	74 23                	je     185a35 <__muldf3+0x67>
  185a12:	66 3d ff 07          	cmp    $0x7ff,%ax
  185a16:	74 7d                	je     185a95 <__muldf3+0xc7>
  185a18:	81 cb 00 00 10 00    	or     $0x100000,%ebx
  185a1e:	89 f8                	mov    %edi,%eax
  185a20:	c1 e3 03             	shl    $0x3,%ebx
  185a23:	c1 e8 1d             	shr    $0x1d,%eax
  185a26:	c1 e6 03             	shl    $0x3,%esi
  185a29:	09 c3                	or     %eax,%ebx
  185a2b:	81 6c 24 04 ff 03 00 	subl   $0x3ff,0x4(%esp)
  185a32:	00 
  185a33:	eb 57                	jmp    185a8c <__muldf3+0xbe>
  185a35:	89 f8                	mov    %edi,%eax
  185a37:	09 d8                	or     %ebx,%eax
  185a39:	74 69                	je     185aa4 <__muldf3+0xd6>
  185a3b:	85 db                	test   %ebx,%ebx
  185a3d:	74 08                	je     185a47 <__muldf3+0x79>
  185a3f:	0f bd f3             	bsr    %ebx,%esi
  185a42:	83 f6 1f             	xor    $0x1f,%esi
  185a45:	eb 09                	jmp    185a50 <__muldf3+0x82>
  185a47:	0f bd f7             	bsr    %edi,%esi
  185a4a:	83 f6 1f             	xor    $0x1f,%esi
  185a4d:	83 c6 20             	add    $0x20,%esi
  185a50:	8d 56 f5             	lea    -0xb(%esi),%edx
  185a53:	83 fa 1c             	cmp    $0x1c,%edx
  185a56:	7f 1c                	jg     185a74 <__muldf3+0xa6>
  185a58:	83 ee 08             	sub    $0x8,%esi
  185a5b:	89 f8                	mov    %edi,%eax
  185a5d:	89 f1                	mov    %esi,%ecx
  185a5f:	d3 e3                	shl    %cl,%ebx
  185a61:	b9 1d 00 00 00       	mov    $0x1d,%ecx
  185a66:	29 d1                	sub    %edx,%ecx
  185a68:	d3 e8                	shr    %cl,%eax
  185a6a:	89 f1                	mov    %esi,%ecx
  185a6c:	09 c3                	or     %eax,%ebx
  185a6e:	d3 e7                	shl    %cl,%edi
  185a70:	89 fe                	mov    %edi,%esi
  185a72:	eb 09                	jmp    185a7d <__muldf3+0xaf>
  185a74:	8d 4e d8             	lea    -0x28(%esi),%ecx
  185a77:	31 f6                	xor    %esi,%esi
  185a79:	d3 e7                	shl    %cl,%edi
  185a7b:	89 fb                	mov    %edi,%ebx
  185a7d:	8b 44 24 04          	mov    0x4(%esp),%eax
  185a81:	29 d0                	sub    %edx,%eax
  185a83:	2d fe 03 00 00       	sub    $0x3fe,%eax
  185a88:	89 44 24 04          	mov    %eax,0x4(%esp)
  185a8c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  185a93:	eb 27                	jmp    185abc <__muldf3+0xee>
  185a95:	89 f8                	mov    %edi,%eax
  185a97:	09 d8                	or     %ebx,%eax
  185a99:	74 16                	je     185ab1 <__muldf3+0xe3>
  185a9b:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  185aa2:	eb 18                	jmp    185abc <__muldf3+0xee>
  185aa4:	31 db                	xor    %ebx,%ebx
  185aa6:	31 f6                	xor    %esi,%esi
  185aa8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  185aaf:	eb 0b                	jmp    185abc <__muldf3+0xee>
  185ab1:	31 db                	xor    %ebx,%ebx
  185ab3:	31 f6                	xor    %esi,%esi
  185ab5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  185abc:	89 6c 24 10          	mov    %ebp,0x10(%esp)
  185ac0:	89 ef                	mov    %ebp,%edi
  185ac2:	c1 ed 14             	shr    $0x14,%ebp
  185ac5:	8b 44 24 08          	mov    0x8(%esp),%eax
  185ac9:	66 81 e5 ff 07       	and    $0x7ff,%bp
  185ace:	81 e7 ff ff 0f 00    	and    $0xfffff,%edi
  185ad4:	0f b7 d5             	movzwl %bp,%edx
  185ad7:	89 54 24 08          	mov    %edx,0x8(%esp)
  185adb:	8b 54 24 10          	mov    0x10(%esp),%edx
  185adf:	c1 ea 1f             	shr    $0x1f,%edx
  185ae2:	89 c1                	mov    %eax,%ecx
  185ae4:	66 85 ed             	test   %bp,%bp
  185ae7:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  185aeb:	0f b6 54 24 1c       	movzbl 0x1c(%esp),%edx
  185af0:	89 54 24 10          	mov    %edx,0x10(%esp)
  185af4:	74 28                	je     185b1e <__muldf3+0x150>
  185af6:	66 81 fd ff 07       	cmp    $0x7ff,%bp
  185afb:	0f 84 80 00 00 00    	je     185b81 <__muldf3+0x1b3>
  185b01:	81 cf 00 00 10 00    	or     $0x100000,%edi
  185b07:	89 c2                	mov    %eax,%edx
  185b09:	c1 e7 03             	shl    $0x3,%edi
  185b0c:	c1 ea 1d             	shr    $0x1d,%edx
  185b0f:	c1 e1 03             	shl    $0x3,%ecx
  185b12:	09 d7                	or     %edx,%edi
  185b14:	81 6c 24 08 ff 03 00 	subl   $0x3ff,0x8(%esp)
  185b1b:	00 
  185b1c:	eb 5f                	jmp    185b7d <__muldf3+0x1af>
  185b1e:	89 c2                	mov    %eax,%edx
  185b20:	09 fa                	or     %edi,%edx
  185b22:	74 71                	je     185b95 <__muldf3+0x1c7>
  185b24:	85 ff                	test   %edi,%edi
  185b26:	74 08                	je     185b30 <__muldf3+0x162>
  185b28:	0f bd cf             	bsr    %edi,%ecx
  185b2b:	83 f1 1f             	xor    $0x1f,%ecx
  185b2e:	eb 09                	jmp    185b39 <__muldf3+0x16b>
  185b30:	0f bd c8             	bsr    %eax,%ecx
  185b33:	83 f1 1f             	xor    $0x1f,%ecx
  185b36:	83 c1 20             	add    $0x20,%ecx
  185b39:	8d 69 f5             	lea    -0xb(%ecx),%ebp
  185b3c:	83 fd 1c             	cmp    $0x1c,%ebp
  185b3f:	7f 24                	jg     185b65 <__muldf3+0x197>
  185b41:	8d 51 f8             	lea    -0x8(%ecx),%edx
  185b44:	89 54 24 14          	mov    %edx,0x14(%esp)
  185b48:	89 c2                	mov    %eax,%edx
  185b4a:	8a 4c 24 14          	mov    0x14(%esp),%cl
  185b4e:	d3 e7                	shl    %cl,%edi
  185b50:	b9 1d 00 00 00       	mov    $0x1d,%ecx
  185b55:	29 e9                	sub    %ebp,%ecx
  185b57:	d3 ea                	shr    %cl,%edx
  185b59:	8a 4c 24 14          	mov    0x14(%esp),%cl
  185b5d:	09 d7                	or     %edx,%edi
  185b5f:	d3 e0                	shl    %cl,%eax
  185b61:	89 c1                	mov    %eax,%ecx
  185b63:	eb 09                	jmp    185b6e <__muldf3+0x1a0>
  185b65:	83 e9 28             	sub    $0x28,%ecx
  185b68:	d3 e0                	shl    %cl,%eax
  185b6a:	89 c7                	mov    %eax,%edi
  185b6c:	31 c9                	xor    %ecx,%ecx
  185b6e:	8b 44 24 08          	mov    0x8(%esp),%eax
  185b72:	29 e8                	sub    %ebp,%eax
  185b74:	2d fe 03 00 00       	sub    $0x3fe,%eax
  185b79:	89 44 24 08          	mov    %eax,0x8(%esp)
  185b7d:	31 c0                	xor    %eax,%eax
  185b7f:	eb 1d                	jmp    185b9e <__muldf3+0x1d0>
  185b81:	09 f8                	or     %edi,%eax
  185b83:	b8 03 00 00 00       	mov    $0x3,%eax
  185b88:	75 14                	jne    185b9e <__muldf3+0x1d0>
  185b8a:	31 ff                	xor    %edi,%edi
  185b8c:	31 c9                	xor    %ecx,%ecx
  185b8e:	b8 02 00 00 00       	mov    $0x2,%eax
  185b93:	eb 09                	jmp    185b9e <__muldf3+0x1d0>
  185b95:	31 ff                	xor    %edi,%edi
  185b97:	31 c9                	xor    %ecx,%ecx
  185b99:	b8 01 00 00 00       	mov    $0x1,%eax
  185b9e:	8a 54 24 1c          	mov    0x1c(%esp),%dl
  185ba2:	33 54 24 18          	xor    0x18(%esp),%edx
  185ba6:	0f b6 ea             	movzbl %dl,%ebp
  185ba9:	8b 54 24 04          	mov    0x4(%esp),%edx
  185bad:	03 54 24 08          	add    0x8(%esp),%edx
  185bb1:	89 54 24 08          	mov    %edx,0x8(%esp)
  185bb5:	42                   	inc    %edx
  185bb6:	89 54 24 04          	mov    %edx,0x4(%esp)
  185bba:	8b 14 24             	mov    (%esp),%edx
  185bbd:	c1 e2 02             	shl    $0x2,%edx
  185bc0:	09 c2                	or     %eax,%edx
  185bc2:	4a                   	dec    %edx
  185bc3:	83 fa 0e             	cmp    $0xe,%edx
  185bc6:	77 10                	ja     185bd8 <__muldf3+0x20a>
  185bc8:	ff 24 95 d8 6f 18 00 	jmp    *0x186fd8(,%edx,4)
  185bcf:	89 fb                	mov    %edi,%ebx
  185bd1:	89 ce                	mov    %ecx,%esi
  185bd3:	e9 cf 00 00 00       	jmp    185ca7 <__muldf3+0x2d9>
  185bd8:	89 f0                	mov    %esi,%eax
  185bda:	f7 e1                	mul    %ecx
  185bdc:	89 54 24 0c          	mov    %edx,0xc(%esp)
  185be0:	89 04 24             	mov    %eax,(%esp)
  185be3:	89 f0                	mov    %esi,%eax
  185be5:	f7 e7                	mul    %edi
  185be7:	89 54 24 10          	mov    %edx,0x10(%esp)
  185beb:	89 c6                	mov    %eax,%esi
  185bed:	89 d8                	mov    %ebx,%eax
  185bef:	f7 e1                	mul    %ecx
  185bf1:	31 c9                	xor    %ecx,%ecx
  185bf3:	89 54 24 18          	mov    %edx,0x18(%esp)
  185bf7:	89 44 24 14          	mov    %eax,0x14(%esp)
  185bfb:	89 d8                	mov    %ebx,%eax
  185bfd:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  185c01:	f7 e7                	mul    %edi
  185c03:	89 cf                	mov    %ecx,%edi
  185c05:	03 74 24 0c          	add    0xc(%esp),%esi
  185c09:	11 c3                	adc    %eax,%ebx
  185c0b:	11 d7                	adc    %edx,%edi
  185c0d:	89 c8                	mov    %ecx,%eax
  185c0f:	8b 54 24 14          	mov    0x14(%esp),%edx
  185c13:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  185c17:	01 f2                	add    %esi,%edx
  185c19:	11 d9                	adc    %ebx,%ecx
  185c1b:	11 f8                	adc    %edi,%eax
  185c1d:	89 ce                	mov    %ecx,%esi
  185c1f:	8b 3c 24             	mov    (%esp),%edi
  185c22:	c1 ee 17             	shr    $0x17,%esi
  185c25:	c1 e0 09             	shl    $0x9,%eax
  185c28:	89 f3                	mov    %esi,%ebx
  185c2a:	09 c3                	or     %eax,%ebx
  185c2c:	89 d0                	mov    %edx,%eax
  185c2e:	c1 e0 09             	shl    $0x9,%eax
  185c31:	09 c7                	or     %eax,%edi
  185c33:	0f 95 c0             	setne  %al
  185c36:	c1 e1 09             	shl    $0x9,%ecx
  185c39:	c1 ea 17             	shr    $0x17,%edx
  185c3c:	89 ce                	mov    %ecx,%esi
  185c3e:	09 d6                	or     %edx,%esi
  185c40:	0f b6 c0             	movzbl %al,%eax
  185c43:	09 c6                	or     %eax,%esi
  185c45:	f7 c3 00 00 00 01    	test   $0x1000000,%ebx
  185c4b:	0f 84 c8 01 00 00    	je     185e19 <__muldf3+0x44b>
  185c51:	89 f0                	mov    %esi,%eax
  185c53:	83 e6 01             	and    $0x1,%esi
  185c56:	d1 e8                	shr    %eax
  185c58:	09 c6                	or     %eax,%esi
  185c5a:	89 d8                	mov    %ebx,%eax
  185c5c:	c1 e0 1f             	shl    $0x1f,%eax
  185c5f:	d1 eb                	shr    %ebx
  185c61:	09 c6                	or     %eax,%esi
  185c63:	8b 44 24 04          	mov    0x4(%esp),%eax
  185c67:	89 44 24 08          	mov    %eax,0x8(%esp)
  185c6b:	e9 a9 01 00 00       	jmp    185e19 <__muldf3+0x44b>
  185c70:	39 fb                	cmp    %edi,%ebx
  185c72:	0f 87 ae 01 00 00    	ja     185e26 <__muldf3+0x458>
  185c78:	39 ce                	cmp    %ecx,%esi
  185c7a:	0f 93 c2             	setae  %dl
  185c7d:	39 fb                	cmp    %edi,%ebx
  185c7f:	0f 94 c0             	sete   %al
  185c82:	84 c2                	test   %al,%dl
  185c84:	0f 85 61 01 00 00    	jne    185deb <__muldf3+0x41d>
  185c8a:	8b 44 24 10          	mov    0x10(%esp),%eax
  185c8e:	89 ce                	mov    %ecx,%esi
  185c90:	89 44 24 0c          	mov    %eax,0xc(%esp)
  185c94:	e9 52 01 00 00       	jmp    185deb <__muldf3+0x41d>
  185c99:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  185c9d:	eb 0b                	jmp    185caa <__muldf3+0x2dc>
  185c9f:	89 fb                	mov    %edi,%ebx
  185ca1:	89 ce                	mov    %ecx,%esi
  185ca3:	8b 6c 24 10          	mov    0x10(%esp),%ebp
  185ca7:	89 04 24             	mov    %eax,(%esp)
  185caa:	83 3c 24 02          	cmpl   $0x2,(%esp)
  185cae:	0f 84 49 01 00 00    	je     185dfd <__muldf3+0x42f>
  185cb4:	83 3c 24 03          	cmpl   $0x3,(%esp)
  185cb8:	0f 84 33 01 00 00    	je     185df1 <__muldf3+0x423>
  185cbe:	83 3c 24 01          	cmpl   $0x1,(%esp)
  185cc2:	0f 84 31 01 00 00    	je     185df9 <__muldf3+0x42b>
  185cc8:	8b 44 24 04          	mov    0x4(%esp),%eax
  185ccc:	8d b8 ff 03 00 00    	lea    0x3ff(%eax),%edi
  185cd2:	85 ff                	test   %edi,%edi
  185cd4:	7e 4e                	jle    185d24 <__muldf3+0x356>
  185cd6:	f7 c6 07 00 00 00    	test   $0x7,%esi
  185cdc:	74 10                	je     185cee <__muldf3+0x320>
  185cde:	89 f0                	mov    %esi,%eax
  185ce0:	83 e0 0f             	and    $0xf,%eax
  185ce3:	83 f8 04             	cmp    $0x4,%eax
  185ce6:	74 06                	je     185cee <__muldf3+0x320>
  185ce8:	83 c6 04             	add    $0x4,%esi
  185ceb:	83 d3 00             	adc    $0x0,%ebx
  185cee:	f7 c3 00 00 00 01    	test   $0x1000000,%ebx
  185cf4:	74 10                	je     185d06 <__muldf3+0x338>
  185cf6:	8b 7c 24 04          	mov    0x4(%esp),%edi
  185cfa:	81 e3 ff ff ff fe    	and    $0xfeffffff,%ebx
  185d00:	81 c7 00 04 00 00    	add    $0x400,%edi
  185d06:	81 ff fe 07 00 00    	cmp    $0x7fe,%edi
  185d0c:	0f 8f eb 00 00 00    	jg     185dfd <__muldf3+0x42f>
  185d12:	c1 ee 03             	shr    $0x3,%esi
  185d15:	89 d8                	mov    %ebx,%eax
  185d17:	c1 e0 1d             	shl    $0x1d,%eax
  185d1a:	c1 eb 03             	shr    $0x3,%ebx
  185d1d:	09 c6                	or     %eax,%esi
  185d1f:	e9 06 01 00 00       	jmp    185e2a <__muldf3+0x45c>
  185d24:	b8 01 00 00 00       	mov    $0x1,%eax
  185d29:	89 c2                	mov    %eax,%edx
  185d2b:	29 fa                	sub    %edi,%edx
  185d2d:	83 fa 38             	cmp    $0x38,%edx
  185d30:	0f 8f 90 00 00 00    	jg     185dc6 <__muldf3+0x3f8>
  185d36:	83 fa 1f             	cmp    $0x1f,%edx
  185d39:	7f 32                	jg     185d6d <__muldf3+0x39f>
  185d3b:	b8 20 00 00 00       	mov    $0x20,%eax
  185d40:	89 df                	mov    %ebx,%edi
  185d42:	29 d0                	sub    %edx,%eax
  185d44:	88 c1                	mov    %al,%cl
  185d46:	d3 e7                	shl    %cl,%edi
  185d48:	89 3c 24             	mov    %edi,(%esp)
  185d4b:	88 d1                	mov    %dl,%cl
  185d4d:	89 f7                	mov    %esi,%edi
  185d4f:	d3 ef                	shr    %cl,%edi
  185d51:	89 f9                	mov    %edi,%ecx
  185d53:	8b 3c 24             	mov    (%esp),%edi
  185d56:	09 cf                	or     %ecx,%edi
  185d58:	88 c1                	mov    %al,%cl
  185d5a:	d3 e6                	shl    %cl,%esi
  185d5c:	31 c0                	xor    %eax,%eax
  185d5e:	85 f6                	test   %esi,%esi
  185d60:	0f 95 c0             	setne  %al
  185d63:	09 c7                	or     %eax,%edi
  185d65:	88 d1                	mov    %dl,%cl
  185d67:	89 fe                	mov    %edi,%esi
  185d69:	d3 eb                	shr    %cl,%ebx
  185d6b:	eb 2a                	jmp    185d97 <__muldf3+0x3c9>
  185d6d:	b9 e1 ff ff ff       	mov    $0xffffffe1,%ecx
  185d72:	89 d8                	mov    %ebx,%eax
  185d74:	29 f9                	sub    %edi,%ecx
  185d76:	d3 e8                	shr    %cl,%eax
  185d78:	31 c9                	xor    %ecx,%ecx
  185d7a:	83 fa 20             	cmp    $0x20,%edx
  185d7d:	74 0b                	je     185d8a <__muldf3+0x3bc>
  185d7f:	b9 40 00 00 00       	mov    $0x40,%ecx
  185d84:	29 d1                	sub    %edx,%ecx
  185d86:	d3 e3                	shl    %cl,%ebx
  185d88:	89 d9                	mov    %ebx,%ecx
  185d8a:	31 d2                	xor    %edx,%edx
  185d8c:	09 f1                	or     %esi,%ecx
  185d8e:	0f 95 c2             	setne  %dl
  185d91:	09 d0                	or     %edx,%eax
  185d93:	31 db                	xor    %ebx,%ebx
  185d95:	89 c6                	mov    %eax,%esi
  185d97:	f7 c6 07 00 00 00    	test   $0x7,%esi
  185d9d:	74 10                	je     185daf <__muldf3+0x3e1>
  185d9f:	89 f0                	mov    %esi,%eax
  185da1:	83 e0 0f             	and    $0xf,%eax
  185da4:	83 f8 04             	cmp    $0x4,%eax
  185da7:	74 06                	je     185daf <__muldf3+0x3e1>
  185da9:	83 c6 04             	add    $0x4,%esi
  185dac:	83 d3 00             	adc    $0x0,%ebx
  185daf:	f7 c3 00 00 80 00    	test   $0x800000,%ebx
  185db5:	75 51                	jne    185e08 <__muldf3+0x43a>
  185db7:	c1 ee 03             	shr    $0x3,%esi
  185dba:	89 d8                	mov    %ebx,%eax
  185dbc:	c1 e0 1d             	shl    $0x1d,%eax
  185dbf:	c1 eb 03             	shr    $0x3,%ebx
  185dc2:	09 c6                	or     %eax,%esi
  185dc4:	eb 4f                	jmp    185e15 <__muldf3+0x447>
  185dc6:	09 f3                	or     %esi,%ebx
  185dc8:	bb 00 00 00 00       	mov    $0x0,%ebx
  185dcd:	74 44                	je     185e13 <__muldf3+0x445>
  185dcf:	89 c6                	mov    %eax,%esi
  185dd1:	83 c6 04             	add    $0x4,%esi
  185dd4:	83 d3 00             	adc    $0x0,%ebx
  185dd7:	c1 ee 03             	shr    $0x3,%esi
  185dda:	eb 39                	jmp    185e15 <__muldf3+0x447>
  185ddc:	bf 00 00 08 00       	mov    $0x80000,%edi
  185de1:	31 f6                	xor    %esi,%esi
  185de3:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  185dea:	00 
  185deb:	89 fb                	mov    %edi,%ebx
  185ded:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  185df1:	81 cb 00 00 08 00    	or     $0x80000,%ebx
  185df7:	eb 08                	jmp    185e01 <__muldf3+0x433>
  185df9:	31 db                	xor    %ebx,%ebx
  185dfb:	eb 16                	jmp    185e13 <__muldf3+0x445>
  185dfd:	31 db                	xor    %ebx,%ebx
  185dff:	31 f6                	xor    %esi,%esi
  185e01:	bf ff 07 00 00       	mov    $0x7ff,%edi
  185e06:	eb 22                	jmp    185e2a <__muldf3+0x45c>
  185e08:	31 db                	xor    %ebx,%ebx
  185e0a:	31 f6                	xor    %esi,%esi
  185e0c:	bf 01 00 00 00       	mov    $0x1,%edi
  185e11:	eb 17                	jmp    185e2a <__muldf3+0x45c>
  185e13:	31 f6                	xor    %esi,%esi
  185e15:	31 ff                	xor    %edi,%edi
  185e17:	eb 11                	jmp    185e2a <__muldf3+0x45c>
  185e19:	8b 44 24 08          	mov    0x8(%esp),%eax
  185e1d:	89 44 24 04          	mov    %eax,0x4(%esp)
  185e21:	e9 a2 fe ff ff       	jmp    185cc8 <__muldf3+0x2fa>
  185e26:	89 df                	mov    %ebx,%edi
  185e28:	eb c1                	jmp    185deb <__muldf3+0x41d>
  185e2a:	31 d2                	xor    %edx,%edx
  185e2c:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
  185e32:	89 d1                	mov    %edx,%ecx
  185e34:	81 e7 ff 07 00 00    	and    $0x7ff,%edi
  185e3a:	81 e1 00 00 f0 ff    	and    $0xfff00000,%ecx
  185e40:	83 c4 20             	add    $0x20,%esp
  185e43:	09 cb                	or     %ecx,%ebx
  185e45:	89 e9                	mov    %ebp,%ecx
  185e47:	c1 e7 14             	shl    $0x14,%edi
  185e4a:	81 e3 ff ff 0f 80    	and    $0x800fffff,%ebx
  185e50:	09 fb                	or     %edi,%ebx
  185e52:	89 f0                	mov    %esi,%eax
  185e54:	c1 e1 1f             	shl    $0x1f,%ecx
  185e57:	81 e3 ff ff ff 7f    	and    $0x7fffffff,%ebx
  185e5d:	09 cb                	or     %ecx,%ebx
  185e5f:	89 da                	mov    %ebx,%edx
  185e61:	5b                   	pop    %ebx
  185e62:	5e                   	pop    %esi
  185e63:	5f                   	pop    %edi
  185e64:	5d                   	pop    %ebp
  185e65:	c3                   	ret    

00185e66 <__subdf3>:
  185e66:	55                   	push   %ebp
  185e67:	89 d1                	mov    %edx,%ecx
  185e69:	57                   	push   %edi
  185e6a:	56                   	push   %esi
  185e6b:	53                   	push   %ebx
  185e6c:	81 e1 ff ff 0f 00    	and    $0xfffff,%ecx
  185e72:	83 ec 10             	sub    $0x10,%esp
  185e75:	89 d3                	mov    %edx,%ebx
  185e77:	c1 ea 1f             	shr    $0x1f,%edx
  185e7a:	89 54 24 04          	mov    %edx,0x4(%esp)
  185e7e:	8d 14 cd 00 00 00 00 	lea    0x0(,%ecx,8),%edx
  185e85:	89 c1                	mov    %eax,%ecx
  185e87:	8b 7c 24 24          	mov    0x24(%esp),%edi
  185e8b:	c1 e9 1d             	shr    $0x1d,%ecx
  185e8e:	c1 eb 14             	shr    $0x14,%ebx
  185e91:	09 ca                	or     %ecx,%edx
  185e93:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  185e97:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
  185e9d:	89 cd                	mov    %ecx,%ebp
  185e9f:	89 ce                	mov    %ecx,%esi
  185ea1:	c1 ed 14             	shr    $0x14,%ebp
  185ea4:	81 e6 ff ff 0f 00    	and    $0xfffff,%esi
  185eaa:	c1 e6 03             	shl    $0x3,%esi
  185ead:	81 e5 ff 07 00 00    	and    $0x7ff,%ebp
  185eb3:	c1 e0 03             	shl    $0x3,%eax
  185eb6:	89 6c 24 08          	mov    %ebp,0x8(%esp)
  185eba:	c1 e9 1f             	shr    $0x1f,%ecx
  185ebd:	89 fd                	mov    %edi,%ebp
  185ebf:	c1 ed 1d             	shr    $0x1d,%ebp
  185ec2:	c1 e7 03             	shl    $0x3,%edi
  185ec5:	09 f5                	or     %esi,%ebp
  185ec7:	81 7c 24 08 ff 07 00 	cmpl   $0x7ff,0x8(%esp)
  185ece:	00 
  185ecf:	75 0e                	jne    185edf <__subdf3+0x79>
  185ed1:	89 ee                	mov    %ebp,%esi
  185ed3:	09 fe                	or     %edi,%esi
  185ed5:	74 08                	je     185edf <__subdf3+0x79>
  185ed7:	0f b6 f1             	movzbl %cl,%esi
  185eda:	89 34 24             	mov    %esi,(%esp)
  185edd:	eb 06                	jmp    185ee5 <__subdf3+0x7f>
  185edf:	83 f1 01             	xor    $0x1,%ecx
  185ee2:	89 0c 24             	mov    %ecx,(%esp)
  185ee5:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  185ee9:	89 de                	mov    %ebx,%esi
  185eeb:	2b 74 24 08          	sub    0x8(%esp),%esi
  185eef:	39 0c 24             	cmp    %ecx,(%esp)
  185ef2:	0f 85 cf 02 00 00    	jne    1861c7 <__subdf3+0x361>
  185ef8:	89 74 24 04          	mov    %esi,0x4(%esp)
  185efc:	83 fe 00             	cmp    $0x0,%esi
  185eff:	0f 8e d8 00 00 00    	jle    185fdd <__subdf3+0x177>
  185f05:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  185f0a:	75 26                	jne    185f32 <__subdf3+0xcc>
  185f0c:	89 ee                	mov    %ebp,%esi
  185f0e:	09 fe                	or     %edi,%esi
  185f10:	0f 84 d2 02 00 00    	je     1861e8 <__subdf3+0x382>
  185f16:	ff 4c 24 04          	decl   0x4(%esp)
  185f1a:	75 09                	jne    185f25 <__subdf3+0xbf>
  185f1c:	01 f8                	add    %edi,%eax
  185f1e:	11 ea                	adc    %ebp,%edx
  185f20:	e9 6c 02 00 00       	jmp    186191 <__subdf3+0x32b>
  185f25:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  185f2b:	75 17                	jne    185f44 <__subdf3+0xde>
  185f2d:	e9 92 06 00 00       	jmp    1865c4 <__subdf3+0x75e>
  185f32:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  185f38:	0f 84 86 06 00 00    	je     1865c4 <__subdf3+0x75e>
  185f3e:	81 cd 00 00 80 00    	or     $0x800000,%ebp
  185f44:	83 7c 24 04 38       	cmpl   $0x38,0x4(%esp)
  185f49:	7f 7e                	jg     185fc9 <__subdf3+0x163>
  185f4b:	83 7c 24 04 1f       	cmpl   $0x1f,0x4(%esp)
  185f50:	7f 48                	jg     185f9a <__subdf3+0x134>
  185f52:	b9 20 00 00 00       	mov    $0x20,%ecx
  185f57:	89 44 24 0c          	mov    %eax,0xc(%esp)
  185f5b:	2b 4c 24 04          	sub    0x4(%esp),%ecx
  185f5f:	89 e8                	mov    %ebp,%eax
  185f61:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  185f65:	8a 4c 24 08          	mov    0x8(%esp),%cl
  185f69:	d3 e0                	shl    %cl,%eax
  185f6b:	89 c6                	mov    %eax,%esi
  185f6d:	8a 4c 24 04          	mov    0x4(%esp),%cl
  185f71:	89 f8                	mov    %edi,%eax
  185f73:	d3 e8                	shr    %cl,%eax
  185f75:	89 c1                	mov    %eax,%ecx
  185f77:	8b 44 24 0c          	mov    0xc(%esp),%eax
  185f7b:	09 f1                	or     %esi,%ecx
  185f7d:	89 ce                	mov    %ecx,%esi
  185f7f:	8a 4c 24 08          	mov    0x8(%esp),%cl
  185f83:	d3 e7                	shl    %cl,%edi
  185f85:	31 c9                	xor    %ecx,%ecx
  185f87:	85 ff                	test   %edi,%edi
  185f89:	89 f7                	mov    %esi,%edi
  185f8b:	0f 95 c1             	setne  %cl
  185f8e:	09 cf                	or     %ecx,%edi
  185f90:	8a 4c 24 04          	mov    0x4(%esp),%cl
  185f94:	d3 ed                	shr    %cl,%ebp
  185f96:	89 ee                	mov    %ebp,%esi
  185f98:	eb 3a                	jmp    185fd4 <__subdf3+0x16e>
  185f9a:	8b 74 24 04          	mov    0x4(%esp),%esi
  185f9e:	8d 4e e0             	lea    -0x20(%esi),%ecx
  185fa1:	89 ee                	mov    %ebp,%esi
  185fa3:	d3 ee                	shr    %cl,%esi
  185fa5:	31 c9                	xor    %ecx,%ecx
  185fa7:	83 7c 24 04 20       	cmpl   $0x20,0x4(%esp)
  185fac:	74 0d                	je     185fbb <__subdf3+0x155>
  185fae:	b9 40 00 00 00       	mov    $0x40,%ecx
  185fb3:	2b 4c 24 04          	sub    0x4(%esp),%ecx
  185fb7:	d3 e5                	shl    %cl,%ebp
  185fb9:	89 e9                	mov    %ebp,%ecx
  185fbb:	09 f9                	or     %edi,%ecx
  185fbd:	89 f7                	mov    %esi,%edi
  185fbf:	0f 95 c1             	setne  %cl
  185fc2:	0f b6 c9             	movzbl %cl,%ecx
  185fc5:	09 cf                	or     %ecx,%edi
  185fc7:	eb 09                	jmp    185fd2 <__subdf3+0x16c>
  185fc9:	31 c9                	xor    %ecx,%ecx
  185fcb:	09 fd                	or     %edi,%ebp
  185fcd:	0f 95 c1             	setne  %cl
  185fd0:	89 cf                	mov    %ecx,%edi
  185fd2:	31 f6                	xor    %esi,%esi
  185fd4:	01 f8                	add    %edi,%eax
  185fd6:	11 f2                	adc    %esi,%edx
  185fd8:	e9 b4 01 00 00       	jmp    186191 <__subdf3+0x32b>
  185fdd:	0f 84 da 00 00 00    	je     1860bd <__subdf3+0x257>
  185fe3:	85 db                	test   %ebx,%ebx
  185fe5:	75 31                	jne    186018 <__subdf3+0x1b2>
  185fe7:	89 d6                	mov    %edx,%esi
  185fe9:	09 c6                	or     %eax,%esi
  185feb:	0f 84 e3 02 00 00    	je     1862d4 <__subdf3+0x46e>
  185ff1:	8b 74 24 04          	mov    0x4(%esp),%esi
  185ff5:	83 f6 ff             	xor    $0xffffffff,%esi
  185ff8:	75 0f                	jne    186009 <__subdf3+0x1a3>
  185ffa:	89 ee                	mov    %ebp,%esi
  185ffc:	01 c7                	add    %eax,%edi
  185ffe:	11 d6                	adc    %edx,%esi
  186000:	89 f2                	mov    %esi,%edx
  186002:	89 f8                	mov    %edi,%eax
  186004:	e9 ab 00 00 00       	jmp    1860b4 <__subdf3+0x24e>
  186009:	81 7c 24 08 ff 07 00 	cmpl   $0x7ff,0x8(%esp)
  186010:	00 
  186011:	75 1f                	jne    186032 <__subdf3+0x1cc>
  186013:	e9 25 06 00 00       	jmp    18663d <__subdf3+0x7d7>
  186018:	81 7c 24 08 ff 07 00 	cmpl   $0x7ff,0x8(%esp)
  18601f:	00 
  186020:	0f 84 17 06 00 00    	je     18663d <__subdf3+0x7d7>
  186026:	8b 74 24 04          	mov    0x4(%esp),%esi
  18602a:	81 ca 00 00 80 00    	or     $0x800000,%edx
  186030:	f7 de                	neg    %esi
  186032:	83 fe 38             	cmp    $0x38,%esi
  186035:	7f 6c                	jg     1860a3 <__subdf3+0x23d>
  186037:	83 fe 1f             	cmp    $0x1f,%esi
  18603a:	7f 42                	jg     18607e <__subdf3+0x218>
  18603c:	bb 20 00 00 00       	mov    $0x20,%ebx
  186041:	29 f3                	sub    %esi,%ebx
  186043:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  186047:	89 d3                	mov    %edx,%ebx
  186049:	8a 4c 24 04          	mov    0x4(%esp),%cl
  18604d:	d3 e3                	shl    %cl,%ebx
  18604f:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  186053:	89 f1                	mov    %esi,%ecx
  186055:	89 c3                	mov    %eax,%ebx
  186057:	d3 eb                	shr    %cl,%ebx
  186059:	89 d9                	mov    %ebx,%ecx
  18605b:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  18605f:	09 cb                	or     %ecx,%ebx
  186061:	8a 4c 24 04          	mov    0x4(%esp),%cl
  186065:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  186069:	31 db                	xor    %ebx,%ebx
  18606b:	d3 e0                	shl    %cl,%eax
  18606d:	89 f1                	mov    %esi,%ecx
  18606f:	85 c0                	test   %eax,%eax
  186071:	0f 95 c3             	setne  %bl
  186074:	d3 ea                	shr    %cl,%edx
  186076:	0b 5c 24 0c          	or     0xc(%esp),%ebx
  18607a:	89 d1                	mov    %edx,%ecx
  18607c:	eb 2e                	jmp    1860ac <__subdf3+0x246>
  18607e:	8d 4e e0             	lea    -0x20(%esi),%ecx
  186081:	89 d3                	mov    %edx,%ebx
  186083:	d3 eb                	shr    %cl,%ebx
  186085:	31 c9                	xor    %ecx,%ecx
  186087:	83 fe 20             	cmp    $0x20,%esi
  18608a:	74 0b                	je     186097 <__subdf3+0x231>
  18608c:	b9 40 00 00 00       	mov    $0x40,%ecx
  186091:	29 f1                	sub    %esi,%ecx
  186093:	d3 e2                	shl    %cl,%edx
  186095:	89 d1                	mov    %edx,%ecx
  186097:	09 c1                	or     %eax,%ecx
  186099:	0f 95 c0             	setne  %al
  18609c:	0f b6 c0             	movzbl %al,%eax
  18609f:	09 c3                	or     %eax,%ebx
  1860a1:	eb 07                	jmp    1860aa <__subdf3+0x244>
  1860a3:	31 db                	xor    %ebx,%ebx
  1860a5:	09 c2                	or     %eax,%edx
  1860a7:	0f 95 c3             	setne  %bl
  1860aa:	31 c9                	xor    %ecx,%ecx
  1860ac:	89 ea                	mov    %ebp,%edx
  1860ae:	89 f8                	mov    %edi,%eax
  1860b0:	01 d8                	add    %ebx,%eax
  1860b2:	11 ca                	adc    %ecx,%edx
  1860b4:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  1860b8:	e9 d4 00 00 00       	jmp    186191 <__subdf3+0x32b>
  1860bd:	8d 4b 01             	lea    0x1(%ebx),%ecx
  1860c0:	89 ce                	mov    %ecx,%esi
  1860c2:	81 e6 ff 07 00 00    	and    $0x7ff,%esi
  1860c8:	4e                   	dec    %esi
  1860c9:	0f 8f 99 00 00 00    	jg     186168 <__subdf3+0x302>
  1860cf:	89 d6                	mov    %edx,%esi
  1860d1:	85 db                	test   %ebx,%ebx
  1860d3:	75 36                	jne    18610b <__subdf3+0x2a5>
  1860d5:	09 c6                	or     %eax,%esi
  1860d7:	0f 84 4e 05 00 00    	je     18662b <__subdf3+0x7c5>
  1860dd:	89 ee                	mov    %ebp,%esi
  1860df:	09 fe                	or     %edi,%esi
  1860e1:	0f 84 8c 05 00 00    	je     186673 <__subdf3+0x80d>
  1860e7:	01 f8                	add    %edi,%eax
  1860e9:	11 ea                	adc    %ebp,%edx
  1860eb:	89 d5                	mov    %edx,%ebp
  1860ed:	89 c7                	mov    %eax,%edi
  1860ef:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  1860f5:	0f 84 30 05 00 00    	je     18662b <__subdf3+0x7c5>
  1860fb:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  186101:	bb 01 00 00 00       	mov    $0x1,%ebx
  186106:	e9 b9 04 00 00       	jmp    1865c4 <__subdf3+0x75e>
  18610b:	09 c6                	or     %eax,%esi
  18610d:	0f 84 2a 05 00 00    	je     18663d <__subdf3+0x7d7>
  186113:	89 ee                	mov    %ebp,%esi
  186115:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  18611a:	09 fe                	or     %edi,%esi
  18611c:	0f 84 a2 04 00 00    	je     1865c4 <__subdf3+0x75e>
  186122:	89 d1                	mov    %edx,%ecx
  186124:	89 eb                	mov    %ebp,%ebx
  186126:	c1 e8 03             	shr    $0x3,%eax
  186129:	c1 e1 1d             	shl    $0x1d,%ecx
  18612c:	c1 ea 03             	shr    $0x3,%edx
  18612f:	09 c1                	or     %eax,%ecx
  186131:	c1 eb 03             	shr    $0x3,%ebx
  186134:	39 da                	cmp    %ebx,%edx
  186136:	77 18                	ja     186150 <__subdf3+0x2ea>
  186138:	89 f8                	mov    %edi,%eax
  18613a:	89 ef                	mov    %ebp,%edi
  18613c:	c1 e8 03             	shr    $0x3,%eax
  18613f:	c1 e7 1d             	shl    $0x1d,%edi
  186142:	09 c7                	or     %eax,%edi
  186144:	39 da                	cmp    %ebx,%edx
  186146:	75 04                	jne    18614c <__subdf3+0x2e6>
  186148:	39 f9                	cmp    %edi,%ecx
  18614a:	77 06                	ja     186152 <__subdf3+0x2ec>
  18614c:	89 f9                	mov    %edi,%ecx
  18614e:	eb 02                	jmp    186152 <__subdf3+0x2ec>
  186150:	89 d3                	mov    %edx,%ebx
  186152:	89 ca                	mov    %ecx,%edx
  186154:	8d 04 cd 00 00 00 00 	lea    0x0(,%ecx,8),%eax
  18615b:	c1 e3 03             	shl    $0x3,%ebx
  18615e:	c1 ea 1d             	shr    $0x1d,%edx
  186161:	09 da                	or     %ebx,%edx
  186163:	e9 d9 04 00 00       	jmp    186641 <__subdf3+0x7db>
  186168:	01 f8                	add    %edi,%eax
  18616a:	11 ea                	adc    %ebp,%edx
  18616c:	81 f9 ff 07 00 00    	cmp    $0x7ff,%ecx
  186172:	0f 84 43 04 00 00    	je     1865bb <__subdf3+0x755>
  186178:	89 c3                	mov    %eax,%ebx
  18617a:	83 e0 01             	and    $0x1,%eax
  18617d:	d1 eb                	shr    %ebx
  18617f:	09 d8                	or     %ebx,%eax
  186181:	89 d3                	mov    %edx,%ebx
  186183:	c1 e3 1f             	shl    $0x1f,%ebx
  186186:	d1 ea                	shr    %edx
  186188:	09 d8                	or     %ebx,%eax
  18618a:	89 cb                	mov    %ecx,%ebx
  18618c:	e9 33 04 00 00       	jmp    1865c4 <__subdf3+0x75e>
  186191:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  186197:	0f 84 0c 04 00 00    	je     1865a9 <__subdf3+0x743>
  18619d:	43                   	inc    %ebx
  18619e:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  1861a4:	0f 84 16 04 00 00    	je     1865c0 <__subdf3+0x75a>
  1861aa:	89 c1                	mov    %eax,%ecx
  1861ac:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  1861b2:	d1 e9                	shr    %ecx
  1861b4:	83 e0 01             	and    $0x1,%eax
  1861b7:	09 c8                	or     %ecx,%eax
  1861b9:	89 d1                	mov    %edx,%ecx
  1861bb:	c1 e1 1f             	shl    $0x1f,%ecx
  1861be:	d1 ea                	shr    %edx
  1861c0:	09 c8                	or     %ecx,%eax
  1861c2:	e9 fd 03 00 00       	jmp    1865c4 <__subdf3+0x75e>
  1861c7:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1861cb:	83 fe 00             	cmp    $0x0,%esi
  1861ce:	0f 8e f0 00 00 00    	jle    1862c4 <__subdf3+0x45e>
  1861d4:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  1861d9:	75 3a                	jne    186215 <__subdf3+0x3af>
  1861db:	89 ee                	mov    %ebp,%esi
  1861dd:	09 fe                	or     %edi,%esi
  1861df:	75 18                	jne    1861f9 <__subdf3+0x393>
  1861e1:	8b 7c 24 04          	mov    0x4(%esp),%edi
  1861e5:	89 3c 24             	mov    %edi,(%esp)
  1861e8:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  1861ee:	0f 85 b5 03 00 00    	jne    1865a9 <__subdf3+0x743>
  1861f4:	e9 cb 03 00 00       	jmp    1865c4 <__subdf3+0x75e>
  1861f9:	ff 4c 24 0c          	decl   0xc(%esp)
  1861fd:	75 09                	jne    186208 <__subdf3+0x3a2>
  1861ff:	29 f8                	sub    %edi,%eax
  186201:	19 ea                	sbb    %ebp,%edx
  186203:	e9 b0 00 00 00       	jmp    1862b8 <__subdf3+0x452>
  186208:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  18620e:	75 17                	jne    186227 <__subdf3+0x3c1>
  186210:	e9 1f 04 00 00       	jmp    186634 <__subdf3+0x7ce>
  186215:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  18621b:	0f 84 13 04 00 00    	je     186634 <__subdf3+0x7ce>
  186221:	81 cd 00 00 80 00    	or     $0x800000,%ebp
  186227:	83 7c 24 0c 38       	cmpl   $0x38,0xc(%esp)
  18622c:	7f 7b                	jg     1862a9 <__subdf3+0x443>
  18622e:	83 7c 24 0c 1f       	cmpl   $0x1f,0xc(%esp)
  186233:	7f 45                	jg     18627a <__subdf3+0x414>
  186235:	b9 20 00 00 00       	mov    $0x20,%ecx
  18623a:	89 44 24 08          	mov    %eax,0x8(%esp)
  18623e:	2b 4c 24 0c          	sub    0xc(%esp),%ecx
  186242:	89 e8                	mov    %ebp,%eax
  186244:	89 0c 24             	mov    %ecx,(%esp)
  186247:	8a 0c 24             	mov    (%esp),%cl
  18624a:	d3 e0                	shl    %cl,%eax
  18624c:	89 c6                	mov    %eax,%esi
  18624e:	8a 4c 24 0c          	mov    0xc(%esp),%cl
  186252:	89 f8                	mov    %edi,%eax
  186254:	d3 e8                	shr    %cl,%eax
  186256:	89 c1                	mov    %eax,%ecx
  186258:	8b 44 24 08          	mov    0x8(%esp),%eax
  18625c:	09 f1                	or     %esi,%ecx
  18625e:	89 ce                	mov    %ecx,%esi
  186260:	8a 0c 24             	mov    (%esp),%cl
  186263:	d3 e7                	shl    %cl,%edi
  186265:	31 c9                	xor    %ecx,%ecx
  186267:	85 ff                	test   %edi,%edi
  186269:	89 f7                	mov    %esi,%edi
  18626b:	0f 95 c1             	setne  %cl
  18626e:	09 cf                	or     %ecx,%edi
  186270:	8a 4c 24 0c          	mov    0xc(%esp),%cl
  186274:	d3 ed                	shr    %cl,%ebp
  186276:	89 ee                	mov    %ebp,%esi
  186278:	eb 3a                	jmp    1862b4 <__subdf3+0x44e>
  18627a:	8b 74 24 0c          	mov    0xc(%esp),%esi
  18627e:	8d 4e e0             	lea    -0x20(%esi),%ecx
  186281:	89 ee                	mov    %ebp,%esi
  186283:	d3 ee                	shr    %cl,%esi
  186285:	31 c9                	xor    %ecx,%ecx
  186287:	83 7c 24 0c 20       	cmpl   $0x20,0xc(%esp)
  18628c:	74 0d                	je     18629b <__subdf3+0x435>
  18628e:	b9 40 00 00 00       	mov    $0x40,%ecx
  186293:	2b 4c 24 0c          	sub    0xc(%esp),%ecx
  186297:	d3 e5                	shl    %cl,%ebp
  186299:	89 e9                	mov    %ebp,%ecx
  18629b:	09 f9                	or     %edi,%ecx
  18629d:	89 f7                	mov    %esi,%edi
  18629f:	0f 95 c1             	setne  %cl
  1862a2:	0f b6 c9             	movzbl %cl,%ecx
  1862a5:	09 cf                	or     %ecx,%edi
  1862a7:	eb 09                	jmp    1862b2 <__subdf3+0x44c>
  1862a9:	31 c9                	xor    %ecx,%ecx
  1862ab:	09 fd                	or     %edi,%ebp
  1862ad:	0f 95 c1             	setne  %cl
  1862b0:	89 cf                	mov    %ecx,%edi
  1862b2:	31 f6                	xor    %esi,%esi
  1862b4:	29 f8                	sub    %edi,%eax
  1862b6:	19 f2                	sbb    %esi,%edx
  1862b8:	8b 7c 24 04          	mov    0x4(%esp),%edi
  1862bc:	89 3c 24             	mov    %edi,(%esp)
  1862bf:	e9 fa 01 00 00       	jmp    1864be <__subdf3+0x658>
  1862c4:	0f 84 f1 00 00 00    	je     1863bb <__subdf3+0x555>
  1862ca:	85 db                	test   %ebx,%ebx
  1862cc:	75 48                	jne    186316 <__subdf3+0x4b0>
  1862ce:	89 d6                	mov    %edx,%esi
  1862d0:	09 c6                	or     %eax,%esi
  1862d2:	75 1b                	jne    1862ef <__subdf3+0x489>
  1862d4:	89 ea                	mov    %ebp,%edx
  1862d6:	89 f8                	mov    %edi,%eax
  1862d8:	81 7c 24 08 ff 07 00 	cmpl   $0x7ff,0x8(%esp)
  1862df:	00 
  1862e0:	0f 84 5b 03 00 00    	je     186641 <__subdf3+0x7db>
  1862e6:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  1862ea:	e9 ba 02 00 00       	jmp    1865a9 <__subdf3+0x743>
  1862ef:	8b 74 24 0c          	mov    0xc(%esp),%esi
  1862f3:	83 f6 ff             	xor    $0xffffffff,%esi
  1862f6:	75 0f                	jne    186307 <__subdf3+0x4a1>
  1862f8:	89 ee                	mov    %ebp,%esi
  1862fa:	29 c7                	sub    %eax,%edi
  1862fc:	19 d6                	sbb    %edx,%esi
  1862fe:	89 f2                	mov    %esi,%edx
  186300:	89 f8                	mov    %edi,%eax
  186302:	e9 ab 00 00 00       	jmp    1863b2 <__subdf3+0x54c>
  186307:	81 7c 24 08 ff 07 00 	cmpl   $0x7ff,0x8(%esp)
  18630e:	00 
  18630f:	75 1f                	jne    186330 <__subdf3+0x4ca>
  186311:	e9 27 03 00 00       	jmp    18663d <__subdf3+0x7d7>
  186316:	81 7c 24 08 ff 07 00 	cmpl   $0x7ff,0x8(%esp)
  18631d:	00 
  18631e:	0f 84 19 03 00 00    	je     18663d <__subdf3+0x7d7>
  186324:	8b 74 24 0c          	mov    0xc(%esp),%esi
  186328:	81 ca 00 00 80 00    	or     $0x800000,%edx
  18632e:	f7 de                	neg    %esi
  186330:	83 fe 38             	cmp    $0x38,%esi
  186333:	7f 6c                	jg     1863a1 <__subdf3+0x53b>
  186335:	83 fe 1f             	cmp    $0x1f,%esi
  186338:	7f 42                	jg     18637c <__subdf3+0x516>
  18633a:	bb 20 00 00 00       	mov    $0x20,%ebx
  18633f:	29 f3                	sub    %esi,%ebx
  186341:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  186345:	89 d3                	mov    %edx,%ebx
  186347:	8a 4c 24 04          	mov    0x4(%esp),%cl
  18634b:	d3 e3                	shl    %cl,%ebx
  18634d:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  186351:	89 f1                	mov    %esi,%ecx
  186353:	89 c3                	mov    %eax,%ebx
  186355:	d3 eb                	shr    %cl,%ebx
  186357:	89 d9                	mov    %ebx,%ecx
  186359:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  18635d:	09 cb                	or     %ecx,%ebx
  18635f:	8a 4c 24 04          	mov    0x4(%esp),%cl
  186363:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  186367:	31 db                	xor    %ebx,%ebx
  186369:	d3 e0                	shl    %cl,%eax
  18636b:	89 f1                	mov    %esi,%ecx
  18636d:	85 c0                	test   %eax,%eax
  18636f:	0f 95 c3             	setne  %bl
  186372:	d3 ea                	shr    %cl,%edx
  186374:	0b 5c 24 0c          	or     0xc(%esp),%ebx
  186378:	89 d1                	mov    %edx,%ecx
  18637a:	eb 2e                	jmp    1863aa <__subdf3+0x544>
  18637c:	8d 4e e0             	lea    -0x20(%esi),%ecx
  18637f:	89 d3                	mov    %edx,%ebx
  186381:	d3 eb                	shr    %cl,%ebx
  186383:	31 c9                	xor    %ecx,%ecx
  186385:	83 fe 20             	cmp    $0x20,%esi
  186388:	74 0b                	je     186395 <__subdf3+0x52f>
  18638a:	b9 40 00 00 00       	mov    $0x40,%ecx
  18638f:	29 f1                	sub    %esi,%ecx
  186391:	d3 e2                	shl    %cl,%edx
  186393:	89 d1                	mov    %edx,%ecx
  186395:	09 c1                	or     %eax,%ecx
  186397:	0f 95 c0             	setne  %al
  18639a:	0f b6 c0             	movzbl %al,%eax
  18639d:	09 c3                	or     %eax,%ebx
  18639f:	eb 07                	jmp    1863a8 <__subdf3+0x542>
  1863a1:	31 db                	xor    %ebx,%ebx
  1863a3:	09 c2                	or     %eax,%edx
  1863a5:	0f 95 c3             	setne  %bl
  1863a8:	31 c9                	xor    %ecx,%ecx
  1863aa:	89 ea                	mov    %ebp,%edx
  1863ac:	89 f8                	mov    %edi,%eax
  1863ae:	29 d8                	sub    %ebx,%eax
  1863b0:	19 ca                	sbb    %ecx,%edx
  1863b2:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  1863b6:	e9 03 01 00 00       	jmp    1864be <__subdf3+0x658>
  1863bb:	8d 4b 01             	lea    0x1(%ebx),%ecx
  1863be:	81 e1 ff 07 00 00    	and    $0x7ff,%ecx
  1863c4:	49                   	dec    %ecx
  1863c5:	0f 8f c1 00 00 00    	jg     18648c <__subdf3+0x626>
  1863cb:	89 d6                	mov    %edx,%esi
  1863cd:	85 db                	test   %ebx,%ebx
  1863cf:	75 51                	jne    186422 <__subdf3+0x5bc>
  1863d1:	09 c6                	or     %eax,%esi
  1863d3:	75 13                	jne    1863e8 <__subdf3+0x582>
  1863d5:	89 e8                	mov    %ebp,%eax
  1863d7:	09 f8                	or     %edi,%eax
  1863d9:	0f 84 fd 01 00 00    	je     1865dc <__subdf3+0x776>
  1863df:	89 ea                	mov    %ebp,%edx
  1863e1:	89 f8                	mov    %edi,%eax
  1863e3:	e9 8b 02 00 00       	jmp    186673 <__subdf3+0x80d>
  1863e8:	89 ee                	mov    %ebp,%esi
  1863ea:	09 fe                	or     %edi,%esi
  1863ec:	0f 84 7a 02 00 00    	je     18666c <__subdf3+0x806>
  1863f2:	89 d1                	mov    %edx,%ecx
  1863f4:	89 c6                	mov    %eax,%esi
  1863f6:	29 fe                	sub    %edi,%esi
  1863f8:	19 e9                	sbb    %ebp,%ecx
  1863fa:	f7 c1 00 00 80 00    	test   $0x800000,%ecx
  186400:	74 0d                	je     18640f <__subdf3+0x5a9>
  186402:	89 ee                	mov    %ebp,%esi
  186404:	29 c7                	sub    %eax,%edi
  186406:	19 d6                	sbb    %edx,%esi
  186408:	89 f5                	mov    %esi,%ebp
  18640a:	e9 1c 02 00 00       	jmp    18662b <__subdf3+0x7c5>
  18640f:	89 c8                	mov    %ecx,%eax
  186411:	09 f0                	or     %esi,%eax
  186413:	0f 84 c3 01 00 00    	je     1865dc <__subdf3+0x776>
  186419:	89 ca                	mov    %ecx,%edx
  18641b:	89 f0                	mov    %esi,%eax
  18641d:	e9 4a 02 00 00       	jmp    18666c <__subdf3+0x806>
  186422:	09 c6                	or     %eax,%esi
  186424:	75 0f                	jne    186435 <__subdf3+0x5cf>
  186426:	89 e8                	mov    %ebp,%eax
  186428:	09 f8                	or     %edi,%eax
  18642a:	0f 84 1b 02 00 00    	je     18664b <__subdf3+0x7e5>
  186430:	e9 08 02 00 00       	jmp    18663d <__subdf3+0x7d7>
  186435:	89 ee                	mov    %ebp,%esi
  186437:	09 fe                	or     %edi,%esi
  186439:	0f 84 24 02 00 00    	je     186663 <__subdf3+0x7fd>
  18643f:	89 d1                	mov    %edx,%ecx
  186441:	89 eb                	mov    %ebp,%ebx
  186443:	c1 e8 03             	shr    $0x3,%eax
  186446:	c1 e1 1d             	shl    $0x1d,%ecx
  186449:	c1 ea 03             	shr    $0x3,%edx
  18644c:	09 c1                	or     %eax,%ecx
  18644e:	c1 eb 03             	shr    $0x3,%ebx
  186451:	39 da                	cmp    %ebx,%edx
  186453:	77 1f                	ja     186474 <__subdf3+0x60e>
  186455:	89 f8                	mov    %edi,%eax
  186457:	89 ef                	mov    %ebp,%edi
  186459:	c1 e8 03             	shr    $0x3,%eax
  18645c:	c1 e7 1d             	shl    $0x1d,%edi
  18645f:	09 c7                	or     %eax,%edi
  186461:	39 da                	cmp    %ebx,%edx
  186463:	75 04                	jne    186469 <__subdf3+0x603>
  186465:	39 f9                	cmp    %edi,%ecx
  186467:	77 0d                	ja     186476 <__subdf3+0x610>
  186469:	8b 04 24             	mov    (%esp),%eax
  18646c:	89 f9                	mov    %edi,%ecx
  18646e:	89 44 24 04          	mov    %eax,0x4(%esp)
  186472:	eb 02                	jmp    186476 <__subdf3+0x610>
  186474:	89 d3                	mov    %edx,%ebx
  186476:	89 ca                	mov    %ecx,%edx
  186478:	8d 04 cd 00 00 00 00 	lea    0x0(,%ecx,8),%eax
  18647f:	c1 e3 03             	shl    $0x3,%ebx
  186482:	c1 ea 1d             	shr    $0x1d,%edx
  186485:	09 da                	or     %ebx,%edx
  186487:	e9 d7 01 00 00       	jmp    186663 <__subdf3+0x7fd>
  18648c:	89 c1                	mov    %eax,%ecx
  18648e:	89 d6                	mov    %edx,%esi
  186490:	29 f9                	sub    %edi,%ecx
  186492:	19 ee                	sbb    %ebp,%esi
  186494:	89 74 24 0c          	mov    %esi,0xc(%esp)
  186498:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  18649c:	f7 c6 00 00 80 00    	test   $0x800000,%esi
  1864a2:	74 0c                	je     1864b0 <__subdf3+0x64a>
  1864a4:	89 ee                	mov    %ebp,%esi
  1864a6:	29 c7                	sub    %eax,%edi
  1864a8:	19 d6                	sbb    %edx,%esi
  1864aa:	89 7c 24 08          	mov    %edi,0x8(%esp)
  1864ae:	eb 26                	jmp    1864d6 <__subdf3+0x670>
  1864b0:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1864b4:	09 c8                	or     %ecx,%eax
  1864b6:	0f 84 1e 01 00 00    	je     1865da <__subdf3+0x774>
  1864bc:	eb 1f                	jmp    1864dd <__subdf3+0x677>
  1864be:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  1864c4:	0f 84 df 00 00 00    	je     1865a9 <__subdf3+0x743>
  1864ca:	89 d6                	mov    %edx,%esi
  1864cc:	89 44 24 08          	mov    %eax,0x8(%esp)
  1864d0:	81 e6 ff ff 7f 00    	and    $0x7fffff,%esi
  1864d6:	8b 04 24             	mov    (%esp),%eax
  1864d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1864dd:	85 f6                	test   %esi,%esi
  1864df:	74 08                	je     1864e9 <__subdf3+0x683>
  1864e1:	0f bd ce             	bsr    %esi,%ecx
  1864e4:	83 f1 1f             	xor    $0x1f,%ecx
  1864e7:	eb 0b                	jmp    1864f4 <__subdf3+0x68e>
  1864e9:	0f bd 4c 24 08       	bsr    0x8(%esp),%ecx
  1864ee:	83 f1 1f             	xor    $0x1f,%ecx
  1864f1:	83 c1 20             	add    $0x20,%ecx
  1864f4:	8d 69 f8             	lea    -0x8(%ecx),%ebp
  1864f7:	83 fd 1f             	cmp    $0x1f,%ebp
  1864fa:	7f 1d                	jg     186519 <__subdf3+0x6b3>
  1864fc:	89 e9                	mov    %ebp,%ecx
  1864fe:	8b 54 24 08          	mov    0x8(%esp),%edx
  186502:	d3 e6                	shl    %cl,%esi
  186504:	b9 20 00 00 00       	mov    $0x20,%ecx
  186509:	8b 44 24 08          	mov    0x8(%esp),%eax
  18650d:	29 e9                	sub    %ebp,%ecx
  18650f:	d3 ea                	shr    %cl,%edx
  186511:	89 e9                	mov    %ebp,%ecx
  186513:	09 f2                	or     %esi,%edx
  186515:	d3 e0                	shl    %cl,%eax
  186517:	eb 0b                	jmp    186524 <__subdf3+0x6be>
  186519:	83 e9 28             	sub    $0x28,%ecx
  18651c:	8b 54 24 08          	mov    0x8(%esp),%edx
  186520:	d3 e2                	shl    %cl,%edx
  186522:	31 c0                	xor    %eax,%eax
  186524:	39 eb                	cmp    %ebp,%ebx
  186526:	7f 72                	jg     18659a <__subdf3+0x734>
  186528:	29 dd                	sub    %ebx,%ebp
  18652a:	8d 5d 01             	lea    0x1(%ebp),%ebx
  18652d:	83 fb 1f             	cmp    $0x1f,%ebx
  186530:	7f 35                	jg     186567 <__subdf3+0x701>
  186532:	bd 20 00 00 00       	mov    $0x20,%ebp
  186537:	89 d6                	mov    %edx,%esi
  186539:	29 dd                	sub    %ebx,%ebp
  18653b:	89 c7                	mov    %eax,%edi
  18653d:	89 e9                	mov    %ebp,%ecx
  18653f:	d3 e6                	shl    %cl,%esi
  186541:	88 d9                	mov    %bl,%cl
  186543:	d3 ef                	shr    %cl,%edi
  186545:	89 e9                	mov    %ebp,%ecx
  186547:	09 f7                	or     %esi,%edi
  186549:	d3 e0                	shl    %cl,%eax
  18654b:	85 c0                	test   %eax,%eax
  18654d:	88 d9                	mov    %bl,%cl
  18654f:	0f 95 c0             	setne  %al
  186552:	0f b6 c0             	movzbl %al,%eax
  186555:	09 c7                	or     %eax,%edi
  186557:	8b 44 24 04          	mov    0x4(%esp),%eax
  18655b:	d3 ea                	shr    %cl,%edx
  18655d:	89 d5                	mov    %edx,%ebp
  18655f:	89 04 24             	mov    %eax,(%esp)
  186562:	e9 c4 00 00 00       	jmp    18662b <__subdf3+0x7c5>
  186567:	8d 4d e1             	lea    -0x1f(%ebp),%ecx
  18656a:	89 d6                	mov    %edx,%esi
  18656c:	d3 ee                	shr    %cl,%esi
  18656e:	31 c9                	xor    %ecx,%ecx
  186570:	83 fb 20             	cmp    $0x20,%ebx
  186573:	74 0b                	je     186580 <__subdf3+0x71a>
  186575:	b9 40 00 00 00       	mov    $0x40,%ecx
  18657a:	29 d9                	sub    %ebx,%ecx
  18657c:	d3 e2                	shl    %cl,%edx
  18657e:	89 d1                	mov    %edx,%ecx
  186580:	09 c8                	or     %ecx,%eax
  186582:	0f 95 c0             	setne  %al
  186585:	0f b6 c0             	movzbl %al,%eax
  186588:	09 c6                	or     %eax,%esi
  18658a:	8b 44 24 04          	mov    0x4(%esp),%eax
  18658e:	89 f7                	mov    %esi,%edi
  186590:	89 04 24             	mov    %eax,(%esp)
  186593:	31 ed                	xor    %ebp,%ebp
  186595:	e9 91 00 00 00       	jmp    18662b <__subdf3+0x7c5>
  18659a:	8b 7c 24 04          	mov    0x4(%esp),%edi
  18659e:	29 eb                	sub    %ebp,%ebx
  1865a0:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  1865a6:	89 3c 24             	mov    %edi,(%esp)
  1865a9:	85 db                	test   %ebx,%ebx
  1865ab:	75 17                	jne    1865c4 <__subdf3+0x75e>
  1865ad:	89 c7                	mov    %eax,%edi
  1865af:	09 d7                	or     %edx,%edi
  1865b1:	0f 85 bc 00 00 00    	jne    186673 <__subdf3+0x80d>
  1865b7:	31 db                	xor    %ebx,%ebx
  1865b9:	eb 28                	jmp    1865e3 <__subdf3+0x77d>
  1865bb:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  1865c0:	31 d2                	xor    %edx,%edx
  1865c2:	31 c0                	xor    %eax,%eax
  1865c4:	a8 07                	test   $0x7,%al
  1865c6:	74 1f                	je     1865e7 <__subdf3+0x781>
  1865c8:	89 c1                	mov    %eax,%ecx
  1865ca:	83 e1 0f             	and    $0xf,%ecx
  1865cd:	83 f9 04             	cmp    $0x4,%ecx
  1865d0:	74 15                	je     1865e7 <__subdf3+0x781>
  1865d2:	83 c0 04             	add    $0x4,%eax
  1865d5:	83 d2 00             	adc    $0x0,%edx
  1865d8:	eb 0d                	jmp    1865e7 <__subdf3+0x781>
  1865da:	31 db                	xor    %ebx,%ebx
  1865dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1865e3:	31 d2                	xor    %edx,%edx
  1865e5:	31 c0                	xor    %eax,%eax
  1865e7:	f7 c2 00 00 80 00    	test   $0x800000,%edx
  1865ed:	74 13                	je     186602 <__subdf3+0x79c>
  1865ef:	43                   	inc    %ebx
  1865f0:	81 e2 ff ff 7f ff    	and    $0xff7fffff,%edx
  1865f6:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  1865fc:	75 04                	jne    186602 <__subdf3+0x79c>
  1865fe:	31 d2                	xor    %edx,%edx
  186600:	31 c0                	xor    %eax,%eax
  186602:	c1 e8 03             	shr    $0x3,%eax
  186605:	89 d6                	mov    %edx,%esi
  186607:	c1 e6 1d             	shl    $0x1d,%esi
  18660a:	c1 ea 03             	shr    $0x3,%edx
  18660d:	09 c6                	or     %eax,%esi
  18660f:	89 d1                	mov    %edx,%ecx
  186611:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  186617:	75 61                	jne    18667a <__subdf3+0x814>
  186619:	89 f0                	mov    %esi,%eax
  18661b:	09 d0                	or     %edx,%eax
  18661d:	74 08                	je     186627 <__subdf3+0x7c1>
  18661f:	81 c9 00 00 08 00    	or     $0x80000,%ecx
  186625:	eb 53                	jmp    18667a <__subdf3+0x814>
  186627:	31 c9                	xor    %ecx,%ecx
  186629:	eb 4f                	jmp    18667a <__subdf3+0x814>
  18662b:	89 ea                	mov    %ebp,%edx
  18662d:	89 f8                	mov    %edi,%eax
  18662f:	e9 79 ff ff ff       	jmp    1865ad <__subdf3+0x747>
  186634:	8b 7c 24 04          	mov    0x4(%esp),%edi
  186638:	89 3c 24             	mov    %edi,(%esp)
  18663b:	eb 87                	jmp    1865c4 <__subdf3+0x75e>
  18663d:	89 ea                	mov    %ebp,%edx
  18663f:	89 f8                	mov    %edi,%eax
  186641:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  186646:	e9 79 ff ff ff       	jmp    1865c4 <__subdf3+0x75e>
  18664b:	ba 00 00 40 00       	mov    $0x400000,%edx
  186650:	31 c0                	xor    %eax,%eax
  186652:	bb ff 07 00 00       	mov    $0x7ff,%ebx
  186657:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  18665e:	e9 61 ff ff ff       	jmp    1865c4 <__subdf3+0x75e>
  186663:	8b 7c 24 04          	mov    0x4(%esp),%edi
  186667:	89 3c 24             	mov    %edi,(%esp)
  18666a:	eb d5                	jmp    186641 <__subdf3+0x7db>
  18666c:	8b 7c 24 04          	mov    0x4(%esp),%edi
  186670:	89 3c 24             	mov    %edi,(%esp)
  186673:	31 db                	xor    %ebx,%ebx
  186675:	e9 4a ff ff ff       	jmp    1865c4 <__subdf3+0x75e>
  18667a:	31 d2                	xor    %edx,%edx
  18667c:	89 f0                	mov    %esi,%eax
  18667e:	89 d6                	mov    %edx,%esi
  186680:	81 e1 ff ff 0f 00    	and    $0xfffff,%ecx
  186686:	81 e6 00 00 f0 ff    	and    $0xfff00000,%esi
  18668c:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
  186692:	c1 e3 14             	shl    $0x14,%ebx
  186695:	09 f1                	or     %esi,%ecx
  186697:	81 e1 ff ff 0f 80    	and    $0x800fffff,%ecx
  18669d:	09 d9                	or     %ebx,%ecx
  18669f:	8b 1c 24             	mov    (%esp),%ebx
  1866a2:	c1 e3 1f             	shl    $0x1f,%ebx
  1866a5:	83 c4 10             	add    $0x10,%esp
  1866a8:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  1866ae:	09 d9                	or     %ebx,%ecx
  1866b0:	5b                   	pop    %ebx
  1866b1:	89 ca                	mov    %ecx,%edx
  1866b3:	5e                   	pop    %esi
  1866b4:	5f                   	pop    %edi
  1866b5:	5d                   	pop    %ebp
  1866b6:	c3                   	ret    

001866b7 <__fixdfsi>:
  1866b7:	57                   	push   %edi
  1866b8:	56                   	push   %esi
  1866b9:	89 d6                	mov    %edx,%esi
  1866bb:	89 c7                	mov    %eax,%edi
  1866bd:	c1 ee 14             	shr    $0x14,%esi
  1866c0:	89 d0                	mov    %edx,%eax
  1866c2:	81 e6 ff 07 00 00    	and    $0x7ff,%esi
  1866c8:	25 ff ff 0f 00       	and    $0xfffff,%eax
  1866cd:	c1 ea 1f             	shr    $0x1f,%edx
  1866d0:	53                   	push   %ebx
  1866d1:	81 fe fe 03 00 00    	cmp    $0x3fe,%esi
  1866d7:	7e 40                	jle    186719 <__fixdfsi+0x62>
  1866d9:	81 fe 1d 04 00 00    	cmp    $0x41d,%esi
  1866df:	7e 08                	jle    1866e9 <__fixdfsi+0x32>
  1866e1:	8d 82 ff ff ff 7f    	lea    0x7fffffff(%edx),%eax
  1866e7:	eb 32                	jmp    18671b <__fixdfsi+0x64>
  1866e9:	b9 33 04 00 00       	mov    $0x433,%ecx
  1866ee:	0d 00 00 10 00       	or     $0x100000,%eax
  1866f3:	29 f1                	sub    %esi,%ecx
  1866f5:	83 f9 1f             	cmp    $0x1f,%ecx
  1866f8:	7f 0e                	jg     186708 <__fixdfsi+0x51>
  1866fa:	d3 ef                	shr    %cl,%edi
  1866fc:	8d 8e ed fb ff ff    	lea    -0x413(%esi),%ecx
  186702:	d3 e0                	shl    %cl,%eax
  186704:	09 f8                	or     %edi,%eax
  186706:	eb 09                	jmp    186711 <__fixdfsi+0x5a>
  186708:	b9 13 04 00 00       	mov    $0x413,%ecx
  18670d:	29 f1                	sub    %esi,%ecx
  18670f:	d3 e8                	shr    %cl,%eax
  186711:	84 d2                	test   %dl,%dl
  186713:	74 06                	je     18671b <__fixdfsi+0x64>
  186715:	f7 d8                	neg    %eax
  186717:	eb 02                	jmp    18671b <__fixdfsi+0x64>
  186719:	31 c0                	xor    %eax,%eax
  18671b:	5b                   	pop    %ebx
  18671c:	5e                   	pop    %esi
  18671d:	5f                   	pop    %edi
  18671e:	c3                   	ret    

0018671f <__floatsidf>:
  18671f:	55                   	push   %ebp
  186720:	85 c0                	test   %eax,%eax
  186722:	57                   	push   %edi
  186723:	56                   	push   %esi
  186724:	53                   	push   %ebx
  186725:	74 43                	je     18676a <__floatsidf+0x4b>
  186727:	99                   	cltd   
  186728:	89 c5                	mov    %eax,%ebp
  18672a:	31 d0                	xor    %edx,%eax
  18672c:	29 d0                	sub    %edx,%eax
  18672e:	ba 1e 04 00 00       	mov    $0x41e,%edx
  186733:	0f bd d8             	bsr    %eax,%ebx
  186736:	be 33 04 00 00       	mov    $0x433,%esi
  18673b:	c1 ed 1f             	shr    $0x1f,%ebp
  18673e:	83 f3 1f             	xor    $0x1f,%ebx
  186741:	29 da                	sub    %ebx,%edx
  186743:	29 d6                	sub    %edx,%esi
  186745:	83 fe 1f             	cmp    $0x1f,%esi
  186748:	7f 11                	jg     18675b <__floatsidf+0x3c>
  18674a:	b9 0b 00 00 00       	mov    $0xb,%ecx
  18674f:	29 d9                	sub    %ebx,%ecx
  186751:	89 c3                	mov    %eax,%ebx
  186753:	d3 eb                	shr    %cl,%ebx
  186755:	89 f1                	mov    %esi,%ecx
  186757:	d3 e0                	shl    %cl,%eax
  186759:	eb 17                	jmp    186772 <__floatsidf+0x53>
  18675b:	b9 13 04 00 00       	mov    $0x413,%ecx
  186760:	29 d1                	sub    %edx,%ecx
  186762:	d3 e0                	shl    %cl,%eax
  186764:	89 c3                	mov    %eax,%ebx
  186766:	31 c0                	xor    %eax,%eax
  186768:	eb 08                	jmp    186772 <__floatsidf+0x53>
  18676a:	31 db                	xor    %ebx,%ebx
  18676c:	31 c0                	xor    %eax,%eax
  18676e:	31 d2                	xor    %edx,%edx
  186770:	31 ed                	xor    %ebp,%ebp
  186772:	31 ff                	xor    %edi,%edi
  186774:	89 c6                	mov    %eax,%esi
  186776:	89 f8                	mov    %edi,%eax
  186778:	81 e3 ff ff 0f 00    	and    $0xfffff,%ebx
  18677e:	25 00 00 f0 ff       	and    $0xfff00000,%eax
  186783:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
  186789:	c1 e5 1f             	shl    $0x1f,%ebp
  18678c:	09 c3                	or     %eax,%ebx
  18678e:	81 e3 ff ff 0f 80    	and    $0x800fffff,%ebx
  186794:	89 d0                	mov    %edx,%eax
  186796:	c1 e0 14             	shl    $0x14,%eax
  186799:	89 da                	mov    %ebx,%edx
  18679b:	09 c2                	or     %eax,%edx
  18679d:	5b                   	pop    %ebx
  18679e:	81 e2 ff ff ff 7f    	and    $0x7fffffff,%edx
  1867a4:	89 f0                	mov    %esi,%eax
  1867a6:	09 ea                	or     %ebp,%edx
  1867a8:	5e                   	pop    %esi
  1867a9:	5f                   	pop    %edi
  1867aa:	5d                   	pop    %ebp
  1867ab:	c3                   	ret    

001867ac <_handle_exc_0_vector_0_stub>:
  1867ac:	6a 00                	push   $0x0
  1867ae:	68 d5 21 18 00       	push   $0x1821d5
  1867b3:	e9 24 b7 ff ff       	jmp    181edc <_exception_enter>

001867b8 <_handle_exc_2_vector_2_stub>:
  1867b8:	6a 00                	push   $0x0
  1867ba:	68 e1 21 18 00       	push   $0x1821e1
  1867bf:	e9 18 b7 ff ff       	jmp    181edc <_exception_enter>

001867c4 <_handle_exc_4_vector_4_stub>:
  1867c4:	6a 00                	push   $0x0
  1867c6:	68 ed 21 18 00       	push   $0x1821ed
  1867cb:	e9 0c b7 ff ff       	jmp    181edc <_exception_enter>

001867d0 <_handle_exc_5_vector_5_stub>:
  1867d0:	6a 00                	push   $0x0
  1867d2:	68 f9 21 18 00       	push   $0x1821f9
  1867d7:	e9 00 b7 ff ff       	jmp    181edc <_exception_enter>

001867dc <_handle_exc_6_vector_6_stub>:
  1867dc:	6a 00                	push   $0x0
  1867de:	68 05 22 18 00       	push   $0x182205
  1867e3:	e9 f4 b6 ff ff       	jmp    181edc <_exception_enter>

001867e8 <_handle_exc_7_vector_7_stub>:
  1867e8:	6a 00                	push   $0x0
  1867ea:	68 11 22 18 00       	push   $0x182211
  1867ef:	e9 e8 b6 ff ff       	jmp    181edc <_exception_enter>

001867f4 <_handle_exc_8_vector_8_stub>:
  1867f4:	68 1d 22 18 00       	push   $0x18221d
  1867f9:	e9 de b6 ff ff       	jmp    181edc <_exception_enter>

001867fe <_handle_exc_10_vector_10_stub>:
  1867fe:	68 29 22 18 00       	push   $0x182229
  186803:	e9 d4 b6 ff ff       	jmp    181edc <_exception_enter>

00186808 <_handle_exc_11_vector_11_stub>:
  186808:	68 35 22 18 00       	push   $0x182235
  18680d:	e9 ca b6 ff ff       	jmp    181edc <_exception_enter>

00186812 <_handle_exc_12_vector_12_stub>:
  186812:	68 41 22 18 00       	push   $0x182241
  186817:	e9 c0 b6 ff ff       	jmp    181edc <_exception_enter>

0018681c <_handle_exc_13_vector_13_stub>:
  18681c:	68 4d 22 18 00       	push   $0x18224d
  186821:	e9 b6 b6 ff ff       	jmp    181edc <_exception_enter>

00186826 <_handle_exc_14_vector_14_stub>:
  186826:	68 59 22 18 00       	push   $0x182259
  18682b:	e9 ac b6 ff ff       	jmp    181edc <_exception_enter>

00186830 <_handle_exc_16_vector_16_stub>:
  186830:	6a 00                	push   $0x0
  186832:	68 65 22 18 00       	push   $0x182265
  186837:	e9 a0 b6 ff ff       	jmp    181edc <_exception_enter>

0018683c <_handle_exc_17_vector_17_stub>:
  18683c:	68 71 22 18 00       	push   $0x182271
  186841:	e9 96 b6 ff ff       	jmp    181edc <_exception_enter>

00186846 <_handle_exc_18_vector_18_stub>:
  186846:	6a 00                	push   $0x0
  186848:	68 7d 22 18 00       	push   $0x18227d
  18684d:	e9 8a b6 ff ff       	jmp    181edc <_exception_enter>
