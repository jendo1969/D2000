
zephyr.elf:     ファイル形式 elf32-iamcu


セクション text の逆アセンブル:

00180000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  180000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  180003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  180008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  18000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  18000c:	0f 01 1d 4c 00 18 00 	lidtl  0x18004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  180013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  180016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  180019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
  18001c:	bc 08 03 28 00       	mov    $0x280308,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  180021:	81 c4 00 01 00 00    	add    $0x100,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
  180027:	bf 00 00 28 00       	mov    $0x280000,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
  18002c:	be 68 36 18 00       	mov    $0x183668,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
  180031:	b9 3e 00 00 00       	mov    $0x3e,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
  180036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  180038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  18003a:	bf 00 01 28 00       	mov    $0x280100,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  18003f:	b9 82 00 00 00       	mov    $0x82,%ecx
	cld
  180044:	fc                   	cld    
	rep
  180045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  180047:	e9 7d 1f 00 00       	jmp    181fc9 <_Cstart>

0018004c <_Idt>:
  18004c:	ff 01 68 34 18 00 66 90 66 90 66 90 66 90 66 90     ..h4..f.f.f.f.f.
  18005c:	66 90 66 90                                         f.f.

00180060 <_thread_entry_wrapper>:
  180060:	58                   	pop    %eax
  180061:	5a                   	pop    %edx
  180062:	59                   	pop    %ecx
  180063:	6a 00                	push   $0x0
  180065:	e9 cc 26 00 00       	jmp    182736 <_thread_entry>

0018006a <pwm_pin_set_usec>:
 * @retval 0 If successful.
 * @retval Negative errno code if failure.
 */
static inline int pwm_pin_set_usec(struct device *dev, uint32_t pwm,
				   uint32_t period, uint32_t pulse)
{
  18006a:	55                   	push   %ebp
  18006b:	57                   	push   %edi
  18006c:	56                   	push   %esi
  18006d:	53                   	push   %ebx
  18006e:	83 ec 10             	sub    $0x10,%esp
  180071:	89 c7                	mov    %eax,%edi
  180073:	89 0c 24             	mov    %ecx,(%esp)
	struct pwm_driver_api *api;
	uint64_t period_cycles, pulse_cycles, cycles_per_sec;

	api = (struct pwm_driver_api *)dev->driver_api;
  180076:	8b 68 04             	mov    0x4(%eax),%ebp

	if (api->get_cycles_per_sec(dev, pwm, &cycles_per_sec) != 0) {
  180079:	8d 4c 24 08          	lea    0x8(%esp),%ecx
  18007d:	89 54 24 04          	mov    %edx,0x4(%esp)
  180081:	ff 55 18             	call   *0x18(%ebp)
  180084:	85 c0                	test   %eax,%eax
  180086:	75 60                	jne    1800e8 <pwm_pin_set_usec+0x7e>
		return -EIO;
	}

	period_cycles = (period * cycles_per_sec) / USEC_PER_SEC;
  180088:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  18008c:	8b 74 24 0c          	mov    0xc(%esp),%esi
  180090:	8b 0c 24             	mov    (%esp),%ecx
  180093:	0f af ce             	imul   %esi,%ecx
  180096:	8b 04 24             	mov    (%esp),%eax
  180099:	f7 e3                	mul    %ebx
  18009b:	01 ca                	add    %ecx,%edx
  18009d:	6a 00                	push   $0x0
  18009f:	68 40 42 0f 00       	push   $0xf4240
  1800a4:	e8 91 2c 00 00       	call   182d3a <__udivdi3>
  1800a9:	83 c4 08             	add    $0x8,%esp
  1800ac:	89 04 24             	mov    %eax,(%esp)
	if (period_cycles >= ((uint64_t)1 << 32)) {
  1800af:	83 fa 00             	cmp    $0x0,%edx
  1800b2:	77 3b                	ja     1800ef <pwm_pin_set_usec+0x85>
		return -ENOTSUP;
	}

	pulse_cycles = (pulse * cycles_per_sec) / USEC_PER_SEC;
  1800b4:	0f af 74 24 24       	imul   0x24(%esp),%esi
  1800b9:	89 d8                	mov    %ebx,%eax
  1800bb:	f7 64 24 24          	mull   0x24(%esp)
  1800bf:	01 f2                	add    %esi,%edx
  1800c1:	6a 00                	push   $0x0
  1800c3:	68 40 42 0f 00       	push   $0xf4240
  1800c8:	e8 6d 2c 00 00       	call   182d3a <__udivdi3>
  1800cd:	83 c4 08             	add    $0x8,%esp
	if (pulse_cycles >= ((uint64_t)1 << 32)) {
  1800d0:	83 fa 00             	cmp    $0x0,%edx
  1800d3:	77 21                	ja     1800f6 <pwm_pin_set_usec+0x8c>
		return -ENOTSUP;
	}

	return api->pin_set(dev, pwm, (uint32_t)period_cycles,
  1800d5:	50                   	push   %eax
  1800d6:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  1800da:	8b 54 24 08          	mov    0x8(%esp),%edx
  1800de:	89 f8                	mov    %edi,%eax
  1800e0:	ff 55 14             	call   *0x14(%ebp)
  1800e3:	83 c4 04             	add    $0x4,%esp
  1800e6:	eb 13                	jmp    1800fb <pwm_pin_set_usec+0x91>
	uint64_t period_cycles, pulse_cycles, cycles_per_sec;

	api = (struct pwm_driver_api *)dev->driver_api;

	if (api->get_cycles_per_sec(dev, pwm, &cycles_per_sec) != 0) {
		return -EIO;
  1800e8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  1800ed:	eb 0c                	jmp    1800fb <pwm_pin_set_usec+0x91>
	}

	period_cycles = (period * cycles_per_sec) / USEC_PER_SEC;
	if (period_cycles >= ((uint64_t)1 << 32)) {
		return -ENOTSUP;
  1800ef:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  1800f4:	eb 05                	jmp    1800fb <pwm_pin_set_usec+0x91>
	}

	pulse_cycles = (pulse * cycles_per_sec) / USEC_PER_SEC;
	if (pulse_cycles >= ((uint64_t)1 << 32)) {
		return -ENOTSUP;
  1800f6:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
	}

	return api->pin_set(dev, pwm, (uint32_t)period_cycles,
			    (uint32_t)pulse_cycles);
}
  1800fb:	83 c4 10             	add    $0x10,%esp
  1800fe:	5b                   	pop    %ebx
  1800ff:	5e                   	pop    %esi
  180100:	5f                   	pop    %edi
  180101:	5d                   	pop    %ebp
  180102:	c3                   	ret    

00180103 <rotA_Trig>:
#define ACC_STEP	3000
//#define ACC_STEP	1000

void rotA_Trig(struct device *gpiob, struct gpio_callback *cb,
		    uint32_t pins)
{
  180103:	53                   	push   %ebx
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_read(struct device *port, uint32_t pin,
				uint32_t *value)
{
	const struct gpio_driver_api *api = port->driver_api;
  180104:	8b 58 04             	mov    0x4(%eax),%ebx

	return api->read(port, GPIO_ACCESS_BY_PIN, pin, value);
  180107:	68 24 01 28 00       	push   $0x280124
  18010c:	b9 0a 00 00 00       	mov    $0xa,%ecx
  180111:	ba 00 00 00 00       	mov    $0x0,%edx
  180116:	ff 53 08             	call   *0x8(%ebx)
  180119:	83 c4 04             	add    $0x4,%esp
	gpio_pin_read(gpiob, PIN_A, &val);
	if(val == 1)
  18011c:	a1 24 01 28 00       	mov    0x280124,%eax
  180121:	83 f8 01             	cmp    $0x1,%eax
  180124:	75 19                	jne    18013f <rotA_Trig+0x3c>
	{
		if(old_B == 1)
  180126:	83 3d 1c 01 28 00 01 	cmpl   $0x1,0x28011c
  18012d:	75 08                	jne    180137 <rotA_Trig+0x34>
		{
			count++;
  18012f:	ff 05 2c 01 28 00    	incl   0x28012c
  180135:	eb 1f                	jmp    180156 <rotA_Trig+0x53>
		}
		else
		{
			count--;
  180137:	ff 0d 2c 01 28 00    	decl   0x28012c
  18013d:	eb 17                	jmp    180156 <rotA_Trig+0x53>
		}
	}
	else
	{
		if(old_B == 1)
  18013f:	83 3d 1c 01 28 00 01 	cmpl   $0x1,0x28011c
  180146:	75 08                	jne    180150 <rotA_Trig+0x4d>
		{
			count--;
  180148:	ff 0d 2c 01 28 00    	decl   0x28012c
  18014e:	eb 06                	jmp    180156 <rotA_Trig+0x53>
		}
		else
		{
			count++;
  180150:	ff 05 2c 01 28 00    	incl   0x28012c
		}
	}
	old_A = val;
  180156:	a3 20 01 28 00       	mov    %eax,0x280120
}
  18015b:	5b                   	pop    %ebx
  18015c:	c3                   	ret    

0018015d <rotB_Trig>:

void rotB_Trig(struct device *gpiob, struct gpio_callback *cb,
		    uint32_t pins)
{
  18015d:	53                   	push   %ebx
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_read(struct device *port, uint32_t pin,
				uint32_t *value)
{
	const struct gpio_driver_api *api = port->driver_api;
  18015e:	8b 58 04             	mov    0x4(%eax),%ebx

	return api->read(port, GPIO_ACCESS_BY_PIN, pin, value);
  180161:	68 24 01 28 00       	push   $0x280124
  180166:	b9 05 00 00 00       	mov    $0x5,%ecx
  18016b:	ba 00 00 00 00       	mov    $0x0,%edx
  180170:	ff 53 08             	call   *0x8(%ebx)
  180173:	83 c4 04             	add    $0x4,%esp
	gpio_pin_read(gpiob, PIN_B, &val);
	if(val == 1)
  180176:	a1 24 01 28 00       	mov    0x280124,%eax
  18017b:	83 f8 01             	cmp    $0x1,%eax
  18017e:	75 19                	jne    180199 <rotB_Trig+0x3c>
	{
		if(old_A == 1)
  180180:	83 3d 20 01 28 00 01 	cmpl   $0x1,0x280120
  180187:	75 08                	jne    180191 <rotB_Trig+0x34>
		{
			count--;
  180189:	ff 0d 2c 01 28 00    	decl   0x28012c
  18018f:	eb 1f                	jmp    1801b0 <rotB_Trig+0x53>
		}
		else
		{
			count++;
  180191:	ff 05 2c 01 28 00    	incl   0x28012c
  180197:	eb 17                	jmp    1801b0 <rotB_Trig+0x53>
		}
	}
	else
	{
		if(old_A == 1)
  180199:	83 3d 20 01 28 00 01 	cmpl   $0x1,0x280120
  1801a0:	75 08                	jne    1801aa <rotB_Trig+0x4d>
		{
			count++;
  1801a2:	ff 05 2c 01 28 00    	incl   0x28012c
  1801a8:	eb 06                	jmp    1801b0 <rotB_Trig+0x53>
		}
		else
		{
			count--;
  1801aa:	ff 0d 2c 01 28 00    	decl   0x28012c
		}
	}
	old_B = val;
  1801b0:	a3 1c 01 28 00       	mov    %eax,0x28011c
}
  1801b5:	5b                   	pop    %ebx
  1801b6:	c3                   	ret    

001801b7 <my_timer_handler>:

struct k_timer my_timer;

void my_timer_handler(struct k_timer *dummy)
{
	printk("Counter = %d, sp = %d\n", count, count - old_count);
  1801b7:	a1 2c 01 28 00       	mov    0x28012c,%eax
  1801bc:	89 c2                	mov    %eax,%edx
  1801be:	2b 15 28 01 28 00    	sub    0x280128,%edx
  1801c4:	52                   	push   %edx
  1801c5:	50                   	push   %eax
  1801c6:	68 60 2f 18 00       	push   $0x182f60
  1801cb:	e8 fe 10 00 00       	call   1812ce <printk>
  1801d0:	83 c4 0c             	add    $0xc,%esp
	old_count = count;
  1801d3:	a1 2c 01 28 00       	mov    0x28012c,%eax
  1801d8:	a3 28 01 28 00       	mov    %eax,0x280128
  1801dd:	c3                   	ret    

001801de <main>:

K_TIMER_DEFINE(my_timer, my_timer_handler, NULL);


void main(void)
{
  1801de:	55                   	push   %ebp
  1801df:	57                   	push   %edi
  1801e0:	56                   	push   %esi
  1801e1:	53                   	push   %ebx
  1801e2:	83 ec 10             	sub    $0x10,%esp
	uint32_t val = 0;
  1801e5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1801ec:	00 
	uint32_t old_val = 0;
	uint8_t r_dir = 0;

	struct device *gpiob;

	printk("PWM demo STEP MOTER\n");
  1801ed:	68 77 2f 18 00       	push   $0x182f77
  1801f2:	e8 d7 10 00 00       	call   1812ce <printk>
  1801f7:	83 c4 04             	add    $0x4,%esp

	gpiob = device_get_binding(PORT);
  1801fa:	b8 8c 2f 18 00       	mov    $0x182f8c,%eax
  1801ff:	e8 55 1c 00 00       	call   181e59 <device_get_binding>
	if (!gpiob) {
  180204:	85 c0                	test   %eax,%eax
  180206:	75 12                	jne    18021a <main+0x3c>
		printk("error\n");
  180208:	68 93 2f 18 00       	push   $0x182f93
  18020d:	e8 bc 10 00 00       	call   1812ce <printk>
  180212:	83 c4 04             	add    $0x4,%esp
		return;
  180215:	e9 fc 02 00 00       	jmp    180516 <main+0x338>
  18021a:	89 c3                	mov    %eax,%ebx
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;
  18021c:	8b 70 04             	mov    0x4(%eax),%esi

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  18021f:	6a 66                	push   $0x66
  180221:	b9 0a 00 00 00       	mov    $0xa,%ecx
  180226:	ba 00 00 00 00       	mov    $0x0,%edx
  18022b:	ff 16                	call   *(%esi)
  18022d:	83 c4 04             	add    $0x4,%esp
				      uint32_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
  180230:	c7 05 10 01 28 00 03 	movl   $0x180103,0x280110
  180237:	01 18 00 
	callback->pin_mask = pin_mask;
  18023a:	c7 05 14 01 28 00 00 	movl   $0x400,0x280114
  180241:	04 00 00 
 * Note: enables to add as many callback as needed on the same port.
 */
static inline int gpio_add_callback(struct device *port,
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api = port->driver_api;
  180244:	8b 73 04             	mov    0x4(%ebx),%esi

	__ASSERT(callback, "Callback pointer should not be NULL");

	return api->manage_callback(port, callback, true);
  180247:	b9 01 00 00 00       	mov    $0x1,%ecx
  18024c:	ba 0c 01 28 00       	mov    $0x28010c,%edx
  180251:	89 d8                	mov    %ebx,%eax
  180253:	ff 56 0c             	call   *0xc(%esi)
 *       the pin to trigger an interruption. So as a semantic detail, if no
 *       callback is registered, of course none will be called.
 */
static inline int gpio_pin_enable_callback(struct device *port, uint32_t pin)
{
	const struct gpio_driver_api *api = port->driver_api;
  180256:	8b 73 04             	mov    0x4(%ebx),%esi

	return api->enable_callback(port, GPIO_ACCESS_BY_PIN, pin);
  180259:	b9 0a 00 00 00       	mov    $0xa,%ecx
  18025e:	ba 00 00 00 00       	mov    $0x0,%edx
  180263:	89 d8                	mov    %ebx,%eax
  180265:	ff 56 10             	call   *0x10(%esi)
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;
  180268:	8b 73 04             	mov    0x4(%ebx),%esi

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  18026b:	6a 66                	push   $0x66
  18026d:	b9 05 00 00 00       	mov    $0x5,%ecx
  180272:	ba 00 00 00 00       	mov    $0x0,%edx
  180277:	89 d8                	mov    %ebx,%eax
  180279:	ff 16                	call   *(%esi)
  18027b:	83 c4 04             	add    $0x4,%esp
				      uint32_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
  18027e:	c7 05 04 01 28 00 5d 	movl   $0x18015d,0x280104
  180285:	01 18 00 
	callback->pin_mask = pin_mask;
  180288:	c7 05 08 01 28 00 20 	movl   $0x20,0x280108
  18028f:	00 00 00 
 * Note: enables to add as many callback as needed on the same port.
 */
static inline int gpio_add_callback(struct device *port,
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api = port->driver_api;
  180292:	8b 73 04             	mov    0x4(%ebx),%esi

	__ASSERT(callback, "Callback pointer should not be NULL");

	return api->manage_callback(port, callback, true);
  180295:	b9 01 00 00 00       	mov    $0x1,%ecx
  18029a:	ba 00 01 28 00       	mov    $0x280100,%edx
  18029f:	89 d8                	mov    %ebx,%eax
  1802a1:	ff 56 0c             	call   *0xc(%esi)
 *       the pin to trigger an interruption. So as a semantic detail, if no
 *       callback is registered, of course none will be called.
 */
static inline int gpio_pin_enable_callback(struct device *port, uint32_t pin)
{
	const struct gpio_driver_api *api = port->driver_api;
  1802a4:	8b 73 04             	mov    0x4(%ebx),%esi

	return api->enable_callback(port, GPIO_ACCESS_BY_PIN, pin);
  1802a7:	b9 05 00 00 00       	mov    $0x5,%ecx
  1802ac:	ba 00 00 00 00       	mov    $0x0,%edx
  1802b1:	89 d8                	mov    %ebx,%eax
  1802b3:	ff 56 10             	call   *0x10(%esi)
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;
  1802b6:	8b 73 04             	mov    0x4(%ebx),%esi

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  1802b9:	6a 00                	push   $0x0
  1802bb:	b9 02 00 00 00       	mov    $0x2,%ecx
  1802c0:	ba 00 00 00 00       	mov    $0x0,%edx
  1802c5:	89 d8                	mov    %ebx,%eax
  1802c7:	ff 16                	call   *(%esi)
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_configure(struct device *port, uint8_t pin,
				     int flags)
{
	const struct gpio_driver_api *api = port->driver_api;
  1802c9:	8b 73 04             	mov    0x4(%ebx),%esi

	return api->config(port, GPIO_ACCESS_BY_PIN, pin, flags);
  1802cc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1802d3:	b9 09 00 00 00       	mov    $0x9,%ecx
  1802d8:	ba 00 00 00 00       	mov    $0x0,%edx
  1802dd:	89 d8                	mov    %ebx,%eax
  1802df:	ff 16                	call   *(%esi)
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;
  1802e1:	8b 73 04             	mov    0x4(%ebx),%esi

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
  1802e4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1802eb:	b9 09 00 00 00       	mov    $0x9,%ecx
  1802f0:	ba 00 00 00 00       	mov    $0x0,%edx
  1802f5:	89 d8                	mov    %ebx,%eax
  1802f7:	ff 56 04             	call   *0x4(%esi)
  1802fa:	83 c4 04             	add    $0x4,%esp
	// PWM
	struct device *pwm_dev;
	int32_t period = MAX_PERIOD;
	uint8_t dir = 0;

	pwm_dev = device_get_binding(PWM_DRIVER);
  1802fd:	b8 9a 2f 18 00       	mov    $0x182f9a,%eax
  180302:	e8 52 1b 00 00       	call   181e59 <device_get_binding>
  180307:	89 c5                	mov    %eax,%ebp
	if (!pwm_dev) {
  180309:	85 c0                	test   %eax,%eax
  18030b:	75 17                	jne    180324 <main+0x146>
		printk("Cannot find %s!\n", PWM_DRIVER);
  18030d:	68 9a 2f 18 00       	push   $0x182f9a
  180312:	68 a0 2f 18 00       	push   $0x182fa0
  180317:	e8 b2 0f 00 00       	call   1812ce <printk>
  18031c:	83 c4 08             	add    $0x8,%esp
		return;
  18031f:	e9 f2 01 00 00       	jmp    180516 <main+0x338>
	}

	struct device *pinmux = device_get_binding(PINMUX_NAME);
  180324:	b8 b1 2f 18 00       	mov    $0x182fb1,%eax
  180329:	e8 2b 1b 00 00       	call   181e59 <device_get_binding>
  18032e:	89 c6                	mov    %eax,%esi
	uint32_t function;

	if (!pinmux) {
  180330:	85 c0                	test   %eax,%eax
  180332:	75 12                	jne    180346 <main+0x168>
		printk("Cannot get PINMUX\n");
  180334:	68 b8 2f 18 00       	push   $0x182fb8
  180339:	e8 90 0f 00 00       	call   1812ce <printk>
  18033e:	83 c4 04             	add    $0x4,%esp
		return;
  180341:	e9 d0 01 00 00       	jmp    180516 <main+0x338>

static inline int pinmux_pin_set(struct device *dev,
				      uint32_t pin,
				      uint32_t func)
{
	const struct pinmux_driver_api *api = dev->driver_api;
  180346:	8b 78 04             	mov    0x4(%eax),%edi

	return api->set(dev, pin, func);
  180349:	b9 02 00 00 00       	mov    $0x2,%ecx
  18034e:	ba 18 00 00 00       	mov    $0x18,%edx
  180353:	ff 17                	call   *(%edi)
	}

	if (pinmux_pin_set(pinmux, PWM1_PIN, PINMUX_FUNC_C)) {
  180355:	85 c0                	test   %eax,%eax
  180357:	74 16                	je     18036f <main+0x191>
		printk("Fail to set pin func, %u : %u\n",
  180359:	6a 02                	push   $0x2
  18035b:	6a 18                	push   $0x18
  18035d:	68 f4 2f 18 00       	push   $0x182ff4
  180362:	e8 67 0f 00 00       	call   1812ce <printk>
  180367:	83 c4 0c             	add    $0xc,%esp
			  PWM1_PIN, PINMUX_FUNC_C);
		return;
  18036a:	e9 a7 01 00 00       	jmp    180516 <main+0x338>

static inline int pinmux_pin_get(struct device *dev,
				      uint32_t pin,
				      uint32_t *func)
{
	const struct pinmux_driver_api *api = dev->driver_api;
  18036f:	8b 7e 04             	mov    0x4(%esi),%edi

	return api->get(dev, pin, func);
  180372:	8d 4c 24 08          	lea    0x8(%esp),%ecx
  180376:	ba 18 00 00 00       	mov    $0x18,%edx
  18037b:	89 f0                	mov    %esi,%eax
  18037d:	ff 57 04             	call   *0x4(%edi)
	}

	if (pinmux_pin_get(pinmux, PWM1_PIN, &function)) {
  180380:	85 c0                	test   %eax,%eax
  180382:	74 12                	je     180396 <main+0x1b8>
		printk("Fail to get pin func\n");
  180384:	68 cb 2f 18 00       	push   $0x182fcb
  180389:	e8 40 0f 00 00       	call   1812ce <printk>
  18038e:	83 c4 04             	add    $0x4,%esp
		return;
  180391:	e9 80 01 00 00       	jmp    180516 <main+0x338>
	}

	if (function != PINMUX_FUNC_C) {
  180396:	83 7c 24 08 02       	cmpl   $0x2,0x8(%esp)
  18039b:	74 12                	je     1803af <main+0x1d1>
		printk("Error. PINMUX get doesn't match PINMUX set\n");
  18039d:	68 14 30 18 00       	push   $0x183014
  1803a2:	e8 27 0f 00 00       	call   1812ce <printk>
  1803a7:	83 c4 04             	add    $0x4,%esp
		return;
  1803aa:	e9 67 01 00 00       	jmp    180516 <main+0x338>
	}


	k_timer_init(&my_timer, my_timer_handler, NULL);
  1803af:	b9 00 00 00 00       	mov    $0x0,%ecx
  1803b4:	ba b7 01 18 00       	mov    $0x1801b7,%edx
  1803b9:	b8 c0 00 28 00       	mov    $0x2800c0,%eax
  1803be:	e8 70 27 00 00       	call   182b33 <k_timer_init>
	k_timer_start(&my_timer, K_SECONDS(1), K_SECONDS(1));
  1803c3:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
  1803c8:	ba e8 03 00 00       	mov    $0x3e8,%edx
  1803cd:	b8 c0 00 28 00       	mov    $0x2800c0,%eax
  1803d2:	e8 ad 27 00 00       	call   182b84 <k_timer_start>
	gpio_pin_write(gpiob, PIN_DIR, r_dir);

	// PWM
	struct device *pwm_dev;
	int32_t period = MAX_PERIOD;
	uint8_t dir = 0;
  1803d7:	c6 44 24 06 00       	movb   $0x0,0x6(%esp)
	gpio_pin_configure(gpiob, PIN_DIR, GPIO_DIR_OUT );
	gpio_pin_write(gpiob, PIN_DIR, r_dir);

	// PWM
	struct device *pwm_dev;
	int32_t period = MAX_PERIOD;
  1803dc:	be 40 0d 03 00       	mov    $0x30d40,%esi

void main(void)
{
	uint32_t val = 0;
	uint32_t old_val = 0;
	uint8_t r_dir = 0;
  1803e1:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)


void main(void)
{
	uint32_t val = 0;
	uint32_t old_val = 0;
  1803e6:	b8 00 00 00 00       	mov    $0x0,%eax
  1803eb:	89 2c 24             	mov    %ebp,(%esp)
  1803ee:	89 c5                	mov    %eax,%ebp
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_read(struct device *port, uint32_t pin,
				uint32_t *value)
{
	const struct gpio_driver_api *api = port->driver_api;
  1803f0:	8b 7b 04             	mov    0x4(%ebx),%edi

	return api->read(port, GPIO_ACCESS_BY_PIN, pin, value);
  1803f3:	8d 44 24 0c          	lea    0xc(%esp),%eax
  1803f7:	50                   	push   %eax
  1803f8:	b9 02 00 00 00       	mov    $0x2,%ecx
  1803fd:	ba 00 00 00 00       	mov    $0x0,%edx
  180402:	89 d8                	mov    %ebx,%eax
  180404:	ff 57 08             	call   *0x8(%edi)
  180407:	83 c4 04             	add    $0x4,%esp
	{
		// SW2 READ
		gpio_pin_read(gpiob, PIN_SW, &val);

		// PWM SET
		if(period == MAX_PERIOD)
  18040a:	81 fe 40 0d 03 00    	cmp    $0x30d40,%esi
  180410:	75 1a                	jne    18042c <main+0x24e>
		{
			if (pwm_pin_set_usec(pwm_dev, PWM_CHANNEL, MAX_PERIOD, 0))
  180412:	6a 00                	push   $0x0
  180414:	b9 40 0d 03 00       	mov    $0x30d40,%ecx
  180419:	ba 01 00 00 00       	mov    $0x1,%edx
  18041e:	8b 44 24 04          	mov    0x4(%esp),%eax
  180422:	e8 43 fc ff ff       	call   18006a <pwm_pin_set_usec>
  180427:	83 c4 04             	add    $0x4,%esp
  18042a:	eb 33                	jmp    18045f <main+0x281>
				//return;
			}
		}
		else
		{
			if (pwm_pin_set_usec(pwm_dev, PWM_CHANNEL, period, period / 2))
  18042c:	89 f0                	mov    %esi,%eax
  18042e:	c1 e8 1f             	shr    $0x1f,%eax
  180431:	01 f0                	add    %esi,%eax
  180433:	d1 f8                	sar    %eax
  180435:	50                   	push   %eax
  180436:	89 f1                	mov    %esi,%ecx
  180438:	ba 01 00 00 00       	mov    $0x1,%edx
  18043d:	8b 44 24 04          	mov    0x4(%esp),%eax
  180441:	e8 24 fc ff ff       	call   18006a <pwm_pin_set_usec>
  180446:	83 c4 04             	add    $0x4,%esp
  180449:	85 c0                	test   %eax,%eax
  18044b:	74 12                	je     18045f <main+0x281>
			{
				printk("pwm pin set fails\n");
  18044d:	68 e1 2f 18 00       	push   $0x182fe1
  180452:	e8 77 0e 00 00       	call   1812ce <printk>
  180457:	83 c4 04             	add    $0x4,%esp
				return;
  18045a:	e9 b7 00 00 00       	jmp    180516 <main+0x338>
			}
		}

		if (dir)
  18045f:	80 7c 24 06 00       	cmpb   $0x0,0x6(%esp)
  180464:	74 10                	je     180476 <main+0x298>
		{
			period += ACC_STEP;
  180466:	81 c6 b8 0b 00 00    	add    $0xbb8,%esi

			if (period > MAX_PERIOD)
  18046c:	81 fe 40 0d 03 00    	cmp    $0x30d40,%esi
  180472:	7f 12                	jg     180486 <main+0x2a8>
  180474:	eb 1c                	jmp    180492 <main+0x2b4>
				period = MAX_PERIOD;
			}
		}
		else
		{
			period -= ACC_STEP;
  180476:	81 ee b8 0b 00 00    	sub    $0xbb8,%esi

			if (period < MIN_PERIOD)
  18047c:	81 fe 9b 00 00 00    	cmp    $0x9b,%esi
  180482:	7e 09                	jle    18048d <main+0x2af>
  180484:	eb 0c                	jmp    180492 <main+0x2b4>
		{
			period += ACC_STEP;

			if (period > MAX_PERIOD)
			{
				period = MAX_PERIOD;
  180486:	be 40 0d 03 00       	mov    $0x30d40,%esi
  18048b:	eb 05                	jmp    180492 <main+0x2b4>
		{
			period -= ACC_STEP;

			if (period < MIN_PERIOD)
			{
				period = MIN_PERIOD;
  18048d:	be 9c 00 00 00       	mov    $0x9c,%esi
			}
		}

		if((period == MAX_PERIOD) || (period == MIN_PERIOD))
  180492:	81 fe 40 0d 03 00    	cmp    $0x30d40,%esi
  180498:	0f 94 c2             	sete   %dl
  18049b:	81 fe 9c 00 00 00    	cmp    $0x9c,%esi
  1804a1:	0f 94 c0             	sete   %al
  1804a4:	08 c2                	or     %al,%dl
  1804a6:	74 55                	je     1804fd <main+0x31f>
		{
			if((val == 0) && (val == old_val))
  1804a8:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1804ac:	85 c0                	test   %eax,%eax
  1804ae:	75 4d                	jne    1804fd <main+0x31f>
  1804b0:	39 c5                	cmp    %eax,%ebp
  1804b2:	75 49                	jne    1804fd <main+0x31f>
			{
				if(period == MAX_PERIOD)
  1804b4:	81 fe 40 0d 03 00    	cmp    $0x30d40,%esi
  1804ba:	75 2e                	jne    1804ea <main+0x30c>
				{
					if(r_dir == 0)
  1804bc:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
  1804c1:	75 07                	jne    1804ca <main+0x2ec>
					{
						r_dir = 1;
  1804c3:	c6 44 24 07 01       	movb   $0x1,0x7(%esp)
  1804c8:	eb 05                	jmp    1804cf <main+0x2f1>
					}
					else
					{
						r_dir = 0;
  1804ca:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
					}
					gpio_pin_write(gpiob, PIN_DIR, r_dir);
  1804cf:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
 * @return 0 if successful, negative errno code on failure.
 */
static inline int gpio_pin_write(struct device *port, uint32_t pin,
				 uint32_t value)
{
	const struct gpio_driver_api *api = port->driver_api;
  1804d4:	8b 7b 04             	mov    0x4(%ebx),%edi

	return api->write(port, GPIO_ACCESS_BY_PIN, pin, value);
  1804d7:	50                   	push   %eax
  1804d8:	b9 09 00 00 00       	mov    $0x9,%ecx
  1804dd:	ba 00 00 00 00       	mov    $0x0,%edx
  1804e2:	89 d8                	mov    %ebx,%eax
  1804e4:	ff 57 04             	call   *0x4(%edi)
  1804e7:	83 c4 04             	add    $0x4,%esp
				}

				if(dir == 0)
  1804ea:	80 7c 24 06 00       	cmpb   $0x0,0x6(%esp)
  1804ef:	75 07                	jne    1804f8 <main+0x31a>
				{
					dir = 1;
  1804f1:	c6 44 24 06 01       	movb   $0x1,0x6(%esp)
  1804f6:	eb 05                	jmp    1804fd <main+0x31f>
				}
				else
				{
					dir = 0;
  1804f8:	c6 44 24 06 00       	movb   $0x0,0x6(%esp)
				}
			}
		}
		old_val = val;
  1804fd:	8b 6c 24 0c          	mov    0xc(%esp),%ebp

		time_cnt++;
  180501:	ff 05 18 01 28 00    	incl   0x280118
		k_sleep(MSEC_10);
  180507:	b8 0a 00 00 00       	mov    $0xa,%eax
  18050c:	e8 c1 1c 00 00       	call   1821d2 <k_sleep>

	}
  180511:	e9 da fe ff ff       	jmp    1803f0 <main+0x212>
}
  180516:	83 c4 10             	add    $0x10,%esp
  180519:	5b                   	pop    %ebx
  18051a:	5e                   	pop    %esi
  18051b:	5f                   	pop    %edi
  18051c:	5d                   	pop    %ebp
  18051d:	c3                   	ret    

0018051e <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  18051e:	53                   	push   %ebx
  18051f:	89 c3                	mov    %eax,%ebx
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  180521:	83 f8 0a             	cmp    $0xa,%eax
  180524:	75 10                	jne    180536 <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
  180526:	a1 30 01 28 00       	mov    0x280130,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  18052b:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  18052e:	ba 0d 00 00 00       	mov    $0xd,%edx
  180533:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
  180536:	a1 30 01 28 00       	mov    0x280130,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  18053b:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  18053e:	0f b6 d3             	movzbl %bl,%edx
  180541:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
  180544:	89 d8                	mov    %ebx,%eax
  180546:	5b                   	pop    %ebx
  180547:	c3                   	ret    

00180548 <uart_console_hook_install>:
 * @return N/A
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
  180548:	b8 1e 05 18 00       	mov    $0x18051e,%eax
  18054d:	e8 15 0a 00 00       	call   180f67 <__stdout_hook_install>
	__printk_hook_install(console_out);
  180552:	b8 1e 05 18 00       	mov    $0x18051e,%eax
  180557:	e8 7f 0b 00 00       	call   1810db <__printk_hook_install>
  18055c:	c3                   	ret    

0018055d <uart_console_init>:
static int uart_console_init(struct device *arg)
{

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  18055d:	b8 40 30 18 00       	mov    $0x183040,%eax
  180562:	e8 f2 18 00 00       	call   181e59 <device_get_binding>
  180567:	a3 30 01 28 00       	mov    %eax,0x280130
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  18056c:	e8 d7 ff ff ff       	call   180548 <uart_console_hook_install>

	return 0;
}
  180571:	b8 00 00 00 00       	mov    $0x0,%eax
  180576:	c3                   	ret    

00180577 <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
  180577:	56                   	push   %esi
  180578:	53                   	push   %ebx
  180579:	83 ec 0c             	sub    $0xc,%esp
  18057c:	89 c6                	mov    %eax,%esi
	const struct uart_qmsi_config_info *config = dev->config->config_info;
  18057e:	8b 00                	mov    (%eax),%eax
  180580:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
  180583:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
	cfg.baud_divisor = config->baud_divisor;
  18058a:	8b 43 08             	mov    0x8(%ebx),%eax
  18058d:	89 44 24 04          	mov    %eax,0x4(%esp)
	cfg.hw_fc = config->hw_fc;
  180591:	8a 43 0c             	mov    0xc(%ebx),%al
  180594:	88 44 24 08          	mov    %al,0x8(%esp)

	clk_periph_enable(config->clock_gate);
  180598:	8b 43 04             	mov    0x4(%ebx),%eax
  18059b:	e8 f6 0f 00 00       	call   181596 <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
  1805a0:	89 e2                	mov    %esp,%edx
  1805a2:	8b 03                	mov    (%ebx),%eax
  1805a4:	e8 f6 11 00 00       	call   18179f <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
  1805a9:	c7 46 04 58 30 18 00 	movl   $0x183058,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  1805b0:	b8 00 00 00 00       	mov    $0x0,%eax
  1805b5:	83 c4 0c             	add    $0xc,%esp
  1805b8:	5b                   	pop    %ebx
  1805b9:	5e                   	pop    %esi
  1805ba:	c3                   	ret    

001805bb <uart_qmsi_err_check>:
	qm_uart_write(instance, data);
	return data;
}

static int uart_qmsi_err_check(struct device *dev)
{
  1805bb:	83 ec 04             	sub    $0x4,%esp
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1805be:	8b 00                	mov    (%eax),%eax
  1805c0:	8b 40 08             	mov    0x8(%eax),%eax
  1805c3:	8b 00                	mov    (%eax),%eax

	/* QMSI and Zephyr use the same bits to represent UART errors
	 * so we don't need to translate each error bit from QMSI API
	 * to Zephyr API.
	 */
	qm_uart_get_status(instance, &status);
  1805c5:	89 e2                	mov    %esp,%edx
  1805c7:	e8 46 12 00 00       	call   181812 <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
  1805cc:	8b 04 24             	mov    (%esp),%eax
  1805cf:	83 e0 1e             	and    $0x1e,%eax
}
  1805d2:	83 c4 04             	add    $0x4,%esp
  1805d5:	c3                   	ret    

001805d6 <uart_qmsi_poll_out>:
	return 0;
}

static unsigned char uart_qmsi_poll_out(struct device *dev,
					unsigned char data)
{
  1805d6:	53                   	push   %ebx
  1805d7:	89 d3                	mov    %edx,%ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1805d9:	8b 00                	mov    (%eax),%eax
  1805db:	8b 40 08             	mov    0x8(%eax),%eax
  1805de:	8b 00                	mov    (%eax),%eax

	qm_uart_write(instance, data);
  1805e0:	0f b6 d2             	movzbl %dl,%edx
  1805e3:	e8 6d 12 00 00       	call   181855 <qm_uart_write>
	return data;
}
  1805e8:	88 d8                	mov    %bl,%al
  1805ea:	5b                   	pop    %ebx
  1805eb:	c3                   	ret    

001805ec <uart_qmsi_poll_in>:
	      uart_qmsi_device_ctrl, &drv_data_1, &config_info_1, PRE_KERNEL_1,
	      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL);
#endif /* CONFIG_UART_QMSI_1 */

static int uart_qmsi_poll_in(struct device *dev, unsigned char *data)
{
  1805ec:	56                   	push   %esi
  1805ed:	53                   	push   %ebx
  1805ee:	83 ec 04             	sub    $0x4,%esp
  1805f1:	89 d6                	mov    %edx,%esi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1805f3:	8b 00                	mov    (%eax),%eax
  1805f5:	8b 40 08             	mov    0x8(%eax),%eax
  1805f8:	8b 18                	mov    (%eax),%ebx
	qm_uart_status_t status;

	qm_uart_get_status(instance, &status);
  1805fa:	89 e2                	mov    %esp,%edx
  1805fc:	89 d8                	mov    %ebx,%eax
  1805fe:	e8 0f 12 00 00       	call   181812 <qm_uart_get_status>
	/* In order to check if there is any data to read from UART
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
  180603:	f6 04 24 40          	testb  $0x40,(%esp)
  180607:	74 15                	je     18061e <uart_qmsi_poll_in+0x32>
		return -1;

	qm_uart_read(instance, data, NULL);
  180609:	b9 00 00 00 00       	mov    $0x0,%ecx
  18060e:	89 f2                	mov    %esi,%edx
  180610:	89 d8                	mov    %ebx,%eax
  180612:	e8 60 12 00 00       	call   181877 <qm_uart_read>
	return 0;
  180617:	b8 00 00 00 00       	mov    $0x0,%eax
  18061c:	eb 05                	jmp    180623 <uart_qmsi_poll_in+0x37>
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
		return -1;
  18061e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	qm_uart_read(instance, data, NULL);
	return 0;
}
  180623:	83 c4 04             	add    $0x4,%esp
  180626:	5b                   	pop    %ebx
  180627:	5e                   	pop    %esi
  180628:	c3                   	ret    

00180629 <_timer_int_handler>:
		timer_mode = TIMER_MODE_PERIODIC;
	}

	_sys_clock_final_tick_announce();
#else
	_sys_clock_tick_announce();
  180629:	a1 30 00 28 00       	mov    0x280030,%eax
  18062e:	e8 40 1d 00 00       	call   182373 <_nano_sys_clock_tick_announce>
  180633:	c3                   	ret    

00180634 <_sys_clock_driver_init>:
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
  180634:	a1 34 00 28 00       	mov    0x280034,%eax
  180639:	48                   	dec    %eax
 * @param count Count from which timer is to count down
 * @return N/A
 */
static inline void initial_count_register_set(uint32_t count)
{
	*_REG_TIMER_ICR = count;
  18063a:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
 *
 * @return N/A
 */
static inline void periodic_mode_set(void)
{
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
  18063f:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
  180644:	0d 00 00 02 00       	or     $0x20000,%eax
  180649:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  18064e:	b9 00 00 00 00       	mov    $0x0,%ecx
  180653:	ba 0a 00 00 00       	mov    $0xa,%edx
  180658:	b8 2a 00 00 00       	mov    $0x2a,%eax
  18065d:	e8 e0 00 00 00       	call   180742 <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
  180662:	b8 0a 00 00 00       	mov    $0xa,%eax
  180667:	e8 b1 00 00 00       	call   18071d <_arch_irq_enable>

	return 0;
}
  18066c:	b8 00 00 00 00       	mov    $0x0,%eax
  180671:	c3                   	ret    

00180672 <_timer_int_handler_irq10_stub>:
	initial_count_register_set(cycles_per_tick - 1);
	periodic_mode_set();
#ifdef CONFIG_DEVICE_POWER_MANAGEMENT
	loapic_timer_device_power_state = DEVICE_PM_ACTIVE_STATE;
#endif
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);
  180672:	6a 00                	push   $0x0
  180674:	68 29 06 18 00       	push   $0x180629
  180679:	e9 5f 14 00 00       	jmp    181add <_interrupt_enter>

0018067e <qm_gpio_0_isr_irq15_stub>:
  18067e:	6a 00                	push   $0x0
  180680:	68 b6 16 18 00       	push   $0x1816b6
  180685:	e9 53 14 00 00       	jmp    181add <_interrupt_enter>

0018068a <_mvic_rte_set>:
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  18068a:	89 c1                	mov    %eax,%ecx
  18068c:	83 e1 07             	and    $0x7,%ecx
  18068f:	01 c9                	add    %ecx,%ecx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  180691:	83 e0 18             	and    $0x18,%eax
  180694:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  180697:	09 c8                	or     %ecx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  180699:	9c                   	pushf  
  18069a:	fa                   	cli    
  18069b:	59                   	pop    %ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  18069c:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
  1806a1:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  1806a7:	f6 c5 02             	test   $0x2,%ch
  1806aa:	74 01                	je     1806ad <_mvic_rte_set+0x23>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1806ac:	fb                   	sti    
  1806ad:	c3                   	ret    

001806ae <_mvic_rte_update>:
 * @param mask of bits to be modified
 *
 * @returns N/A
 */
static void _mvic_rte_update(unsigned int irq, uint32_t value, uint32_t mask)
{
  1806ae:	53                   	push   %ebx
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  1806af:	89 c3                	mov    %eax,%ebx
  1806b1:	83 e3 07             	and    $0x7,%ebx
  1806b4:	01 db                	add    %ebx,%ebx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  1806b6:	83 e0 18             	and    $0x18,%eax
  1806b9:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  1806bc:	09 d8                	or     %ebx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1806be:	9c                   	pushf  
  1806bf:	fa                   	cli    
  1806c0:	5b                   	pop    %ebx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1806c1:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1806c6:	a1 10 00 c0 fe       	mov    0xfec00010,%eax
	key = irq_lock();

	sys_write32(regsel, MVIC_IOREGSEL);

	old_value = sys_read32(MVIC_IOWIN);
	updated_value = (old_value & ~mask) | (value & mask);
  1806cb:	31 c2                	xor    %eax,%edx
  1806cd:	21 d1                	and    %edx,%ecx
  1806cf:	31 c8                	xor    %ecx,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1806d1:	a3 10 00 c0 fe       	mov    %eax,0xfec00010
  1806d6:	f6 c7 02             	test   $0x2,%bh
  1806d9:	74 01                	je     1806dc <_mvic_rte_update+0x2e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1806db:	fb                   	sti    
	sys_write32(updated_value, MVIC_IOWIN);

	irq_unlock(key);
}
  1806dc:	5b                   	pop    %ebx
  1806dd:	c3                   	ret    

001806de <_mvic_init>:
 * This routine replaces the standard Local APIC / IO APIC init routines.
 *
 * @returns: N/A
 */
static int _mvic_init(struct device *unused)
{
  1806de:	53                   	push   %ebx
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  1806df:	bb 00 00 00 00       	mov    $0x0,%ebx
  1806e4:	eb 0d                	jmp    1806f3 <_mvic_init+0x15>
		_mvic_rte_set(i, MVIC_IOWIN_MASK);
  1806e6:	ba 00 00 01 00       	mov    $0x10000,%edx
  1806eb:	89 d8                	mov    %ebx,%eax
  1806ed:	e8 98 ff ff ff       	call   18068a <_mvic_rte_set>
{
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  1806f2:	43                   	inc    %ebx
  1806f3:	83 fb 1f             	cmp    $0x1f,%ebx
  1806f6:	7e ee                	jle    1806e6 <_mvic_init+0x8>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1806f8:	b8 00 00 00 00       	mov    $0x0,%eax
  1806fd:	a3 80 00 e0 fe       	mov    %eax,0xfee00080
  180702:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
  180707:	b8 0a 00 01 00       	mov    $0x1000a,%eax
  18070c:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180711:	b8 00 00 00 00       	mov    $0x0,%eax
  180716:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	/* discard a pending interrupt if any */
	sys_write32(0, MVIC_EOI);

	return 0;

}
  18071b:	5b                   	pop    %ebx
  18071c:	c3                   	ret    

0018071d <_arch_irq_enable>:
SYS_INIT(_mvic_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


void _arch_irq_enable(unsigned int irq)
{
	if (irq == CONFIG_MVIC_TIMER_IRQ) {
  18071d:	83 f8 0a             	cmp    $0xa,%eax
  180720:	75 10                	jne    180732 <_arch_irq_enable+0x15>
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180722:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
		sys_write32(sys_read32(MVIC_LVTTIMER) & ~MVIC_LVTTIMER_MASK,
  180727:	25 ff ff fe ff       	and    $0xfffeffff,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  18072c:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180731:	c3                   	ret    
			    MVIC_LVTTIMER);
	} else {
		_mvic_rte_update(irq, 0, MVIC_IOWIN_MASK);
  180732:	b9 00 00 01 00       	mov    $0x10000,%ecx
  180737:	ba 00 00 00 00       	mov    $0x0,%edx
  18073c:	e8 6d ff ff ff       	call   1806ae <_mvic_rte_update>
  180741:	c3                   	ret    

00180742 <__irq_controller_irq_config>:

	/* Vector argument always ignored. There are no triggering options
	 * for the timer, so nothing to do at all for that case. Other I/O
	 * interrupts need their triggering set
	 */
	if (irq != CONFIG_MVIC_TIMER_IRQ) {
  180742:	83 fa 0a             	cmp    $0xa,%edx
  180745:	74 0f                	je     180756 <__irq_controller_irq_config+0x14>
  180747:	89 d0                	mov    %edx,%eax
		_mvic_rte_set(irq, MVIC_IOWIN_MASK | flags);
  180749:	81 c9 00 00 01 00    	or     $0x10000,%ecx
  18074f:	89 ca                	mov    %ecx,%edx
  180751:	e8 34 ff ff ff       	call   18068a <_mvic_rte_set>
  180756:	c3                   	ret    

00180757 <__irq_controller_isr_vector_get>:
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180757:	a1 10 01 e0 fe       	mov    0xfee00110,%eax
{
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
  18075c:	85 c0                	test   %eax,%eax
  18075e:	74 0e                	je     18076e <__irq_controller_isr_vector_get+0x17>

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  180760:	0f bd c0             	bsr    %eax,%eax
  180763:	75 05                	jne    18076a <__irq_controller_isr_vector_get+0x13>
  180765:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		return -1;
	}
	return 32 + (find_msb_set(isr) - 1);
  18076a:	83 c0 20             	add    $0x20,%eax
  18076d:	c3                   	ret    
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
		return -1;
  18076e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
	return 32 + (find_msb_set(isr) - 1);
}
  180773:	c3                   	ret    

00180774 <gpio_qmsi_callback>:
	      POST_KERNEL, CONFIG_GPIO_QMSI_INIT_PRIORITY, NULL);

#endif /* CONFIG_GPIO_QMSI_1 */

static void gpio_qmsi_callback(void *data, uint32_t status)
{
  180774:	57                   	push   %edi
  180775:	56                   	push   %esi
  180776:	53                   	push   %ebx
	struct device *port = data;
	struct gpio_qmsi_runtime *context = port->driver_data;
  180777:	8b 48 08             	mov    0x8(%eax),%ecx
	const uint32_t enabled_mask = context->pin_callbacks & status;

	if (enabled_mask) {
  18077a:	89 d6                	mov    %edx,%esi
  18077c:	23 71 08             	and    0x8(%ecx),%esi
  18077f:	74 3c                	je     1807bd <gpio_qmsi_callback+0x49>
  180781:	89 c7                	mov    %eax,%edi
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  180783:	8b 19                	mov    (%ecx),%ebx
  180785:	eb 32                	jmp    1807b9 <gpio_qmsi_callback+0x45>
					uint32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
		if (cb->pin_mask & pins) {
  180787:	85 73 08             	test   %esi,0x8(%ebx)
  18078a:	74 09                	je     180795 <gpio_qmsi_callback+0x21>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, pins);
  18078c:	89 f1                	mov    %esi,%ecx
  18078e:	89 da                	mov    %ebx,%edx
  180790:	89 f8                	mov    %edi,%eax
  180792:	ff 53 04             	call   *0x4(%ebx)
					struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb;

	SYS_SLIST_FOR_EACH_CONTAINER(list, cb, node) {
  180795:	89 d8                	mov    %ebx,%eax
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  180797:	85 db                	test   %ebx,%ebx
  180799:	74 04                	je     18079f <gpio_qmsi_callback+0x2b>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
  18079b:	8b 13                	mov    (%ebx),%edx
  18079d:	eb 02                	jmp    1807a1 <gpio_qmsi_callback+0x2d>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  18079f:	89 da                	mov    %ebx,%edx
  1807a1:	85 d2                	test   %edx,%edx
  1807a3:	74 0f                	je     1807b4 <gpio_qmsi_callback+0x40>
  1807a5:	85 c0                	test   %eax,%eax
  1807a7:	74 04                	je     1807ad <gpio_qmsi_callback+0x39>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
  1807a9:	8b 1b                	mov    (%ebx),%ebx
  1807ab:	eb 0c                	jmp    1807b9 <gpio_qmsi_callback+0x45>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  1807ad:	bb 00 00 00 00       	mov    $0x0,%ebx
  1807b2:	eb 05                	jmp    1807b9 <gpio_qmsi_callback+0x45>
  1807b4:	bb 00 00 00 00       	mov    $0x0,%ebx
  1807b9:	85 db                	test   %ebx,%ebx
  1807bb:	75 ca                	jne    180787 <gpio_qmsi_callback+0x13>
		_gpio_fire_callbacks(&context->callbacks, port, enabled_mask);
	}
}
  1807bd:	5b                   	pop    %ebx
  1807be:	5e                   	pop    %esi
  1807bf:	5f                   	pop    %edi
  1807c0:	c3                   	ret    

001807c1 <qmsi_write_bit>:

static void qmsi_write_bit(uint32_t *target, uint8_t bit, uint8_t value)
{
	if (value) {
  1807c1:	84 c9                	test   %cl,%cl
  1807c3:	74 07                	je     1807cc <qmsi_write_bit+0xb>
		sys_set_bit((uintptr_t) target, bit);
  1807c5:	0f b6 d2             	movzbl %dl,%edx


static ALWAYS_INLINE
	void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
  1807c8:	0f ab 10             	bts    %edx,(%eax)
  1807cb:	c3                   	ret    
	} else {
		sys_clear_bit((uintptr_t) target, bit);
  1807cc:	0f b6 d2             	movzbl %dl,%edx
}

static ALWAYS_INLINE
	void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
  1807cf:	0f b3 10             	btr    %edx,(%eax)
  1807d2:	c3                   	ret    

001807d3 <gpio_qmsi_manage_callback>:
}

static inline int gpio_qmsi_manage_callback(struct device *port,
					    struct gpio_callback *callback,
					    bool set)
{
  1807d3:	57                   	push   %edi
  1807d4:	56                   	push   %esi
  1807d5:	53                   	push   %ebx
	struct gpio_qmsi_runtime *context = port->driver_data;
  1807d6:	8b 58 08             	mov    0x8(%eax),%ebx
					 bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (set) {
  1807d9:	84 c9                	test   %cl,%cl
  1807db:	74 11                	je     1807ee <gpio_qmsi_manage_callback+0x1b>
 * @param node A pointer on the node to prepend
 */
static inline void sys_slist_prepend(sys_slist_t *list,
				     sys_snode_t *node)
{
	node->next = list->head;
  1807dd:	8b 03                	mov    (%ebx),%eax
  1807df:	89 02                	mov    %eax,(%edx)
	list->head = node;
  1807e1:	89 13                	mov    %edx,(%ebx)

	if (!list->tail) {
  1807e3:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  1807e7:	75 4c                	jne    180835 <gpio_qmsi_manage_callback+0x62>
		list->tail = list->head;
  1807e9:	89 53 04             	mov    %edx,0x4(%ebx)
  1807ec:	eb 47                	jmp    180835 <gpio_qmsi_manage_callback+0x62>
		sys_slist_prepend(callbacks, &callback->node);
	} else {
		sys_slist_find_and_remove(callbacks, &callback->node);
  1807ee:	89 d7                	mov    %edx,%edi
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
  1807f0:	8b 03                	mov    (%ebx),%eax
 * @param node A pointer on the node to remove from the list
 */
static inline void sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
  1807f2:	be 00 00 00 00       	mov    $0x0,%esi
  1807f7:	eb 38                	jmp    180831 <gpio_qmsi_manage_callback+0x5e>
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
		if (test == node) {
  1807f9:	39 c7                	cmp    %eax,%edi
  1807fb:	75 26                	jne    180823 <gpio_qmsi_manage_callback+0x50>
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node)
{
	if (!prev_node) {
  1807fd:	85 f6                	test   %esi,%esi
  1807ff:	75 0e                	jne    18080f <gpio_qmsi_manage_callback+0x3c>
		list->head = node->next;
  180801:	8b 02                	mov    (%edx),%eax
  180803:	89 03                	mov    %eax,(%ebx)

		/* Was node also the tail? */
		if (list->tail == node) {
  180805:	3b 53 04             	cmp    0x4(%ebx),%edx
  180808:	75 11                	jne    18081b <gpio_qmsi_manage_callback+0x48>
			list->tail = list->head;
  18080a:	89 43 04             	mov    %eax,0x4(%ebx)
  18080d:	eb 0c                	jmp    18081b <gpio_qmsi_manage_callback+0x48>
		}
	} else {
		prev_node->next = node->next;
  18080f:	8b 02                	mov    (%edx),%eax
  180811:	89 06                	mov    %eax,(%esi)

		/* Was node the tail? */
		if (list->tail == node) {
  180813:	3b 53 04             	cmp    0x4(%ebx),%edx
  180816:	75 03                	jne    18081b <gpio_qmsi_manage_callback+0x48>
			list->tail = prev_node;
  180818:	89 73 04             	mov    %esi,0x4(%ebx)
		}
	}

	node->next = NULL;
  18081b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  180821:	eb 12                	jmp    180835 <gpio_qmsi_manage_callback+0x62>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  180823:	85 c0                	test   %eax,%eax
  180825:	74 04                	je     18082b <gpio_qmsi_manage_callback+0x58>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node)
{
	return node->next;
  180827:	8b 08                	mov    (%eax),%ecx
  180829:	eb 02                	jmp    18082d <gpio_qmsi_manage_callback+0x5a>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node)
{
	return node ? sys_slist_peek_next_no_check(node) : NULL;
  18082b:	89 c1                	mov    %eax,%ecx
		if (test == node) {
			sys_slist_remove(list, prev, node);
			break;
		}

		prev = test;
  18082d:	89 c6                	mov    %eax,%esi
					     sys_snode_t *node)
{
	sys_snode_t *prev = NULL;
	sys_snode_t *test;

	SYS_SLIST_FOR_EACH_NODE(list, test) {
  18082f:	89 c8                	mov    %ecx,%eax
  180831:	85 c0                	test   %eax,%eax
  180833:	75 c4                	jne    1807f9 <gpio_qmsi_manage_callback+0x26>

	_gpio_manage_callback(&context->callbacks, callback, set);

	return 0;
}
  180835:	b8 00 00 00 00       	mov    $0x0,%eax
  18083a:	5b                   	pop    %ebx
  18083b:	5e                   	pop    %esi
  18083c:	5f                   	pop    %edi
  18083d:	c3                   	ret    

0018083e <gpio_qmsi_enable_callback>:

static inline int gpio_qmsi_enable_callback(struct device *port,
					    int access_op, uint32_t pin)
{
	struct gpio_qmsi_runtime *context = port->driver_data;
  18083e:	8b 40 08             	mov    0x8(%eax),%eax

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
  180841:	85 d2                	test   %edx,%edx
  180843:	75 0c                	jne    180851 <gpio_qmsi_enable_callback+0x13>
		context->pin_callbacks |= BIT(pin);
  180845:	ba 01 00 00 00       	mov    $0x1,%edx
  18084a:	d3 e2                	shl    %cl,%edx
  18084c:	09 50 08             	or     %edx,0x8(%eax)
  18084f:	eb 07                	jmp    180858 <gpio_qmsi_enable_callback+0x1a>
	} else {
		context->pin_callbacks = 0xffffffff;
  180851:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}
	return 0;
}
  180858:	b8 00 00 00 00       	mov    $0x0,%eax
  18085d:	c3                   	ret    

0018085e <gpio_qmsi_disable_callback>:

static inline int gpio_qmsi_disable_callback(struct device *port,
					     int access_op, uint32_t pin)
{
	struct gpio_qmsi_runtime *context = port->driver_data;
  18085e:	8b 40 08             	mov    0x8(%eax),%eax

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
  180861:	85 d2                	test   %edx,%edx
  180863:	75 0e                	jne    180873 <gpio_qmsi_disable_callback+0x15>
		context->pin_callbacks &= ~BIT(pin);
  180865:	ba 01 00 00 00       	mov    $0x1,%edx
  18086a:	d3 e2                	shl    %cl,%edx
  18086c:	f7 d2                	not    %edx
  18086e:	21 50 08             	and    %edx,0x8(%eax)
  180871:	eb 07                	jmp    18087a <gpio_qmsi_disable_callback+0x1c>
	} else {
		context->pin_callbacks = 0;
  180873:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}

	return 0;
}
  18087a:	b8 00 00 00 00       	mov    $0x0,%eax
  18087f:	c3                   	ret    

00180880 <gpio_qmsi_get_pending_int>:

static uint32_t gpio_qmsi_get_pending_int(struct device *dev)
{
	const struct gpio_qmsi_config *gpio_config = dev->config->config_info;
  180880:	8b 00                	mov    (%eax),%eax
  180882:	8b 40 08             	mov    0x8(%eax),%eax
	qm_gpio_t gpio = gpio_config->gpio;
  180885:	8b 00                	mov    (%eax),%eax

	return QM_GPIO[gpio]->gpio_intstatus;
  180887:	8b 04 85 24 00 28 00 	mov    0x280024(,%eax,4),%eax
  18088e:	8b 40 40             	mov    0x40(%eax),%eax
}
  180891:	c3                   	ret    

00180892 <gpio_qmsi_read>:
	return 0;
}

static inline int gpio_qmsi_read(struct device *port,
				 int access_op, uint32_t pin, uint32_t *value)
{
  180892:	83 ec 04             	sub    $0x4,%esp
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
  180895:	8b 00                	mov    (%eax),%eax
  180897:	8b 40 08             	mov    0x8(%eax),%eax
	qm_gpio_t gpio = gpio_config->gpio;
  18089a:	8b 00                	mov    (%eax),%eax
	qm_gpio_state_t state;

	if (access_op == GPIO_ACCESS_BY_PIN) {
  18089c:	85 d2                	test   %edx,%edx
  18089e:	75 15                	jne    1808b5 <gpio_qmsi_read+0x23>
		qm_gpio_read_pin(gpio, pin, &state);
  1808a0:	0f b6 d1             	movzbl %cl,%edx
  1808a3:	89 e1                	mov    %esp,%ecx
  1808a5:	e8 75 0e 00 00       	call   18171f <qm_gpio_read_pin>
		*value = state;
  1808aa:	8b 04 24             	mov    (%esp),%eax
  1808ad:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1808b1:	89 01                	mov    %eax,(%ecx)
  1808b3:	eb 09                	jmp    1808be <gpio_qmsi_read+0x2c>
	} else {
		qm_gpio_read_port(gpio, (uint32_t *const) value);
  1808b5:	8b 54 24 08          	mov    0x8(%esp),%edx
  1808b9:	e8 c0 0e 00 00       	call   18177e <qm_gpio_read_port>
	}

	return 0;
}
  1808be:	b8 00 00 00 00       	mov    $0x0,%eax
  1808c3:	83 c4 04             	add    $0x4,%esp
  1808c6:	c3                   	ret    

001808c7 <gpio_qmsi_write>:
}

static inline int gpio_qmsi_write(struct device *port,
				  int access_op, uint32_t pin, uint32_t value)
{
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
  1808c7:	8b 00                	mov    (%eax),%eax
  1808c9:	8b 40 08             	mov    0x8(%eax),%eax
	qm_gpio_t gpio = gpio_config->gpio;
  1808cc:	8b 00                	mov    (%eax),%eax

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
  1808ce:	85 d2                	test   %edx,%edx
  1808d0:	75 1b                	jne    1808ed <gpio_qmsi_write+0x26>
		if (value) {
  1808d2:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  1808d7:	74 0a                	je     1808e3 <gpio_qmsi_write+0x1c>
			qm_gpio_set_pin(gpio, pin);
  1808d9:	0f b6 d1             	movzbl %cl,%edx
  1808dc:	e8 5b 0e 00 00       	call   18173c <qm_gpio_set_pin>
  1808e1:	eb 13                	jmp    1808f6 <gpio_qmsi_write+0x2f>
		} else {
			qm_gpio_clear_pin(gpio, pin);
  1808e3:	0f b6 d1             	movzbl %cl,%edx
  1808e6:	e8 71 0e 00 00       	call   18175c <qm_gpio_clear_pin>
  1808eb:	eb 09                	jmp    1808f6 <gpio_qmsi_write+0x2f>
		}
	} else {
		qm_gpio_write_port(gpio, value);
  1808ed:	8b 54 24 04          	mov    0x4(%esp),%edx
  1808f1:	e8 9a 0e 00 00       	call   181790 <qm_gpio_write_port>

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(port));
	}
	return 0;
}
  1808f6:	b8 00 00 00 00       	mov    $0x0,%eax
  1808fb:	c3                   	ret    

001808fc <gpio_qmsi_init>:
	.get_pending_int = gpio_qmsi_get_pending_int,
};

static int gpio_qmsi_init(struct device *port)
{
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
  1808fc:	8b 10                	mov    (%eax),%edx
  1808fe:	8b 52 08             	mov    0x8(%edx),%edx
	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_init(RP_GET(port), 0, UINT_MAX);
		k_sem_give(RP_GET(port));
	}

	switch (gpio_config->gpio) {
  180901:	83 3a 00             	cmpl   $0x0,(%edx)
  180904:	75 46                	jne    18094c <gpio_qmsi_init+0x50>
	.disable_callback = gpio_qmsi_disable_callback,
	.get_pending_int = gpio_qmsi_get_pending_int,
};

static int gpio_qmsi_init(struct device *port)
{
  180906:	53                   	push   %ebx
  180907:	89 c3                	mov    %eax,%ebx
		k_sem_give(RP_GET(port));
	}

	switch (gpio_config->gpio) {
	case QM_GPIO_0:
		clk_periph_enable(CLK_PERIPH_GPIO_REGISTER |
  180909:	b8 82 21 00 00       	mov    $0x2182,%eax
  18090e:	e8 83 0c 00 00       	call   181596 <clk_periph_enable>
  180913:	b9 00 80 00 00       	mov    $0x8000,%ecx
  180918:	ba 0f 00 00 00       	mov    $0xf,%edx
  18091d:	b8 2f 00 00 00       	mov    $0x2f,%eax
  180922:	e8 1b fe ff ff       	call   180742 <__irq_controller_irq_config>
				  CLK_PERIPH_GPIO_DB |
				  CLK_PERIPH_CLK);
		IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_GPIO_0_INT),
			    CONFIG_GPIO_QMSI_0_IRQ_PRI, qm_gpio_0_isr, 0,
			    IOAPIC_LEVEL | IOAPIC_HIGH);
		irq_enable(IRQ_GET_NUMBER(QM_IRQ_GPIO_0_INT));
  180927:	b8 0f 00 00 00       	mov    $0xf,%eax
  18092c:	e8 ec fd ff ff       	call   18071d <_arch_irq_enable>
		QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->gpio_0_int_mask);
  180931:	a1 6c 04 80 b0       	mov    0xb080046c,%eax
  180936:	83 e0 fe             	and    $0xfffffffe,%eax
  180939:	a3 6c 04 80 b0       	mov    %eax,0xb080046c
		return -EIO;
	}

	gpio_qmsi_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	port->driver_api = &api_funcs;
  18093e:	c7 43 04 84 30 18 00 	movl   $0x183084,0x4(%ebx)
	return 0;
  180945:	b8 00 00 00 00       	mov    $0x0,%eax
  18094a:	eb 06                	jmp    180952 <gpio_qmsi_init+0x56>
		QM_IR_UNMASK_INTERRUPTS(
			QM_INTERRUPT_ROUTER->aon_gpio_0_int_mask);
		break;
#endif /* CONFIG_GPIO_QMSI_1 */
	default:
		return -EIO;
  18094c:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  180951:	c3                   	ret    

	gpio_qmsi_set_power_state(port, DEVICE_PM_ACTIVE_STATE);

	port->driver_api = &api_funcs;
	return 0;
}
  180952:	5b                   	pop    %ebx
  180953:	c3                   	ret    

00180954 <gpio_qmsi_config>:
	}
}

static inline int gpio_qmsi_config(struct device *port,
				   int access_op, uint32_t pin, int flags)
{
  180954:	55                   	push   %ebp
  180955:	57                   	push   %edi
  180956:	56                   	push   %esi
  180957:	53                   	push   %ebx
  180958:	83 ec 28             	sub    $0x28,%esp
	/* If the pin/port is set to receive interrupts, make sure the pin
	   is an input */
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
  18095b:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
  18095f:	83 e3 03             	and    $0x3,%ebx
  180962:	83 fb 03             	cmp    $0x3,%ebx
  180965:	0f 84 10 02 00 00    	je     180b7b <gpio_qmsi_config+0x227>
  18096b:	89 ce                	mov    %ecx,%esi
  18096d:	89 c5                	mov    %eax,%ebp
		return -EINVAL;
	}

	if (access_op == GPIO_ACCESS_BY_PIN) {
  18096f:	85 d2                	test   %edx,%edx
  180971:	0f 85 f1 00 00 00    	jne    180a68 <gpio_qmsi_config+0x114>
	}
}

static inline void qmsi_pin_config(struct device *port, uint32_t pin, int flags)
{
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
  180977:	8b 00                	mov    (%eax),%eax
  180979:	8b 40 08             	mov    0x8(%eax),%eax
	qm_gpio_t gpio = gpio_config->gpio;
  18097c:	8b 18                	mov    (%eax),%ebx
	qm_gpio_port_config_t cfg = { 0 };
  18097e:	8d 7c 24 08          	lea    0x8(%esp),%edi
  180982:	b9 08 00 00 00       	mov    $0x8,%ecx
  180987:	b8 00 00 00 00       	mov    $0x0,%eax
  18098c:	f3 ab                	rep stos %eax,%es:(%edi)

	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
  18098e:	8b 04 9d 24 00 28 00 	mov    0x280024(,%ebx,4),%eax
  180995:	8b 50 04             	mov    0x4(%eax),%edx
  180998:	89 54 24 08          	mov    %edx,0x8(%esp)
	cfg.int_en = QM_GPIO[gpio]->gpio_inten;
  18099c:	8b 50 30             	mov    0x30(%eax),%edx
  18099f:	89 54 24 0c          	mov    %edx,0xc(%esp)
	cfg.int_type = QM_GPIO[gpio]->gpio_inttype_level;
  1809a3:	8b 50 38             	mov    0x38(%eax),%edx
  1809a6:	89 54 24 10          	mov    %edx,0x10(%esp)
	cfg.int_polarity = QM_GPIO[gpio]->gpio_int_polarity;
  1809aa:	8b 50 3c             	mov    0x3c(%eax),%edx
  1809ad:	89 54 24 14          	mov    %edx,0x14(%esp)
	cfg.int_debounce = QM_GPIO[gpio]->gpio_debounce;
  1809b1:	8b 50 48             	mov    0x48(%eax),%edx
  1809b4:	89 54 24 18          	mov    %edx,0x18(%esp)
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
  1809b8:	8b 40 68             	mov    0x68(%eax),%eax
  1809bb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	cfg.callback = gpio_qmsi_callback;
  1809bf:	c7 44 24 20 74 07 18 	movl   $0x180774,0x20(%esp)
  1809c6:	00 
	cfg.callback_data = port;
  1809c7:	89 6c 24 24          	mov    %ebp,0x24(%esp)

	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
  1809cb:	89 f0                	mov    %esi,%eax
  1809cd:	0f b6 f0             	movzbl %al,%esi
  1809d0:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  1809d4:	83 e1 01             	and    $0x1,%ecx
  1809d7:	89 f2                	mov    %esi,%edx
  1809d9:	8d 44 24 08          	lea    0x8(%esp),%eax
  1809dd:	e8 df fd ff ff       	call   1807c1 <qmsi_write_bit>

	if (flags & GPIO_INT) {
  1809e2:	f6 44 24 3c 02       	testb  $0x2,0x3c(%esp)
  1809e7:	74 5a                	je     180a43 <gpio_qmsi_config+0xef>
		qmsi_write_bit(&cfg.int_type, pin, (flags & GPIO_INT_EDGE));
  1809e9:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  1809ed:	83 e1 20             	and    $0x20,%ecx
  1809f0:	89 f2                	mov    %esi,%edx
  1809f2:	8d 44 24 10          	lea    0x10(%esp),%eax
  1809f6:	e8 c6 fd ff ff       	call   1807c1 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_polarity, pin,
  1809fb:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  1809ff:	83 e1 04             	and    $0x4,%ecx
  180a02:	89 f2                	mov    %esi,%edx
  180a04:	8d 44 24 14          	lea    0x14(%esp),%eax
  180a08:	e8 b4 fd ff ff       	call   1807c1 <qmsi_write_bit>
			       (flags & GPIO_INT_ACTIVE_HIGH));
		qmsi_write_bit(&cfg.int_debounce, pin,
  180a0d:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  180a11:	83 e1 10             	and    $0x10,%ecx
  180a14:	89 f2                	mov    %esi,%edx
  180a16:	8d 44 24 18          	lea    0x18(%esp),%eax
  180a1a:	e8 a2 fd ff ff       	call   1807c1 <qmsi_write_bit>
			       (flags & GPIO_INT_DEBOUNCE));
		qmsi_write_bit(&cfg.int_bothedge, pin,
  180a1f:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  180a23:	83 e1 40             	and    $0x40,%ecx
  180a26:	89 f2                	mov    %esi,%edx
  180a28:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  180a2c:	e8 90 fd ff ff       	call   1807c1 <qmsi_write_bit>
			       (flags & GPIO_INT_DOUBLE_EDGE));
		qmsi_write_bit(&cfg.int_en, pin, 1);
  180a31:	b9 01 00 00 00       	mov    $0x1,%ecx
  180a36:	89 f2                	mov    %esi,%edx
  180a38:	8d 44 24 0c          	lea    0xc(%esp),%eax
  180a3c:	e8 80 fd ff ff       	call   1807c1 <qmsi_write_bit>
  180a41:	eb 10                	jmp    180a53 <gpio_qmsi_config+0xff>
	} else {
		qmsi_write_bit(&cfg.int_en, pin, 0);
  180a43:	b9 00 00 00 00       	mov    $0x0,%ecx
  180a48:	89 f2                	mov    %esi,%edx
  180a4a:	8d 44 24 0c          	lea    0xc(%esp),%eax
  180a4e:	e8 6e fd ff ff       	call   1807c1 <qmsi_write_bit>

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	qm_gpio_set_config(gpio, &cfg);
  180a53:	8d 54 24 08          	lea    0x8(%esp),%edx
  180a57:	89 d8                	mov    %ebx,%eax
  180a59:	e8 63 0c 00 00       	call   1816c1 <qm_gpio_set_config>
	if (access_op == GPIO_ACCESS_BY_PIN) {
		qmsi_pin_config(port, pin, flags);
	} else {
		qmsi_port_config(port, flags);
	}
	return 0;
  180a5e:	b8 00 00 00 00       	mov    $0x0,%eax
  180a63:	e9 18 01 00 00       	jmp    180b80 <gpio_qmsi_config+0x22c>
	}
}

static inline void qmsi_port_config(struct device *port, int flags)
{
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
  180a68:	8b 00                	mov    (%eax),%eax
  180a6a:	8b 40 08             	mov    0x8(%eax),%eax
	uint8_t num_pins = gpio_config->num_pins;
  180a6d:	8a 40 04             	mov    0x4(%eax),%al
  180a70:	88 44 24 07          	mov    %al,0x7(%esp)
	int i;

	for (i = 0; i < num_pins; i++) {
  180a74:	bb 00 00 00 00       	mov    $0x0,%ebx
  180a79:	89 1c 24             	mov    %ebx,(%esp)
  180a7c:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  180a80:	e9 e1 00 00 00       	jmp    180b66 <gpio_qmsi_config+0x212>
	}
}

static inline void qmsi_pin_config(struct device *port, uint32_t pin, int flags)
{
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
  180a85:	8b 45 00             	mov    0x0(%ebp),%eax
  180a88:	8b 40 08             	mov    0x8(%eax),%eax
	qm_gpio_t gpio = gpio_config->gpio;
  180a8b:	8b 18                	mov    (%eax),%ebx
	qm_gpio_port_config_t cfg = { 0 };
  180a8d:	8d 7c 24 08          	lea    0x8(%esp),%edi
  180a91:	b9 08 00 00 00       	mov    $0x8,%ecx
  180a96:	b8 00 00 00 00       	mov    $0x0,%eax
  180a9b:	f3 ab                	rep stos %eax,%es:(%edi)

	cfg.direction = QM_GPIO[gpio]->gpio_swporta_ddr;
  180a9d:	8b 04 9d 24 00 28 00 	mov    0x280024(,%ebx,4),%eax
  180aa4:	8b 50 04             	mov    0x4(%eax),%edx
  180aa7:	89 54 24 08          	mov    %edx,0x8(%esp)
	cfg.int_en = QM_GPIO[gpio]->gpio_inten;
  180aab:	8b 50 30             	mov    0x30(%eax),%edx
  180aae:	89 54 24 0c          	mov    %edx,0xc(%esp)
	cfg.int_type = QM_GPIO[gpio]->gpio_inttype_level;
  180ab2:	8b 50 38             	mov    0x38(%eax),%edx
  180ab5:	89 54 24 10          	mov    %edx,0x10(%esp)
	cfg.int_polarity = QM_GPIO[gpio]->gpio_int_polarity;
  180ab9:	8b 50 3c             	mov    0x3c(%eax),%edx
  180abc:	89 54 24 14          	mov    %edx,0x14(%esp)
	cfg.int_debounce = QM_GPIO[gpio]->gpio_debounce;
  180ac0:	8b 50 48             	mov    0x48(%eax),%edx
  180ac3:	89 54 24 18          	mov    %edx,0x18(%esp)
	cfg.int_bothedge = QM_GPIO[gpio]->gpio_int_bothedge;
  180ac7:	8b 40 68             	mov    0x68(%eax),%eax
  180aca:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	cfg.callback = gpio_qmsi_callback;
  180ace:	c7 44 24 20 74 07 18 	movl   $0x180774,0x20(%esp)
  180ad5:	00 
	cfg.callback_data = port;
  180ad6:	89 6c 24 24          	mov    %ebp,0x24(%esp)

	qmsi_write_bit(&cfg.direction, pin, (flags & GPIO_DIR_MASK));
  180ada:	0f b6 3c 24          	movzbl (%esp),%edi
  180ade:	89 f1                	mov    %esi,%ecx
  180ae0:	83 e1 01             	and    $0x1,%ecx
  180ae3:	89 fa                	mov    %edi,%edx
  180ae5:	8d 44 24 08          	lea    0x8(%esp),%eax
  180ae9:	e8 d3 fc ff ff       	call   1807c1 <qmsi_write_bit>

	if (flags & GPIO_INT) {
  180aee:	f7 c6 02 00 00 00    	test   $0x2,%esi
  180af4:	74 52                	je     180b48 <gpio_qmsi_config+0x1f4>
		qmsi_write_bit(&cfg.int_type, pin, (flags & GPIO_INT_EDGE));
  180af6:	89 f1                	mov    %esi,%ecx
  180af8:	83 e1 20             	and    $0x20,%ecx
  180afb:	89 fa                	mov    %edi,%edx
  180afd:	8d 44 24 10          	lea    0x10(%esp),%eax
  180b01:	e8 bb fc ff ff       	call   1807c1 <qmsi_write_bit>
		qmsi_write_bit(&cfg.int_polarity, pin,
  180b06:	89 f1                	mov    %esi,%ecx
  180b08:	83 e1 04             	and    $0x4,%ecx
  180b0b:	89 fa                	mov    %edi,%edx
  180b0d:	8d 44 24 14          	lea    0x14(%esp),%eax
  180b11:	e8 ab fc ff ff       	call   1807c1 <qmsi_write_bit>
			       (flags & GPIO_INT_ACTIVE_HIGH));
		qmsi_write_bit(&cfg.int_debounce, pin,
  180b16:	89 f1                	mov    %esi,%ecx
  180b18:	83 e1 10             	and    $0x10,%ecx
  180b1b:	89 fa                	mov    %edi,%edx
  180b1d:	8d 44 24 18          	lea    0x18(%esp),%eax
  180b21:	e8 9b fc ff ff       	call   1807c1 <qmsi_write_bit>
			       (flags & GPIO_INT_DEBOUNCE));
		qmsi_write_bit(&cfg.int_bothedge, pin,
  180b26:	89 f1                	mov    %esi,%ecx
  180b28:	83 e1 40             	and    $0x40,%ecx
  180b2b:	89 fa                	mov    %edi,%edx
  180b2d:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  180b31:	e8 8b fc ff ff       	call   1807c1 <qmsi_write_bit>
			       (flags & GPIO_INT_DOUBLE_EDGE));
		qmsi_write_bit(&cfg.int_en, pin, 1);
  180b36:	b9 01 00 00 00       	mov    $0x1,%ecx
  180b3b:	89 fa                	mov    %edi,%edx
  180b3d:	8d 44 24 0c          	lea    0xc(%esp),%eax
  180b41:	e8 7b fc ff ff       	call   1807c1 <qmsi_write_bit>
  180b46:	eb 10                	jmp    180b58 <gpio_qmsi_config+0x204>
	} else {
		qmsi_write_bit(&cfg.int_en, pin, 0);
  180b48:	b9 00 00 00 00       	mov    $0x0,%ecx
  180b4d:	89 fa                	mov    %edi,%edx
  180b4f:	8d 44 24 0c          	lea    0xc(%esp),%eax
  180b53:	e8 69 fc ff ff       	call   1807c1 <qmsi_write_bit>

	if (IS_ENABLED(CONFIG_GPIO_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(port), K_FOREVER);
	}

	qm_gpio_set_config(gpio, &cfg);
  180b58:	8d 54 24 08          	lea    0x8(%esp),%edx
  180b5c:	89 d8                	mov    %ebx,%eax
  180b5e:	e8 5e 0b 00 00       	call   1816c1 <qm_gpio_set_config>
{
	const struct gpio_qmsi_config *gpio_config = port->config->config_info;
	uint8_t num_pins = gpio_config->num_pins;
	int i;

	for (i = 0; i < num_pins; i++) {
  180b63:	ff 04 24             	incl   (%esp)
  180b66:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
  180b6b:	39 04 24             	cmp    %eax,(%esp)
  180b6e:	0f 8c 11 ff ff ff    	jl     180a85 <gpio_qmsi_config+0x131>
	if (access_op == GPIO_ACCESS_BY_PIN) {
		qmsi_pin_config(port, pin, flags);
	} else {
		qmsi_port_config(port, flags);
	}
	return 0;
  180b74:	b8 00 00 00 00       	mov    $0x0,%eax
  180b79:	eb 05                	jmp    180b80 <gpio_qmsi_config+0x22c>
				   int access_op, uint32_t pin, int flags)
{
	/* If the pin/port is set to receive interrupts, make sure the pin
	   is an input */
	if ((flags & GPIO_INT) && (flags & GPIO_DIR_OUT)) {
		return -EINVAL;
  180b7b:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		qmsi_pin_config(port, pin, flags);
	} else {
		qmsi_port_config(port, flags);
	}
	return 0;
}
  180b80:	83 c4 28             	add    $0x28,%esp
  180b83:	5b                   	pop    %ebx
  180b84:	5e                   	pop    %esi
  180b85:	5f                   	pop    %edi
  180b86:	5d                   	pop    %ebp
  180b87:	c3                   	ret    

00180b88 <pwm_qmsi_configure>:
	ARG_UNUSED(access_op);
	ARG_UNUSED(pwm);
	ARG_UNUSED(flags);

	return 0;
}
  180b88:	b8 00 00 00 00       	mov    $0x0,%eax
  180b8d:	c3                   	ret    

00180b8e <pwm_qmsi_set_period>:

}

static int pwm_qmsi_set_period(struct device *dev, int access_op,
			       uint32_t pwm, uint32_t period)
{
  180b8e:	56                   	push   %esi
  180b8f:	53                   	push   %ebx
  180b90:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
	struct pwm_data *context = dev->driver_data;
  180b94:	8b 70 08             	mov    0x8(%eax),%esi
	uint32_t *channel_period = context->channel_period;
	int ret_val = 0;

	if (channel_period == NULL) {
  180b97:	85 f6                	test   %esi,%esi
  180b99:	74 43                	je     180bde <pwm_qmsi_set_period+0x50>
		return -EIO;
	}

	if (period < MIN_PERIOD || period > MAX_PERIOD) {
  180b9b:	8d 43 fc             	lea    -0x4(%ebx),%eax
  180b9e:	3d fc ff ff 0f       	cmp    $0xffffffc,%eax
  180ba3:	77 40                	ja     180be5 <pwm_qmsi_set_period+0x57>

	if (IS_ENABLED(CONFIG_PWM_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(dev), K_FOREVER);
	}

	switch (access_op) {
  180ba5:	85 d2                	test   %edx,%edx
  180ba7:	74 07                	je     180bb0 <pwm_qmsi_set_period+0x22>
  180ba9:	83 fa 01             	cmp    $0x1,%edx
  180bac:	74 1f                	je     180bcd <pwm_qmsi_set_period+0x3f>
  180bae:	eb 3c                	jmp    180bec <pwm_qmsi_set_period+0x5e>
	case PWM_ACCESS_BY_PIN:
		/* make sure the PWM port exists */
		if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
  180bb0:	83 f9 01             	cmp    $0x1,%ecx
  180bb3:	77 3e                	ja     180bf3 <pwm_qmsi_set_period+0x65>
			ret_val = -EIO;
			goto pwm_set_period_return;
		}
		channel_period[pwm] = period * HW_CLOCK_CYCLES_PER_USEC;
  180bb5:	c1 e3 05             	shl    $0x5,%ebx
  180bb8:	89 1c 8e             	mov    %ebx,(%esi,%ecx,4)
static int pwm_qmsi_set_period(struct device *dev, int access_op,
			       uint32_t pwm, uint32_t period)
{
	struct pwm_data *context = dev->driver_data;
	uint32_t *channel_period = context->channel_period;
	int ret_val = 0;
  180bbb:	b8 00 00 00 00       	mov    $0x0,%eax
		if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
			ret_val = -EIO;
			goto pwm_set_period_return;
		}
		channel_period[pwm] = period * HW_CLOCK_CYCLES_PER_USEC;
		break;
  180bc0:	eb 36                	jmp    180bf8 <pwm_qmsi_set_period+0x6a>
	case PWM_ACCESS_ALL:
		for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
			channel_period[i] = period *
  180bc2:	89 da                	mov    %ebx,%edx
  180bc4:	c1 e2 05             	shl    $0x5,%edx
  180bc7:	89 14 86             	mov    %edx,(%esi,%eax,4)
			goto pwm_set_period_return;
		}
		channel_period[pwm] = period * HW_CLOCK_CYCLES_PER_USEC;
		break;
	case PWM_ACCESS_ALL:
		for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180bca:	40                   	inc    %eax
  180bcb:	eb 05                	jmp    180bd2 <pwm_qmsi_set_period+0x44>

	if (IS_ENABLED(CONFIG_PWM_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(dev), K_FOREVER);
	}

	switch (access_op) {
  180bcd:	b8 00 00 00 00       	mov    $0x0,%eax
			goto pwm_set_period_return;
		}
		channel_period[pwm] = period * HW_CLOCK_CYCLES_PER_USEC;
		break;
	case PWM_ACCESS_ALL:
		for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180bd2:	83 f8 01             	cmp    $0x1,%eax
  180bd5:	7e eb                	jle    180bc2 <pwm_qmsi_set_period+0x34>
static int pwm_qmsi_set_period(struct device *dev, int access_op,
			       uint32_t pwm, uint32_t period)
{
	struct pwm_data *context = dev->driver_data;
	uint32_t *channel_period = context->channel_period;
	int ret_val = 0;
  180bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  180bdc:	eb 1a                	jmp    180bf8 <pwm_qmsi_set_period+0x6a>

	if (channel_period == NULL) {
		return -EIO;
  180bde:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  180be3:	eb 13                	jmp    180bf8 <pwm_qmsi_set_period+0x6a>
	}

	if (period < MIN_PERIOD || period > MAX_PERIOD) {
		return -ENOTSUP;
  180be5:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  180bea:	eb 0c                	jmp    180bf8 <pwm_qmsi_set_period+0x6a>
			channel_period[i] = period *
					    HW_CLOCK_CYCLES_PER_USEC;
		}
		break;
	default:
		ret_val = -ENOTSUP;
  180bec:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  180bf1:	eb 05                	jmp    180bf8 <pwm_qmsi_set_period+0x6a>

	switch (access_op) {
	case PWM_ACCESS_BY_PIN:
		/* make sure the PWM port exists */
		if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
			ret_val = -EIO;
  180bf3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	if (IS_ENABLED(CONFIG_PWM_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(dev));
	}

	return ret_val;
}
  180bf8:	5b                   	pop    %ebx
  180bf9:	5e                   	pop    %esi
  180bfa:	c3                   	ret    

00180bfb <pwm_qmsi_set_phase>:
	ARG_UNUSED(access_op);
	ARG_UNUSED(pwm);
	ARG_UNUSED(phase);

	return -ENOTSUP;
}
  180bfb:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  180c00:	c3                   	ret    

00180c01 <pwm_qmsi_init>:
#define pwm_qmsi_set_power_state(...)
#endif

static int pwm_qmsi_init(struct device *dev)
{
	struct pwm_data *context = dev->driver_data;
  180c01:	8b 50 08             	mov    0x8(%eax),%edx
	uint32_t *channel_period = context->channel_period;

	for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180c04:	b8 00 00 00 00       	mov    $0x0,%eax
  180c09:	eb 08                	jmp    180c13 <pwm_qmsi_init+0x12>
		channel_period[i] = DEFAULT_PERIOD *
  180c0b:	c7 04 82 00 fa 00 00 	movl   $0xfa00,(%edx,%eax,4)
static int pwm_qmsi_init(struct device *dev)
{
	struct pwm_data *context = dev->driver_data;
	uint32_t *channel_period = context->channel_period;

	for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180c12:	40                   	inc    %eax
  180c13:	83 f8 01             	cmp    $0x1,%eax
  180c16:	7e f3                	jle    180c0b <pwm_qmsi_init+0xa>
		channel_period[i] = DEFAULT_PERIOD *
				    HW_CLOCK_CYCLES_PER_USEC;
	}

	clk_periph_enable(CLK_PERIPH_PWM_REGISTER | CLK_PERIPH_CLK);
  180c18:	b8 02 10 00 00       	mov    $0x1002,%eax
  180c1d:	e8 74 09 00 00       	call   181596 <clk_periph_enable>
	}

	pwm_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  180c22:	b8 00 00 00 00       	mov    $0x0,%eax
  180c27:	c3                   	ret    

00180c28 <pwm_qmsi_get_cycles_per_sec>:
 * return 0, or negative errno code
 */
static int pwm_qmsi_get_cycles_per_sec(struct device *dev, uint32_t pwm,
				       uint64_t *cycles)
{
	if (cycles == NULL) {
  180c28:	85 c9                	test   %ecx,%ecx
  180c2a:	74 1b                	je     180c47 <pwm_qmsi_get_cycles_per_sec+0x1f>
 *
 * return 0, or negative errno code
 */
static int pwm_qmsi_get_cycles_per_sec(struct device *dev, uint32_t pwm,
				       uint64_t *cycles)
{
  180c2c:	53                   	push   %ebx
  180c2d:	89 cb                	mov    %ecx,%ebx
	if (cycles == NULL) {
		return -EINVAL;
	}

	*cycles = (uint64_t)clk_sys_get_ticks_per_us() * USEC_PER_SEC;
  180c2f:	e8 75 09 00 00       	call   1815a9 <clk_sys_get_ticks_per_us>
  180c34:	ba 40 42 0f 00       	mov    $0xf4240,%edx
  180c39:	f7 e2                	mul    %edx
  180c3b:	89 03                	mov    %eax,(%ebx)
  180c3d:	89 53 04             	mov    %edx,0x4(%ebx)

	return 0;
  180c40:	b8 00 00 00 00       	mov    $0x0,%eax
  180c45:	eb 06                	jmp    180c4d <pwm_qmsi_get_cycles_per_sec+0x25>
 */
static int pwm_qmsi_get_cycles_per_sec(struct device *dev, uint32_t pwm,
				       uint64_t *cycles)
{
	if (cycles == NULL) {
		return -EINVAL;
  180c47:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  180c4c:	c3                   	ret    
	}

	*cycles = (uint64_t)clk_sys_get_ticks_per_us() * USEC_PER_SEC;

	return 0;
}
  180c4d:	5b                   	pop    %ebx
  180c4e:	c3                   	ret    

00180c4f <__set_one_port>:
	return 0;
}

static int __set_one_port(struct device *dev, qm_pwm_t id, uint32_t pwm,
				uint32_t on, uint32_t off)
{
  180c4f:	55                   	push   %ebp
  180c50:	57                   	push   %edi
  180c51:	56                   	push   %esi
  180c52:	53                   	push   %ebx
  180c53:	83 ec 18             	sub    $0x18,%esp
  180c56:	89 d3                	mov    %edx,%ebx
  180c58:	89 ce                	mov    %ecx,%esi
  180c5a:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  180c5e:	8b 6c 24 30          	mov    0x30(%esp),%ebp
	if (IS_ENABLED(CONFIG_PWM_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(dev), K_FOREVER);
	}

	/* Disable timer to prevent any output */
	qm_pwm_stop(id, pwm);
  180c62:	89 ca                	mov    %ecx,%edx
  180c64:	89 d8                	mov    %ebx,%eax
  180c66:	e8 77 09 00 00       	call   1815e2 <qm_pwm_stop>

	if (on == 0) {
  180c6b:	85 ff                	test   %edi,%edi
  180c6d:	74 4c                	je     180cbb <__set_one_port+0x6c>

	/**
	 * off period must be more than zero. Otherwise, the PWM pin will be
	 * turned off. Let's use the minimum value which is 1 for this case.
	 */
	if (off == 0) {
  180c6f:	85 ed                	test   %ebp,%ebp
  180c71:	75 05                	jne    180c78 <__set_one_port+0x29>
		off = 1;
  180c73:	bd 01 00 00 00       	mov    $0x1,%ebp
	}

	/* PWM mode, user-defined count mode, timer disabled */
	cfg.mode = QM_PWM_MODE_PWM;
  180c78:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  180c7f:	00 

	/* No interrupts */
	cfg.mask_interrupt = true;
  180c80:	c6 44 24 08 01       	movb   $0x1,0x8(%esp)
	cfg.callback = NULL;
  180c85:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  180c8c:	00 
	cfg.callback_data = NULL;
  180c8d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  180c94:	00 

	/* Data for the timer to stay high and low */
	cfg.hi_count = on;
  180c95:	89 7c 24 04          	mov    %edi,0x4(%esp)
	cfg.lo_count = off;
  180c99:	89 2c 24             	mov    %ebp,(%esp)

	if (qm_pwm_set_config(id, pwm, &cfg) != 0) {
  180c9c:	89 e1                	mov    %esp,%ecx
  180c9e:	89 f2                	mov    %esi,%edx
  180ca0:	89 d8                	mov    %ebx,%eax
  180ca2:	e8 6e 09 00 00       	call   181615 <qm_pwm_set_config>
  180ca7:	85 c0                	test   %eax,%eax
  180ca9:	75 17                	jne    180cc2 <__set_one_port+0x73>
		ret_val = -EIO;
		goto pwm_set_port_return;
	}

	/* Enable timer so it starts running and counting */
	qm_pwm_start(id, pwm);
  180cab:	89 f2                	mov    %esi,%edx
  180cad:	89 d8                	mov    %ebx,%eax
  180caf:	e8 fb 08 00 00       	call   1815af <qm_pwm_start>

static int __set_one_port(struct device *dev, qm_pwm_t id, uint32_t pwm,
				uint32_t on, uint32_t off)
{
	qm_pwm_config_t cfg;
	int ret_val = 0;
  180cb4:	b8 00 00 00 00       	mov    $0x0,%eax
  180cb9:	eb 0c                	jmp    180cc7 <__set_one_port+0x78>
  180cbb:	b8 00 00 00 00       	mov    $0x0,%eax
  180cc0:	eb 05                	jmp    180cc7 <__set_one_port+0x78>
	/* Data for the timer to stay high and low */
	cfg.hi_count = on;
	cfg.lo_count = off;

	if (qm_pwm_set_config(id, pwm, &cfg) != 0) {
		ret_val = -EIO;
  180cc2:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	if (IS_ENABLED(CONFIG_PWM_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(dev));
	}

	return ret_val;
}
  180cc7:	83 c4 18             	add    $0x18,%esp
  180cca:	5b                   	pop    %ebx
  180ccb:	5e                   	pop    %esi
  180ccc:	5f                   	pop    %edi
  180ccd:	5d                   	pop    %ebp
  180cce:	c3                   	ret    

00180ccf <pwm_qmsi_pin_set>:
 *
 * return 0, or negative errno code
 */
static int pwm_qmsi_pin_set(struct device *dev, uint32_t pwm,
			    uint32_t period_cycles, uint32_t pulse_cycles)
{
  180ccf:	57                   	push   %edi
  180cd0:	56                   	push   %esi
  180cd1:	53                   	push   %ebx
  180cd2:	83 ec 04             	sub    $0x4,%esp
  180cd5:	8b 74 24 14          	mov    0x14(%esp),%esi
	uint32_t high, low;

	if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
  180cd9:	83 fa 01             	cmp    $0x1,%edx
  180cdc:	77 37                	ja     180d15 <pwm_qmsi_pin_set+0x46>
  180cde:	89 c7                	mov    %eax,%edi
		return -EINVAL;
	}

	if (period_cycles == 0 || pulse_cycles > period_cycles) {
  180ce0:	85 c9                	test   %ecx,%ecx
  180ce2:	0f 94 44 24 03       	sete   0x3(%esp)
  180ce7:	8a 44 24 03          	mov    0x3(%esp),%al
  180ceb:	39 f1                	cmp    %esi,%ecx
  180ced:	0f 92 c3             	setb   %bl
  180cf0:	08 d8                	or     %bl,%al
  180cf2:	75 28                	jne    180d1c <pwm_qmsi_pin_set+0x4d>

	/*
	 * low must be more than zero. Otherwise, the PWM pin will be
	 * turned off. Let's make sure low is always more than zero.
	 */
	if (low == 0) {
  180cf4:	89 cb                	mov    %ecx,%ebx
  180cf6:	29 f3                	sub    %esi,%ebx
  180cf8:	75 06                	jne    180d00 <pwm_qmsi_pin_set+0x31>
		high--;
  180cfa:	4e                   	dec    %esi
		low = 1;
  180cfb:	bb 01 00 00 00       	mov    $0x1,%ebx
  180d00:	89 d1                	mov    %edx,%ecx
  180d02:	89 f8                	mov    %edi,%eax
	}

	return __set_one_port(dev, QM_PWM_0, pwm, high, low);
  180d04:	53                   	push   %ebx
  180d05:	56                   	push   %esi
  180d06:	ba 00 00 00 00       	mov    $0x0,%edx
  180d0b:	e8 3f ff ff ff       	call   180c4f <__set_one_port>
  180d10:	83 c4 08             	add    $0x8,%esp
  180d13:	eb 0c                	jmp    180d21 <pwm_qmsi_pin_set+0x52>
			    uint32_t period_cycles, uint32_t pulse_cycles)
{
	uint32_t high, low;

	if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
		return -EINVAL;
  180d15:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  180d1a:	eb 05                	jmp    180d21 <pwm_qmsi_pin_set+0x52>
	}

	if (period_cycles == 0 || pulse_cycles > period_cycles) {
		return -EINVAL;
  180d1c:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
		high--;
		low = 1;
	}

	return __set_one_port(dev, QM_PWM_0, pwm, high, low);
}
  180d21:	83 c4 04             	add    $0x4,%esp
  180d24:	5b                   	pop    %ebx
  180d25:	5e                   	pop    %esi
  180d26:	5f                   	pop    %edi
  180d27:	c3                   	ret    

00180d28 <pwm_qmsi_set_duty_cycle>:
	return ret_val;
}

static int pwm_qmsi_set_duty_cycle(struct device *dev, int access_op,
				   uint32_t pwm, uint8_t duty)
{
  180d28:	55                   	push   %ebp
  180d29:	57                   	push   %edi
  180d2a:	56                   	push   %esi
  180d2b:	53                   	push   %ebx
  180d2c:	83 ec 04             	sub    $0x4,%esp
  180d2f:	8b 5c 24 18          	mov    0x18(%esp),%ebx
	struct pwm_data *context = dev->driver_data;
  180d33:	8b 78 08             	mov    0x8(%eax),%edi
	uint32_t *channel_period = context->channel_period;
	uint32_t on, off;

	if (channel_period == NULL) {
  180d36:	85 ff                	test   %edi,%edi
  180d38:	0f 84 a7 00 00 00    	je     180de5 <pwm_qmsi_set_duty_cycle+0xbd>
  180d3e:	89 dd                	mov    %ebx,%ebp
		return -EIO;
	}

	if (duty > 100) {
  180d40:	80 fb 64             	cmp    $0x64,%bl
  180d43:	0f 87 a3 00 00 00    	ja     180dec <pwm_qmsi_set_duty_cycle+0xc4>
  180d49:	89 04 24             	mov    %eax,(%esp)
		return -ENOTSUP;
	}

	switch (access_op) {
  180d4c:	85 d2                	test   %edx,%edx
  180d4e:	74 0a                	je     180d5a <pwm_qmsi_set_duty_cycle+0x32>
  180d50:	83 fa 01             	cmp    $0x1,%edx
  180d53:	74 7f                	je     180dd4 <pwm_qmsi_set_duty_cycle+0xac>
  180d55:	e9 99 00 00 00       	jmp    180df3 <pwm_qmsi_set_duty_cycle+0xcb>
	case PWM_ACCESS_BY_PIN:
		/* make sure the PWM port exists */
		if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
  180d5a:	83 f9 01             	cmp    $0x1,%ecx
  180d5d:	0f 87 97 00 00 00    	ja     180dfa <pwm_qmsi_set_duty_cycle+0xd2>
			return -EIO;
		}
		on = (channel_period[pwm] * duty) / 100;
  180d63:	8b 3c 8f             	mov    (%edi,%ecx,4),%edi
  180d66:	0f b6 f3             	movzbl %bl,%esi
  180d69:	0f af f7             	imul   %edi,%esi
  180d6c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  180d71:	89 f0                	mov    %esi,%eax
  180d73:	f7 e2                	mul    %edx
  180d75:	c1 ea 05             	shr    $0x5,%edx
		off = channel_period[pwm] - on;
		if (off == 0) {
  180d78:	29 d7                	sub    %edx,%edi
  180d7a:	75 06                	jne    180d82 <pwm_qmsi_set_duty_cycle+0x5a>
			on--;
  180d7c:	4a                   	dec    %edx
			off = 1;
  180d7d:	bf 01 00 00 00       	mov    $0x1,%edi
		}
		return __set_one_port(dev, QM_PWM_0, pwm, on, off);
  180d82:	57                   	push   %edi
  180d83:	52                   	push   %edx
  180d84:	ba 00 00 00 00       	mov    $0x0,%edx
  180d89:	8b 44 24 08          	mov    0x8(%esp),%eax
  180d8d:	e8 bd fe ff ff       	call   180c4f <__set_one_port>
  180d92:	83 c4 08             	add    $0x8,%esp
  180d95:	eb 6f                	jmp    180e06 <pwm_qmsi_set_duty_cycle+0xde>
	case PWM_ACCESS_ALL:
		for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
			on = (channel_period[i] * duty) / 100;
  180d97:	89 f1                	mov    %esi,%ecx
  180d99:	8b 1c b7             	mov    (%edi,%esi,4),%ebx
  180d9c:	89 e8                	mov    %ebp,%eax
  180d9e:	0f b6 d0             	movzbl %al,%edx
  180da1:	89 d0                	mov    %edx,%eax
  180da3:	0f af c3             	imul   %ebx,%eax
  180da6:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  180dab:	f7 e2                	mul    %edx
  180dad:	c1 ea 05             	shr    $0x5,%edx
			off = channel_period[i] - on;
			if (off == 0) {
  180db0:	29 d3                	sub    %edx,%ebx
  180db2:	75 06                	jne    180dba <pwm_qmsi_set_duty_cycle+0x92>
				on--;
  180db4:	4a                   	dec    %edx
				off = 1;
  180db5:	bb 01 00 00 00       	mov    $0x1,%ebx
			}
			if (__set_one_port(dev, QM_PWM_0, i, on, off) != 0) {
  180dba:	53                   	push   %ebx
  180dbb:	52                   	push   %edx
  180dbc:	ba 00 00 00 00       	mov    $0x0,%edx
  180dc1:	8b 44 24 08          	mov    0x8(%esp),%eax
  180dc5:	e8 85 fe ff ff       	call   180c4f <__set_one_port>
  180dca:	83 c4 08             	add    $0x8,%esp
  180dcd:	85 c0                	test   %eax,%eax
  180dcf:	75 30                	jne    180e01 <pwm_qmsi_set_duty_cycle+0xd9>
			on--;
			off = 1;
		}
		return __set_one_port(dev, QM_PWM_0, pwm, on, off);
	case PWM_ACCESS_ALL:
		for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180dd1:	46                   	inc    %esi
  180dd2:	eb 05                	jmp    180dd9 <pwm_qmsi_set_duty_cycle+0xb1>

	if (duty > 100) {
		return -ENOTSUP;
	}

	switch (access_op) {
  180dd4:	be 00 00 00 00       	mov    $0x0,%esi
			on--;
			off = 1;
		}
		return __set_one_port(dev, QM_PWM_0, pwm, on, off);
	case PWM_ACCESS_ALL:
		for (int i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180dd9:	83 fe 01             	cmp    $0x1,%esi
  180ddc:	7e b9                	jle    180d97 <pwm_qmsi_set_duty_cycle+0x6f>
		break;
	default:
		return -ENOTSUP;
	}

	return 0;
  180dde:	b8 00 00 00 00       	mov    $0x0,%eax
  180de3:	eb 21                	jmp    180e06 <pwm_qmsi_set_duty_cycle+0xde>
	struct pwm_data *context = dev->driver_data;
	uint32_t *channel_period = context->channel_period;
	uint32_t on, off;

	if (channel_period == NULL) {
		return -EIO;
  180de5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  180dea:	eb 1a                	jmp    180e06 <pwm_qmsi_set_duty_cycle+0xde>
	}

	if (duty > 100) {
		return -ENOTSUP;
  180dec:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  180df1:	eb 13                	jmp    180e06 <pwm_qmsi_set_duty_cycle+0xde>
				return -EIO;
			}
		}
		break;
	default:
		return -ENOTSUP;
  180df3:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  180df8:	eb 0c                	jmp    180e06 <pwm_qmsi_set_duty_cycle+0xde>

	switch (access_op) {
	case PWM_ACCESS_BY_PIN:
		/* make sure the PWM port exists */
		if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
			return -EIO;
  180dfa:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  180dff:	eb 05                	jmp    180e06 <pwm_qmsi_set_duty_cycle+0xde>
			if (off == 0) {
				on--;
				off = 1;
			}
			if (__set_one_port(dev, QM_PWM_0, i, on, off) != 0) {
				return -EIO;
  180e01:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	default:
		return -ENOTSUP;
	}

	return 0;
}
  180e06:	83 c4 04             	add    $0x4,%esp
  180e09:	5b                   	pop    %ebx
  180e0a:	5e                   	pop    %esi
  180e0b:	5f                   	pop    %edi
  180e0c:	5d                   	pop    %ebp
  180e0d:	c3                   	ret    

00180e0e <pwm_qmsi_set_values>:
 *
 * return 0, or negative errno code
 */
static int pwm_qmsi_set_values(struct device *dev, int access_op,
			       uint32_t pwm, uint32_t on, uint32_t off)
{
  180e0e:	55                   	push   %ebp
  180e0f:	57                   	push   %edi
  180e10:	56                   	push   %esi
  180e11:	53                   	push   %ebx
  180e12:	83 ec 04             	sub    $0x4,%esp
  180e15:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
	struct pwm_data *context = dev->driver_data;
  180e19:	8b 78 08             	mov    0x8(%eax),%edi
	uint32_t *channel_period = context->channel_period;
	int i, high, low;

	if (on) {
  180e1c:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
  180e21:	0f 85 a2 00 00 00    	jne    180ec9 <pwm_qmsi_set_values+0xbb>
  180e27:	89 04 24             	mov    %eax,(%esp)
		return -EINVAL;
	}

	switch (access_op) {
  180e2a:	85 d2                	test   %edx,%edx
  180e2c:	74 0e                	je     180e3c <pwm_qmsi_set_values+0x2e>
  180e2e:	83 fa 01             	cmp    $0x1,%edx
  180e31:	0f 84 81 00 00 00    	je     180eb8 <pwm_qmsi_set_values+0xaa>
  180e37:	e9 94 00 00 00       	jmp    180ed0 <pwm_qmsi_set_values+0xc2>
	case PWM_ACCESS_BY_PIN:
		/* make sure the PWM port exists */
		if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
  180e3c:	83 f9 01             	cmp    $0x1,%ecx
  180e3f:	0f 87 92 00 00 00    	ja     180ed7 <pwm_qmsi_set_values+0xc9>
			return -EIO;
		}

		high = off;
  180e45:	89 da                	mov    %ebx,%edx
		low = channel_period[pwm] - off;
  180e47:	8b 04 8f             	mov    (%edi,%ecx,4),%eax
  180e4a:	89 c6                	mov    %eax,%esi
  180e4c:	29 de                	sub    %ebx,%esi

		if (off >= channel_period[pwm]) {
  180e4e:	39 c3                	cmp    %eax,%ebx
  180e50:	72 08                	jb     180e5a <pwm_qmsi_set_values+0x4c>
			high = channel_period[pwm] - 1;
  180e52:	8d 50 ff             	lea    -0x1(%eax),%edx
			low = 1;
  180e55:	be 01 00 00 00       	mov    $0x1,%esi
		}

		if (off == 0) {
  180e5a:	85 db                	test   %ebx,%ebx
  180e5c:	75 08                	jne    180e66 <pwm_qmsi_set_values+0x58>
			high = 1;
			low = channel_period[pwm] - 1;
  180e5e:	8d 70 ff             	lea    -0x1(%eax),%esi
			high = channel_period[pwm] - 1;
			low = 1;
		}

		if (off == 0) {
			high = 1;
  180e61:	ba 01 00 00 00       	mov    $0x1,%edx
			low = channel_period[pwm] - 1;
		}

		return __set_one_port(dev, QM_PWM_0, pwm, high, low);
  180e66:	56                   	push   %esi
  180e67:	52                   	push   %edx
  180e68:	ba 00 00 00 00       	mov    $0x0,%edx
  180e6d:	8b 44 24 08          	mov    0x8(%esp),%eax
  180e71:	e8 d9 fd ff ff       	call   180c4f <__set_one_port>
  180e76:	83 c4 08             	add    $0x8,%esp
  180e79:	eb 68                	jmp    180ee3 <pwm_qmsi_set_values+0xd5>

	case PWM_ACCESS_ALL:
		for (i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
			high = off;
  180e7b:	89 da                	mov    %ebx,%edx
			low = channel_period[i] - off;
  180e7d:	89 f1                	mov    %esi,%ecx
  180e7f:	8b 04 b7             	mov    (%edi,%esi,4),%eax
  180e82:	89 c5                	mov    %eax,%ebp
  180e84:	29 dd                	sub    %ebx,%ebp

			if (off >= channel_period[i]) {
  180e86:	39 c3                	cmp    %eax,%ebx
  180e88:	72 08                	jb     180e92 <pwm_qmsi_set_values+0x84>
				high = channel_period[i] - 1;
  180e8a:	8d 50 ff             	lea    -0x1(%eax),%edx
				low = 1;
  180e8d:	bd 01 00 00 00       	mov    $0x1,%ebp
			}

			if (off == 0) {
  180e92:	85 db                	test   %ebx,%ebx
  180e94:	75 08                	jne    180e9e <pwm_qmsi_set_values+0x90>
				high = 1;
				low = channel_period[i] - 1;
  180e96:	8d 68 ff             	lea    -0x1(%eax),%ebp
				high = channel_period[i] - 1;
				low = 1;
			}

			if (off == 0) {
				high = 1;
  180e99:	ba 01 00 00 00       	mov    $0x1,%edx
				low = channel_period[i] - 1;
			}

			if (__set_one_port(dev, QM_PWM_0, i, high, low) != 0) {
  180e9e:	55                   	push   %ebp
  180e9f:	52                   	push   %edx
  180ea0:	ba 00 00 00 00       	mov    $0x0,%edx
  180ea5:	8b 44 24 08          	mov    0x8(%esp),%eax
  180ea9:	e8 a1 fd ff ff       	call   180c4f <__set_one_port>
  180eae:	83 c4 08             	add    $0x8,%esp
  180eb1:	85 c0                	test   %eax,%eax
  180eb3:	75 29                	jne    180ede <pwm_qmsi_set_values+0xd0>
		}

		return __set_one_port(dev, QM_PWM_0, pwm, high, low);

	case PWM_ACCESS_ALL:
		for (i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180eb5:	46                   	inc    %esi
  180eb6:	eb 05                	jmp    180ebd <pwm_qmsi_set_values+0xaf>

	if (on) {
		return -EINVAL;
	}

	switch (access_op) {
  180eb8:	be 00 00 00 00       	mov    $0x0,%esi
		}

		return __set_one_port(dev, QM_PWM_0, pwm, high, low);

	case PWM_ACCESS_ALL:
		for (i = 0; i < CONFIG_PWM_QMSI_NUM_PORTS; i++) {
  180ebd:	83 fe 01             	cmp    $0x1,%esi
  180ec0:	7e b9                	jle    180e7b <pwm_qmsi_set_values+0x6d>
		break;
	default:
		return -ENOTSUP;
	}

	return 0;
  180ec2:	b8 00 00 00 00       	mov    $0x0,%eax
  180ec7:	eb 1a                	jmp    180ee3 <pwm_qmsi_set_values+0xd5>
	struct pwm_data *context = dev->driver_data;
	uint32_t *channel_period = context->channel_period;
	int i, high, low;

	if (on) {
		return -EINVAL;
  180ec9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
  180ece:	eb 13                	jmp    180ee3 <pwm_qmsi_set_values+0xd5>
				return -EIO;
			}
		}
		break;
	default:
		return -ENOTSUP;
  180ed0:	b8 dd ff ff ff       	mov    $0xffffffdd,%eax
  180ed5:	eb 0c                	jmp    180ee3 <pwm_qmsi_set_values+0xd5>

	switch (access_op) {
	case PWM_ACCESS_BY_PIN:
		/* make sure the PWM port exists */
		if (pwm >= CONFIG_PWM_QMSI_NUM_PORTS) {
			return -EIO;
  180ed7:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  180edc:	eb 05                	jmp    180ee3 <pwm_qmsi_set_values+0xd5>
				high = 1;
				low = channel_period[i] - 1;
			}

			if (__set_one_port(dev, QM_PWM_0, i, high, low) != 0) {
				return -EIO;
  180ede:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
		return -ENOTSUP;
	}

	return 0;

}
  180ee3:	83 c4 04             	add    $0x4,%esp
  180ee6:	5b                   	pop    %ebx
  180ee7:	5e                   	pop    %esi
  180ee8:	5f                   	pop    %edi
  180ee9:	5d                   	pop    %ebp
  180eea:	c3                   	ret    

00180eeb <pinmux_get>:
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_get(struct device *dev, uint32_t pin,
			  uint32_t *func)
{
  180eeb:	56                   	push   %esi
  180eec:	53                   	push   %ebx
  180eed:	89 cb                	mov    %ecx,%ebx
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
  180eef:	89 d6                	mov    %edx,%esi
  180ef1:	c1 ee 04             	shr    $0x4,%esi

	/* The pin offset within the register */
	uint32_t pin_no = pin % 16;
  180ef4:	83 e2 0f             	and    $0xf,%edx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
  180ef7:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  180efa:	b8 03 00 00 00       	mov    $0x3,%eax
  180eff:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
  180f01:	8b 14 b5 30 09 80 b0 	mov    -0x4f7ff6d0(,%esi,4),%edx
  180f08:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
  180f0a:	d3 e8                	shr    %cl,%eax

	*func = mode;
  180f0c:	89 03                	mov    %eax,(%ebx)

	return 0;
}
  180f0e:	b8 00 00 00 00       	mov    $0x0,%eax
  180f13:	5b                   	pop    %ebx
  180f14:	5e                   	pop    %esi
  180f15:	c3                   	ret    

00180f16 <pinmux_initialize>:
};

static int pinmux_initialize(struct device *port)
{
	return 0;
}
  180f16:	b8 00 00 00 00       	mov    $0x0,%eax
  180f1b:	c3                   	ret    

00180f1c <pinmux_input>:
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_input(struct device *dev, uint32_t pin,
			    uint8_t func)
{
  180f1c:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
  180f1e:	84 c9                	test   %cl,%cl
  180f20:	0f 95 c2             	setne  %dl
  180f23:	0f b6 d2             	movzbl %dl,%edx
  180f26:	e8 21 0a 00 00       	call   18194c <qm_pmux_input_en>
  180f2b:	85 c0                	test   %eax,%eax
  180f2d:	74 05                	je     180f34 <pinmux_input+0x18>
  180f2f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180f34:	c3                   	ret    

00180f35 <pinmux_pullup>:
	return 0;
}

static int pinmux_pullup(struct device *dev, uint32_t pin,
			     uint8_t func)
{
  180f35:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
  180f37:	84 c9                	test   %cl,%cl
  180f39:	0f 95 c2             	setne  %dl
  180f3c:	0f b6 d2             	movzbl %dl,%edx
  180f3f:	e8 69 0a 00 00       	call   1819ad <qm_pmux_pullup_en>
  180f44:	85 c0                	test   %eax,%eax
  180f46:	74 05                	je     180f4d <pinmux_pullup+0x18>
  180f48:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180f4d:	c3                   	ret    

00180f4e <pinmux_set>:

#define MASK_2_BITS	0x3

static int pinmux_set(struct device *dev, uint32_t pin,
			  uint32_t func)
{
  180f4e:	89 d0                	mov    %edx,%eax
  180f50:	89 ca                	mov    %ecx,%edx
	ARG_UNUSED(dev);

	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
  180f52:	e8 9d 09 00 00       	call   1818f4 <qm_pmux_select>
  180f57:	85 c0                	test   %eax,%eax
  180f59:	74 05                	je     180f60 <pinmux_set+0x12>
  180f5b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180f60:	c3                   	ret    

00180f61 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
  180f61:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  180f66:	c3                   	ret    

00180f67 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
  180f67:	a3 10 00 28 00       	mov    %eax,0x280010
  180f6c:	c3                   	ret    

00180f6d <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  180f6d:	53                   	push   %ebx
	while ((*s1 == *s2) && (*s1 != '\0')) {
  180f6e:	eb 02                	jmp    180f72 <strcmp+0x5>
		s1++;
  180f70:	40                   	inc    %eax
		s2++;
  180f71:	42                   	inc    %edx
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
  180f72:	8a 08                	mov    (%eax),%cl
  180f74:	8a 1a                	mov    (%edx),%bl
  180f76:	38 d9                	cmp    %bl,%cl
  180f78:	75 04                	jne    180f7e <strcmp+0x11>
  180f7a:	84 c9                	test   %cl,%cl
  180f7c:	75 f2                	jne    180f70 <strcmp+0x3>
		s1++;
		s2++;
	}

	return *s1 - *s2;
  180f7e:	0f be c1             	movsbl %cl,%eax
  180f81:	0f be db             	movsbl %bl,%ebx
  180f84:	29 d8                	sub    %ebx,%eax
}
  180f86:	5b                   	pop    %ebx
  180f87:	c3                   	ret    

00180f88 <_nop_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  180f88:	b8 00 00 00 00       	mov    $0x0,%eax
  180f8d:	c3                   	ret    

00180f8e <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
  180f8e:	8b 0a                	mov    (%edx),%ecx
  180f90:	41                   	inc    %ecx
  180f91:	89 0a                	mov    %ecx,(%edx)
	return _char_out(c);
  180f93:	ff 15 14 00 28 00    	call   *0x280014
}
  180f99:	c3                   	ret    

00180f9a <_printk_hex_ulong>:
 * @return N/A
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  180f9a:	55                   	push   %ebp
  180f9b:	57                   	push   %edi
  180f9c:	56                   	push   %esi
  180f9d:	53                   	push   %ebx
  180f9e:	83 ec 08             	sub    $0x8,%esp
  180fa1:	89 c5                	mov    %eax,%ebp
  180fa3:	89 14 24             	mov    %edx,(%esp)
  180fa6:	89 cf                	mov    %ecx,%edi
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
  180fa8:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  180faf:	00 
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
  180fb0:	bb 00 00 00 00       	mov    $0x0,%ebx
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
  180fb5:	ba 08 00 00 00       	mov    $0x8,%edx
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  180fba:	eb 65                	jmp    181021 <_printk_hex_ulong+0x87>
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  180fbc:	8d 72 ff             	lea    -0x1(%edx),%esi
  180fbf:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  180fc6:	89 f8                	mov    %edi,%eax
  180fc8:	d3 e8                	shr    %cl,%eax

		if (nibble || found_largest_digit || size == 1) {
  180fca:	83 e0 0f             	and    $0xf,%eax
  180fcd:	0f 95 c1             	setne  %cl
  180fd0:	08 d9                	or     %bl,%cl
  180fd2:	75 05                	jne    180fd9 <_printk_hex_ulong+0x3f>
  180fd4:	83 fa 01             	cmp    $0x1,%edx
  180fd7:	75 1b                	jne    180ff4 <_printk_hex_ulong+0x5a>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
  180fd9:	3c 09                	cmp    $0x9,%al
  180fdb:	7e 04                	jle    180fe1 <_printk_hex_ulong+0x47>
  180fdd:	b2 57                	mov    $0x57,%dl
  180fdf:	eb 02                	jmp    180fe3 <_printk_hex_ulong+0x49>
  180fe1:	b2 30                	mov    $0x30,%dl
  180fe3:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
  180fe5:	0f be c0             	movsbl %al,%eax
  180fe8:	8b 14 24             	mov    (%esp),%edx
  180feb:	ff d5                	call   *%ebp

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  180fed:	bb 01 00 00 00       	mov    $0x1,%ebx
			nibble += nibble > 9 ? 87 : 48;
			out((int)nibble, ctx);
			continue;
  180ff2:	eb 2b                	jmp    18101f <_printk_hex_ulong+0x85>
		}

		if (remaining-- <= min_width) {
  180ff4:	8b 44 24 04          	mov    0x4(%esp),%eax
  180ff8:	8d 48 ff             	lea    -0x1(%eax),%ecx
  180ffb:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  180fff:	3b 44 24 20          	cmp    0x20(%esp),%eax
  181003:	7f 1a                	jg     18101f <_printk_hex_ulong+0x85>
			out((int)(pad_zero ? '0' : ' '), ctx);
  181005:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  18100a:	74 07                	je     181013 <_printk_hex_ulong+0x79>
  18100c:	b8 30 00 00 00       	mov    $0x30,%eax
  181011:	eb 05                	jmp    181018 <_printk_hex_ulong+0x7e>
  181013:	b8 20 00 00 00       	mov    $0x20,%eax
  181018:	8b 14 24             	mov    (%esp),%edx
  18101b:	ff d5                	call   *%ebp
  18101d:	eb 00                	jmp    18101f <_printk_hex_ulong+0x85>

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  18101f:	89 f2                	mov    %esi,%edx
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  181021:	85 d2                	test   %edx,%edx
  181023:	75 97                	jne    180fbc <_printk_hex_ulong+0x22>

		if (remaining-- <= min_width) {
			out((int)(pad_zero ? '0' : ' '), ctx);
		}
	}
}
  181025:	83 c4 08             	add    $0x8,%esp
  181028:	5b                   	pop    %ebx
  181029:	5e                   	pop    %esi
  18102a:	5f                   	pop    %edi
  18102b:	5d                   	pop    %ebp
  18102c:	c3                   	ret    

0018102d <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  18102d:	55                   	push   %ebp
  18102e:	57                   	push   %edi
  18102f:	56                   	push   %esi
  181030:	53                   	push   %ebx
  181031:	83 ec 08             	sub    $0x8,%esp
  181034:	89 c5                	mov    %eax,%ebp
  181036:	89 54 24 04          	mov    %edx,0x4(%esp)
	unsigned long remainder = num;
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  18103a:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  18103f:	7f 08                	jg     181049 <_printk_dec_ulong+0x1c>
		min_width = 1;
  181041:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  181048:	00 
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  181049:	89 0c 24             	mov    %ecx,(%esp)
  18104c:	bf 0a 00 00 00       	mov    $0xa,%edi
  181051:	bb 00 00 00 00       	mov    $0x0,%ebx
  181056:	be ff c9 9a 3b       	mov    $0x3b9ac9ff,%esi
  18105b:	eb 65                	jmp    1810c2 <_printk_dec_ulong+0x95>
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  18105d:	3b 34 24             	cmp    (%esp),%esi
  181060:	0f 92 c0             	setb   %al
  181063:	08 d8                	or     %bl,%al
  181065:	74 1d                	je     181084 <_printk_dec_ulong+0x57>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
  181067:	8d 4e 01             	lea    0x1(%esi),%ecx
  18106a:	8b 04 24             	mov    (%esp),%eax
  18106d:	ba 00 00 00 00       	mov    $0x0,%edx
  181072:	f7 f1                	div    %ecx
  181074:	83 c0 30             	add    $0x30,%eax
  181077:	8b 54 24 04          	mov    0x4(%esp),%edx
  18107b:	ff d5                	call   *%ebp
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  18107d:	bb 01 00 00 00       	mov    $0x1,%ebx
  181082:	eb 1f                	jmp    1810a3 <_printk_dec_ulong+0x76>
			out((int)((remainder / (pos + 1)) + 48), ctx);
		} else if (remaining <= min_width) {
  181084:	3b 7c 24 20          	cmp    0x20(%esp),%edi
  181088:	7f 19                	jg     1810a3 <_printk_dec_ulong+0x76>
			out((int)(pad_zero ? '0' : ' '), ctx);
  18108a:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  18108f:	74 07                	je     181098 <_printk_dec_ulong+0x6b>
  181091:	b8 30 00 00 00       	mov    $0x30,%eax
  181096:	eb 05                	jmp    18109d <_printk_dec_ulong+0x70>
  181098:	b8 20 00 00 00       	mov    $0x20,%eax
  18109d:	8b 54 24 04          	mov    0x4(%esp),%edx
  1810a1:	ff d5                	call   *%ebp
		}
		remaining--;
  1810a3:	4f                   	dec    %edi
		remainder %= (pos + 1);
  1810a4:	8d 4e 01             	lea    0x1(%esi),%ecx
  1810a7:	8b 04 24             	mov    (%esp),%eax
  1810aa:	ba 00 00 00 00       	mov    $0x0,%edx
  1810af:	f7 f1                	div    %ecx
  1810b1:	89 14 24             	mov    %edx,(%esp)
		pos /= 10;
  1810b4:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  1810b9:	89 f0                	mov    %esi,%eax
  1810bb:	f7 e2                	mul    %edx
  1810bd:	89 d6                	mov    %edx,%esi
  1810bf:	c1 ee 03             	shr    $0x3,%esi
	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
  1810c2:	83 fe 08             	cmp    $0x8,%esi
  1810c5:	77 96                	ja     18105d <_printk_dec_ulong+0x30>
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
	}
	out((int)(remainder + 48), ctx);
  1810c7:	8b 04 24             	mov    (%esp),%eax
  1810ca:	83 c0 30             	add    $0x30,%eax
  1810cd:	8b 54 24 04          	mov    0x4(%esp),%edx
  1810d1:	ff d5                	call   *%ebp
}
  1810d3:	83 c4 08             	add    $0x8,%esp
  1810d6:	5b                   	pop    %ebx
  1810d7:	5e                   	pop    %esi
  1810d8:	5f                   	pop    %edi
  1810d9:	5d                   	pop    %ebp
  1810da:	c3                   	ret    

001810db <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  1810db:	a3 14 00 28 00       	mov    %eax,0x280014
  1810e0:	c3                   	ret    

001810e1 <_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
  1810e1:	55                   	push   %ebp
  1810e2:	57                   	push   %edi
  1810e3:	56                   	push   %esi
  1810e4:	53                   	push   %ebx
  1810e5:	83 ec 10             	sub    $0x10,%esp
  1810e8:	89 c7                	mov    %eax,%edi
  1810ea:	89 54 24 04          	mov    %edx,0x4(%esp)
  1810ee:	89 cb                	mov    %ecx,%ebx
  1810f0:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
	int min_width = -1;
  1810f4:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
  1810fb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  181102:	00 
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  181103:	be 00 00 00 00       	mov    $0x0,%esi
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  181108:	e9 af 01 00 00       	jmp    1812bc <_vprintk+0x1db>
		if (!might_format) {
  18110d:	85 f6                	test   %esi,%esi
  18110f:	75 16                	jne    181127 <_vprintk+0x46>
			if (*fmt != '%') {
  181111:	3c 25                	cmp    $0x25,%al
  181113:	0f 84 84 01 00 00    	je     18129d <_vprintk+0x1bc>
				out((int)*fmt, ctx);
  181119:	0f be c0             	movsbl %al,%eax
  18111c:	8b 54 24 04          	mov    0x4(%esp),%edx
  181120:	ff d7                	call   *%edi
  181122:	e9 94 01 00 00       	jmp    1812bb <_vprintk+0x1da>
				might_format = 1;
				min_width = -1;
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
  181127:	8d 50 db             	lea    -0x25(%eax),%edx
  18112a:	80 fa 55             	cmp    $0x55,%dl
  18112d:	0f 87 4f 01 00 00    	ja     181282 <_vprintk+0x1a1>
  181133:	0f b6 d2             	movzbl %dl,%edx
  181136:	ff 24 95 c4 30 18 00 	jmp    *0x1830c4(,%edx,4)
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  18113d:	8b 14 24             	mov    (%esp),%edx
  181140:	c1 ea 1f             	shr    $0x1f,%edx
  181143:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  181148:	0f 94 c1             	sete   %cl
  18114b:	84 d1                	test   %dl,%cl
  18114d:	0f 85 60 01 00 00    	jne    1812b3 <_vprintk+0x1d2>
					pad_zero = 1;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
  181153:	83 3c 24 00          	cmpl   $0x0,(%esp)
  181157:	79 0e                	jns    181167 <_vprintk+0x86>
					min_width = *fmt - '0';
  181159:	0f be c0             	movsbl %al,%eax
  18115c:	83 e8 30             	sub    $0x30,%eax
  18115f:	89 04 24             	mov    %eax,(%esp)
  181162:	e9 54 01 00 00       	jmp    1812bb <_vprintk+0x1da>
				} else {
					min_width = 10 * min_width + *fmt - '0';
  181167:	8b 0c 24             	mov    (%esp),%ecx
  18116a:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  18116d:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  181170:	0f be c0             	movsbl %al,%eax
  181173:	8d 44 02 d0          	lea    -0x30(%edx,%eax,1),%eax
  181177:	89 04 24             	mov    %eax,(%esp)
  18117a:	e9 3c 01 00 00       	jmp    1812bb <_vprintk+0x1da>
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  18117f:	8d 75 04             	lea    0x4(%ebp),%esi
  181182:	8b 6d 00             	mov    0x0(%ebp),%ebp

				if (d < 0) {
  181185:	85 ed                	test   %ebp,%ebp
  181187:	79 10                	jns    181199 <_vprintk+0xb8>
					out((int)'-', ctx);
  181189:	8b 54 24 04          	mov    0x4(%esp),%edx
  18118d:	b8 2d 00 00 00       	mov    $0x2d,%eax
  181192:	ff d7                	call   *%edi
					d = -d;
  181194:	f7 dd                	neg    %ebp
					min_width--;
  181196:	ff 0c 24             	decl   (%esp)
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
  181199:	ff 34 24             	pushl  (%esp)
  18119c:	ff 74 24 0c          	pushl  0xc(%esp)
  1811a0:	89 e9                	mov    %ebp,%ecx
  1811a2:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1811a6:	89 f8                	mov    %edi,%eax
  1811a8:	e8 80 fe ff ff       	call   18102d <_printk_dec_ulong>
  1811ad:	83 c4 08             	add    $0x8,%esp
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  1811b0:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  1811b2:	be 00 00 00 00       	mov    $0x0,%esi
					d = -d;
					min_width--;
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
  1811b7:	e9 ff 00 00 00       	jmp    1812bb <_vprintk+0x1da>
			}
			case 'u': {
				unsigned long u = va_arg(
  1811bc:	8d 75 04             	lea    0x4(%ebp),%esi
  1811bf:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
  1811c2:	ff 34 24             	pushl  (%esp)
  1811c5:	ff 74 24 0c          	pushl  0xc(%esp)
  1811c9:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1811cd:	89 f8                	mov    %edi,%eax
  1811cf:	e8 59 fe ff ff       	call   18102d <_printk_dec_ulong>
  1811d4:	83 c4 08             	add    $0x8,%esp
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  1811d7:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  1811d9:	be 00 00 00 00       	mov    $0x0,%esi
			case 'u': {
				unsigned long u = va_arg(
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
						  min_width);
				break;
  1811de:	e9 d8 00 00 00       	jmp    1812bb <_vprintk+0x1da>
			}
			case 'p':
				  out('0', ctx);
  1811e3:	8b 74 24 04          	mov    0x4(%esp),%esi
  1811e7:	89 f2                	mov    %esi,%edx
  1811e9:	b8 30 00 00 00       	mov    $0x30,%eax
  1811ee:	ff d7                	call   *%edi
				  out('x', ctx);
  1811f0:	89 f2                	mov    %esi,%edx
  1811f2:	b8 78 00 00 00       	mov    $0x78,%eax
  1811f7:	ff d7                	call   *%edi
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
				  min_width = 8;
  1811f9:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
			}
			case 'p':
				  out('0', ctx);
				  out('x', ctx);
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
  181200:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  181207:	00 
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  181208:	8d 75 04             	lea    0x4(%ebp),%esi
  18120b:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
  18120e:	ff 34 24             	pushl  (%esp)
  181211:	ff 74 24 0c          	pushl  0xc(%esp)
  181215:	8b 54 24 0c          	mov    0xc(%esp),%edx
  181219:	89 f8                	mov    %edi,%eax
  18121b:	e8 7a fd ff ff       	call   180f9a <_printk_hex_ulong>
  181220:	83 c4 08             	add    $0x8,%esp
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  181223:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181225:	be 00 00 00 00       	mov    $0x0,%esi
			case 'X': {
				unsigned long x = va_arg(
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
  18122a:	e9 8c 00 00 00       	jmp    1812bb <_vprintk+0x1da>
			}
			case 's': {
				char *s = va_arg(ap, char *);
  18122f:	8d 75 04             	lea    0x4(%ebp),%esi
  181232:	8b 6d 00             	mov    0x0(%ebp),%ebp
  181235:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  181239:	8b 5c 24 04          	mov    0x4(%esp),%ebx

				while (*s)
  18123d:	eb 08                	jmp    181247 <_vprintk+0x166>
					out((int)(*s++), ctx);
  18123f:	45                   	inc    %ebp
  181240:	0f be c0             	movsbl %al,%eax
  181243:	89 da                	mov    %ebx,%edx
  181245:	ff d7                	call   *%edi
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);

				while (*s)
  181247:	8a 45 00             	mov    0x0(%ebp),%al
  18124a:	84 c0                	test   %al,%al
  18124c:	75 f1                	jne    18123f <_vprintk+0x15e>
  18124e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  181252:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181254:	be 00 00 00 00       	mov    $0x0,%esi
  181259:	eb 60                	jmp    1812bb <_vprintk+0x1da>
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  18125b:	8d 75 04             	lea    0x4(%ebp),%esi
  18125e:	8b 45 00             	mov    0x0(%ebp),%eax

				out(c, ctx);
  181261:	8b 54 24 04          	mov    0x4(%esp),%edx
  181265:	ff d7                	call   *%edi
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  181267:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181269:	be 00 00 00 00       	mov    $0x0,%esi
			}
			case 'c': {
				int c = va_arg(ap, int);

				out(c, ctx);
				break;
  18126e:	eb 4b                	jmp    1812bb <_vprintk+0x1da>
			}
			case '%': {
				out((int)'%', ctx);
  181270:	8b 54 24 04          	mov    0x4(%esp),%edx
  181274:	b8 25 00 00 00       	mov    $0x25,%eax
  181279:	ff d7                	call   *%edi
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  18127b:	be 00 00 00 00       	mov    $0x0,%esi
				out(c, ctx);
				break;
			}
			case '%': {
				out((int)'%', ctx);
				break;
  181280:	eb 39                	jmp    1812bb <_vprintk+0x1da>
			}
			default:
				out((int)'%', ctx);
  181282:	8b 74 24 04          	mov    0x4(%esp),%esi
  181286:	89 f2                	mov    %esi,%edx
  181288:	b8 25 00 00 00       	mov    $0x25,%eax
  18128d:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
  18128f:	0f be 03             	movsbl (%ebx),%eax
  181292:	89 f2                	mov    %esi,%edx
  181294:	ff d7                	call   *%edi
				break;
			}
			might_format = 0;
  181296:	be 00 00 00 00       	mov    $0x0,%esi
				break;
			}
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
  18129b:	eb 1e                	jmp    1812bb <_vprintk+0x1da>
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
  18129d:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
				pad_zero = 0;
  1812a4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1812ab:	00 
	while (*fmt) {
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
  1812ac:	be 01 00 00 00       	mov    $0x1,%esi
  1812b1:	eb 08                	jmp    1812bb <_vprintk+0x1da>
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
					pad_zero = 1;
  1812b3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1812ba:	00 
				break;
			}
			might_format = 0;
		}
still_might_format:
		++fmt;
  1812bb:	43                   	inc    %ebx
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  1812bc:	8a 03                	mov    (%ebx),%al
  1812be:	84 c0                	test   %al,%al
  1812c0:	0f 85 47 fe ff ff    	jne    18110d <_vprintk+0x2c>
			might_format = 0;
		}
still_might_format:
		++fmt;
	}
}
  1812c6:	83 c4 10             	add    $0x10,%esp
  1812c9:	5b                   	pop    %ebx
  1812ca:	5e                   	pop    %esi
  1812cb:	5f                   	pop    %edi
  1812cc:	5d                   	pop    %ebp
  1812cd:	c3                   	ret    

001812ce <printk>:
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
  1812ce:	83 ec 04             	sub    $0x4,%esp
	struct out_context ctx = { 0 };
  1812d1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	va_list ap;

	va_start(ap, fmt);
  1812d8:	8d 44 24 0c          	lea    0xc(%esp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
  1812dc:	50                   	push   %eax
  1812dd:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  1812e1:	8d 54 24 04          	lea    0x4(%esp),%edx
  1812e5:	b8 8e 0f 18 00       	mov    $0x180f8e,%eax
  1812ea:	e8 f2 fd ff ff       	call   1810e1 <_vprintk>
	va_end(ap);

	return ctx.count;
}
  1812ef:	8b 44 24 04          	mov    0x4(%esp),%eax
  1812f3:	83 c4 08             	add    $0x8,%esp
  1812f6:	c3                   	ret    

001812f7 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_SOC, 1);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
  1812f7:	c3                   	ret    

001812f8 <_pinmux_defaults>:
/******** End PINMUX mapping **************************/

#define PINMUX_MAX_REGISTERS 2

static void _pinmux_defaults(uint32_t base)
{
  1812f8:	53                   	push   %ebx
  1812f9:	83 ec 08             	sub    $0x8,%esp
	PIN_CONFIG(mux_config,  6, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config,  7, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 12, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 13, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 14, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
  1812fc:	c7 04 24 42 a1 00 aa 	movl   $0xaa00a142,(%esp)
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);
  181303:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  18130a:	00 

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  18130b:	ba 00 00 00 00       	mov    $0x0,%edx
  181310:	eb 0a                	jmp    18131c <_pinmux_defaults+0x24>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
  181312:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
  181315:	8b 0c 94             	mov    (%esp,%edx,4),%ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  181318:	89 4b 30             	mov    %ecx,0x30(%ebx)
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  18131b:	42                   	inc    %edx
  18131c:	83 fa 01             	cmp    $0x1,%edx
  18131f:	7e f1                	jle    181312 <_pinmux_defaults+0x1a>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}
  181321:	83 c4 08             	add    $0x8,%esp
  181324:	5b                   	pop    %ebx
  181325:	c3                   	ret    

00181326 <pinmux_initialize>:

static int pinmux_initialize(struct device *port)
{
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);
  181326:	b8 00 09 80 b0       	mov    $0xb0800900,%eax
  18132b:	e8 c8 ff ff ff       	call   1812f8 <_pinmux_defaults>

	/*
	 * MAGIC NUMBER: 0x1 is used as the pullup is a single bit in a
	 * 32-bit register.
	 */
	(*(mux_register)) = ((*(mux_register)) & ~(0x1 << pin_offset)) |
  181330:	a1 20 09 80 b0       	mov    0xb0800920,%eax
  181335:	83 c8 20             	or     $0x20,%eax
  181338:	a3 20 09 80 b0       	mov    %eax,0xb0800920

	/* Enable the UART RX pin to receive input */
	_quark_mcu_set_mux(PINMUX_BASE_ADDR + PINMUX_INPUT_OFFSET, 5, 0x1);

	return 0;
}
  18133d:	b8 00 00 00 00       	mov    $0x0,%eax
  181342:	c3                   	ret    

00181343 <qm_rar_set_mode>:
		qm_power_soc_deep_sleep_restore();
	}
}

int qm_rar_set_mode(const qm_rar_state_t mode)
{
  181343:	83 ec 08             	sub    $0x8,%esp
	QM_CHECK(mode <= QM_RAR_RETENTION, -EINVAL);
	volatile uint32_t i = 32;
  181346:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  18134d:	00 
	volatile uint32_t reg;

	switch (mode) {
  18134e:	85 c0                	test   %eax,%eax
  181350:	74 25                	je     181377 <qm_rar_set_mode+0x34>
  181352:	83 f8 01             	cmp    $0x1,%eax
  181355:	75 62                	jne    1813b9 <qm_rar_set_mode+0x76>
	case QM_RAR_RETENTION:
		QM_SCSS_PMU->aon_vr |=
  181357:	a1 40 05 80 b0       	mov    0xb0800540,%eax
  18135c:	0d 00 02 c4 9d       	or     $0x9dc40200,%eax
  181361:	a3 40 05 80 b0       	mov    %eax,0xb0800540
		    (QM_AON_VR_PASS_CODE | QM_AON_VR_ROK_BUF_VREG_MASK);
		QM_SCSS_PMU->aon_vr |=
  181366:	a1 40 05 80 b0       	mov    0xb0800540,%eax
  18136b:	0d 00 01 c4 9d       	or     $0x9dc40100,%eax
  181370:	a3 40 05 80 b0       	mov    %eax,0xb0800540
		    (QM_AON_VR_PASS_CODE | QM_AON_VR_VREG_SEL);
		break;
  181375:	eb 42                	jmp    1813b9 <qm_rar_set_mode+0x76>

	case QM_RAR_NORMAL:
		reg = QM_SCSS_PMU->aon_vr & ~QM_AON_VR_VREG_SEL;
  181377:	a1 40 05 80 b0       	mov    0xb0800540,%eax
  18137c:	80 e4 fe             	and    $0xfe,%ah
  18137f:	89 04 24             	mov    %eax,(%esp)
		QM_SCSS_PMU->aon_vr = QM_AON_VR_PASS_CODE | reg;
  181382:	8b 04 24             	mov    (%esp),%eax
  181385:	0d 00 00 c4 9d       	or     $0x9dc40000,%eax
  18138a:	a3 40 05 80 b0       	mov    %eax,0xb0800540
		/* Wait for >= 2usec, at most 64 clock cycles. */
		while (i--) {
  18138f:	eb 01                	jmp    181392 <qm_rar_set_mode+0x4f>
			__asm__ __volatile__("nop");
  181391:	90                   	nop

	case QM_RAR_NORMAL:
		reg = QM_SCSS_PMU->aon_vr & ~QM_AON_VR_VREG_SEL;
		QM_SCSS_PMU->aon_vr = QM_AON_VR_PASS_CODE | reg;
		/* Wait for >= 2usec, at most 64 clock cycles. */
		while (i--) {
  181392:	8b 44 24 04          	mov    0x4(%esp),%eax
  181396:	8d 50 ff             	lea    -0x1(%eax),%edx
  181399:	89 54 24 04          	mov    %edx,0x4(%esp)
  18139d:	85 c0                	test   %eax,%eax
  18139f:	75 f0                	jne    181391 <qm_rar_set_mode+0x4e>
			__asm__ __volatile__("nop");
		}
		reg = QM_SCSS_PMU->aon_vr & ~QM_AON_VR_ROK_BUF_VREG_MASK;
  1813a1:	a1 40 05 80 b0       	mov    0xb0800540,%eax
  1813a6:	80 e4 fd             	and    $0xfd,%ah
  1813a9:	89 04 24             	mov    %eax,(%esp)
		QM_SCSS_PMU->aon_vr = QM_AON_VR_PASS_CODE | reg;
  1813ac:	8b 04 24             	mov    (%esp),%eax
  1813af:	0d 00 00 c4 9d       	or     $0x9dc40000,%eax
  1813b4:	a3 40 05 80 b0       	mov    %eax,0xb0800540
		break;
	}
	return 0;
}
  1813b9:	b8 00 00 00 00       	mov    $0x0,%eax
  1813be:	83 c4 08             	add    $0x8,%esp
  1813c1:	c3                   	ret    

001813c2 <qm_power_soc_sleep_restore>:

void qm_power_soc_sleep_restore(void)
{
	/* From here on, restore the SoC to an active state. */
	/* Set the RAR to normal mode. */
	qm_rar_set_mode(QM_RAR_NORMAL);
  1813c2:	b8 00 00 00 00       	mov    $0x0,%eax
  1813c7:	e8 77 ff ff ff       	call   181343 <qm_rar_set_mode>
	 * In the worst case scenario, when switching back to 32MHz,
	 * 2 wait states will be restored.
	 * This setting will be too conservative until the frequency has been
	 * restored.
	 */
	QM_FLASH[QM_FLASH_0]->tmg_ctrl = power_context.flash_tmg_save;
  1813cc:	8b 15 7c 01 28 00    	mov    0x28017c,%edx
  1813d2:	a1 18 00 28 00       	mov    0x280018,%eax
  1813d7:	89 10                	mov    %edx,(%eax)

	/* Restore all previous values. */
	QM_SCSS_CCU->ccu_sys_clk_ctl = power_context.sys_clk_ctl_save;
  1813d9:	a1 68 01 28 00       	mov    0x280168,%eax
  1813de:	a3 38 00 80 b0       	mov    %eax,0xb0800038
	/* Re-apply clock divider values. DIV_EN must go 0 -> 1. */
	QM_SCSS_CCU->ccu_sys_clk_ctl &=
  1813e3:	a1 38 00 80 b0       	mov    0xb0800038,%eax
  1813e8:	24 7b                	and    $0x7b,%al
  1813ea:	a3 38 00 80 b0       	mov    %eax,0xb0800038
	    ~(QM_CCU_SYS_CLK_DIV_EN | QM_CCU_RTC_CLK_DIV_EN);
	QM_SCSS_CCU->ccu_sys_clk_ctl |=
  1813ef:	a1 38 00 80 b0       	mov    0xb0800038,%eax
  1813f4:	0c 84                	or     $0x84,%al
  1813f6:	a3 38 00 80 b0       	mov    %eax,0xb0800038
	    QM_CCU_SYS_CLK_DIV_EN | QM_CCU_RTC_CLK_DIV_EN;

	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER, SOCW_REG_CCU_SYS_CLK_CTL);

	/* Wait for the XTAL or SI oscillator to stabilise. */
	while (!(QM_SCSS_CCU->osc0_stat1 &
  1813fb:	a1 04 00 80 b0       	mov    0xb0800004,%eax
  181400:	a8 03                	test   $0x3,%al
  181402:	74 f7                	je     1813fb <qm_power_soc_sleep_restore+0x39>
		 (QM_OSC0_LOCK_SI | QM_OSC0_LOCK_XTAL))) {
	};

	/* Restore original clocking, ADC, analog comparator states. */
	QM_SCSS_CCU->osc0_cfg1 = power_context.osc0_cfg_save;
  181404:	a1 6c 01 28 00       	mov    0x28016c,%eax
  181409:	a3 08 00 80 b0       	mov    %eax,0xb0800008
	QM_SCSS_CCU->ccu_periph_clk_gate_ctl = power_context.clk_gate_save;
  18140e:	a1 64 01 28 00       	mov    0x280164,%eax
  181413:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER, SOCW_REG_OSC0_CFG1);
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
	QM_SCSS_CMP->cmp_pwr = power_context.ac_power_save;
  181418:	a1 60 01 28 00       	mov    0x280160,%eax
  18141d:	a3 0c 03 80 b0       	mov    %eax,0xb080030c
	QM_ADC->adc_op_mode = power_context.adc_mode_save;
  181422:	a1 74 01 28 00       	mov    0x280174,%eax
  181427:	a3 38 40 00 b0       	mov    %eax,0xb0004038
	QM_SCSS_CCU->ccu_lp_clk_ctl = power_context.lp_clk_save;
  18142c:	a1 84 01 28 00       	mov    0x280184,%eax
  181431:	a3 2c 00 80 b0       	mov    %eax,0xb080002c

	QM_SCSS_GP->gps0 &= ~QM_GPS0_POWER_STATE_SLEEP;
  181436:	a1 00 01 80 b0       	mov    0xb0800100,%eax
  18143b:	83 e0 bf             	and    $0xffffffbf,%eax
  18143e:	a3 00 01 80 b0       	mov    %eax,0xb0800100
  181443:	c3                   	ret    

00181444 <qm_power_soc_deep_sleep_restore>:

void qm_power_soc_deep_sleep_restore(void)
{
	/* We are now exiting from deep sleep mode. */
	/* Set the RAR to normal mode. */
	qm_rar_set_mode(QM_RAR_NORMAL);
  181444:	b8 00 00 00 00       	mov    $0x0,%eax
  181449:	e8 f5 fe ff ff       	call   181343 <qm_rar_set_mode>
	 * In the worst case scenario, when switching back to 32MHz,
	 * 2 wait states will be restored.
	 * This setting will be too conservative until the frequency has been
	 * restored.
	 */
	QM_FLASH[QM_FLASH_0]->tmg_ctrl = power_context.flash_tmg_save;
  18144e:	8b 15 7c 01 28 00    	mov    0x28017c,%edx
  181454:	a1 18 00 28 00       	mov    0x280018,%eax
  181459:	89 10                	mov    %edx,(%eax)

	/* Restore operating voltage to 1.8V. */
	/* SCSS.AON_VR.VSEL = 0x10; */
	QM_SCSS_PMU->aon_vr =
	    (QM_AON_VR_PASS_CODE | (QM_SCSS_PMU->aon_vr & QM_AON_VR_VSEL_MASK) |
  18145b:	a1 40 05 80 b0       	mov    0xb0800540,%eax
	     QM_AON_VR_VSEL_1V8 | QM_AON_VR_ROK_BUF_VREG_MASK);
  181460:	25 e0 fd 00 00       	and    $0xfde0,%eax
  181465:	0d 10 02 c4 9d       	or     $0x9dc40210,%eax
	 */
	QM_FLASH[QM_FLASH_0]->tmg_ctrl = power_context.flash_tmg_save;

	/* Restore operating voltage to 1.8V. */
	/* SCSS.AON_VR.VSEL = 0x10; */
	QM_SCSS_PMU->aon_vr =
  18146a:	a3 40 05 80 b0       	mov    %eax,0xb0800540
	    (QM_AON_VR_PASS_CODE | (QM_SCSS_PMU->aon_vr & QM_AON_VR_VSEL_MASK) |
	     QM_AON_VR_VSEL_1V8 | QM_AON_VR_ROK_BUF_VREG_MASK);

	/* SCSS.AON_VR.VSEL_STROBE = 1;  */
	QM_SCSS_PMU->aon_vr =
	    (QM_AON_VR_PASS_CODE | QM_SCSS_PMU->aon_vr | QM_AON_VR_VSTRB);
  18146f:	a1 40 05 80 b0       	mov    0xb0800540,%eax
  181474:	0d 20 00 c4 9d       	or     $0x9dc40020,%eax
	QM_SCSS_PMU->aon_vr =
	    (QM_AON_VR_PASS_CODE | (QM_SCSS_PMU->aon_vr & QM_AON_VR_VSEL_MASK) |
	     QM_AON_VR_VSEL_1V8 | QM_AON_VR_ROK_BUF_VREG_MASK);

	/* SCSS.AON_VR.VSEL_STROBE = 1;  */
	QM_SCSS_PMU->aon_vr =
  181479:	a3 40 05 80 b0       	mov    %eax,0xb0800540
	    (QM_AON_VR_PASS_CODE | QM_SCSS_PMU->aon_vr | QM_AON_VR_VSTRB);

	/* Wait >= 1 usec, at 256 kHz this is 1 cycle. */
	__asm__ __volatile__("nop");
  18147e:	90                   	nop

	/* SCSS.AON_VR.VSEL_STROBE = 0; */
	QM_SCSS_PMU->aon_vr =
	    (QM_AON_VR_PASS_CODE | (QM_SCSS_PMU->aon_vr & ~QM_AON_VR_VSTRB));
  18147f:	a1 40 05 80 b0       	mov    0xb0800540,%eax
  181484:	25 df ff 3b 62       	and    $0x623bffdf,%eax
  181489:	0d 00 00 c4 9d       	or     $0x9dc40000,%eax

	/* Wait >= 1 usec, at 256 kHz this is 1 cycle. */
	__asm__ __volatile__("nop");

	/* SCSS.AON_VR.VSEL_STROBE = 0; */
	QM_SCSS_PMU->aon_vr =
  18148e:	a3 40 05 80 b0       	mov    %eax,0xb0800540
	    (QM_AON_VR_PASS_CODE | (QM_SCSS_PMU->aon_vr & ~QM_AON_VR_VSTRB));

	/* Wait >= 2 usec, at 256 kHz this is 1 cycle. */
	__asm__ __volatile__("nop");
  181493:	90                   	nop

	/* SCSS.AON_VR.ROK_BUF_VREG_MASK = 0;  */
	QM_SCSS_PMU->aon_vr =
	    (QM_AON_VR_PASS_CODE |
	     (QM_SCSS_PMU->aon_vr & ~QM_AON_VR_ROK_BUF_VREG_MASK));
  181494:	a1 40 05 80 b0       	mov    0xb0800540,%eax
	/* Wait >= 2 usec, at 256 kHz this is 1 cycle. */
	__asm__ __volatile__("nop");

	/* SCSS.AON_VR.ROK_BUF_VREG_MASK = 0;  */
	QM_SCSS_PMU->aon_vr =
	    (QM_AON_VR_PASS_CODE |
  181499:	25 ff fd 3b 62       	and    $0x623bfdff,%eax
  18149e:	0d 00 00 c4 9d       	or     $0x9dc40000,%eax

	/* Wait >= 2 usec, at 256 kHz this is 1 cycle. */
	__asm__ __volatile__("nop");

	/* SCSS.AON_VR.ROK_BUF_VREG_MASK = 0;  */
	QM_SCSS_PMU->aon_vr =
  1814a3:	a3 40 05 80 b0       	mov    %eax,0xb0800540
	    (QM_AON_VR_PASS_CODE |
	     (QM_SCSS_PMU->aon_vr & ~QM_AON_VR_ROK_BUF_VREG_MASK));

	/* Wait >= 1 usec, at 256 kHz this is 1 cycle. */
	__asm__ __volatile__("nop");
  1814a8:	90                   	nop

	/* Wait for voltage regulator to attain 1.8V regulation. */
	while (!(QM_SCSS_PMU->aon_vr & QM_AON_VR_ROK_BUF_VREG_STATUS)) {
  1814a9:	a1 40 05 80 b0       	mov    0xb0800540,%eax
  1814ae:	f6 c4 80             	test   $0x80,%ah
  1814b1:	74 f6                	je     1814a9 <qm_power_soc_deep_sleep_restore+0x65>
	}

	/* SCSS.OSC0_CFG0.OSC0_HYB_SET_REG1.OSC0_CFG0[0]  = 0; */
	QM_SCSS_CCU->osc0_cfg0 &= ~QM_SI_OSC_1V2_MODE;
  1814b3:	a1 00 00 80 b0       	mov    0xb0800000,%eax
  1814b8:	83 e0 fe             	and    $0xfffffffe,%eax
  1814bb:	a3 00 00 80 b0       	mov    %eax,0xb0800000

	/* FlashCtrl.CTRL.LVE_MODE = 0; */
	QM_FLASH[QM_FLASH_0]->ctrl &= ~QM_FLASH_LVE_MODE;
  1814c0:	8b 15 18 00 28 00    	mov    0x280018,%edx
  1814c6:	8b 42 18             	mov    0x18(%edx),%eax
  1814c9:	83 e0 df             	and    $0xffffffdf,%eax
  1814cc:	89 42 18             	mov    %eax,0x18(%edx)

	/* Restore all previous values. */
	QM_SCSS_CCU->ccu_sys_clk_ctl = power_context.sys_clk_ctl_save;
  1814cf:	a1 68 01 28 00       	mov    0x280168,%eax
  1814d4:	a3 38 00 80 b0       	mov    %eax,0xb0800038
	/* Re-apply clock divider values. DIV_EN must go 0 -> 1. */
	QM_SCSS_CCU->ccu_sys_clk_ctl &=
  1814d9:	a1 38 00 80 b0       	mov    0xb0800038,%eax
  1814de:	24 7b                	and    $0x7b,%al
  1814e0:	a3 38 00 80 b0       	mov    %eax,0xb0800038
	    ~(QM_CCU_SYS_CLK_DIV_EN | QM_CCU_RTC_CLK_DIV_EN);
	QM_SCSS_CCU->ccu_sys_clk_ctl |=
  1814e5:	a1 38 00 80 b0       	mov    0xb0800038,%eax
  1814ea:	0c 84                	or     $0x84,%al
  1814ec:	a3 38 00 80 b0       	mov    %eax,0xb0800038
	    QM_CCU_SYS_CLK_DIV_EN | QM_CCU_RTC_CLK_DIV_EN;

	/* Wait for the XTAL or SI oscillator to stabilise. */
	while (!(QM_SCSS_CCU->osc0_stat1 &
  1814f1:	a1 04 00 80 b0       	mov    0xb0800004,%eax
  1814f6:	a8 03                	test   $0x3,%al
  1814f8:	74 f7                	je     1814f1 <qm_power_soc_deep_sleep_restore+0xad>
		 (QM_OSC0_LOCK_SI | QM_OSC0_LOCK_XTAL))) {
	};
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER, SOCW_REG_CCU_SYS_CLK_CTL);

	/* Re-enable clocks. */
	clk_periph_enable(CLK_PERIPH_REGISTER);
  1814fa:	b8 01 00 00 00       	mov    $0x1,%eax
  1814ff:	e8 92 00 00 00       	call   181596 <clk_periph_enable>

	/* Re-enable gpio debounce clocking. */
	QM_SCSS_CCU->ccu_gpio_db_clk_ctl |= QM_CCU_GPIO_DB_CLK_EN;
  181504:	a1 20 00 80 b0       	mov    0xb0800020,%eax
  181509:	83 c8 01             	or     $0x1,%eax
  18150c:	a3 20 00 80 b0       	mov    %eax,0xb0800020

	/* Restore original clocking, ADC, analog comparator states. */
	QM_SCSS_CCU->osc0_cfg1 = power_context.osc0_cfg_save;
  181511:	a1 6c 01 28 00       	mov    0x28016c,%eax
  181516:	a3 08 00 80 b0       	mov    %eax,0xb0800008
	QM_SCSS_CCU->ccu_periph_clk_gate_ctl = power_context.clk_gate_save;
  18151b:	a1 64 01 28 00       	mov    0x280164,%eax
  181520:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	QM_SCSS_CCU->osc1_cfg0 = power_context.osc1_cfg_save;
  181525:	a1 70 01 28 00       	mov    0x280170,%eax
  18152a:	a3 10 00 80 b0       	mov    %eax,0xb0800010

	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER, SOCW_REG_OSC0_CFG1);
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
	QM_SCSS_CMP->cmp_pwr = power_context.ac_power_save;
  18152f:	a1 60 01 28 00       	mov    0x280160,%eax
  181534:	a3 0c 03 80 b0       	mov    %eax,0xb080030c
	QM_ADC->adc_op_mode = power_context.adc_mode_save;
  181539:	a1 74 01 28 00       	mov    0x280174,%eax
  18153e:	a3 38 40 00 b0       	mov    %eax,0xb0004038

	QM_SCSS_PMUX->pmux_slew[0] = power_context.pmux_slew_save;
  181543:	a1 88 01 28 00       	mov    0x280188,%eax
  181548:	a3 10 09 80 b0       	mov    %eax,0xb0800910
	QM_SCSS_CCU->ccu_ext_clock_ctl = power_context.ext_clock_save;
  18154d:	a1 80 01 28 00       	mov    0x280180,%eax
  181552:	a3 24 00 80 b0       	mov    %eax,0xb0800024
	QM_SCSS_CCU->ccu_lp_clk_ctl = power_context.lp_clk_save;
  181557:	a1 84 01 28 00       	mov    0x280184,%eax
  18155c:	a3 2c 00 80 b0       	mov    %eax,0xb080002c

	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER, SOCW_REG_PMUX_SLEW);
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER, SOCW_REG_CCU_LP_CLK_CTL);
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER, SOCW_REG_CCU_EXT_CLK_CTL);

	QM_SCSS_CCU->wake_mask = SET_ALL_BITS;
  181561:	c7 05 30 00 80 b0 ff 	movl   $0xffffffff,0xb0800030
  181568:	ff ff ff 
	QM_SCSS_GP->gps0 &= ~QM_GPS0_POWER_STATE_DEEP_SLEEP;
  18156b:	a1 00 01 80 b0       	mov    0xb0800100,%eax
  181570:	24 7f                	and    $0x7f,%al
  181572:	a3 00 01 80 b0       	mov    %eax,0xb0800100
  181577:	c3                   	ret    

00181578 <qm_power_soc_restore>:
{
	/*
	 * If the SoC is waking from sleep or deep sleep mode then the full
	 * system state must be restored.
	 */
	if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATE_SLEEP) {
  181578:	a1 00 01 80 b0       	mov    0xb0800100,%eax
  18157d:	a8 40                	test   $0x40,%al
  18157f:	74 06                	je     181587 <qm_power_soc_restore+0xf>
		qm_power_soc_sleep_restore();
  181581:	e8 3c fe ff ff       	call   1813c2 <qm_power_soc_sleep_restore>
  181586:	c3                   	ret    
	} else if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATE_DEEP_SLEEP) {
  181587:	a1 00 01 80 b0       	mov    0xb0800100,%eax
  18158c:	a8 80                	test   $0x80,%al
  18158e:	74 05                	je     181595 <qm_power_soc_restore+0x1d>
		qm_power_soc_deep_sleep_restore();
  181590:	e8 af fe ff ff       	call   181444 <qm_power_soc_deep_sleep_restore>
  181595:	c3                   	ret    

00181596 <clk_periph_enable>:

int clk_periph_enable(const clk_periph_t clocks)
{
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
  181596:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
  18159c:	09 d0                	or     %edx,%eax
  18159e:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
  1815a3:	b8 00 00 00 00       	mov    $0x0,%eax
  1815a8:	c3                   	ret    

001815a9 <clk_sys_get_ticks_per_us>:
}

uint32_t clk_sys_get_ticks_per_us(void)
{
	return ticks_per_us;
}
  1815a9:	a1 1c 00 28 00       	mov    0x28001c,%eax
  1815ae:	c3                   	ret    

001815af <qm_pwm_start>:
}

#endif /* NUM_PWM_CONTROLLER_INTERRUPTS > 1 */

int qm_pwm_start(const qm_pwm_t pwm, const qm_pwm_id_t id)
{
  1815af:	56                   	push   %esi
  1815b0:	53                   	push   %ebx
	QM_CHECK(pwm < QM_PWM_NUM, -EINVAL);
	QM_CHECK(id < QM_PWM_ID_NUM, -EINVAL);

	qm_pwm_reg_t *const controller = QM_PWM[pwm];
  1815b1:	8b 1c 85 20 00 28 00 	mov    0x280020(,%eax,4),%ebx
	controller->timer[id].controlreg |= PWM_START;
  1815b8:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
  1815bf:	8d 34 10             	lea    (%eax,%edx,1),%esi
  1815c2:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  1815c9:	89 ce                	mov    %ecx,%esi
  1815cb:	01 d9                	add    %ebx,%ecx
  1815cd:	8b 49 08             	mov    0x8(%ecx),%ecx
  1815d0:	83 c9 01             	or     $0x1,%ecx
  1815d3:	89 f0                	mov    %esi,%eax
  1815d5:	01 d8                	add    %ebx,%eax
  1815d7:	89 48 08             	mov    %ecx,0x8(%eax)

	return 0;
}
  1815da:	b8 00 00 00 00       	mov    $0x0,%eax
  1815df:	5b                   	pop    %ebx
  1815e0:	5e                   	pop    %esi
  1815e1:	c3                   	ret    

001815e2 <qm_pwm_stop>:

int qm_pwm_stop(const qm_pwm_t pwm, const qm_pwm_id_t id)
{
  1815e2:	56                   	push   %esi
  1815e3:	53                   	push   %ebx
	QM_CHECK(pwm < QM_PWM_NUM, -EINVAL);
	QM_CHECK(id < QM_PWM_ID_NUM, -EINVAL);

	qm_pwm_reg_t *const controller = QM_PWM[pwm];
  1815e4:	8b 1c 85 20 00 28 00 	mov    0x280020(,%eax,4),%ebx

	controller->timer[id].controlreg &= ~PWM_START;
  1815eb:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
  1815f2:	8d 34 10             	lea    (%eax,%edx,1),%esi
  1815f5:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  1815fc:	89 ce                	mov    %ecx,%esi
  1815fe:	01 d9                	add    %ebx,%ecx
  181600:	8b 49 08             	mov    0x8(%ecx),%ecx
  181603:	83 e1 fe             	and    $0xfffffffe,%ecx
  181606:	89 f0                	mov    %esi,%eax
  181608:	01 d8                	add    %ebx,%eax
  18160a:	89 48 08             	mov    %ecx,0x8(%eax)

	return 0;
}
  18160d:	b8 00 00 00 00       	mov    $0x0,%eax
  181612:	5b                   	pop    %ebx
  181613:	5e                   	pop    %esi
  181614:	c3                   	ret    

00181615 <qm_pwm_set_config>:

int qm_pwm_set_config(const qm_pwm_t pwm, const qm_pwm_id_t id,
		      const qm_pwm_config_t *const cfg)
{
  181615:	55                   	push   %ebp
  181616:	57                   	push   %edi
  181617:	56                   	push   %esi
  181618:	53                   	push   %ebx
	QM_CHECK(0 < cfg->lo_count, -EINVAL);
	/* If mode is PWM, hi_count must be > 0, otherwise don't care. */
	QM_CHECK(cfg->mode == QM_PWM_MODE_PWM ? 0 != cfg->hi_count : 1,
		 -EINVAL);

	qm_pwm_reg_t *const controller = QM_PWM[pwm];
  181619:	8b 3c 85 20 00 28 00 	mov    0x280020(,%eax,4),%edi
	controller->timer[id].loadcount = cfg->lo_count - 1;
  181620:	8b 19                	mov    (%ecx),%ebx
  181622:	8d 6b ff             	lea    -0x1(%ebx),%ebp
  181625:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
  18162c:	01 d6                	add    %edx,%esi
  18162e:	8d 1c b5 00 00 00 00 	lea    0x0(,%esi,4),%ebx
  181635:	01 fb                	add    %edi,%ebx
  181637:	89 2b                	mov    %ebp,(%ebx)
	controller->timer[id].controlreg =
	    (cfg->mode | (cfg->mask_interrupt << QM_PWM_INTERRUPT_MASK_OFFSET));
  181639:	0f b6 71 08          	movzbl 0x8(%ecx),%esi
  18163d:	c1 e6 02             	shl    $0x2,%esi
  181640:	0b 71 0c             	or     0xc(%ecx),%esi
	QM_CHECK(cfg->mode == QM_PWM_MODE_PWM ? 0 != cfg->hi_count : 1,
		 -EINVAL);

	qm_pwm_reg_t *const controller = QM_PWM[pwm];
	controller->timer[id].loadcount = cfg->lo_count - 1;
	controller->timer[id].controlreg =
  181643:	89 73 08             	mov    %esi,0x8(%ebx)
	    (cfg->mode | (cfg->mask_interrupt << QM_PWM_INTERRUPT_MASK_OFFSET));
	controller->timer_loadcount2[id] = cfg->hi_count - 1;
  181646:	8b 59 04             	mov    0x4(%ecx),%ebx
  181649:	4b                   	dec    %ebx
  18164a:	8d 72 2c             	lea    0x2c(%edx),%esi
  18164d:	89 1c b7             	mov    %ebx,(%edi,%esi,4)

	/* Assign user callback function. */
	callback[pwm][id] = cfg->callback;
  181650:	8b 59 10             	mov    0x10(%ecx),%ebx
  181653:	8d 04 42             	lea    (%edx,%eax,2),%eax
  181656:	89 1c 85 98 01 28 00 	mov    %ebx,0x280198(,%eax,4)
	callback_data[pwm][id] = cfg->callback_data;
  18165d:	8b 51 14             	mov    0x14(%ecx),%edx
  181660:	89 14 85 8c 01 28 00 	mov    %edx,0x28018c(,%eax,4)

	return 0;
}
  181667:	b8 00 00 00 00       	mov    $0x0,%eax
  18166c:	5b                   	pop    %ebx
  18166d:	5e                   	pop    %esi
  18166e:	5f                   	pop    %edi
  18166f:	5d                   	pop    %ebp
  181670:	c3                   	ret    

00181671 <gpio_isr>:

static void (*callback[QM_GPIO_NUM])(void *, uint32_t);
static void *callback_data[QM_GPIO_NUM];

static void gpio_isr(const qm_gpio_t gpio)
{
  181671:	56                   	push   %esi
  181672:	53                   	push   %ebx
  181673:	89 c3                	mov    %eax,%ebx
	const uint32_t int_status = QM_GPIO[gpio]->gpio_intstatus;
  181675:	8b 04 85 24 00 28 00 	mov    0x280024(,%eax,4),%eax
  18167c:	8b 70 40             	mov    0x40(%eax),%esi

#if (HAS_SOC_CONTEXT_RETENTION)
	if (QM_SCSS_GP->gps0 & QM_GPS0_POWER_STATES_MASK) {
  18167f:	a1 00 01 80 b0       	mov    0xb0800100,%eax
  181684:	a9 c0 03 00 00       	test   $0x3c0,%eax
  181689:	74 05                	je     181690 <gpio_isr+0x1f>
		qm_power_soc_restore();
  18168b:	e8 e8 fe ff ff       	call   181578 <qm_power_soc_restore>
	}
#endif

	if (callback[gpio]) {
  181690:	8b 0c 9d a0 01 28 00 	mov    0x2801a0(,%ebx,4),%ecx
  181697:	85 c9                	test   %ecx,%ecx
  181699:	74 0b                	je     1816a6 <gpio_isr+0x35>
		(*callback[gpio])(callback_data[gpio], int_status);
  18169b:	8b 04 9d 94 01 28 00 	mov    0x280194(,%ebx,4),%eax
  1816a2:	89 f2                	mov    %esi,%edx
  1816a4:	ff d1                	call   *%ecx
	}

	/* This will clear all pending interrupts flags in status */
	QM_GPIO[gpio]->gpio_porta_eoi = int_status;
  1816a6:	8b 04 9d 24 00 28 00 	mov    0x280024(,%ebx,4),%eax
  1816ad:	89 70 4c             	mov    %esi,0x4c(%eax)
	/* Read back EOI register to avoid a spurious interrupt due to EOI
	 * propagation delay */
	QM_GPIO[gpio]->gpio_porta_eoi;
  1816b0:	8b 40 4c             	mov    0x4c(%eax),%eax
}
  1816b3:	5b                   	pop    %ebx
  1816b4:	5e                   	pop    %esi
  1816b5:	c3                   	ret    

001816b6 <qm_gpio_0_isr>:

QM_ISR_DECLARE(qm_gpio_0_isr)
{
	gpio_isr(QM_GPIO_0);
  1816b6:	b8 00 00 00 00       	mov    $0x0,%eax
  1816bb:	e8 b1 ff ff ff       	call   181671 <gpio_isr>
  1816c0:	c3                   	ret    

001816c1 <qm_gpio_set_config>:
}
#endif

int qm_gpio_set_config(const qm_gpio_t gpio,
		       const qm_gpio_port_config_t *const cfg)
{
  1816c1:	56                   	push   %esi
  1816c2:	53                   	push   %ebx
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_gpio_reg_t *const controller = QM_GPIO[gpio];
  1816c3:	8b 0c 85 24 00 28 00 	mov    0x280024(,%eax,4),%ecx

	uint32_t mask = controller->gpio_intmask;
  1816ca:	8b 71 34             	mov    0x34(%ecx),%esi
	controller->gpio_intmask = 0xffffffff;
  1816cd:	c7 41 34 ff ff ff ff 	movl   $0xffffffff,0x34(%ecx)

	controller->gpio_swporta_ddr = cfg->direction;
  1816d4:	8b 1a                	mov    (%edx),%ebx
  1816d6:	89 59 04             	mov    %ebx,0x4(%ecx)
	controller->gpio_inten = cfg->int_en;
  1816d9:	8b 5a 04             	mov    0x4(%edx),%ebx
  1816dc:	89 59 30             	mov    %ebx,0x30(%ecx)
	controller->gpio_inttype_level = cfg->int_type;
  1816df:	8b 5a 08             	mov    0x8(%edx),%ebx
  1816e2:	89 59 38             	mov    %ebx,0x38(%ecx)
	controller->gpio_int_polarity = cfg->int_polarity;
  1816e5:	8b 5a 0c             	mov    0xc(%edx),%ebx
  1816e8:	89 59 3c             	mov    %ebx,0x3c(%ecx)
	controller->gpio_debounce = cfg->int_debounce;
  1816eb:	8b 5a 10             	mov    0x10(%edx),%ebx
  1816ee:	89 59 48             	mov    %ebx,0x48(%ecx)
	controller->gpio_int_bothedge = cfg->int_bothedge;
  1816f1:	8b 5a 14             	mov    0x14(%edx),%ebx
  1816f4:	89 59 68             	mov    %ebx,0x68(%ecx)
	controller->gpio_ls_sync |= ENABLE_PCLK;
  1816f7:	8b 59 60             	mov    0x60(%ecx),%ebx
  1816fa:	83 cb 01             	or     $0x1,%ebx
  1816fd:	89 59 60             	mov    %ebx,0x60(%ecx)
	callback[gpio] = cfg->callback;
  181700:	8b 5a 18             	mov    0x18(%edx),%ebx
  181703:	89 1c 85 a0 01 28 00 	mov    %ebx,0x2801a0(,%eax,4)
	callback_data[gpio] = cfg->callback_data;
  18170a:	8b 52 1c             	mov    0x1c(%edx),%edx
  18170d:	89 14 85 94 01 28 00 	mov    %edx,0x280194(,%eax,4)

	controller->gpio_intmask = mask;
  181714:	89 71 34             	mov    %esi,0x34(%ecx)

	return 0;
}
  181717:	b8 00 00 00 00       	mov    $0x0,%eax
  18171c:	5b                   	pop    %ebx
  18171d:	5e                   	pop    %esi
  18171e:	c3                   	ret    

0018171f <qm_gpio_read_pin>:

int qm_gpio_read_pin(const qm_gpio_t gpio, const uint8_t pin,
		     qm_gpio_state_t *const state)
{
  18171f:	53                   	push   %ebx
  181720:	89 cb                	mov    %ecx,%ebx
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);
	QM_CHECK(state != NULL, -EINVAL);

	*state = ((QM_GPIO[gpio]->gpio_ext_porta) >> pin) & 1;
  181722:	8b 04 85 24 00 28 00 	mov    0x280024(,%eax,4),%eax
  181729:	8b 40 50             	mov    0x50(%eax),%eax
  18172c:	88 d1                	mov    %dl,%cl
  18172e:	d3 e8                	shr    %cl,%eax
  181730:	83 e0 01             	and    $0x1,%eax
  181733:	89 03                	mov    %eax,(%ebx)

	return 0;
}
  181735:	b8 00 00 00 00       	mov    $0x0,%eax
  18173a:	5b                   	pop    %ebx
  18173b:	c3                   	ret    

0018173c <qm_gpio_set_pin>:

int qm_gpio_set_pin(const qm_gpio_t gpio, const uint8_t pin)
{
  18173c:	56                   	push   %esi
  18173d:	53                   	push   %ebx
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr |= (1 << pin);
  18173e:	8b 34 85 24 00 28 00 	mov    0x280024(,%eax,4),%esi
  181745:	8b 06                	mov    (%esi),%eax
  181747:	bb 01 00 00 00       	mov    $0x1,%ebx
  18174c:	88 d1                	mov    %dl,%cl
  18174e:	d3 e3                	shl    %cl,%ebx
  181750:	09 d8                	or     %ebx,%eax
  181752:	89 06                	mov    %eax,(%esi)

	return 0;
}
  181754:	b8 00 00 00 00       	mov    $0x0,%eax
  181759:	5b                   	pop    %ebx
  18175a:	5e                   	pop    %esi
  18175b:	c3                   	ret    

0018175c <qm_gpio_clear_pin>:

int qm_gpio_clear_pin(const qm_gpio_t gpio, const uint8_t pin)
{
  18175c:	56                   	push   %esi
  18175d:	53                   	push   %ebx
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(pin <= QM_NUM_GPIO_PINS, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr &= ~(1 << pin);
  18175e:	8b 34 85 24 00 28 00 	mov    0x280024(,%eax,4),%esi
  181765:	8b 1e                	mov    (%esi),%ebx
  181767:	b8 01 00 00 00       	mov    $0x1,%eax
  18176c:	88 d1                	mov    %dl,%cl
  18176e:	d3 e0                	shl    %cl,%eax
  181770:	f7 d0                	not    %eax
  181772:	21 d8                	and    %ebx,%eax
  181774:	89 06                	mov    %eax,(%esi)

	return 0;
}
  181776:	b8 00 00 00 00       	mov    $0x0,%eax
  18177b:	5b                   	pop    %ebx
  18177c:	5e                   	pop    %esi
  18177d:	c3                   	ret    

0018177e <qm_gpio_read_port>:
int qm_gpio_read_port(const qm_gpio_t gpio, uint32_t *const port)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);
	QM_CHECK(port != NULL, -EINVAL);

	*port = QM_GPIO[gpio]->gpio_ext_porta;
  18177e:	8b 04 85 24 00 28 00 	mov    0x280024(,%eax,4),%eax
  181785:	8b 40 50             	mov    0x50(%eax),%eax
  181788:	89 02                	mov    %eax,(%edx)

	return 0;
}
  18178a:	b8 00 00 00 00       	mov    $0x0,%eax
  18178f:	c3                   	ret    

00181790 <qm_gpio_write_port>:

int qm_gpio_write_port(const qm_gpio_t gpio, const uint32_t val)
{
	QM_CHECK(gpio < QM_GPIO_NUM, -EINVAL);

	QM_GPIO[gpio]->gpio_swporta_dr = val;
  181790:	8b 04 85 24 00 28 00 	mov    0x280024(,%eax,4),%eax
  181797:	89 10                	mov    %edx,(%eax)

	return 0;
}
  181799:	b8 00 00 00 00       	mov    $0x0,%eax
  18179e:	c3                   	ret    

0018179f <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
  18179f:	83 ec 04             	sub    $0x4,%esp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  1817a2:	8b 04 85 28 00 28 00 	mov    0x280028(,%eax,4),%eax
	volatile uint32_t unused_lsr __attribute__((unused));

	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;
  1817a9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
  1817b0:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
  1817b7:	8b 4a 04             	mov    0x4(%edx),%ecx
  1817ba:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  1817c0:	c1 e9 10             	shr    $0x10,%ecx
  1817c3:	89 48 04             	mov    %ecx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
  1817c6:	8b 4a 04             	mov    0x4(%edx),%ecx
  1817c9:	0f b6 cd             	movzbl %ch,%ecx
  1817cc:	89 08                	mov    %ecx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
  1817ce:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  1817d2:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
  1817d8:	8b 0a                	mov    (%edx),%ecx
  1817da:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
  1817dd:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
  1817e4:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  1817e8:	74 09                	je     1817f3 <qm_uart_set_config+0x54>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
  1817ea:	8b 50 10             	mov    0x10(%eax),%edx
  1817ed:	83 ca 22             	or     $0x22,%edx
  1817f0:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
  1817f3:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
  1817fa:	8b 50 04             	mov    0x4(%eax),%edx
  1817fd:	80 ca 80             	or     $0x80,%dl
  181800:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
  181803:	8b 40 14             	mov    0x14(%eax),%eax
  181806:	89 04 24             	mov    %eax,(%esp)

	return 0;
}
  181809:	b8 00 00 00 00       	mov    $0x0,%eax
  18180e:	83 c4 04             	add    $0x4,%esp
  181811:	c3                   	ret    

00181812 <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
  181812:	56                   	push   %esi
  181813:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
  181814:	8b 04 85 28 00 28 00 	mov    0x280028(,%eax,4),%eax
	uint32_t lsr = regs->lsr;
  18181b:	8b 48 14             	mov    0x14(%eax),%ecx

	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
  18181e:	89 cb                	mov    %ecx,%ebx
  181820:	83 e3 1e             	and    $0x1e,%ebx
  181823:	89 1a                	mov    %ebx,(%edx)

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
  181825:	8b 70 1c             	mov    0x1c(%eax),%esi
  181828:	f7 c6 01 00 00 00    	test   $0x1,%esi
  18182e:	74 0b                	je     18183b <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
  181830:	8b 58 1c             	mov    0x1c(%eax),%ebx
  181833:	83 e3 fe             	and    $0xfffffffe,%ebx
  181836:	89 58 1c             	mov    %ebx,0x1c(%eax)
  181839:	eb 0a                	jmp    181845 <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
  18183b:	f6 c1 40             	test   $0x40,%cl
  18183e:	75 05                	jne    181845 <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
  181840:	83 cb 20             	or     $0x20,%ebx
  181843:	89 1a                	mov    %ebx,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
  181845:	f6 c1 01             	test   $0x1,%cl
  181848:	74 03                	je     18184d <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
  18184a:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
  18184d:	b8 00 00 00 00       	mov    $0x0,%eax
  181852:	5b                   	pop    %ebx
  181853:	5e                   	pop    %esi
  181854:	c3                   	ret    

00181855 <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181855:	8b 04 85 28 00 28 00 	mov    0x280028(,%eax,4),%eax

	while (regs->lsr & QM_UART_LSR_THRE) {
  18185c:	8b 48 14             	mov    0x14(%eax),%ecx
  18185f:	f6 c1 20             	test   $0x20,%cl
  181862:	75 f8                	jne    18185c <qm_uart_write+0x7>
	}
	regs->rbr_thr_dll = data;
  181864:	0f b6 d2             	movzbl %dl,%edx
  181867:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
  181869:	8b 50 14             	mov    0x14(%eax),%edx
  18186c:	f6 c2 40             	test   $0x40,%dl
  18186f:	74 f8                	je     181869 <qm_uart_write+0x14>
	}

	return 0;
}
  181871:	b8 00 00 00 00       	mov    $0x0,%eax
  181876:	c3                   	ret    

00181877 <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
  181877:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181878:	8b 1c 85 28 00 28 00 	mov    0x280028(,%eax,4),%ebx

	uint32_t lsr = regs->lsr;
  18187f:	8b 43 14             	mov    0x14(%ebx),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
  181882:	eb 03                	jmp    181887 <qm_uart_read+0x10>
		lsr = regs->lsr;
  181884:	8b 43 14             	mov    0x14(%ebx),%eax
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
  181887:	a8 01                	test   $0x1,%al
  181889:	74 f9                	je     181884 <qm_uart_read+0xd>
		lsr = regs->lsr;
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
  18188b:	83 e0 1e             	and    $0x1e,%eax
  18188e:	74 0d                	je     18189d <qm_uart_read+0x26>
		if (status) {
  181890:	85 c9                	test   %ecx,%ecx
  181892:	74 14                	je     1818a8 <qm_uart_read+0x31>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
  181894:	89 01                	mov    %eax,(%ecx)
		}
		return -EIO;
  181896:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  18189b:	eb 10                	jmp    1818ad <qm_uart_read+0x36>
	}
	*data = regs->rbr_thr_dll;
  18189d:	8b 03                	mov    (%ebx),%eax
  18189f:	88 02                	mov    %al,(%edx)

	return 0;
  1818a1:	b8 00 00 00 00       	mov    $0x0,%eax
  1818a6:	eb 05                	jmp    1818ad <qm_uart_read+0x36>
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
  1818a8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}
	*data = regs->rbr_thr_dll;

	return 0;
}
  1818ad:	5b                   	pop    %ebx
  1818ae:	c3                   	ret    

001818af <pin_to_register>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The register index of the given pin.
 */
static uint32_t pin_to_register(uint32_t pin, uint32_t width)
{
  1818af:	56                   	push   %esi
  1818b0:	53                   	push   %ebx
  1818b1:	89 c3                	mov    %eax,%ebx
  1818b3:	89 d6                	mov    %edx,%esi
	return (pin / (32 / width));
  1818b5:	b8 20 00 00 00       	mov    $0x20,%eax
  1818ba:	ba 00 00 00 00       	mov    $0x0,%edx
  1818bf:	f7 f6                	div    %esi
  1818c1:	89 c1                	mov    %eax,%ecx
  1818c3:	89 d8                	mov    %ebx,%eax
  1818c5:	ba 00 00 00 00       	mov    $0x0,%edx
  1818ca:	f7 f1                	div    %ecx
}
  1818cc:	5b                   	pop    %ebx
  1818cd:	5e                   	pop    %esi
  1818ce:	c3                   	ret    

001818cf <pin_to_offset>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
  1818cf:	56                   	push   %esi
  1818d0:	53                   	push   %ebx
  1818d1:	89 c6                	mov    %eax,%esi
  1818d3:	89 d3                	mov    %edx,%ebx
	return ((pin % (32 / width)) * width);
  1818d5:	b8 20 00 00 00       	mov    $0x20,%eax
  1818da:	ba 00 00 00 00       	mov    $0x0,%edx
  1818df:	f7 f3                	div    %ebx
  1818e1:	89 c1                	mov    %eax,%ecx
  1818e3:	89 f0                	mov    %esi,%eax
  1818e5:	ba 00 00 00 00       	mov    $0x0,%edx
  1818ea:	f7 f1                	div    %ecx
  1818ec:	89 d8                	mov    %ebx,%eax
  1818ee:	0f af c2             	imul   %edx,%eax
}
  1818f1:	5b                   	pop    %ebx
  1818f2:	5e                   	pop    %esi
  1818f3:	c3                   	ret    

001818f4 <qm_pmux_select>:

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
  1818f4:	57                   	push   %edi
  1818f5:	56                   	push   %esi
  1818f6:	53                   	push   %ebx
  1818f7:	89 c7                	mov    %eax,%edi
  1818f9:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
  1818fb:	ba 02 00 00 00       	mov    $0x2,%edx
  181900:	e8 aa ff ff ff       	call   1818af <pin_to_register>
  181905:	89 c3                	mov    %eax,%ebx
	uint32_t offs = pin_to_offset(pin, 2);
  181907:	ba 02 00 00 00       	mov    $0x2,%edx
  18190c:	89 f8                	mov    %edi,%eax
  18190e:	e8 bc ff ff ff       	call   1818cf <pin_to_offset>
  181913:	89 c1                	mov    %eax,%ecx

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
  181915:	83 c3 0c             	add    $0xc,%ebx
  181918:	8b 3c 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edi
  18191f:	ba 03 00 00 00       	mov    $0x3,%edx
  181924:	d3 e2                	shl    %cl,%edx
  181926:	f7 d2                	not    %edx
  181928:	21 fa                	and    %edi,%edx
  18192a:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
  181931:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181938:	d3 e6                	shl    %cl,%esi
  18193a:	09 c6                	or     %eax,%esi
  18193c:	89 34 9d 00 09 80 b0 	mov    %esi,-0x4f7ff700(,%ebx,4)

	return 0;
}
  181943:	b8 00 00 00 00       	mov    $0x0,%eax
  181948:	5b                   	pop    %ebx
  181949:	5e                   	pop    %esi
  18194a:	5f                   	pop    %edi
  18194b:	c3                   	ret    

0018194c <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
  18194c:	57                   	push   %edi
  18194d:	56                   	push   %esi
  18194e:	53                   	push   %ebx
  18194f:	89 c7                	mov    %eax,%edi
  181951:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  181953:	ba 01 00 00 00       	mov    $0x1,%edx
  181958:	e8 52 ff ff ff       	call   1818af <pin_to_register>
  18195d:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  18195f:	ba 01 00 00 00       	mov    $0x1,%edx
  181964:	89 f8                	mov    %edi,%eax
  181966:	e8 64 ff ff ff       	call   1818cf <pin_to_offset>
  18196b:	ba 01 00 00 00       	mov    $0x1,%edx
  181970:	88 c1                	mov    %al,%cl
  181972:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  181974:	89 f0                	mov    %esi,%eax
  181976:	84 c0                	test   %al,%al
  181978:	75 17                	jne    181991 <qm_pmux_input_en+0x45>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
  18197a:	83 c3 08             	add    $0x8,%ebx
  18197d:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181984:	f7 d2                	not    %edx
  181986:	21 c2                	and    %eax,%edx
  181988:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  18198f:	eb 13                	jmp    1819a4 <qm_pmux_input_en+0x58>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
  181991:	83 c3 08             	add    $0x8,%ebx
  181994:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  18199b:	09 c2                	or     %eax,%edx
  18199d:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  1819a4:	b8 00 00 00 00       	mov    $0x0,%eax
  1819a9:	5b                   	pop    %ebx
  1819aa:	5e                   	pop    %esi
  1819ab:	5f                   	pop    %edi
  1819ac:	c3                   	ret    

001819ad <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
  1819ad:	57                   	push   %edi
  1819ae:	56                   	push   %esi
  1819af:	53                   	push   %ebx
  1819b0:	89 c7                	mov    %eax,%edi
  1819b2:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  1819b4:	ba 01 00 00 00       	mov    $0x1,%edx
  1819b9:	e8 f1 fe ff ff       	call   1818af <pin_to_register>
  1819be:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  1819c0:	ba 01 00 00 00       	mov    $0x1,%edx
  1819c5:	89 f8                	mov    %edi,%eax
  1819c7:	e8 03 ff ff ff       	call   1818cf <pin_to_offset>
  1819cc:	ba 01 00 00 00       	mov    $0x1,%edx
  1819d1:	88 c1                	mov    %al,%cl
  1819d3:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  1819d5:	89 f0                	mov    %esi,%eax
  1819d7:	84 c0                	test   %al,%al
  1819d9:	75 14                	jne    1819ef <qm_pmux_pullup_en+0x42>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
  1819db:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  1819e2:	f7 d2                	not    %edx
  1819e4:	21 c2                	and    %eax,%edx
  1819e6:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  1819ed:	eb 10                	jmp    1819ff <qm_pmux_pullup_en+0x52>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
  1819ef:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  1819f6:	09 c2                	or     %eax,%edx
  1819f8:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  1819ff:	b8 00 00 00 00       	mov    $0x0,%eax
  181a04:	5b                   	pop    %ebx
  181a05:	5e                   	pop    %esi
  181a06:	5f                   	pop    %edi
  181a07:	c3                   	ret    

00181a08 <k_cpu_idle>:
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  181a08:	fb                   	sti    
  181a09:	f4                   	hlt    
  181a0a:	c3                   	ret    

00181a0b <_SysFatalErrorHandler>:
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
  181a0b:	e8 dd 0c 00 00       	call   1826ed <k_is_in_isr>
  181a10:	85 c0                	test   %eax,%eax
  181a12:	75 09                	jne    181a1d <_SysFatalErrorHandler+0x12>
  181a14:	e8 e2 0c 00 00       	call   1826fb <_is_thread_essential>
  181a19:	85 c0                	test   %eax,%eax
  181a1b:	74 25                	je     181a42 <_SysFatalErrorHandler+0x37>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  181a1d:	e8 cb 0c 00 00       	call   1826ed <k_is_in_isr>
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  181a22:	85 c0                	test   %eax,%eax
  181a24:	74 07                	je     181a2d <_SysFatalErrorHandler+0x22>
  181a26:	b8 1c 32 18 00       	mov    $0x18321c,%eax
  181a2b:	eb 05                	jmp    181a32 <_SysFatalErrorHandler+0x27>
  181a2d:	b8 20 32 18 00       	mov    $0x183220,%eax
  181a32:	50                   	push   %eax
  181a33:	68 70 32 18 00       	push   $0x183270
  181a38:	e8 91 f8 ff ff       	call   1812ce <printk>
  181a3d:	83 c4 08             	add    $0x8,%esp
  181a40:	eb fe                	jmp    181a40 <_SysFatalErrorHandler+0x35>
		       k_is_in_isr() ? "ISR" : "essential thread");
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  181a42:	ff 35 c8 01 28 00    	pushl  0x2801c8
  181a48:	68 90 32 18 00       	push   $0x183290
  181a4d:	e8 7c f8 ff ff       	call   1812ce <printk>
  181a52:	83 c4 08             	add    $0x8,%esp
	k_thread_abort(_current);
  181a55:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  181a5a:	e8 e6 0e 00 00       	call   182945 <k_thread_abort>

00181a5f <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  181a5f:	53                   	push   %ebx
	movl $1, %eax
  181a60:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  181a65:	0f a2                	cpuid  
	movl %ebx, %eax
  181a67:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  181a69:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  181a6e:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  181a71:	5b                   	pop    %ebx
	ret
  181a72:	c3                   	ret    

00181a73 <init_cache_line_size>:

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  181a73:	e8 e7 ff ff ff       	call   181a5f <_cache_line_size_get>
  181a78:	a3 ec 02 28 00       	mov    %eax,0x2802ec
  181a7d:	c3                   	ret    

00181a7e <init_cache>:
static int init_cache(struct device *unused)
{
	ARG_UNUSED(unused);

	init_cache_flush();
	init_cache_line_size();
  181a7e:	e8 f0 ff ff ff       	call   181a73 <init_cache_line_size>

	return 0;
}
  181a83:	b8 00 00 00 00       	mov    $0x0,%eax
  181a88:	c3                   	ret    

00181a89 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  181a89:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  181a8a:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  181a8d:	50                   	push   %eax
	pushl	%edx
  181a8e:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  181a8f:	57                   	push   %edi
	pushl	%esi
  181a90:	56                   	push   %esi
	pushl	%ebx
  181a91:	53                   	push   %ebx
	pushl	%ebp
  181a92:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  181a93:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  181a97:	50                   	push   %eax

	/* ESP is pointing to the ESF at this point */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %edx
  181a98:	8b 15 c8 01 28 00    	mov    0x2801c8,%edx

	/* inc exception nest count */
	incl	_thread_offset_to_excNestCount(%edx)
  181a9e:	ff 42 44             	incl   0x44(%edx)
     * the current execution context if this is the outermost exception.
     * The ESF pointer is used by debug tools to locate the volatile
     * registers and the stack of the preempted thread.
     */

	testb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  181aa1:	f6 42 09 40          	testb  $0x40,0x9(%edx)
	jne	alreadyInException
  181aa5:	75 03                	jne    181aaa <alreadyInException>
	movl	%esp, _thread_offset_to_esf(%edx)
  181aa7:	89 62 40             	mov    %esp,0x40(%edx)

00181aaa <alreadyInException>:
	 * (where needed) if the exception handler causes a context switch.
	 * It also indicates to debug tools that an exception is being
	 * handled in the event of a context switch.
	 */

	orb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  181aaa:	80 4a 09 40          	orb    $0x40,0x9(%edx)
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  181aae:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  181ab5:	00 
	je	allDone
  181ab6:	74 01                	je     181ab9 <allDone>
	sti
  181ab8:	fb                   	sti    

00181ab9 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
  181ab9:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
  181abb:	ff d1                	call   *%ecx
	addl	$0x4, %esp
#endif

#if defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %ecx
  181abd:	8b 0d c8 01 28 00    	mov    0x2801c8,%ecx
	 * Must lock interrupts to prevent outside interference.
	 * (Using "lock" prefix would be nicer, but this won't work
	 * on platforms that don't respect the CPU's bus lock signal.)
	 */

	cli
  181ac3:	fa                   	cli    

	/*
	 * Determine whether exiting from a nested interrupt.
	 */

	decl	_thread_offset_to_excNestCount(%ecx)
  181ac4:	ff 49 44             	decl   0x44(%ecx)

	cmpl	$0, _thread_offset_to_excNestCount(%ecx)
  181ac7:	83 79 44 00          	cmpl   $0x0,0x44(%ecx)
	jne	nestedException
  181acb:	75 04                	jne    181ad1 <nestedException>
	 * Clear the _EXC_ACTIVE bit in the k_thread of the current execution
	 * context if we are not in a nested exception (ie, when we exit the
	 * outermost exception).
	 */

	andb	$~_EXC_ACTIVE, _thread_offset_to_thread_state(%ecx)
  181acd:	80 61 09 bf          	andb   $0xbf,0x9(%ecx)

00181ad1 <nestedException>:
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  181ad1:	5d                   	pop    %ebp
	popl	%ebp
  181ad2:	5d                   	pop    %ebp
	popl	%ebx
  181ad3:	5b                   	pop    %ebx
	popl	%esi
  181ad4:	5e                   	pop    %esi
	popl	%edi
  181ad5:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  181ad6:	5a                   	pop    %edx
	popl	%eax
  181ad7:	58                   	pop    %eax
	popl	%ecx
  181ad8:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  181ad9:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181adc:	cf                   	iret   

00181add <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  181add:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  181ade:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  181ae2:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  181ae5:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  181ae6:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  181ae7:	b9 c0 01 28 00       	mov    $0x2801c0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  181aec:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  181aee:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  181af1:	75 06                	jne    181af9 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  181af3:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  181af5:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  181af8:	57                   	push   %edi

00181af9 <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  181af9:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  181afa:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  181afc:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
  181afd:	31 c0                	xor    %eax,%eax
  181aff:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  181b04:	b9 c0 01 28 00       	mov    $0x2801c0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  181b09:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  181b0b:	75 2b                	jne    181b38 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  181b0d:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
  181b10:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
  181b16:	73 1f                	jae    181b37 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  181b18:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
  181b1b:	74 1a                	je     181b37 <noReschedule>
	 * preserved using the lazy save/restore algorithm, or to indicate to
	 * debug tools that a preemptive context switch has occurred.
	 */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)
	orb	$_INT_ACTIVE, _thread_offset_to_thread_state(%edx)
  181b1d:	80 4a 09 80          	orb    $0x80,0x9(%edx)
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  181b21:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  181b22:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
  181b23:	58                   	pop    %eax
#endif
	call	_Swap
  181b24:	e8 30 00 00 00       	call   181b59 <_Swap>
	 * _Swap() has restored the floating point registers, if needed.
	 * Clear the _INT_ACTIVE bit in the interrupted thread's state
	 * since it has served its purpose.
	 */

	movl	_kernel + _kernel_offset_to_current, %eax
  181b29:	a1 c8 01 28 00       	mov    0x2801c8,%eax
	andb	$~_INT_ACTIVE, _thread_offset_to_thread_state(%eax)
  181b2e:	80 60 09 7f          	andb   $0x7f,0x9(%eax)

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  181b32:	5f                   	pop    %edi
	popl	%ecx
  181b33:	59                   	pop    %ecx
	popl	%edx
  181b34:	5a                   	pop    %edx
	popl	%eax
  181b35:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181b36:	cf                   	iret   

00181b37 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  181b37:	5c                   	pop    %esp

00181b38 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  181b38:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  181b39:	59                   	pop    %ecx
	popl	%edx
  181b3a:	5a                   	pop    %edx
	popl	%eax
  181b3b:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181b3c:	cf                   	iret   

00181b3d <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  181b3d:	6a 00                	push   $0x0

00181b3f <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  181b3f:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  181b40:	50                   	push   %eax
	pushl %ecx
  181b41:	51                   	push   %ecx
	pushl %edx
  181b42:	52                   	push   %edx
	pushl %edi
  181b43:	57                   	push   %edi
	pushl %esi
  181b44:	56                   	push   %esi
	pushl %ebx
  181b45:	53                   	push   %ebx
	pushl %ebp
  181b46:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  181b47:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  181b4b:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
  181b4c:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
  181b4e:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
  181b4f:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  181b54:	e8 d5 00 00 00       	call   181c2e <_NanoFatalErrorHandler>

00181b59 <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
  181b59:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
  181b5c:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  181b60:	57                   	push   %edi

	movl	$_kernel, %edi
  181b61:	bf c0 01 28 00       	mov    $0x2801c0,%edi

	pushl	%esi
  181b66:	56                   	push   %esi
	pushl	%ebx
  181b67:	53                   	push   %ebx
	pushl	%ebp
  181b68:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
  181b69:	ff 35 64 34 18 00    	pushl  0x183464


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  181b6f:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  181b72:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  181b75:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  181b78:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  181b7b:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
  181b7e:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  181b7f:	5d                   	pop    %ebp
	popl	%ebx
  181b80:	5b                   	pop    %ebx
	popl	%esi
  181b81:	5e                   	pop    %esi
	popl	%edi
  181b82:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  181b83:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  181b87:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
  181b88:	5a                   	pop    %edx
	movl	%edx, (%esp)
  181b89:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
  181b8c:	c3                   	ret    

00181b8d <_new_thread_internal>:
 * @return N/A
 */
static void _new_thread_internal(char *pStackMem, unsigned stackSize,
				 int priority,
				 unsigned options)
{
  181b8d:	56                   	push   %esi
  181b8e:	53                   	push   %ebx
  181b8f:	89 c3                	mov    %eax,%ebx
  181b91:	89 d6                	mov    %edx,%esi
  181b93:	89 ca                	mov    %ecx,%edx
	unsigned long *pInitialCtx;
	/* ptr to the new task's k_thread */
	struct k_thread *thread = (struct k_thread *)pStackMem;

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
  181b95:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
  181b9c:	ff 74 24 0c          	pushl  0xc(%esp)
  181ba0:	b9 04 00 00 00       	mov    $0x4,%ecx
  181ba5:	e8 6b 0d 00 00       	call   182915 <_init_thread_base>
  181baa:	83 c4 04             	add    $0x4,%esp

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  181bad:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	thread->fn_abort = NULL;
  181bb4:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
	 * the base address of the stack which is past the initial stack frame.
	 * Therefore some of the calculations done in the other routines that
	 * initialize the stack frame need to be repeated.
	 */

	pInitialCtx = (unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  181bbb:	8d 14 33             	lea    (%ebx,%esi,1),%edx
  181bbe:	83 e2 fc             	and    $0xfffffffc,%edx
#ifdef CONFIG_THREAD_MONITOR
	/*
	 * In debug mode thread->entry give direct access to the thread entry
	 * and the corresponding parameters.
	 */
	thread->entry = (struct __thread_entry *)(pInitialCtx -
  181bc1:	8d 42 c0             	lea    -0x40(%edx),%eax
  181bc4:	89 43 34             	mov    %eax,0x34(%ebx)
	 *  - 4 thread entry routine parameters
	 *  - eflags
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;
  181bc7:	83 ea 2c             	sub    $0x2c,%edx

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  181bca:	89 53 28             	mov    %edx,0x28(%ebx)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  181bcd:	9c                   	pushf  
  181bce:	fa                   	cli    
  181bcf:	58                   	pop    %eax
static ALWAYS_INLINE void thread_monitor_init(struct k_thread *thread)
{
	unsigned int key;

	key = irq_lock();
	thread->next_thread = _kernel.threads;
  181bd0:	8b 15 dc 02 28 00    	mov    0x2802dc,%edx
  181bd6:	89 53 38             	mov    %edx,0x38(%ebx)
	_kernel.threads = thread;
  181bd9:	89 1d dc 02 28 00    	mov    %ebx,0x2802dc
  181bdf:	f6 c4 02             	test   $0x2,%ah
  181be2:	74 01                	je     181be5 <_new_thread_internal+0x58>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181be4:	fb                   	sti    
	PRINTK("\nInitial context ESP = 0x%x\n", thread->coopReg.esp);

	PRINTK("\nstruct thread * = 0x%x", thread);

	thread_monitor_init(thread);
}
  181be5:	5b                   	pop    %ebx
  181be6:	5e                   	pop    %esi
  181be7:	c3                   	ret    

00181be8 <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  181be8:	56                   	push   %esi
  181be9:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  181bea:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  181bed:	83 e3 fc             	and    $0xfffffffc,%ebx
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  181bf0:	8b 74 24 14          	mov    0x14(%esp),%esi
  181bf4:	89 73 fc             	mov    %esi,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  181bf7:	8b 74 24 10          	mov    0x10(%esp),%esi
  181bfb:	89 73 f8             	mov    %esi,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  181bfe:	8b 74 24 0c          	mov    0xc(%esp),%esi
  181c02:	89 73 f4             	mov    %esi,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  181c05:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  181c08:	9c                   	pushf  
  181c09:	59                   	pop    %ecx

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  181c0a:	80 e5 cd             	and    $0xcd,%ch
  181c0d:	80 cd 02             	or     $0x2,%ch
  181c10:	89 4b ec             	mov    %ecx,-0x14(%ebx)
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
  181c13:	c7 43 e8 60 00 18 00 	movl   $0x180060,-0x18(%ebx)
	/*
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
  181c1a:	ff 74 24 1c          	pushl  0x1c(%esp)
  181c1e:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  181c22:	e8 66 ff ff ff       	call   181b8d <_new_thread_internal>
  181c27:	83 c4 04             	add    $0x4,%esp
}
  181c2a:	5b                   	pop    %ebx
  181c2b:	5e                   	pop    %esi
  181c2c:	c3                   	ret    

00181c2d <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  181c2d:	c3                   	ret    

00181c2e <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  181c2e:	55                   	push   %ebp
  181c2f:	57                   	push   %edi
  181c30:	56                   	push   %esi
  181c31:	53                   	push   %ebx
  181c32:	83 ec 24             	sub    $0x24,%esp
  181c35:	89 c6                	mov    %eax,%esi
  181c37:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
  181c39:	89 d0                	mov    %edx,%eax
  181c3b:	e8 ed ff ff ff       	call   181c2d <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  181c40:	83 fe 03             	cmp    $0x3,%esi
  181c43:	74 4c                	je     181c91 <_NanoFatalErrorHandler+0x63>
  181c45:	83 fe 03             	cmp    $0x3,%esi
  181c48:	77 06                	ja     181c50 <_NanoFatalErrorHandler+0x22>
  181c4a:	85 f6                	test   %esi,%esi
  181c4c:	74 0e                	je     181c5c <_NanoFatalErrorHandler+0x2e>
  181c4e:	eb 5f                	jmp    181caf <_NanoFatalErrorHandler+0x81>
  181c50:	83 fe 05             	cmp    $0x5,%esi
  181c53:	74 4b                	je     181ca0 <_NanoFatalErrorHandler+0x72>
  181c55:	83 fe 06             	cmp    $0x6,%esi
  181c58:	74 63                	je     181cbd <_NanoFatalErrorHandler+0x8f>
  181c5a:	eb 53                	jmp    181caf <_NanoFatalErrorHandler+0x81>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  181c5c:	e8 f6 ea ff ff       	call   180757 <__irq_controller_isr_vector_get>
  181c61:	89 c3                	mov    %eax,%ebx
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  181c63:	68 b8 32 18 00       	push   $0x1832b8
  181c68:	e8 61 f6 ff ff       	call   1812ce <printk>
  181c6d:	83 c4 04             	add    $0x4,%esp
		if (vector >= 0) {
  181c70:	85 db                	test   %ebx,%ebx
  181c72:	78 0e                	js     181c82 <_NanoFatalErrorHandler+0x54>
			printk("%d ", vector);
  181c74:	53                   	push   %ebx
  181c75:	68 31 32 18 00       	push   $0x183231
  181c7a:	e8 4f f6 ff ff       	call   1812ce <printk>
  181c7f:	83 c4 08             	add    $0x8,%esp
		}
		printk("*****\n");
  181c82:	68 35 32 18 00       	push   $0x183235
  181c87:	e8 42 f6 ff ff       	call   1812ce <printk>
  181c8c:	83 c4 04             	add    $0x4,%esp
		break;
  181c8f:	eb 2c                	jmp    181cbd <_NanoFatalErrorHandler+0x8f>
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  181c91:	68 dc 32 18 00       	push   $0x1832dc
  181c96:	e8 33 f6 ff ff       	call   1812ce <printk>
  181c9b:	83 c4 04             	add    $0x4,%esp
		break;
  181c9e:	eb 1d                	jmp    181cbd <_NanoFatalErrorHandler+0x8f>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  181ca0:	68 08 33 18 00       	push   $0x183308
  181ca5:	e8 24 f6 ff ff       	call   1812ce <printk>
  181caa:	83 c4 04             	add    $0x4,%esp
		break;
  181cad:	eb 0e                	jmp    181cbd <_NanoFatalErrorHandler+0x8f>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  181caf:	56                   	push   %esi
  181cb0:	68 30 33 18 00       	push   $0x183330
  181cb5:	e8 14 f6 ff ff       	call   1812ce <printk>
  181cba:	83 c4 08             	add    $0x8,%esp
		break;
	}

	printk("Current thread ID = %p\n"
  181cbd:	8b 6f 2c             	mov    0x2c(%edi),%ebp
  181cc0:	8b 07                	mov    (%edi),%eax
  181cc2:	89 04 24             	mov    %eax,(%esp)
  181cc5:	8b 4f 04             	mov    0x4(%edi),%ecx
  181cc8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  181ccc:	8b 5f 10             	mov    0x10(%edi),%ebx
  181ccf:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  181cd3:	8b 57 0c             	mov    0xc(%edi),%edx
  181cd6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  181cda:	8b 47 14             	mov    0x14(%edi),%eax
  181cdd:	89 44 24 10          	mov    %eax,0x10(%esp)
  181ce1:	8b 4f 1c             	mov    0x1c(%edi),%ecx
  181ce4:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  181ce8:	8b 5f 08             	mov    0x8(%edi),%ebx
  181ceb:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  181cef:	8b 57 18             	mov    0x18(%edi),%edx
  181cf2:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  181cf6:	8b 47 24             	mov    0x24(%edi),%eax
  181cf9:	89 44 24 20          	mov    %eax,0x20(%esp)
	       "Faulting segment:address = 0x%x:0x%x\n"
	       "eax: 0x%x, ebx: 0x%x, ecx: 0x%x, edx: 0x%x\n"
	       "esi: 0x%x, edi: 0x%x, ebp: 0%x, esp: 0x%x\n"
	       "eflags: 0x%x\n",
	       k_current_get(),
	       pEsf->cs & 0xFFFF, pEsf->eip,
  181cfd:	8b 5f 28             	mov    0x28(%edi),%ebx
	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}

	printk("Current thread ID = %p\n"
  181d00:	e8 0d 06 00 00       	call   182312 <k_current_get>
  181d05:	55                   	push   %ebp
  181d06:	ff 74 24 04          	pushl  0x4(%esp)
  181d0a:	ff 74 24 0c          	pushl  0xc(%esp)
  181d0e:	ff 74 24 14          	pushl  0x14(%esp)
  181d12:	ff 74 24 1c          	pushl  0x1c(%esp)
  181d16:	ff 74 24 24          	pushl  0x24(%esp)
  181d1a:	ff 74 24 2c          	pushl  0x2c(%esp)
  181d1e:	ff 74 24 34          	pushl  0x34(%esp)
  181d22:	ff 74 24 3c          	pushl  0x3c(%esp)
  181d26:	ff 74 24 44          	pushl  0x44(%esp)
  181d2a:	0f b7 d3             	movzwl %bx,%edx
  181d2d:	52                   	push   %edx
  181d2e:	50                   	push   %eax
  181d2f:	68 54 33 18 00       	push   $0x183354
  181d34:	e8 95 f5 ff ff       	call   1812ce <printk>
  181d39:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  181d3c:	89 fa                	mov    %edi,%edx
  181d3e:	89 f0                	mov    %esi,%eax
  181d40:	e8 c6 fc ff ff       	call   181a0b <_SysFatalErrorHandler>

00181d45 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  181d45:	56                   	push   %esi
  181d46:	53                   	push   %ebx
  181d47:	89 c3                	mov    %eax,%ebx
  181d49:	89 d6                	mov    %edx,%esi
	printk("***** CPU exception %d\n", vector);
  181d4b:	50                   	push   %eax
  181d4c:	68 3c 32 18 00       	push   $0x18323c
  181d51:	e8 78 f5 ff ff       	call   1812ce <printk>
  181d56:	83 c4 08             	add    $0x8,%esp
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  181d59:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  181d5e:	88 d9                	mov    %bl,%cl
  181d60:	d3 f8                	sar    %cl,%eax
  181d62:	a8 01                	test   $0x1,%al
  181d64:	74 10                	je     181d76 <generic_exc_handle+0x31>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  181d66:	ff 76 20             	pushl  0x20(%esi)
  181d69:	68 54 32 18 00       	push   $0x183254
  181d6e:	e8 5b f5 ff ff       	call   1812ce <printk>
  181d73:	83 c4 08             	add    $0x8,%esp
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  181d76:	89 f2                	mov    %esi,%edx
  181d78:	b8 06 00 00 00       	mov    $0x6,%eax
  181d7d:	e8 ac fe ff ff       	call   181c2e <_NanoFatalErrorHandler>

00181d82 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  181d82:	89 c2                	mov    %eax,%edx
  181d84:	b8 00 00 00 00       	mov    $0x0,%eax
  181d89:	e8 b7 ff ff ff       	call   181d45 <generic_exc_handle>

00181d8e <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  181d8e:	89 c2                	mov    %eax,%edx
  181d90:	b8 02 00 00 00       	mov    $0x2,%eax
  181d95:	e8 ab ff ff ff       	call   181d45 <generic_exc_handle>

00181d9a <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  181d9a:	89 c2                	mov    %eax,%edx
  181d9c:	b8 04 00 00 00       	mov    $0x4,%eax
  181da1:	e8 9f ff ff ff       	call   181d45 <generic_exc_handle>

00181da6 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  181da6:	89 c2                	mov    %eax,%edx
  181da8:	b8 05 00 00 00       	mov    $0x5,%eax
  181dad:	e8 93 ff ff ff       	call   181d45 <generic_exc_handle>

00181db2 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  181db2:	89 c2                	mov    %eax,%edx
  181db4:	b8 06 00 00 00       	mov    $0x6,%eax
  181db9:	e8 87 ff ff ff       	call   181d45 <generic_exc_handle>

00181dbe <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  181dbe:	89 c2                	mov    %eax,%edx
  181dc0:	b8 07 00 00 00       	mov    $0x7,%eax
  181dc5:	e8 7b ff ff ff       	call   181d45 <generic_exc_handle>

00181dca <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  181dca:	89 c2                	mov    %eax,%edx
  181dcc:	b8 08 00 00 00       	mov    $0x8,%eax
  181dd1:	e8 6f ff ff ff       	call   181d45 <generic_exc_handle>

00181dd6 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  181dd6:	89 c2                	mov    %eax,%edx
  181dd8:	b8 0a 00 00 00       	mov    $0xa,%eax
  181ddd:	e8 63 ff ff ff       	call   181d45 <generic_exc_handle>

00181de2 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  181de2:	89 c2                	mov    %eax,%edx
  181de4:	b8 0b 00 00 00       	mov    $0xb,%eax
  181de9:	e8 57 ff ff ff       	call   181d45 <generic_exc_handle>

00181dee <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  181dee:	89 c2                	mov    %eax,%edx
  181df0:	b8 0c 00 00 00       	mov    $0xc,%eax
  181df5:	e8 4b ff ff ff       	call   181d45 <generic_exc_handle>

00181dfa <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  181dfa:	89 c2                	mov    %eax,%edx
  181dfc:	b8 0d 00 00 00       	mov    $0xd,%eax
  181e01:	e8 3f ff ff ff       	call   181d45 <generic_exc_handle>

00181e06 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  181e06:	89 c2                	mov    %eax,%edx
  181e08:	b8 0e 00 00 00       	mov    $0xe,%eax
  181e0d:	e8 33 ff ff ff       	call   181d45 <generic_exc_handle>

00181e12 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  181e12:	89 c2                	mov    %eax,%edx
  181e14:	b8 10 00 00 00       	mov    $0x10,%eax
  181e19:	e8 27 ff ff ff       	call   181d45 <generic_exc_handle>

00181e1e <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  181e1e:	89 c2                	mov    %eax,%edx
  181e20:	b8 11 00 00 00       	mov    $0x11,%eax
  181e25:	e8 1b ff ff ff       	call   181d45 <generic_exc_handle>

00181e2a <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  181e2a:	89 c2                	mov    %eax,%edx
  181e2c:	b8 12 00 00 00       	mov    $0x12,%eax
  181e31:	e8 0f ff ff ff       	call   181d45 <generic_exc_handle>

00181e36 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  181e36:	56                   	push   %esi
  181e37:	53                   	push   %ebx
  181e38:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  181e3a:	8b 1c 85 40 34 18 00 	mov    0x183440(,%eax,4),%ebx
  181e41:	eb 0a                	jmp    181e4d <_sys_device_do_config_level+0x17>
		struct device_config *device = info->config;
  181e43:	8b 13                	mov    (%ebx),%edx

		device->init(info);
  181e45:	89 d8                	mov    %ebx,%eax
  181e47:	ff 52 04             	call   *0x4(%edx)
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  181e4a:	83 c3 0c             	add    $0xc,%ebx
  181e4d:	3b 1c b5 44 34 18 00 	cmp    0x183444(,%esi,4),%ebx
  181e54:	72 ed                	jb     181e43 <_sys_device_do_config_level+0xd>
		struct device_config *device = info->config;

		device->init(info);
	}
}
  181e56:	5b                   	pop    %ebx
  181e57:	5e                   	pop    %esi
  181e58:	c3                   	ret    

00181e59 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  181e59:	56                   	push   %esi
  181e5a:	53                   	push   %ebx
  181e5b:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  181e5d:	bb 38 00 28 00       	mov    $0x280038,%ebx
  181e62:	eb 18                	jmp    181e7c <device_get_binding+0x23>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  181e64:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  181e68:	74 0f                	je     181e79 <device_get_binding+0x20>
  181e6a:	8b 03                	mov    (%ebx),%eax
  181e6c:	8b 10                	mov    (%eax),%edx
  181e6e:	89 f0                	mov    %esi,%eax
  181e70:	e8 f8 f0 ff ff       	call   180f6d <strcmp>
  181e75:	85 c0                	test   %eax,%eax
  181e77:	74 12                	je     181e8b <device_get_binding+0x32>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  181e79:	83 c3 0c             	add    $0xc,%ebx
  181e7c:	81 fb bc 00 28 00    	cmp    $0x2800bc,%ebx
  181e82:	75 e0                	jne    181e64 <device_get_binding+0xb>
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
  181e84:	b8 00 00 00 00       	mov    $0x0,%eax
  181e89:	eb 02                	jmp    181e8d <device_get_binding+0x34>
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
  181e8b:	89 d8                	mov    %ebx,%eax
		}
	}

	return NULL;
}
  181e8d:	5b                   	pop    %ebx
  181e8e:	5e                   	pop    %esi
  181e8f:	c3                   	ret    

00181e90 <prepare_multithreading>:
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  181e90:	a3 c8 01 28 00       	mov    %eax,0x2801c8

	dummy_thread->base.user_options = K_ESSENTIAL;
  181e95:	c6 40 08 01          	movb   $0x1,0x8(%eax)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  181e99:	b8 00 00 00 00       	mov    $0x0,%eax
  181e9e:	eb 1a                	jmp    181eba <prepare_multithreading+0x2a>
		sys_dlist_init(&_ready_q.q[ii]);
  181ea0:	8d 50 01             	lea    0x1(%eax),%edx
  181ea3:	8d 0c d5 d4 01 28 00 	lea    0x2801d4(,%edx,8),%ecx
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  181eaa:	89 0c d5 d4 01 28 00 	mov    %ecx,0x2801d4(,%edx,8)
	list->tail = (sys_dnode_t *)list;
  181eb1:	89 0c c5 e0 01 28 00 	mov    %ecx,0x2801e0(,%eax,8)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  181eb8:	89 d0                	mov    %edx,%eax
  181eba:	83 f8 1f             	cmp    $0x1f,%eax
  181ebd:	7e e1                	jle    181ea0 <prepare_multithreading+0x10>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
  181ebf:	c7 05 d4 01 28 00 08 	movl   $0x280508,0x2801d4
  181ec6:	05 28 00 

	_new_thread(_main_stack, MAIN_STACK_SIZE,
  181ec9:	6a 01                	push   $0x1
  181ecb:	6a 00                	push   $0x0
  181ecd:	6a 00                	push   $0x0
  181ecf:	6a 00                	push   $0x0
  181ed1:	6a 00                	push   $0x0
  181ed3:	b9 7f 1f 18 00       	mov    $0x181f7f,%ecx
  181ed8:	ba 00 02 00 00       	mov    $0x200,%edx
  181edd:	b8 08 05 28 00       	mov    $0x280508,%eax
  181ee2:	e8 01 fd ff ff       	call   181be8 <_new_thread>
  181ee7:	83 c4 14             	add    $0x14,%esp
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  181eea:	a0 11 05 28 00       	mov    0x280511,%al
  181eef:	83 e0 fb             	and    $0xfffffffb,%eax
  181ef2:	a2 11 05 28 00       	mov    %al,0x280511
		    _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
  181ef7:	b8 08 05 28 00       	mov    $0x280508,%eax
  181efc:	e8 3b 01 00 00       	call   18203c <_add_thread_to_ready_q>

#ifdef CONFIG_MULTITHREADING
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  181f01:	6a 01                	push   $0x1
  181f03:	6a 0f                	push   $0xf
  181f05:	6a 00                	push   $0x0
  181f07:	6a 00                	push   $0x0
  181f09:	6a 00                	push   $0x0
  181f0b:	b9 10 2d 18 00       	mov    $0x182d10,%ecx
  181f10:	ba 00 01 00 00       	mov    $0x100,%edx
  181f15:	b8 08 04 28 00       	mov    $0x280408,%eax
  181f1a:	e8 c9 fc ff ff       	call   181be8 <_new_thread>
  181f1f:	83 c4 14             	add    $0x14,%esp
  181f22:	a0 11 04 28 00       	mov    0x280411,%al
  181f27:	83 e0 fb             	and    $0xfffffffb,%eax
  181f2a:	a2 11 04 28 00       	mov    %al,0x280411
		    idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
  181f2f:	b8 08 04 28 00       	mov    $0x280408,%eax
  181f34:	e8 03 01 00 00       	call   18203c <_add_thread_to_ready_q>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  181f39:	c7 05 cc 01 28 00 cc 	movl   $0x2801cc,0x2801cc
  181f40:	01 28 00 
	list->tail = (sys_dnode_t *)list;
  181f43:	c7 05 d0 01 28 00 cc 	movl   $0x2801cc,0x2801d0
  181f4a:	01 28 00 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
  181f4d:	c7 05 c0 01 28 00 00 	movl   $0x0,0x2801c0
  181f54:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  181f57:	c7 05 c4 01 28 00 08 	movl   $0x280408,0x2801c4
  181f5e:	04 28 00 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  181f61:	c7 05 f0 02 28 00 00 	movl   $0x200,0x2802f0
  181f68:	02 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
  181f6b:	c7 05 e8 02 28 00 89 	movl   $0x181a89,0x2802e8
  181f72:	1a 18 00 
  181f75:	c3                   	ret    

00181f76 <switch_to_main_thread>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  181f76:	9c                   	pushf  
  181f77:	fa                   	cli    
  181f78:	58                   	pop    %eax
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */

	_Swap(irq_lock());
  181f79:	e8 db fb ff ff       	call   181b59 <_Swap>
  181f7e:	c3                   	ret    

00181f7f <_main>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  181f7f:	b8 02 00 00 00       	mov    $0x2,%eax
  181f84:	e8 ad fe ff ff       	call   181e36 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  181f89:	b8 05 00 00 00       	mov    $0x5,%eax
  181f8e:	e8 a3 fe ff ff       	call   181e36 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  181f93:	b8 06 00 00 00       	mov    $0x6,%eax
  181f98:	e8 99 fe ff ff       	call   181e36 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  181f9d:	b8 07 00 00 00       	mov    $0x7,%eax
  181fa2:	e8 8f fe ff ff       	call   181e36 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  181fa7:	b8 03 00 00 00       	mov    $0x3,%eax
  181fac:	e8 85 fe ff ff       	call   181e36 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  181fb1:	e8 d6 08 00 00       	call   18288c <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  181fb6:	e8 23 e2 ff ff       	call   1801de <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
  181fbb:	a0 10 05 28 00       	mov    0x280510,%al
  181fc0:	83 e0 fe             	and    $0xfffffffe,%eax
  181fc3:	a2 10 05 28 00       	mov    %al,0x280510
  181fc8:	c3                   	ret    

00181fc9 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  181fc9:	83 ec 48             	sub    $0x48,%esp
	 * Initialize kernel data structures. This step includes
	 * initializing the interrupt subsystem, which must be performed
	 * before the hardware initialization phase.
	 */

	prepare_multithreading(dummy_thread);
  181fcc:	89 e0                	mov    %esp,%eax
  181fce:	e8 bd fe ff ff       	call   181e90 <prepare_multithreading>

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  181fd3:	b8 04 00 00 00       	mov    $0x4,%eax
  181fd8:	e8 59 fe ff ff       	call   181e36 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  181fdd:	b8 00 00 00 00       	mov    $0x0,%eax
  181fe2:	e8 4f fe ff ff       	call   181e36 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  181fe7:	b8 01 00 00 00       	mov    $0x1,%eax
  181fec:	e8 45 fe ff ff       	call   181e36 <_sys_device_do_config_level>

	/* display boot banner */

	PRINT_BOOT_BANNER();

	switch_to_main_thread();
  181ff1:	e8 80 ff ff ff       	call   181f76 <switch_to_main_thread>

00181ff6 <_set_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  181ff6:	8d 48 10             	lea    0x10(%eax),%ecx
  181ff9:	89 ca                	mov    %ecx,%edx
  181ffb:	c1 fa 05             	sar    $0x5,%edx
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  181ffe:	b8 01 00 00 00       	mov    $0x1,%eax
  182003:	d3 e0                	shl    %cl,%eax
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  182005:	09 04 95 d8 01 28 00 	or     %eax,0x2801d8(,%edx,4)
  18200c:	c3                   	ret    

0018200d <_clear_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  18200d:	8d 48 10             	lea    0x10(%eax),%ecx
  182010:	89 c8                	mov    %ecx,%eax
  182012:	c1 f8 05             	sar    $0x5,%eax
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  182015:	ba 01 00 00 00       	mov    $0x1,%edx
  18201a:	d3 e2                	shl    %cl,%edx
static void _clear_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap &= ~_get_ready_q_prio_bit(prio);
  18201c:	f7 d2                	not    %edx
  18201e:	21 14 85 d8 01 28 00 	and    %edx,0x2801d8(,%eax,4)
  182025:	c3                   	ret    

00182026 <_get_ready_q_head>:

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  182026:	0f bc 05 d8 01 28 00 	bsf    0x2801d8,%eax
  18202d:	75 05                	jne    182034 <_get_ready_q_head+0xe>
  18202f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 * @return a pointer to the head element
 */

static inline sys_dnode_t *sys_dlist_peek_head_not_empty(sys_dlist_t *list)
{
	return list->head;
  182034:	8b 04 c5 dc 01 28 00 	mov    0x2801dc(,%eax,8),%eax

	struct k_thread *thread =
		(struct k_thread *)sys_dlist_peek_head_not_empty(list);

	return thread;
}
  18203b:	c3                   	ret    

0018203c <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  18203c:	57                   	push   %edi
  18203d:	56                   	push   %esi
  18203e:	53                   	push   %ebx
  18203f:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  182041:	0f be 58 0a          	movsbl 0xa(%eax),%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
  182045:	8d 3c dd 5c 02 28 00 	lea    0x28025c(,%ebx,8),%edi

	_set_ready_q_prio_bit(thread->base.prio);
  18204c:	89 d8                	mov    %ebx,%eax
  18204e:	e8 a3 ff ff ff       	call   181ff6 <_set_ready_q_prio_bit>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182053:	89 3e                	mov    %edi,(%esi)
	node->prev = list->tail;
  182055:	83 c3 14             	add    $0x14,%ebx
  182058:	8b 04 dd c0 01 28 00 	mov    0x2801c0(,%ebx,8),%eax
  18205f:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  182062:	8b 04 dd c0 01 28 00 	mov    0x2801c0(,%ebx,8),%eax
  182069:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  18206b:	89 34 dd c0 01 28 00 	mov    %esi,0x2801c0(,%ebx,8)
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
  182072:	a1 d4 01 28 00       	mov    0x2801d4,%eax
  182077:	8a 50 0a             	mov    0xa(%eax),%dl
  18207a:	38 56 0a             	cmp    %dl,0xa(%esi)
  18207d:	7d 02                	jge    182081 <_add_thread_to_ready_q+0x45>
  18207f:	89 f0                	mov    %esi,%eax
  182081:	a3 d4 01 28 00       	mov    %eax,0x2801d4
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
  182086:	5b                   	pop    %ebx
  182087:	5e                   	pop    %esi
  182088:	5f                   	pop    %edi
  182089:	c3                   	ret    

0018208a <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  18208a:	56                   	push   %esi
  18208b:	53                   	push   %ebx
  18208c:	89 c3                	mov    %eax,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  18208e:	0f be 40 0a          	movsbl 0xa(%eax),%eax
	sys_dlist_t *q = &_ready_q.q[q_index];
  182092:	83 c0 11             	add    $0x11,%eax
  182095:	8d 14 c5 d4 01 28 00 	lea    0x2801d4(,%eax,8),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18209c:	8b 4b 04             	mov    0x4(%ebx),%ecx
  18209f:	8b 33                	mov    (%ebx),%esi
  1820a1:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  1820a3:	8b 0b                	mov    (%ebx),%ecx
  1820a5:	8b 73 04             	mov    0x4(%ebx),%esi
  1820a8:	89 71 04             	mov    %esi,0x4(%ecx)

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  1820ab:	3b 14 c5 d4 01 28 00 	cmp    0x2801d4(,%eax,8),%edx
  1820b2:	75 09                	jne    1820bd <_remove_thread_from_ready_q+0x33>
		_clear_ready_q_prio_bit(thread->base.prio);
  1820b4:	0f be 43 0a          	movsbl 0xa(%ebx),%eax
  1820b8:	e8 50 ff ff ff       	call   18200d <_clear_ready_q_prio_bit>
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  1820bd:	a1 d4 01 28 00       	mov    0x2801d4,%eax
  1820c2:	39 c3                	cmp    %eax,%ebx
  1820c4:	75 05                	jne    1820cb <_remove_thread_from_ready_q+0x41>
  1820c6:	e8 5b ff ff ff       	call   182026 <_get_ready_q_head>
  1820cb:	a3 d4 01 28 00       	mov    %eax,0x2801d4
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
  1820d0:	5b                   	pop    %ebx
  1820d1:	5e                   	pop    %esi
  1820d2:	c3                   	ret    

001820d3 <__must_switch_threads>:
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  1820d3:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  1820d8:	0f be 50 0a          	movsbl 0xa(%eax),%edx
  1820dc:	0f bc 05 d8 01 28 00 	bsf    0x2801d8,%eax
  1820e3:	75 05                	jne    1820ea <__must_switch_threads+0x17>
  1820e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	int abs_prio = (find_lsb_set(ready_range) - 1) + (bitmap << 5);

	__ASSERT(abs_prio < K_NUM_PRIORITIES, "prio out-of-range\n");

	return abs_prio - _NUM_COOP_PRIO;
  1820ea:	83 e8 10             	sub    $0x10,%eax
	return _is_prio1_higher_than_or_equal_to_prio2(prio1, prio2);
}

static inline int _is_prio1_higher_than_prio2(int prio1, int prio2)
{
	return prio1 < prio2;
  1820ed:	39 c2                	cmp    %eax,%edx
  1820ef:	0f 9f c0             	setg   %al
  1820f2:	0f b6 c0             	movzbl %al,%eax
#else
	return 0;
#endif
}
  1820f5:	c3                   	ret    

001820f6 <_reschedule_threads>:

/* reschedule threads if the scheduler is not locked */
/* not callable from ISR */
/* must be called with interrupts locked */
void _reschedule_threads(int key)
{
  1820f6:	53                   	push   %ebx
  1820f7:	89 c3                	mov    %eax,%ebx
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  1820f9:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  1820fe:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  182103:	77 10                	ja     182115 <_reschedule_threads+0x1f>
  182105:	e8 c9 ff ff ff       	call   1820d3 <__must_switch_threads>
  18210a:	85 c0                	test   %eax,%eax
  18210c:	74 0c                	je     18211a <_reschedule_threads+0x24>
  18210e:	b8 01 00 00 00       	mov    $0x1,%eax
  182113:	eb 05                	jmp    18211a <_reschedule_threads+0x24>
  182115:	b8 00 00 00 00       	mov    $0x0,%eax
#ifdef CONFIG_PREEMPT_ENABLED
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
  18211a:	85 c0                	test   %eax,%eax
  18211c:	74 09                	je     182127 <_reschedule_threads+0x31>
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  18211e:	89 d8                	mov    %ebx,%eax
  182120:	e8 34 fa ff ff       	call   181b59 <_Swap>
  182125:	eb 06                	jmp    18212d <_reschedule_threads+0x37>
  182127:	f6 c7 02             	test   $0x2,%bh
  18212a:	74 01                	je     18212d <_reschedule_threads+0x37>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18212c:	fb                   	sti    
		irq_unlock(key);
	}
#else
	irq_unlock(key);
#endif
}
  18212d:	5b                   	pop    %ebx
  18212e:	c3                   	ret    

0018212f <k_sched_unlock>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18212f:	9c                   	pushf  
  182130:	fa                   	cli    
  182131:	58                   	pop    %eax

	int key = irq_lock();

	/* compiler_barrier() not needed, comes from irq_lock() */

	++_current->base.sched_locked;
  182132:	8b 0d c8 01 28 00    	mov    0x2801c8,%ecx
  182138:	8a 51 0b             	mov    0xb(%ecx),%dl
  18213b:	42                   	inc    %edx
  18213c:	88 51 0b             	mov    %dl,0xb(%ecx)

	K_DEBUG("scheduler unlocked (%p:%d)\n",
		_current, _current->base.sched_locked);

	_reschedule_threads(key);
  18213f:	e8 b2 ff ff ff       	call   1820f6 <_reschedule_threads>
  182144:	c3                   	ret    

00182145 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  182145:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	sys_dlist_t *q = &_ready_q.q[q_index];

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  182149:	3b 04 cd 60 02 28 00 	cmp    0x280260(,%ecx,8),%eax
  182150:	74 53                	je     1821a5 <_move_thread_to_end_of_prio_q+0x60>
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  182152:	56                   	push   %esi
  182153:	53                   	push   %ebx
  182154:	8d 51 10             	lea    0x10(%ecx),%edx
  182157:	8d 1c cd 5c 02 28 00 	lea    0x28025c(,%ecx,8),%ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18215e:	8b 48 04             	mov    0x4(%eax),%ecx
  182161:	8b 30                	mov    (%eax),%esi
  182163:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  182165:	8b 08                	mov    (%eax),%ecx
  182167:	8b 70 04             	mov    0x4(%eax),%esi
  18216a:	89 71 04             	mov    %esi,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  18216d:	89 18                	mov    %ebx,(%eax)
	node->prev = list->tail;
  18216f:	83 c2 04             	add    $0x4,%edx
  182172:	8b 0c d5 c0 01 28 00 	mov    0x2801c0(,%edx,8),%ecx
  182179:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  18217c:	8b 0c d5 c0 01 28 00 	mov    0x2801c0(,%edx,8),%ecx
  182183:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  182185:	89 04 d5 c0 01 28 00 	mov    %eax,0x2801c0(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  18218c:	8b 15 d4 01 28 00    	mov    0x2801d4,%edx
  182192:	39 d0                	cmp    %edx,%eax
  182194:	75 07                	jne    18219d <_move_thread_to_end_of_prio_q+0x58>
  182196:	e8 8b fe ff ff       	call   182026 <_get_ready_q_head>
  18219b:	89 c2                	mov    %eax,%edx
  18219d:	89 15 d4 01 28 00    	mov    %edx,0x2801d4
#endif
}
  1821a3:	5b                   	pop    %ebx
  1821a4:	5e                   	pop    %esi
  1821a5:	c3                   	ret    

001821a6 <k_yield>:

void k_yield(void)
{
  1821a6:	53                   	push   %ebx
  1821a7:	9c                   	pushf  
  1821a8:	fa                   	cli    
  1821a9:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	int key = irq_lock();

	_move_thread_to_end_of_prio_q(_current);
  1821aa:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  1821af:	e8 91 ff ff ff       	call   182145 <_move_thread_to_end_of_prio_q>

	if (_current == _get_next_ready_thread()) {
  1821b4:	a1 d4 01 28 00       	mov    0x2801d4,%eax
  1821b9:	39 05 c8 01 28 00    	cmp    %eax,0x2801c8
  1821bf:	75 08                	jne    1821c9 <k_yield+0x23>
  1821c1:	f6 c7 02             	test   $0x2,%bh
  1821c4:	74 0a                	je     1821d0 <k_yield+0x2a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1821c6:	fb                   	sti    
  1821c7:	eb 07                	jmp    1821d0 <k_yield+0x2a>
		irq_unlock(key);
	} else {
		_Swap(key);
  1821c9:	89 d8                	mov    %ebx,%eax
  1821cb:	e8 89 f9 ff ff       	call   181b59 <_Swap>
	}
}
  1821d0:	5b                   	pop    %ebx
  1821d1:	c3                   	ret    

001821d2 <k_sleep>:

void k_sleep(int32_t duration)
{
  1821d2:	57                   	push   %edi
  1821d3:	56                   	push   %esi
  1821d4:	53                   	push   %ebx
  1821d5:	83 ec 04             	sub    $0x4,%esp
	__ASSERT(duration != K_FOREVER, "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
  1821d8:	85 c0                	test   %eax,%eax
  1821da:	75 0a                	jne    1821e6 <k_sleep+0x14>
		k_yield();
  1821dc:	e8 c5 ff ff ff       	call   1821a6 <k_yield>
		return;
  1821e1:	e9 25 01 00 00       	jmp    18230b <k_sleep+0x139>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  1821e6:	83 c0 09             	add    $0x9,%eax
  1821e9:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  1821ee:	f7 e2                	mul    %edx
  1821f0:	c1 ea 03             	shr    $0x3,%edx
	}

	ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  1821f3:	42                   	inc    %edx
  1821f4:	89 14 24             	mov    %edx,(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1821f7:	9c                   	pushf  
  1821f8:	fa                   	cli    
  1821f9:	5b                   	pop    %ebx
	key = irq_lock();

	_remove_thread_from_ready_q(_current);
  1821fa:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  1821ff:	e8 86 fe ff ff       	call   18208a <_remove_thread_from_ready_q>
	_add_thread_timeout(_current, NULL, ticks);
  182204:	8b 04 24             	mov    (%esp),%eax
  182207:	8b 3d c8 01 28 00    	mov    0x2801c8,%edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  18220d:	8d 77 10             	lea    0x10(%edi),%esi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  182210:	89 46 10             	mov    %eax,0x10(%esi)
	timeout->thread = thread;
  182213:	89 7e 08             	mov    %edi,0x8(%esi)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  182216:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  18221d:	a1 cc 01 28 00       	mov    0x2801cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182222:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  182227:	75 07                	jne    182230 <k_sleep+0x5e>
  182229:	ba 00 00 00 00       	mov    $0x0,%edx
  18222e:	eb 02                	jmp    182232 <k_sleep+0x60>
  182230:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182232:	85 d2                	test   %edx,%edx
  182234:	74 15                	je     18224b <k_sleep+0x79>
  182236:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  18223b:	0f 85 9f 00 00 00    	jne    1822e0 <k_sleep+0x10e>
  182241:	b8 00 00 00 00       	mov    $0x0,%eax
  182246:	e9 95 00 00 00       	jmp    1822e0 <k_sleep+0x10e>
  18224b:	b8 00 00 00 00       	mov    $0x0,%eax
  182250:	e9 8b 00 00 00       	jmp    1822e0 <k_sleep+0x10e>
		if (*delta <= in_q->delta_ticks_from_prev) {
  182255:	8b 56 10             	mov    0x10(%esi),%edx
  182258:	8b 48 10             	mov    0x10(%eax),%ecx
  18225b:	39 ca                	cmp    %ecx,%edx
  18225d:	7f 3a                	jg     182299 <k_sleep+0xc7>
			in_q->delta_ticks_from_prev -= *delta;
  18225f:	29 d1                	sub    %edx,%ecx
  182261:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  182264:	85 c0                	test   %eax,%eax
  182266:	75 1e                	jne    182286 <k_sleep+0xb4>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182268:	c7 47 10 cc 01 28 00 	movl   $0x2801cc,0x10(%edi)
	node->prev = list->tail;
  18226f:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182274:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  182277:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  18227c:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  18227e:	89 35 d0 01 28 00    	mov    %esi,0x2801d0
  182284:	eb 7e                	jmp    182304 <k_sleep+0x132>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  182286:	8b 50 04             	mov    0x4(%eax),%edx
  182289:	89 56 04             	mov    %edx,0x4(%esi)
		node->next = insert_point;
  18228c:	89 47 10             	mov    %eax,0x10(%edi)
		insert_point->prev->next = node;
  18228f:	8b 50 04             	mov    0x4(%eax),%edx
  182292:	89 32                	mov    %esi,(%edx)
		insert_point->prev = node;
  182294:	89 70 04             	mov    %esi,0x4(%eax)
  182297:	eb 6b                	jmp    182304 <k_sleep+0x132>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  182299:	29 ca                	sub    %ecx,%edx
  18229b:	89 56 10             	mov    %edx,0x10(%esi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  18229e:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1822a0:	85 c0                	test   %eax,%eax
  1822a2:	74 0c                	je     1822b0 <k_sleep+0xde>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1822a4:	3b 05 d0 01 28 00    	cmp    0x2801d0,%eax
  1822aa:	74 08                	je     1822b4 <k_sleep+0xe2>
  1822ac:	8b 08                	mov    (%eax),%ecx
  1822ae:	eb 09                	jmp    1822b9 <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1822b0:	89 c1                	mov    %eax,%ecx
  1822b2:	eb 05                	jmp    1822b9 <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1822b4:	b9 00 00 00 00       	mov    $0x0,%ecx
  1822b9:	85 c9                	test   %ecx,%ecx
  1822bb:	74 1e                	je     1822db <k_sleep+0x109>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1822bd:	85 d2                	test   %edx,%edx
  1822bf:	74 0c                	je     1822cd <k_sleep+0xfb>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1822c1:	3b 15 d0 01 28 00    	cmp    0x2801d0,%edx
  1822c7:	74 0b                	je     1822d4 <k_sleep+0x102>
  1822c9:	8b 00                	mov    (%eax),%eax
  1822cb:	eb 13                	jmp    1822e0 <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1822cd:	b8 00 00 00 00       	mov    $0x0,%eax
  1822d2:	eb 0c                	jmp    1822e0 <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1822d4:	b8 00 00 00 00       	mov    $0x0,%eax
  1822d9:	eb 05                	jmp    1822e0 <k_sleep+0x10e>
  1822db:	b8 00 00 00 00       	mov    $0x0,%eax
  1822e0:	85 c0                	test   %eax,%eax
  1822e2:	0f 85 6d ff ff ff    	jne    182255 <k_sleep+0x83>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1822e8:	c7 47 10 cc 01 28 00 	movl   $0x2801cc,0x10(%edi)
	node->prev = list->tail;
  1822ef:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  1822f4:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  1822f7:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  1822fc:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  1822fe:	89 35 d0 01 28 00    	mov    %esi,0x2801d0

	_Swap(key);
  182304:	89 d8                	mov    %ebx,%eax
  182306:	e8 4e f8 ff ff       	call   181b59 <_Swap>
#endif
}
  18230b:	83 c4 04             	add    $0x4,%esp
  18230e:	5b                   	pop    %ebx
  18230f:	5e                   	pop    %esi
  182310:	5f                   	pop    %edi
  182311:	c3                   	ret    

00182312 <k_current_get>:
}

k_tid_t k_current_get(void)
{
	return _current;
}
  182312:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  182317:	c3                   	ret    

00182318 <handle_time_slicing>:
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
	if (_time_slice_duration == 0) {
  182318:	8b 15 e4 02 28 00    	mov    0x2802e4,%edx
  18231e:	85 d2                	test   %edx,%edx
  182320:	74 50                	je     182372 <handle_time_slicing+0x5a>
		return;
	}

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  182322:	8b 0d c8 01 28 00    	mov    0x2801c8,%ecx
  182328:	0f be 49 0a          	movsbl 0xa(%ecx),%ecx
  18232c:	39 0d e0 02 28 00    	cmp    %ecx,0x2802e0
  182332:	7f 3e                	jg     182372 <handle_time_slicing+0x5a>
 *   in this function and at thread level
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
  182334:	57                   	push   %edi
  182335:	56                   	push   %esi
  182336:	53                   	push   %ebx
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
  182337:	89 c1                	mov    %eax,%ecx
  182339:	89 c6                	mov    %eax,%esi
  18233b:	01 c6                	add    %eax,%esi
  18233d:	c1 e1 03             	shl    $0x3,%ecx
  182340:	01 f1                	add    %esi,%ecx

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
  182342:	03 0d f8 02 28 00    	add    0x2802f8,%ecx
  182348:	89 0d f8 02 28 00    	mov    %ecx,0x2802f8
	if (_time_slice_elapsed >= _time_slice_duration) {
  18234e:	39 ca                	cmp    %ecx,%edx
  182350:	7f 1d                	jg     18236f <handle_time_slicing+0x57>

		unsigned int key;

		_time_slice_elapsed = 0;
  182352:	c7 05 f8 02 28 00 00 	movl   $0x0,0x2802f8
  182359:	00 00 00 
  18235c:	9c                   	pushf  
  18235d:	fa                   	cli    
  18235e:	5b                   	pop    %ebx

		key = irq_lock();
		_move_thread_to_end_of_prio_q(_current);
  18235f:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  182364:	e8 dc fd ff ff       	call   182145 <_move_thread_to_end_of_prio_q>
  182369:	f6 c7 02             	test   $0x2,%bh
  18236c:	74 01                	je     18236f <handle_time_slicing+0x57>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18236e:	fb                   	sti    
		irq_unlock(key);
	}
}
  18236f:	5b                   	pop    %ebx
  182370:	5e                   	pop    %esi
  182371:	5f                   	pop    %edi
  182372:	c3                   	ret    

00182373 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  182373:	57                   	push   %edi
  182374:	56                   	push   %esi
  182375:	53                   	push   %ebx
  182376:	83 ec 08             	sub    $0x8,%esp
  182379:	89 c6                	mov    %eax,%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18237b:	9c                   	pushf  
  18237c:	fa                   	cli    
  18237d:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
  18237e:	89 f3                	mov    %esi,%ebx
  182380:	c1 fb 1f             	sar    $0x1f,%ebx
  182383:	01 35 fc 02 28 00    	add    %esi,0x2802fc
  182389:	11 1d 00 03 28 00    	adc    %ebx,0x280300
  18238f:	f6 c4 02             	test   $0x2,%ah
  182392:	74 01                	je     182395 <_nano_sys_clock_tick_announce+0x22>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182394:	fb                   	sti    
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  182395:	89 24 24             	mov    %esp,(%esp)
	list->tail = (sys_dnode_t *)list;
  182398:	89 64 24 04          	mov    %esp,0x4(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18239c:	9c                   	pushf  
  18239d:	fa                   	cli    
  18239e:	59                   	pop    %ecx
  18239f:	89 ca                	mov    %ecx,%edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1823a1:	a1 cc 01 28 00       	mov    0x2801cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1823a6:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  1823ab:	75 05                	jne    1823b2 <_nano_sys_clock_tick_announce+0x3f>
  1823ad:	b8 00 00 00 00       	mov    $0x0,%eax
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (!head) {
  1823b2:	85 c0                	test   %eax,%eax
  1823b4:	75 0f                	jne    1823c5 <_nano_sys_clock_tick_announce+0x52>
  1823b6:	f6 c5 02             	test   $0x2,%ch
  1823b9:	0f 84 52 01 00 00    	je     182511 <_nano_sys_clock_tick_announce+0x19e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1823bf:	fb                   	sti    
  1823c0:	e9 4c 01 00 00       	jmp    182511 <_nano_sys_clock_tick_announce+0x19e>
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
  1823c5:	29 70 10             	sub    %esi,0x10(%eax)
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
  1823c8:	c7 05 f4 02 28 00 01 	movl   $0x1,0x2802f4
  1823cf:	00 00 00 
  1823d2:	eb 41                	jmp    182415 <_nano_sys_clock_tick_announce+0xa2>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1823d4:	8b 48 04             	mov    0x4(%eax),%ecx
  1823d7:	8b 18                	mov    (%eax),%ebx
  1823d9:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  1823db:	8b 08                	mov    (%eax),%ecx
  1823dd:	8b 58 04             	mov    0x4(%eax),%ebx
  1823e0:	89 59 04             	mov    %ebx,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
  1823e3:	8b 0c 24             	mov    (%esp),%ecx
  1823e6:	89 08                	mov    %ecx,(%eax)
	node->prev = list;
  1823e8:	89 60 04             	mov    %esp,0x4(%eax)

	list->head->prev = node;
  1823eb:	8b 0c 24             	mov    (%esp),%ecx
  1823ee:	89 41 04             	mov    %eax,0x4(%ecx)
	list->head = node;
  1823f1:	89 04 24             	mov    %eax,(%esp)
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
  1823f4:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
  1823fb:	f6 c6 02             	test   $0x2,%dh
  1823fe:	74 01                	je     182401 <_nano_sys_clock_tick_announce+0x8e>
  182400:	fb                   	sti    

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182401:	9c                   	pushf  
  182402:	fa                   	cli    
  182403:	5a                   	pop    %edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182404:	a1 cc 01 28 00       	mov    0x2801cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182409:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  18240e:	75 05                	jne    182415 <_nano_sys_clock_tick_announce+0xa2>
  182410:	b8 00 00 00 00       	mov    $0x0,%eax
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
  182415:	85 c0                	test   %eax,%eax
  182417:	74 06                	je     18241f <_nano_sys_clock_tick_announce+0xac>
  182419:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  18241d:	74 b5                	je     1823d4 <_nano_sys_clock_tick_announce+0x61>
  18241f:	f6 c6 02             	test   $0x2,%dh
  182422:	74 01                	je     182425 <_nano_sys_clock_tick_announce+0xb2>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182424:	fb                   	sti    
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182425:	8b 14 24             	mov    (%esp),%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182428:	39 e2                	cmp    %esp,%edx
  18242a:	75 05                	jne    182431 <_nano_sys_clock_tick_announce+0xbe>
  18242c:	ba 00 00 00 00       	mov    $0x0,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182431:	85 d2                	test   %edx,%edx
  182433:	74 0d                	je     182442 <_nano_sys_clock_tick_announce+0xcf>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182435:	3b 54 24 04          	cmp    0x4(%esp),%edx
  182439:	74 0e                	je     182449 <_nano_sys_clock_tick_announce+0xd6>
  18243b:	8b 1a                	mov    (%edx),%ebx
  18243d:	e9 bd 00 00 00       	jmp    1824ff <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182442:	89 d3                	mov    %edx,%ebx
  182444:	e9 b6 00 00 00       	jmp    1824ff <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182449:	bb 00 00 00 00       	mov    $0x0,%ebx
  18244e:	e9 ac 00 00 00       	jmp    1824ff <_nano_sys_clock_tick_announce+0x18c>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182453:	8b 42 04             	mov    0x4(%edx),%eax
  182456:	8b 0a                	mov    (%edx),%ecx
  182458:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  18245a:	8b 02                	mov    (%edx),%eax
  18245c:	8b 4a 04             	mov    0x4(%edx),%ecx
  18245f:	89 48 04             	mov    %ecx,0x4(%eax)
 * kept as -EAGAIN, set previously in _Swap().
 */

static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
  182462:	8b 42 08             	mov    0x8(%edx),%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182465:	9c                   	pushf  
  182466:	fa                   	cli    
  182467:	5f                   	pop    %edi
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
  182468:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	K_DEBUG("timeout %p\n", timeout);
	if (thread) {
  18246f:	85 c0                	test   %eax,%eax
  182471:	74 5d                	je     1824d0 <_nano_sys_clock_tick_announce+0x15d>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
  182473:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  182477:	74 1a                	je     182493 <_nano_sys_clock_tick_announce+0x120>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182479:	8b 50 04             	mov    0x4(%eax),%edx
  18247c:	8b 08                	mov    (%eax),%ecx
  18247e:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  182480:	8b 10                	mov    (%eax),%edx
  182482:	8b 48 04             	mov    0x4(%eax),%ecx
  182485:	89 4a 04             	mov    %ecx,0x4(%edx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  182488:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
  18248c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182493:	8a 50 09             	mov    0x9(%eax),%dl
  182496:	88 d1                	mov    %dl,%cl
  182498:	83 e1 fb             	and    $0xfffffffb,%ecx
  18249b:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  18249e:	f6 c2 1b             	test   $0x1b,%dl
  1824a1:	75 0d                	jne    1824b0 <_nano_sys_clock_tick_announce+0x13d>
  1824a3:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1824a7:	75 0e                	jne    1824b7 <_nano_sys_clock_tick_announce+0x144>
  1824a9:	ba 01 00 00 00       	mov    $0x1,%edx
  1824ae:	eb 0c                	jmp    1824bc <_nano_sys_clock_tick_announce+0x149>
  1824b0:	ba 00 00 00 00       	mov    $0x0,%edx
  1824b5:	eb 05                	jmp    1824bc <_nano_sys_clock_tick_announce+0x149>
  1824b7:	ba 00 00 00 00       	mov    $0x0,%edx
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  1824bc:	85 d2                	test   %edx,%edx
  1824be:	74 05                	je     1824c5 <_nano_sys_clock_tick_announce+0x152>
		_add_thread_to_ready_q(thread);
  1824c0:	e8 77 fb ff ff       	call   18203c <_add_thread_to_ready_q>
  1824c5:	f7 c7 00 02 00 00    	test   $0x200,%edi
  1824cb:	74 17                	je     1824e4 <_nano_sys_clock_tick_announce+0x171>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1824cd:	fb                   	sti    
  1824ce:	eb 14                	jmp    1824e4 <_nano_sys_clock_tick_announce+0x171>
  1824d0:	f7 c7 00 02 00 00    	test   $0x200,%edi
  1824d6:	74 01                	je     1824d9 <_nano_sys_clock_tick_announce+0x166>
  1824d8:	fb                   	sti    
		_unpend_thread_timing_out(thread, timeout);
		_ready_thread(thread);
		irq_unlock(key);
	} else {
		irq_unlock(key);
		if (timeout->func) {
  1824d9:	8b 4a 14             	mov    0x14(%edx),%ecx
  1824dc:	85 c9                	test   %ecx,%ecx
  1824de:	74 04                	je     1824e4 <_nano_sys_clock_tick_announce+0x171>
			timeout->func(timeout);
  1824e0:	89 d0                	mov    %edx,%eax
  1824e2:	ff d1                	call   *%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1824e4:	85 db                	test   %ebx,%ebx
  1824e6:	74 0a                	je     1824f2 <_nano_sys_clock_tick_announce+0x17f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1824e8:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
  1824ec:	74 08                	je     1824f6 <_nano_sys_clock_tick_announce+0x183>
  1824ee:	8b 03                	mov    (%ebx),%eax
  1824f0:	eb 09                	jmp    1824fb <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1824f2:	89 d8                	mov    %ebx,%eax
  1824f4:	eb 05                	jmp    1824fb <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1824f6:	b8 00 00 00 00       	mov    $0x0,%eax

static inline void _handle_expired_timeouts(sys_dlist_t *expired)
{
	sys_dnode_t *timeout, *next;

	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
  1824fb:	89 da                	mov    %ebx,%edx
  1824fd:	89 c3                	mov    %eax,%ebx
  1824ff:	85 d2                	test   %edx,%edx
  182501:	0f 85 4c ff ff ff    	jne    182453 <_nano_sys_clock_tick_announce+0xe0>

	irq_unlock(key);

	_handle_expired_timeouts(&expired);

	_handling_timeouts = 0;
  182507:	c7 05 f4 02 28 00 00 	movl   $0x0,0x2802f4
  18250e:	00 00 00 
	irq_unlock(key);

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
  182511:	89 f0                	mov    %esi,%eax
  182513:	e8 00 fe ff ff       	call   182318 <handle_time_slicing>
}
  182518:	83 c4 08             	add    $0x8,%esp
  18251b:	5b                   	pop    %ebx
  18251c:	5e                   	pop    %esi
  18251d:	5f                   	pop    %edi
  18251e:	c3                   	ret    

0018251f <_k_thread_single_start>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  18251f:	8a 50 09             	mov    0x9(%eax),%dl
  182522:	88 d1                	mov    %dl,%cl
  182524:	83 e1 fb             	and    $0xfffffffb,%ecx
  182527:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  18252a:	f6 c2 1b             	test   $0x1b,%dl
  18252d:	75 0d                	jne    18253c <_k_thread_single_start+0x1d>
  18252f:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  182533:	75 0e                	jne    182543 <_k_thread_single_start+0x24>
  182535:	ba 01 00 00 00       	mov    $0x1,%edx
  18253a:	eb 0c                	jmp    182548 <_k_thread_single_start+0x29>
  18253c:	ba 00 00 00 00       	mov    $0x0,%edx
  182541:	eb 05                	jmp    182548 <_k_thread_single_start+0x29>
  182543:	ba 00 00 00 00       	mov    $0x0,%edx

void _k_thread_single_start(struct k_thread *thread)
{
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182548:	85 d2                	test   %edx,%edx
  18254a:	74 05                	je     182551 <_k_thread_single_start+0x32>
		_add_thread_to_ready_q(thread);
  18254c:	e8 eb fa ff ff       	call   18203c <_add_thread_to_ready_q>
  182551:	c3                   	ret    

00182552 <start_thread>:
	CODE_UNREACHABLE;
}

#ifdef CONFIG_MULTITHREADING
static void start_thread(struct k_thread *thread)
{
  182552:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182553:	9c                   	pushf  
  182554:	fa                   	cli    
  182555:	5b                   	pop    %ebx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182556:	8a 50 09             	mov    0x9(%eax),%dl
  182559:	88 d1                	mov    %dl,%cl
  18255b:	83 e1 fb             	and    $0xfffffffb,%ecx
  18255e:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182561:	f6 c2 1b             	test   $0x1b,%dl
  182564:	75 0d                	jne    182573 <start_thread+0x21>
  182566:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  18256a:	75 0e                	jne    18257a <start_thread+0x28>
  18256c:	ba 01 00 00 00       	mov    $0x1,%edx
  182571:	eb 0c                	jmp    18257f <start_thread+0x2d>
  182573:	ba 00 00 00 00       	mov    $0x0,%edx
  182578:	eb 05                	jmp    18257f <start_thread+0x2d>
  18257a:	ba 00 00 00 00       	mov    $0x0,%edx
	int key = irq_lock(); /* protect kernel queues */

	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  18257f:	85 d2                	test   %edx,%edx
  182581:	74 33                	je     1825b6 <start_thread+0x64>
		_add_thread_to_ready_q(thread);
  182583:	e8 b4 fa ff ff       	call   18203c <_add_thread_to_ready_q>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  182588:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  18258d:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  182592:	77 10                	ja     1825a4 <start_thread+0x52>
  182594:	e8 3a fb ff ff       	call   1820d3 <__must_switch_threads>
  182599:	85 c0                	test   %eax,%eax
  18259b:	74 0c                	je     1825a9 <start_thread+0x57>
  18259d:	b8 01 00 00 00       	mov    $0x1,%eax
  1825a2:	eb 05                	jmp    1825a9 <start_thread+0x57>
  1825a4:	b8 00 00 00 00       	mov    $0x0,%eax
		if (_must_switch_threads()) {
  1825a9:	85 c0                	test   %eax,%eax
  1825ab:	74 09                	je     1825b6 <start_thread+0x64>
			_Swap(key);
  1825ad:	89 d8                	mov    %ebx,%eax
  1825af:	e8 a5 f5 ff ff       	call   181b59 <_Swap>
			return;
  1825b4:	eb 06                	jmp    1825bc <start_thread+0x6a>
  1825b6:	f6 c7 02             	test   $0x2,%bh
  1825b9:	74 01                	je     1825bc <start_thread+0x6a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1825bb:	fb                   	sti    
		}
	}

	irq_unlock(key);
}
  1825bc:	5b                   	pop    %ebx
  1825bd:	c3                   	ret    

001825be <schedule_new_thread>:
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
  1825be:	57                   	push   %edi
  1825bf:	56                   	push   %esi
  1825c0:	53                   	push   %ebx
  1825c1:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  1825c3:	85 d2                	test   %edx,%edx
  1825c5:	75 0a                	jne    1825d1 <schedule_new_thread+0x13>
		start_thread(thread);
  1825c7:	e8 86 ff ff ff       	call   182552 <start_thread>
  1825cc:	e9 18 01 00 00       	jmp    1826e9 <schedule_new_thread+0x12b>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  1825d1:	83 c2 09             	add    $0x9,%edx
  1825d4:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  1825d9:	89 d0                	mov    %edx,%eax
  1825db:	f7 e1                	mul    %ecx
  1825dd:	c1 ea 03             	shr    $0x3,%edx
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  1825e0:	42                   	inc    %edx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1825e1:	9c                   	pushf  
  1825e2:	fa                   	cli    
  1825e3:	5f                   	pop    %edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  1825e4:	8d 46 10             	lea    0x10(%esi),%eax
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  1825e7:	89 50 10             	mov    %edx,0x10(%eax)
	timeout->thread = thread;
  1825ea:	89 70 08             	mov    %esi,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  1825ed:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1825f4:	8b 15 cc 01 28 00    	mov    0x2801cc,%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1825fa:	81 fa cc 01 28 00    	cmp    $0x2801cc,%edx
  182600:	75 07                	jne    182609 <schedule_new_thread+0x4b>
  182602:	b9 00 00 00 00       	mov    $0x0,%ecx
  182607:	eb 02                	jmp    18260b <schedule_new_thread+0x4d>
  182609:	89 d1                	mov    %edx,%ecx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  18260b:	85 c9                	test   %ecx,%ecx
  18260d:	74 16                	je     182625 <schedule_new_thread+0x67>
  18260f:	81 fa cc 01 28 00    	cmp    $0x2801cc,%edx
  182615:	0f 85 a0 00 00 00    	jne    1826bb <schedule_new_thread+0xfd>
  18261b:	ba 00 00 00 00       	mov    $0x0,%edx
  182620:	e9 96 00 00 00       	jmp    1826bb <schedule_new_thread+0xfd>
  182625:	ba 00 00 00 00       	mov    $0x0,%edx
  18262a:	e9 8c 00 00 00       	jmp    1826bb <schedule_new_thread+0xfd>
		if (*delta <= in_q->delta_ticks_from_prev) {
  18262f:	8b 48 10             	mov    0x10(%eax),%ecx
  182632:	8b 5a 10             	mov    0x10(%edx),%ebx
  182635:	39 d9                	cmp    %ebx,%ecx
  182637:	7f 3b                	jg     182674 <schedule_new_thread+0xb6>
			in_q->delta_ticks_from_prev -= *delta;
  182639:	29 cb                	sub    %ecx,%ebx
  18263b:	89 5a 10             	mov    %ebx,0x10(%edx)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  18263e:	85 d2                	test   %edx,%edx
  182640:	75 1f                	jne    182661 <schedule_new_thread+0xa3>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182642:	c7 46 10 cc 01 28 00 	movl   $0x2801cc,0x10(%esi)
	node->prev = list->tail;
  182649:	8b 15 d0 01 28 00    	mov    0x2801d0,%edx
  18264f:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  182652:	8b 15 d0 01 28 00    	mov    0x2801d0,%edx
  182658:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  18265a:	a3 d0 01 28 00       	mov    %eax,0x2801d0
  18265f:	eb 7f                	jmp    1826e0 <schedule_new_thread+0x122>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  182661:	8b 4a 04             	mov    0x4(%edx),%ecx
  182664:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
  182667:	89 56 10             	mov    %edx,0x10(%esi)
		insert_point->prev->next = node;
  18266a:	8b 4a 04             	mov    0x4(%edx),%ecx
  18266d:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
  18266f:	89 42 04             	mov    %eax,0x4(%edx)
  182672:	eb 6c                	jmp    1826e0 <schedule_new_thread+0x122>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  182674:	29 d9                	sub    %ebx,%ecx
  182676:	89 48 10             	mov    %ecx,0x10(%eax)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182679:	89 d1                	mov    %edx,%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18267b:	85 d2                	test   %edx,%edx
  18267d:	74 0c                	je     18268b <schedule_new_thread+0xcd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18267f:	3b 15 d0 01 28 00    	cmp    0x2801d0,%edx
  182685:	74 08                	je     18268f <schedule_new_thread+0xd1>
  182687:	8b 1a                	mov    (%edx),%ebx
  182689:	eb 09                	jmp    182694 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18268b:	89 d3                	mov    %edx,%ebx
  18268d:	eb 05                	jmp    182694 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18268f:	bb 00 00 00 00       	mov    $0x0,%ebx
  182694:	85 db                	test   %ebx,%ebx
  182696:	74 1e                	je     1826b6 <schedule_new_thread+0xf8>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182698:	85 c9                	test   %ecx,%ecx
  18269a:	74 0c                	je     1826a8 <schedule_new_thread+0xea>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18269c:	3b 0d d0 01 28 00    	cmp    0x2801d0,%ecx
  1826a2:	74 0b                	je     1826af <schedule_new_thread+0xf1>
  1826a4:	8b 12                	mov    (%edx),%edx
  1826a6:	eb 13                	jmp    1826bb <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1826a8:	ba 00 00 00 00       	mov    $0x0,%edx
  1826ad:	eb 0c                	jmp    1826bb <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1826af:	ba 00 00 00 00       	mov    $0x0,%edx
  1826b4:	eb 05                	jmp    1826bb <schedule_new_thread+0xfd>
  1826b6:	ba 00 00 00 00       	mov    $0x0,%edx
  1826bb:	85 d2                	test   %edx,%edx
  1826bd:	0f 85 6c ff ff ff    	jne    18262f <schedule_new_thread+0x71>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1826c3:	c7 46 10 cc 01 28 00 	movl   $0x2801cc,0x10(%esi)
	node->prev = list->tail;
  1826ca:	8b 15 d0 01 28 00    	mov    0x2801d0,%edx
  1826d0:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  1826d3:	8b 15 d0 01 28 00    	mov    0x2801d0,%edx
  1826d9:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  1826db:	a3 d0 01 28 00       	mov    %eax,0x2801d0
  1826e0:	f7 c7 00 02 00 00    	test   $0x200,%edi
  1826e6:	74 01                	je     1826e9 <schedule_new_thread+0x12b>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1826e8:	fb                   	sti    
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  1826e9:	5b                   	pop    %ebx
  1826ea:	5e                   	pop    %esi
  1826eb:	5f                   	pop    %edi
  1826ec:	c3                   	ret    

001826ed <k_is_in_isr>:
}
#endif

int k_is_in_isr(void)
{
	return _is_in_isr();
  1826ed:	83 3d c0 01 28 00 00 	cmpl   $0x0,0x2801c0
  1826f4:	0f 95 c0             	setne  %al
  1826f7:	0f b6 c0             	movzbl %al,%eax
}
  1826fa:	c3                   	ret    

001826fb <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.user_options & K_ESSENTIAL;
  1826fb:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  182700:	8a 40 08             	mov    0x8(%eax),%al
  182703:	83 e0 01             	and    $0x1,%eax
}
  182706:	c3                   	ret    

00182707 <_thread_monitor_exit>:
#if defined(CONFIG_THREAD_MONITOR)
/*
 * Remove a thread from the kernel's list of active threads.
 */
void _thread_monitor_exit(struct k_thread *thread)
{
  182707:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182708:	9c                   	pushf  
  182709:	fa                   	cli    
  18270a:	5b                   	pop    %ebx
	unsigned int key = irq_lock();

	if (thread == _kernel.threads) {
  18270b:	8b 0d dc 02 28 00    	mov    0x2802dc,%ecx
  182711:	39 c1                	cmp    %eax,%ecx
  182713:	75 0c                	jne    182721 <_thread_monitor_exit+0x1a>
		_kernel.threads = _kernel.threads->next_thread;
  182715:	8b 41 38             	mov    0x38(%ecx),%eax
  182718:	a3 dc 02 28 00       	mov    %eax,0x2802dc
  18271d:	eb 0f                	jmp    18272e <_thread_monitor_exit+0x27>
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
			prev_thread = prev_thread->next_thread;
  18271f:	89 d1                	mov    %edx,%ecx
		_kernel.threads = _kernel.threads->next_thread;
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
  182721:	8b 51 38             	mov    0x38(%ecx),%edx
  182724:	39 d0                	cmp    %edx,%eax
  182726:	75 f7                	jne    18271f <_thread_monitor_exit+0x18>
			prev_thread = prev_thread->next_thread;
		}
		prev_thread->next_thread = thread->next_thread;
  182728:	8b 40 38             	mov    0x38(%eax),%eax
  18272b:	89 41 38             	mov    %eax,0x38(%ecx)
  18272e:	f6 c7 02             	test   $0x2,%bh
  182731:	74 01                	je     182734 <_thread_monitor_exit+0x2d>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182733:	fb                   	sti    
	}

	irq_unlock(key);
}
  182734:	5b                   	pop    %ebx
  182735:	c3                   	ret    

00182736 <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
  182736:	53                   	push   %ebx
  182737:	89 c3                	mov    %eax,%ebx
  182739:	89 d0                	mov    %edx,%eax
  18273b:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
  18273d:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  182741:	ff d3                	call   *%ebx

#ifdef CONFIG_MULTITHREADING
	if (_is_thread_essential()) {
  182743:	e8 b3 ff ff ff       	call   1826fb <_is_thread_essential>
  182748:	85 c0                	test   %eax,%eax
  18274a:	74 0f                	je     18275b <_thread_entry+0x25>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  18274c:	ba 00 34 18 00       	mov    $0x183400,%edx
  182751:	b8 03 00 00 00       	mov    $0x3,%eax
  182756:	e8 d3 f4 ff ff       	call   181c2e <_NanoFatalErrorHandler>
				       &_default_esf);
	}

	k_thread_abort(_current);
  18275b:	a1 c8 01 28 00       	mov    0x2801c8,%eax
  182760:	e8 e0 01 00 00       	call   182945 <k_thread_abort>

00182765 <_k_thread_group_op>:
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  182765:	55                   	push   %ebp
  182766:	57                   	push   %edi
  182767:	56                   	push   %esi
  182768:	53                   	push   %ebx
  182769:	89 c6                	mov    %eax,%esi
  18276b:	89 d5                	mov    %edx,%ebp
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  18276d:	8b 15 c8 01 28 00    	mov    0x2801c8,%edx
  182773:	8a 42 0b             	mov    0xb(%edx),%al
  182776:	48                   	dec    %eax
  182777:	88 42 0b             	mov    %al,0xb(%edx)

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  18277a:	bb bc 00 28 00       	mov    $0x2800bc,%ebx
  18277f:	eb 18                	jmp    182799 <_k_thread_group_op+0x34>
		if (is_in_any_group(thread_data, groups)) {
  182781:	85 73 28             	test   %esi,0x28(%ebx)
  182784:	74 10                	je     182796 <_k_thread_group_op+0x31>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182786:	9c                   	pushf  
  182787:	fa                   	cli    
  182788:	5f                   	pop    %edi
			key = irq_lock();
			func(thread_data->thread);
  182789:	8b 03                	mov    (%ebx),%eax
  18278b:	ff d5                	call   *%ebp
  18278d:	f7 c7 00 02 00 00    	test   $0x200,%edi
  182793:	74 01                	je     182796 <_k_thread_group_op+0x31>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182795:	fb                   	sti    

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  182796:	83 c3 2c             	add    $0x2c,%ebx
  182799:	81 fb bc 00 28 00    	cmp    $0x2800bc,%ebx
  18279f:	72 e0                	jb     182781 <_k_thread_group_op+0x1c>

	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
  1827a1:	a1 c8 01 28 00       	mov    0x2801c8,%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1827a6:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  1827aa:	75 0d                	jne    1827b9 <_k_thread_group_op+0x54>
  1827ac:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1827b0:	75 0e                	jne    1827c0 <_k_thread_group_op+0x5b>
  1827b2:	b8 01 00 00 00       	mov    $0x1,%eax
  1827b7:	eb 0c                	jmp    1827c5 <_k_thread_group_op+0x60>
  1827b9:	b8 00 00 00 00       	mov    $0x0,%eax
  1827be:	eb 05                	jmp    1827c5 <_k_thread_group_op+0x60>
  1827c0:	b8 00 00 00 00       	mov    $0x0,%eax
  1827c5:	85 c0                	test   %eax,%eax
  1827c7:	74 07                	je     1827d0 <_k_thread_group_op+0x6b>
		k_sched_unlock();
  1827c9:	e8 61 f9 ff ff       	call   18212f <k_sched_unlock>
		return;
  1827ce:	eb 15                	jmp    1827e5 <_k_thread_group_op+0x80>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1827d0:	9c                   	pushf  
  1827d1:	fa                   	cli    
  1827d2:	58                   	pop    %eax
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 0, "");

	compiler_barrier();

	++_current->base.sched_locked;
  1827d3:	8b 0d c8 01 28 00    	mov    0x2801c8,%ecx
  1827d9:	8a 51 0b             	mov    0xb(%ecx),%dl
  1827dc:	42                   	inc    %edx
  1827dd:	88 51 0b             	mov    %dl,0xb(%ecx)
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  1827e0:	e8 74 f3 ff ff       	call   181b59 <_Swap>
}
  1827e5:	5b                   	pop    %ebx
  1827e6:	5e                   	pop    %esi
  1827e7:	5f                   	pop    %edi
  1827e8:	5d                   	pop    %ebp
  1827e9:	c3                   	ret    

001827ea <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  1827ea:	56                   	push   %esi
  1827eb:	53                   	push   %ebx
  1827ec:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
  1827ee:	8b 40 30             	mov    0x30(%eax),%eax
  1827f1:	85 c0                	test   %eax,%eax
  1827f3:	74 02                	je     1827f7 <_k_thread_single_abort+0xd>
		thread->fn_abort();
  1827f5:	ff d0                	call   *%eax
	return !(thread->base.thread_state & _THREAD_PRESTART);
}

static inline int _is_thread_prevented_from_running(struct k_thread *thread)
{
	uint8_t state = thread->base.thread_state;
  1827f7:	8a 43 09             	mov    0x9(%ebx),%al
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1827fa:	a8 1f                	test   $0x1f,%al
  1827fc:	75 0d                	jne    18280b <_k_thread_single_abort+0x21>
  1827fe:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  182802:	75 0e                	jne    182812 <_k_thread_single_abort+0x28>
  182804:	ba 01 00 00 00       	mov    $0x1,%edx
  182809:	eb 0c                	jmp    182817 <_k_thread_single_abort+0x2d>
  18280b:	ba 00 00 00 00       	mov    $0x0,%edx
  182810:	eb 05                	jmp    182817 <_k_thread_single_abort+0x2d>
  182812:	ba 00 00 00 00       	mov    $0x0,%edx
	}

	if (_is_thread_ready(thread)) {
  182817:	85 d2                	test   %edx,%edx
  182819:	74 09                	je     182824 <_k_thread_single_abort+0x3a>
		_remove_thread_from_ready_q(thread);
  18281b:	89 d8                	mov    %ebx,%eax
  18281d:	e8 68 f8 ff ff       	call   18208a <_remove_thread_from_ready_q>
  182822:	eb 61                	jmp    182885 <_k_thread_single_abort+0x9b>
	} else {
		if (_is_thread_pending(thread)) {
  182824:	a8 02                	test   $0x2,%al
  182826:	74 13                	je     18283b <_k_thread_single_abort+0x51>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182828:	8b 43 04             	mov    0x4(%ebx),%eax
  18282b:	8b 13                	mov    (%ebx),%edx
  18282d:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  18282f:	8b 03                	mov    (%ebx),%eax
  182831:	8b 53 04             	mov    0x4(%ebx),%edx
  182834:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  182837:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  18283b:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  18283f:	74 44                	je     182885 <_k_thread_single_abort+0x9b>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  182841:	8d 43 10             	lea    0x10(%ebx),%eax
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  182844:	8b 48 10             	mov    0x10(%eax),%ecx
  182847:	83 f9 ff             	cmp    $0xffffffff,%ecx
  18284a:	74 39                	je     182885 <_k_thread_single_abort+0x9b>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  18284c:	89 c2                	mov    %eax,%edx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  18284e:	8b 35 d0 01 28 00    	mov    0x2801d0,%esi
  182854:	39 f0                	cmp    %esi,%eax
  182856:	74 15                	je     18286d <_k_thread_single_abort+0x83>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182858:	85 c0                	test   %eax,%eax
  18285a:	74 0e                	je     18286a <_k_thread_single_abort+0x80>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18285c:	39 f0                	cmp    %esi,%eax
  18285e:	74 05                	je     182865 <_k_thread_single_abort+0x7b>
  182860:	8b 53 10             	mov    0x10(%ebx),%edx
  182863:	eb 05                	jmp    18286a <_k_thread_single_abort+0x80>
  182865:	ba 00 00 00 00       	mov    $0x0,%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  18286a:	01 4a 10             	add    %ecx,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18286d:	8b 50 04             	mov    0x4(%eax),%edx
  182870:	8b 4b 10             	mov    0x10(%ebx),%ecx
  182873:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  182875:	8b 53 10             	mov    0x10(%ebx),%edx
  182878:	8b 48 04             	mov    0x4(%eax),%ecx
  18287b:	89 4a 04             	mov    %ecx,0x4(%edx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  18287e:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_DEAD;
  182885:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  182889:	5b                   	pop    %ebx
  18288a:	5e                   	pop    %esi
  18288b:	c3                   	ret    

0018288c <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
  18288c:	56                   	push   %esi
  18288d:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  18288e:	bb bc 00 28 00       	mov    $0x2800bc,%ebx
  182893:	eb 27                	jmp    1828bc <_init_static_threads+0x30>
		_task_group_adjust(thread_data);
		_new_thread(
  182895:	8b 4b 08             	mov    0x8(%ebx),%ecx
  182898:	8b 53 04             	mov    0x4(%ebx),%edx
  18289b:	ff 73 1c             	pushl  0x1c(%ebx)
  18289e:	ff 73 18             	pushl  0x18(%ebx)
  1828a1:	ff 73 14             	pushl  0x14(%ebx)
  1828a4:	ff 73 10             	pushl  0x10(%ebx)
  1828a7:	ff 73 0c             	pushl  0xc(%ebx)
  1828aa:	8b 03                	mov    (%ebx),%eax
  1828ac:	e8 37 f3 ff ff       	call   181be8 <_new_thread>
  1828b1:	83 c4 14             	add    $0x14,%esp
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  1828b4:	8b 03                	mov    (%ebx),%eax
  1828b6:	89 58 2c             	mov    %ebx,0x2c(%eax)
#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  1828b9:	83 c3 2c             	add    $0x2c,%ebx
  1828bc:	81 fb bc 00 28 00    	cmp    $0x2800bc,%ebx
  1828c2:	72 d1                	jb     182895 <_init_static_threads+0x9>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  1828c4:	8b 15 c8 01 28 00    	mov    0x2801c8,%edx
  1828ca:	8a 42 0b             	mov    0xb(%edx),%al
  1828cd:	48                   	dec    %eax
  1828ce:	88 42 0b             	mov    %al,0xb(%edx)
	}

	_sched_lock();
#if defined(CONFIG_LEGACY_KERNEL)
	/* Start all (legacy) threads that are part of the EXE task group */
	_k_thread_group_op(K_TASK_GROUP_EXE, _k_thread_single_start);
  1828d1:	ba 1f 25 18 00       	mov    $0x18251f,%edx
  1828d6:	b8 01 00 00 00       	mov    $0x1,%eax
  1828db:	e8 85 fe ff ff       	call   182765 <_k_thread_group_op>
  1828e0:	9c                   	pushf  
  1828e1:	fa                   	cli    
  1828e2:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  1828e3:	bb bc 00 28 00       	mov    $0x2800bc,%ebx
  1828e8:	eb 12                	jmp    1828fc <_init_static_threads+0x70>
		if (thread_data->init_delay != K_FOREVER) {
  1828ea:	8b 53 20             	mov    0x20(%ebx),%edx
  1828ed:	83 fa ff             	cmp    $0xffffffff,%edx
  1828f0:	74 07                	je     1828f9 <_init_static_threads+0x6d>
			schedule_new_thread(thread_data->thread,
  1828f2:	8b 03                	mov    (%ebx),%eax
  1828f4:	e8 c5 fc ff ff       	call   1825be <schedule_new_thread>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  1828f9:	83 c3 2c             	add    $0x2c,%ebx
  1828fc:	81 fb bc 00 28 00    	cmp    $0x2800bc,%ebx
  182902:	72 e6                	jb     1828ea <_init_static_threads+0x5e>
  182904:	f7 c6 00 02 00 00    	test   $0x200,%esi
  18290a:	74 01                	je     18290d <_init_static_threads+0x81>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18290c:	fb                   	sti    
			schedule_new_thread(thread_data->thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
  18290d:	e8 1d f8 ff ff       	call   18212f <k_sched_unlock>
}
  182912:	5b                   	pop    %ebx
  182913:	5e                   	pop    %esi
  182914:	c3                   	ret    

00182915 <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  182915:	53                   	push   %ebx
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
  182916:	8a 5c 24 08          	mov    0x8(%esp),%bl
  18291a:	88 58 08             	mov    %bl,0x8(%eax)
	thread_base->thread_state = (uint8_t)initial_state;
  18291d:	88 48 09             	mov    %cl,0x9(%eax)

	thread_base->prio = priority;
  182920:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
  182923:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
  182927:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  18292e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  182935:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  18293c:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  182943:	5b                   	pop    %ebx
  182944:	c3                   	ret    

00182945 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
  182945:	56                   	push   %esi
  182946:	53                   	push   %ebx
  182947:	89 c3                	mov    %eax,%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182949:	9c                   	pushf  
  18294a:	fa                   	cli    
  18294b:	5e                   	pop    %esi
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  18294c:	e8 99 fe ff ff       	call   1827ea <_k_thread_single_abort>
	_thread_monitor_exit(thread);
  182951:	89 d8                	mov    %ebx,%eax
  182953:	e8 af fd ff ff       	call   182707 <_thread_monitor_exit>

	if (_current == thread) {
  182958:	3b 1d c8 01 28 00    	cmp    0x2801c8,%ebx
  18295e:	75 07                	jne    182967 <k_thread_abort+0x22>
		_Swap(key);
  182960:	89 f0                	mov    %esi,%eax
  182962:	e8 f2 f1 ff ff       	call   181b59 <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  182967:	89 f0                	mov    %esi,%eax
  182969:	e8 88 f7 ff ff       	call   1820f6 <_reschedule_threads>
}
  18296e:	5b                   	pop    %ebx
  18296f:	5e                   	pop    %esi
  182970:	c3                   	ret    

00182971 <init_timer_module>:
{
	ARG_UNUSED(dev);

	struct k_timer *timer;

	for (timer = _k_timer_list_start; timer < _k_timer_list_end; timer++) {
  182971:	b8 c0 00 28 00       	mov    $0x2800c0,%eax
  182976:	eb 1a                	jmp    182992 <init_timer_module+0x21>
  182978:	9c                   	pushf  
  182979:	fa                   	cli    
  18297a:	5a                   	pop    %edx
		SYS_TRACING_OBJ_INIT(k_timer, timer);
  18297b:	8b 0d 04 03 28 00    	mov    0x280304,%ecx
  182981:	89 48 34             	mov    %ecx,0x34(%eax)
  182984:	a3 04 03 28 00       	mov    %eax,0x280304
  182989:	f6 c6 02             	test   $0x2,%dh
  18298c:	74 01                	je     18298f <init_timer_module+0x1e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18298e:	fb                   	sti    
{
	ARG_UNUSED(dev);

	struct k_timer *timer;

	for (timer = _k_timer_list_start; timer < _k_timer_list_end; timer++) {
  18298f:	83 c0 38             	add    $0x38,%eax
  182992:	3d f8 00 28 00       	cmp    $0x2800f8,%eax
  182997:	72 df                	jb     182978 <init_timer_module+0x7>
		SYS_TRACING_OBJ_INIT(k_timer, timer);
	}
	return 0;
}
  182999:	b8 00 00 00 00       	mov    $0x0,%eax
  18299e:	c3                   	ret    

0018299f <_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void _timer_expiration_handler(struct _timeout *t)
{
  18299f:	57                   	push   %edi
  1829a0:	56                   	push   %esi
  1829a1:	53                   	push   %ebx
  1829a2:	89 c3                	mov    %eax,%ebx

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
  1829a4:	83 78 28 00          	cmpl   $0x0,0x28(%eax)
  1829a8:	0f 8e 05 01 00 00    	jle    182ab3 <_timer_expiration_handler+0x114>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1829ae:	9c                   	pushf  
  1829af:	fa                   	cli    
  1829b0:	5e                   	pop    %esi
		key = irq_lock();
		_add_timeout(NULL, &timer->timeout, &timer->wait_q,
  1829b1:	8b 50 28             	mov    0x28(%eax),%edx
  1829b4:	8d 40 18             	lea    0x18(%eax),%eax
  1829b7:	89 df                	mov    %ebx,%edi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  1829b9:	89 53 10             	mov    %edx,0x10(%ebx)
	timeout->thread = thread;
  1829bc:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  1829c3:	89 43 0c             	mov    %eax,0xc(%ebx)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1829c6:	a1 cc 01 28 00       	mov    0x2801cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1829cb:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  1829d0:	75 07                	jne    1829d9 <_timer_expiration_handler+0x3a>
  1829d2:	ba 00 00 00 00       	mov    $0x0,%edx
  1829d7:	eb 02                	jmp    1829db <_timer_expiration_handler+0x3c>
  1829d9:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1829db:	85 d2                	test   %edx,%edx
  1829dd:	74 15                	je     1829f4 <_timer_expiration_handler+0x55>
  1829df:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  1829e4:	0f 85 9d 00 00 00    	jne    182a87 <_timer_expiration_handler+0xe8>
  1829ea:	b8 00 00 00 00       	mov    $0x0,%eax
  1829ef:	e9 93 00 00 00       	jmp    182a87 <_timer_expiration_handler+0xe8>
  1829f4:	b8 00 00 00 00       	mov    $0x0,%eax
  1829f9:	e9 89 00 00 00       	jmp    182a87 <_timer_expiration_handler+0xe8>
		if (*delta <= in_q->delta_ticks_from_prev) {
  1829fe:	8b 57 10             	mov    0x10(%edi),%edx
  182a01:	8b 48 10             	mov    0x10(%eax),%ecx
  182a04:	39 ca                	cmp    %ecx,%edx
  182a06:	7f 38                	jg     182a40 <_timer_expiration_handler+0xa1>
			in_q->delta_ticks_from_prev -= *delta;
  182a08:	29 d1                	sub    %edx,%ecx
  182a0a:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  182a0d:	85 c0                	test   %eax,%eax
  182a0f:	75 1d                	jne    182a2e <_timer_expiration_handler+0x8f>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182a11:	c7 03 cc 01 28 00    	movl   $0x2801cc,(%ebx)
	node->prev = list->tail;
  182a17:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182a1c:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  182a1f:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182a24:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  182a26:	89 1d d0 01 28 00    	mov    %ebx,0x2801d0
  182a2c:	eb 7c                	jmp    182aaa <_timer_expiration_handler+0x10b>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  182a2e:	8b 50 04             	mov    0x4(%eax),%edx
  182a31:	89 53 04             	mov    %edx,0x4(%ebx)
		node->next = insert_point;
  182a34:	89 03                	mov    %eax,(%ebx)
		insert_point->prev->next = node;
  182a36:	8b 50 04             	mov    0x4(%eax),%edx
  182a39:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
  182a3b:	89 58 04             	mov    %ebx,0x4(%eax)
  182a3e:	eb 6a                	jmp    182aaa <_timer_expiration_handler+0x10b>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  182a40:	29 ca                	sub    %ecx,%edx
  182a42:	89 57 10             	mov    %edx,0x10(%edi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182a45:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182a47:	85 c0                	test   %eax,%eax
  182a49:	74 0c                	je     182a57 <_timer_expiration_handler+0xb8>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182a4b:	3b 05 d0 01 28 00    	cmp    0x2801d0,%eax
  182a51:	74 08                	je     182a5b <_timer_expiration_handler+0xbc>
  182a53:	8b 08                	mov    (%eax),%ecx
  182a55:	eb 09                	jmp    182a60 <_timer_expiration_handler+0xc1>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182a57:	89 c1                	mov    %eax,%ecx
  182a59:	eb 05                	jmp    182a60 <_timer_expiration_handler+0xc1>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182a5b:	b9 00 00 00 00       	mov    $0x0,%ecx
  182a60:	85 c9                	test   %ecx,%ecx
  182a62:	74 1e                	je     182a82 <_timer_expiration_handler+0xe3>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182a64:	85 d2                	test   %edx,%edx
  182a66:	74 0c                	je     182a74 <_timer_expiration_handler+0xd5>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182a68:	3b 15 d0 01 28 00    	cmp    0x2801d0,%edx
  182a6e:	74 0b                	je     182a7b <_timer_expiration_handler+0xdc>
  182a70:	8b 00                	mov    (%eax),%eax
  182a72:	eb 13                	jmp    182a87 <_timer_expiration_handler+0xe8>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182a74:	b8 00 00 00 00       	mov    $0x0,%eax
  182a79:	eb 0c                	jmp    182a87 <_timer_expiration_handler+0xe8>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182a7b:	b8 00 00 00 00       	mov    $0x0,%eax
  182a80:	eb 05                	jmp    182a87 <_timer_expiration_handler+0xe8>
  182a82:	b8 00 00 00 00       	mov    $0x0,%eax
  182a87:	85 c0                	test   %eax,%eax
  182a89:	0f 85 6f ff ff ff    	jne    1829fe <_timer_expiration_handler+0x5f>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182a8f:	c7 03 cc 01 28 00    	movl   $0x2801cc,(%ebx)
	node->prev = list->tail;
  182a95:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182a9a:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  182a9d:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182aa2:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  182aa4:	89 1d d0 01 28 00    	mov    %ebx,0x2801d0
  182aaa:	f7 c6 00 02 00 00    	test   $0x200,%esi
  182ab0:	74 01                	je     182ab3 <_timer_expiration_handler+0x114>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182ab2:	fb                   	sti    
				timer->period);
		irq_unlock(key);
	}

	/* update timer's status */
	timer->status += 1;
  182ab3:	ff 43 2c             	incl   0x2c(%ebx)

	/* invoke timer expiry function */
	if (timer->expiry_fn) {
  182ab6:	8b 53 20             	mov    0x20(%ebx),%edx
  182ab9:	85 d2                	test   %edx,%edx
  182abb:	74 04                	je     182ac1 <_timer_expiration_handler+0x122>
		timer->expiry_fn(timer);
  182abd:	89 d8                	mov    %ebx,%eax
  182abf:	ff d2                	call   *%edx
	}

	thread = (struct k_thread *)sys_dlist_peek_head(&timer->wait_q);
  182ac1:	8d 43 18             	lea    0x18(%ebx),%eax
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182ac4:	8b 5b 18             	mov    0x18(%ebx),%ebx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182ac7:	39 d8                	cmp    %ebx,%eax
  182ac9:	75 05                	jne    182ad0 <_timer_expiration_handler+0x131>
  182acb:	bb 00 00 00 00       	mov    $0x0,%ebx

	if (!thread) {
  182ad0:	85 db                	test   %ebx,%ebx
  182ad2:	74 5b                	je     182b2f <_timer_expiration_handler+0x190>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182ad4:	8b 43 04             	mov    0x4(%ebx),%eax
  182ad7:	8b 13                	mov    (%ebx),%edx
  182ad9:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  182adb:	8b 03                	mov    (%ebx),%eax
  182add:	8b 53 04             	mov    0x4(%ebx),%edx
  182ae0:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  182ae3:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182ae7:	9c                   	pushf  
  182ae8:	fa                   	cli    
  182ae9:	5e                   	pop    %esi
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182aea:	8a 43 09             	mov    0x9(%ebx),%al
  182aed:	88 c2                	mov    %al,%dl
  182aef:	83 e2 fb             	and    $0xfffffffb,%edx
  182af2:	88 53 09             	mov    %dl,0x9(%ebx)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182af5:	a8 1b                	test   $0x1b,%al
  182af7:	75 0d                	jne    182b06 <_timer_expiration_handler+0x167>
  182af9:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  182afd:	75 0e                	jne    182b0d <_timer_expiration_handler+0x16e>
  182aff:	b8 01 00 00 00       	mov    $0x1,%eax
  182b04:	eb 0c                	jmp    182b12 <_timer_expiration_handler+0x173>
  182b06:	b8 00 00 00 00       	mov    $0x0,%eax
  182b0b:	eb 05                	jmp    182b12 <_timer_expiration_handler+0x173>
  182b0d:	b8 00 00 00 00       	mov    $0x0,%eax
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182b12:	85 c0                	test   %eax,%eax
  182b14:	74 07                	je     182b1d <_timer_expiration_handler+0x17e>
		_add_thread_to_ready_q(thread);
  182b16:	89 d8                	mov    %ebx,%eax
  182b18:	e8 1f f5 ff ff       	call   18203c <_add_thread_to_ready_q>
  182b1d:	f7 c6 00 02 00 00    	test   $0x200,%esi
  182b23:	74 01                	je     182b26 <_timer_expiration_handler+0x187>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182b25:	fb                   	sti    
static ALWAYS_INLINE void
_set_thread_return_value(struct k_thread *thread, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(thread->callee_saved.esp) = value;
  182b26:	8b 43 28             	mov    0x28(%ebx),%eax
  182b29:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	key = irq_lock();
	_ready_thread(thread);
	irq_unlock(key);

	_set_thread_return_value(thread, 0);
}
  182b2f:	5b                   	pop    %ebx
  182b30:	5e                   	pop    %esi
  182b31:	5f                   	pop    %edi
  182b32:	c3                   	ret    

00182b33 <k_timer_init>:

void k_timer_init(struct k_timer *timer,
		  void (*expiry_fn)(struct k_timer *),
		  void (*stop_fn)(struct k_timer *))
{
	timer->expiry_fn = expiry_fn;
  182b33:	89 50 20             	mov    %edx,0x20(%eax)
	timer->stop_fn = stop_fn;
  182b36:	89 48 24             	mov    %ecx,0x24(%eax)
	timer->status = 0;
  182b39:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)

	sys_dlist_init(&timer->wait_q);
  182b40:	8d 50 18             	lea    0x18(%eax),%edx
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  182b43:	89 50 18             	mov    %edx,0x18(%eax)
	list->tail = (sys_dnode_t *)list;
  182b46:	89 50 1c             	mov    %edx,0x1c(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
  182b49:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  182b50:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  182b57:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  182b5e:	c7 40 14 9f 29 18 00 	movl   $0x18299f,0x14(%eax)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182b65:	9c                   	pushf  
  182b66:	fa                   	cli    
  182b67:	5a                   	pop    %edx
	_init_timeout(&timer->timeout, _timer_expiration_handler);
	SYS_TRACING_OBJ_INIT(k_timer, timer);
  182b68:	8b 0d 04 03 28 00    	mov    0x280304,%ecx
  182b6e:	89 48 34             	mov    %ecx,0x34(%eax)
  182b71:	a3 04 03 28 00       	mov    %eax,0x280304
  182b76:	f6 c6 02             	test   $0x2,%dh
  182b79:	74 01                	je     182b7c <k_timer_init+0x49>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182b7b:	fb                   	sti    

	timer->user_data = 0;
  182b7c:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
  182b83:	c3                   	ret    

00182b84 <k_timer_start>:
}


void k_timer_start(struct k_timer *timer, int32_t duration, int32_t period)
{
  182b84:	57                   	push   %edi
  182b85:	56                   	push   %esi
  182b86:	53                   	push   %ebx
  182b87:	83 ec 08             	sub    $0x8,%esp
  182b8a:	89 c3                	mov    %eax,%ebx
  182b8c:	89 d7                	mov    %edx,%edi
  182b8e:	8d 51 09             	lea    0x9(%ecx),%edx
  182b91:	be cd cc cc cc       	mov    $0xcccccccd,%esi
  182b96:	89 d0                	mov    %edx,%eax
  182b98:	f7 e6                	mul    %esi
  182b9a:	c1 ea 03             	shr    $0x3,%edx
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile int32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = _ms_to_ticks(period);
  182b9d:	89 54 24 04          	mov    %edx,0x4(%esp)
  182ba1:	8d 57 09             	lea    0x9(%edi),%edx
  182ba4:	89 d0                	mov    %edx,%eax
  182ba6:	f7 e6                	mul    %esi
  182ba8:	c1 ea 03             	shr    $0x3,%edx
	duration_in_ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  182bab:	42                   	inc    %edx
  182bac:	89 14 24             	mov    %edx,(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182baf:	9c                   	pushf  
  182bb0:	fa                   	cli    
  182bb1:	5e                   	pop    %esi

	unsigned int key = irq_lock();

	if (timer->timeout.delta_ticks_from_prev != _INACTIVE) {
  182bb2:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  182bb6:	74 3b                	je     182bf3 <k_timer_start+0x6f>
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  182bb8:	8b 53 10             	mov    0x10(%ebx),%edx
  182bbb:	74 36                	je     182bf3 <k_timer_start+0x6f>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  182bbd:	89 d8                	mov    %ebx,%eax
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  182bbf:	8b 0d d0 01 28 00    	mov    0x2801d0,%ecx
  182bc5:	39 cb                	cmp    %ecx,%ebx
  182bc7:	74 14                	je     182bdd <k_timer_start+0x59>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182bc9:	85 db                	test   %ebx,%ebx
  182bcb:	74 0d                	je     182bda <k_timer_start+0x56>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182bcd:	39 cb                	cmp    %ecx,%ebx
  182bcf:	74 04                	je     182bd5 <k_timer_start+0x51>
  182bd1:	8b 03                	mov    (%ebx),%eax
  182bd3:	eb 05                	jmp    182bda <k_timer_start+0x56>
  182bd5:	b8 00 00 00 00       	mov    $0x0,%eax
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  182bda:	01 50 10             	add    %edx,0x10(%eax)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182bdd:	8b 43 04             	mov    0x4(%ebx),%eax
  182be0:	8b 13                	mov    (%ebx),%edx
  182be2:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  182be4:	8b 03                	mov    (%ebx),%eax
  182be6:	8b 53 04             	mov    0x4(%ebx),%edx
  182be9:	89 50 04             	mov    %edx,0x4(%eax)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  182bec:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
		_abort_timeout(&timer->timeout);
	}

	timer->period = period_in_ticks;
  182bf3:	8b 44 24 04          	mov    0x4(%esp),%eax
  182bf7:	89 43 28             	mov    %eax,0x28(%ebx)
	_add_timeout(NULL, &timer->timeout, &timer->wait_q, duration_in_ticks);
  182bfa:	8b 14 24             	mov    (%esp),%edx
  182bfd:	8d 43 18             	lea    0x18(%ebx),%eax
  182c00:	89 df                	mov    %ebx,%edi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  182c02:	89 53 10             	mov    %edx,0x10(%ebx)
	timeout->thread = thread;
  182c05:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  182c0c:	89 43 0c             	mov    %eax,0xc(%ebx)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182c0f:	a1 cc 01 28 00       	mov    0x2801cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182c14:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  182c19:	75 07                	jne    182c22 <k_timer_start+0x9e>
  182c1b:	ba 00 00 00 00       	mov    $0x0,%edx
  182c20:	eb 02                	jmp    182c24 <k_timer_start+0xa0>
  182c22:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182c24:	85 d2                	test   %edx,%edx
  182c26:	74 15                	je     182c3d <k_timer_start+0xb9>
  182c28:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  182c2d:	0f 85 9d 00 00 00    	jne    182cd0 <k_timer_start+0x14c>
  182c33:	b8 00 00 00 00       	mov    $0x0,%eax
  182c38:	e9 93 00 00 00       	jmp    182cd0 <k_timer_start+0x14c>
  182c3d:	b8 00 00 00 00       	mov    $0x0,%eax
  182c42:	e9 89 00 00 00       	jmp    182cd0 <k_timer_start+0x14c>
		if (*delta <= in_q->delta_ticks_from_prev) {
  182c47:	8b 57 10             	mov    0x10(%edi),%edx
  182c4a:	8b 48 10             	mov    0x10(%eax),%ecx
  182c4d:	39 ca                	cmp    %ecx,%edx
  182c4f:	7f 38                	jg     182c89 <k_timer_start+0x105>
			in_q->delta_ticks_from_prev -= *delta;
  182c51:	29 d1                	sub    %edx,%ecx
  182c53:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  182c56:	85 c0                	test   %eax,%eax
  182c58:	75 1d                	jne    182c77 <k_timer_start+0xf3>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182c5a:	c7 03 cc 01 28 00    	movl   $0x2801cc,(%ebx)
	node->prev = list->tail;
  182c60:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182c65:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  182c68:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182c6d:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  182c6f:	89 1d d0 01 28 00    	mov    %ebx,0x2801d0
  182c75:	eb 7c                	jmp    182cf3 <k_timer_start+0x16f>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  182c77:	8b 50 04             	mov    0x4(%eax),%edx
  182c7a:	89 53 04             	mov    %edx,0x4(%ebx)
		node->next = insert_point;
  182c7d:	89 03                	mov    %eax,(%ebx)
		insert_point->prev->next = node;
  182c7f:	8b 50 04             	mov    0x4(%eax),%edx
  182c82:	89 1a                	mov    %ebx,(%edx)
		insert_point->prev = node;
  182c84:	89 58 04             	mov    %ebx,0x4(%eax)
  182c87:	eb 6a                	jmp    182cf3 <k_timer_start+0x16f>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  182c89:	29 ca                	sub    %ecx,%edx
  182c8b:	89 57 10             	mov    %edx,0x10(%edi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182c8e:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182c90:	85 c0                	test   %eax,%eax
  182c92:	74 0c                	je     182ca0 <k_timer_start+0x11c>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182c94:	3b 05 d0 01 28 00    	cmp    0x2801d0,%eax
  182c9a:	74 08                	je     182ca4 <k_timer_start+0x120>
  182c9c:	8b 08                	mov    (%eax),%ecx
  182c9e:	eb 09                	jmp    182ca9 <k_timer_start+0x125>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182ca0:	89 c1                	mov    %eax,%ecx
  182ca2:	eb 05                	jmp    182ca9 <k_timer_start+0x125>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182ca4:	b9 00 00 00 00       	mov    $0x0,%ecx
  182ca9:	85 c9                	test   %ecx,%ecx
  182cab:	74 1e                	je     182ccb <k_timer_start+0x147>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182cad:	85 d2                	test   %edx,%edx
  182caf:	74 0c                	je     182cbd <k_timer_start+0x139>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182cb1:	3b 15 d0 01 28 00    	cmp    0x2801d0,%edx
  182cb7:	74 0b                	je     182cc4 <k_timer_start+0x140>
  182cb9:	8b 00                	mov    (%eax),%eax
  182cbb:	eb 13                	jmp    182cd0 <k_timer_start+0x14c>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182cbd:	b8 00 00 00 00       	mov    $0x0,%eax
  182cc2:	eb 0c                	jmp    182cd0 <k_timer_start+0x14c>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  182cc9:	eb 05                	jmp    182cd0 <k_timer_start+0x14c>
  182ccb:	b8 00 00 00 00       	mov    $0x0,%eax
  182cd0:	85 c0                	test   %eax,%eax
  182cd2:	0f 85 6f ff ff ff    	jne    182c47 <k_timer_start+0xc3>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182cd8:	c7 03 cc 01 28 00    	movl   $0x2801cc,(%ebx)
	node->prev = list->tail;
  182cde:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182ce3:	89 43 04             	mov    %eax,0x4(%ebx)

	list->tail->next = node;
  182ce6:	a1 d0 01 28 00       	mov    0x2801d0,%eax
  182ceb:	89 18                	mov    %ebx,(%eax)
	list->tail = node;
  182ced:	89 1d d0 01 28 00    	mov    %ebx,0x2801d0
	timer->status = 0;
  182cf3:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  182cfa:	f7 c6 00 02 00 00    	test   $0x200,%esi
  182d00:	74 01                	je     182d03 <k_timer_start+0x17f>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182d02:	fb                   	sti    
	irq_unlock(key);
}
  182d03:	83 c4 08             	add    $0x8,%esp
  182d06:	5b                   	pop    %ebx
  182d07:	5e                   	pop    %esi
  182d08:	5f                   	pop    %edi
  182d09:	c3                   	ret    

00182d0a <_sys_power_save_idle>:
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
  182d0a:	e8 f9 ec ff ff       	call   181a08 <k_cpu_idle>
  182d0f:	c3                   	ret    

00182d10 <idle>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182d10:	9c                   	pushf  
  182d11:	fa                   	cli    
  182d12:	58                   	pop    %eax
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182d13:	a1 cc 01 28 00       	mov    0x2801cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182d18:	3d cc 01 28 00       	cmp    $0x2801cc,%eax
  182d1d:	75 05                	jne    182d24 <idle+0x14>
  182d1f:	b8 00 00 00 00       	mov    $0x0,%eax
static inline int32_t _get_next_timeout_expiry(void)
{
	struct _timeout *t = (struct _timeout *)
			     sys_dlist_peek_head(&_timeout_q);

	return t ? t->delta_ticks_from_prev : K_FOREVER;
  182d24:	85 c0                	test   %eax,%eax
  182d26:	74 05                	je     182d2d <idle+0x1d>
  182d28:	8b 40 10             	mov    0x10(%eax),%eax
  182d2b:	eb 05                	jmp    182d32 <idle+0x22>
  182d2d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	__idle_tsc = _tsc_read();
#endif

	for (;;) {
		(void)irq_lock();
		_sys_power_save_idle(_get_next_timeout_expiry());
  182d32:	e8 d3 ff ff ff       	call   182d0a <_sys_power_save_idle>

		IDLE_YIELD_IF_COOP();
	}
  182d37:	eb d7                	jmp    182d10 <idle>

00182d39 <_OffsetAbsSyms>:
/* tTaskStateSegment structure member offsets */


/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));
  182d39:	c3                   	ret    

00182d3a <__udivdi3>:
  182d3a:	55                   	push   %ebp
  182d3b:	57                   	push   %edi
  182d3c:	56                   	push   %esi
  182d3d:	53                   	push   %ebx
  182d3e:	83 ec 08             	sub    $0x8,%esp
  182d41:	89 c3                	mov    %eax,%ebx
  182d43:	89 d1                	mov    %edx,%ecx
  182d45:	89 d6                	mov    %edx,%esi
  182d47:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  182d4b:	8b 54 24 20          	mov    0x20(%esp),%edx
  182d4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  182d53:	89 1c 24             	mov    %ebx,(%esp)
  182d56:	89 c5                	mov    %eax,%ebp
  182d58:	85 d2                	test   %edx,%edx
  182d5a:	75 35                	jne    182d91 <__udivdi3+0x57>
  182d5c:	89 c7                	mov    %eax,%edi
  182d5e:	39 c8                	cmp    %ecx,%eax
  182d60:	76 0d                	jbe    182d6f <__udivdi3+0x35>
  182d62:	89 d8                	mov    %ebx,%eax
  182d64:	89 ca                	mov    %ecx,%edx
  182d66:	f7 f7                	div    %edi
  182d68:	89 c3                	mov    %eax,%ebx
  182d6a:	e9 a2 00 00 00       	jmp    182e11 <__udivdi3+0xd7>
  182d6f:	85 c0                	test   %eax,%eax
  182d71:	75 0b                	jne    182d7e <__udivdi3+0x44>
  182d73:	b8 01 00 00 00       	mov    $0x1,%eax
  182d78:	31 d2                	xor    %edx,%edx
  182d7a:	f7 f5                	div    %ebp
  182d7c:	89 c7                	mov    %eax,%edi
  182d7e:	89 c8                	mov    %ecx,%eax
  182d80:	31 d2                	xor    %edx,%edx
  182d82:	f7 f7                	div    %edi
  182d84:	89 c1                	mov    %eax,%ecx
  182d86:	89 d8                	mov    %ebx,%eax
  182d88:	f7 f7                	div    %edi
  182d8a:	89 c3                	mov    %eax,%ebx
  182d8c:	e9 82 00 00 00       	jmp    182e13 <__udivdi3+0xd9>
  182d91:	39 ca                	cmp    %ecx,%edx
  182d93:	77 76                	ja     182e0b <__udivdi3+0xd1>
  182d95:	0f bd fa             	bsr    %edx,%edi
  182d98:	83 f7 1f             	xor    $0x1f,%edi
  182d9b:	75 12                	jne    182daf <__udivdi3+0x75>
  182d9d:	31 c9                	xor    %ecx,%ecx
  182d9f:	39 f2                	cmp    %esi,%edx
  182da1:	72 05                	jb     182da8 <__udivdi3+0x6e>
  182da3:	3b 04 24             	cmp    (%esp),%eax
  182da6:	77 65                	ja     182e0d <__udivdi3+0xd3>
  182da8:	bb 01 00 00 00       	mov    $0x1,%ebx
  182dad:	eb 64                	jmp    182e13 <__udivdi3+0xd9>
  182daf:	b8 20 00 00 00       	mov    $0x20,%eax
  182db4:	89 f9                	mov    %edi,%ecx
  182db6:	29 f8                	sub    %edi,%eax
  182db8:	89 eb                	mov    %ebp,%ebx
  182dba:	d3 e2                	shl    %cl,%edx
  182dbc:	88 c1                	mov    %al,%cl
  182dbe:	d3 eb                	shr    %cl,%ebx
  182dc0:	89 f9                	mov    %edi,%ecx
  182dc2:	09 d3                	or     %edx,%ebx
  182dc4:	d3 e5                	shl    %cl,%ebp
  182dc6:	89 6c 24 04          	mov    %ebp,0x4(%esp)
  182dca:	88 c1                	mov    %al,%cl
  182dcc:	89 f5                	mov    %esi,%ebp
  182dce:	8b 14 24             	mov    (%esp),%edx
  182dd1:	d3 ed                	shr    %cl,%ebp
  182dd3:	89 f9                	mov    %edi,%ecx
  182dd5:	d3 e6                	shl    %cl,%esi
  182dd7:	88 c1                	mov    %al,%cl
  182dd9:	d3 ea                	shr    %cl,%edx
  182ddb:	09 d6                	or     %edx,%esi
  182ddd:	89 ea                	mov    %ebp,%edx
  182ddf:	89 f0                	mov    %esi,%eax
  182de1:	f7 f3                	div    %ebx
  182de3:	89 d5                	mov    %edx,%ebp
  182de5:	89 c6                	mov    %eax,%esi
  182de7:	89 c3                	mov    %eax,%ebx
  182de9:	f7 64 24 04          	mull   0x4(%esp)
  182ded:	89 44 24 04          	mov    %eax,0x4(%esp)
  182df1:	39 d5                	cmp    %edx,%ebp
  182df3:	72 11                	jb     182e06 <__udivdi3+0xcc>
  182df5:	8b 04 24             	mov    (%esp),%eax
  182df8:	89 f9                	mov    %edi,%ecx
  182dfa:	d3 e0                	shl    %cl,%eax
  182dfc:	3b 44 24 04          	cmp    0x4(%esp),%eax
  182e00:	73 0f                	jae    182e11 <__udivdi3+0xd7>
  182e02:	39 d5                	cmp    %edx,%ebp
  182e04:	75 0b                	jne    182e11 <__udivdi3+0xd7>
  182e06:	8d 5e ff             	lea    -0x1(%esi),%ebx
  182e09:	eb 06                	jmp    182e11 <__udivdi3+0xd7>
  182e0b:	31 c9                	xor    %ecx,%ecx
  182e0d:	31 db                	xor    %ebx,%ebx
  182e0f:	eb 02                	jmp    182e13 <__udivdi3+0xd9>
  182e11:	31 c9                	xor    %ecx,%ecx
  182e13:	89 d8                	mov    %ebx,%eax
  182e15:	89 ca                	mov    %ecx,%edx
  182e17:	83 c4 08             	add    $0x8,%esp
  182e1a:	5b                   	pop    %ebx
  182e1b:	5e                   	pop    %esi
  182e1c:	5f                   	pop    %edi
  182e1d:	5d                   	pop    %ebp
  182e1e:	c3                   	ret    

00182e1f <_handle_exc_0_vector_0_stub>:
  182e1f:	6a 00                	push   $0x0
  182e21:	68 82 1d 18 00       	push   $0x181d82
  182e26:	e9 5e ec ff ff       	jmp    181a89 <_exception_enter>

00182e2b <_handle_exc_2_vector_2_stub>:
  182e2b:	6a 00                	push   $0x0
  182e2d:	68 8e 1d 18 00       	push   $0x181d8e
  182e32:	e9 52 ec ff ff       	jmp    181a89 <_exception_enter>

00182e37 <_handle_exc_4_vector_4_stub>:
  182e37:	6a 00                	push   $0x0
  182e39:	68 9a 1d 18 00       	push   $0x181d9a
  182e3e:	e9 46 ec ff ff       	jmp    181a89 <_exception_enter>

00182e43 <_handle_exc_5_vector_5_stub>:
  182e43:	6a 00                	push   $0x0
  182e45:	68 a6 1d 18 00       	push   $0x181da6
  182e4a:	e9 3a ec ff ff       	jmp    181a89 <_exception_enter>

00182e4f <_handle_exc_6_vector_6_stub>:
  182e4f:	6a 00                	push   $0x0
  182e51:	68 b2 1d 18 00       	push   $0x181db2
  182e56:	e9 2e ec ff ff       	jmp    181a89 <_exception_enter>

00182e5b <_handle_exc_7_vector_7_stub>:
  182e5b:	6a 00                	push   $0x0
  182e5d:	68 be 1d 18 00       	push   $0x181dbe
  182e62:	e9 22 ec ff ff       	jmp    181a89 <_exception_enter>

00182e67 <_handle_exc_8_vector_8_stub>:
  182e67:	68 ca 1d 18 00       	push   $0x181dca
  182e6c:	e9 18 ec ff ff       	jmp    181a89 <_exception_enter>

00182e71 <_handle_exc_10_vector_10_stub>:
  182e71:	68 d6 1d 18 00       	push   $0x181dd6
  182e76:	e9 0e ec ff ff       	jmp    181a89 <_exception_enter>

00182e7b <_handle_exc_11_vector_11_stub>:
  182e7b:	68 e2 1d 18 00       	push   $0x181de2
  182e80:	e9 04 ec ff ff       	jmp    181a89 <_exception_enter>

00182e85 <_handle_exc_12_vector_12_stub>:
  182e85:	68 ee 1d 18 00       	push   $0x181dee
  182e8a:	e9 fa eb ff ff       	jmp    181a89 <_exception_enter>

00182e8f <_handle_exc_13_vector_13_stub>:
  182e8f:	68 fa 1d 18 00       	push   $0x181dfa
  182e94:	e9 f0 eb ff ff       	jmp    181a89 <_exception_enter>

00182e99 <_handle_exc_14_vector_14_stub>:
  182e99:	68 06 1e 18 00       	push   $0x181e06
  182e9e:	e9 e6 eb ff ff       	jmp    181a89 <_exception_enter>

00182ea3 <_handle_exc_16_vector_16_stub>:
  182ea3:	6a 00                	push   $0x0
  182ea5:	68 12 1e 18 00       	push   $0x181e12
  182eaa:	e9 da eb ff ff       	jmp    181a89 <_exception_enter>

00182eaf <_handle_exc_17_vector_17_stub>:
  182eaf:	68 1e 1e 18 00       	push   $0x181e1e
  182eb4:	e9 d0 eb ff ff       	jmp    181a89 <_exception_enter>

00182eb9 <_handle_exc_18_vector_18_stub>:
  182eb9:	6a 00                	push   $0x0
  182ebb:	68 2a 1e 18 00       	push   $0x181e2a
  182ec0:	e9 c4 eb ff ff       	jmp    181a89 <_exception_enter>
