
zephyr.elf:     ファイル形式 elf32-iamcu


セクション text の逆アセンブル:

00180000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  180000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  180003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  180008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  18000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  18000c:	0f 01 1d 4c 00 18 00 	lidtl  0x18004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  180013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  180016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  180019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
  18001c:	bc 04 02 28 00       	mov    $0x280204,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  180021:	81 c4 00 01 00 00    	add    $0x100,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
  180027:	bf 00 00 28 00       	mov    $0x280000,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
  18002c:	be 08 22 18 00       	mov    $0x182208,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
  180031:	b9 25 00 00 00       	mov    $0x25,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
  180036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  180038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  18003a:	bf a0 00 28 00       	mov    $0x2800a0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  18003f:	b9 59 00 00 00       	mov    $0x59,%ecx
	cld
  180044:	fc                   	cld    
	rep
  180045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  180047:	e9 ba 10 00 00       	jmp    181106 <_Cstart>

0018004c <_Idt>:
  18004c:	ff 01 08 20 18 00 66 90 66 90 66 90 66 90 66 90     ... ..f.f.f.f.f.
  18005c:	66 90 66 90                                         f.f.

00180060 <_thread_entry_wrapper>:
  180060:	58                   	pop    %eax
  180061:	5a                   	pop    %edx
  180062:	59                   	pop    %ecx
  180063:	6a 00                	push   $0x0
  180065:	e9 09 18 00 00       	jmp    181873 <_thread_entry>

0018006a <main>:

/* 1000 msec = 1 sec */
#define SLEEP_TIME 	1000

void main(void)
{
  18006a:	53                   	push   %ebx
	struct device *uart_dev;

	uart_dev = device_get_binding("UART_0");
  18006b:	b8 00 1c 18 00       	mov    $0x181c00,%eax
  180070:	e8 21 0f 00 00       	call   180f96 <device_get_binding>
  180075:	89 c3                	mov    %eax,%ebx
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  180077:	8b 4b 04             	mov    0x4(%ebx),%ecx

	return api->poll_out(dev, out_char);
  18007a:	ba 61 00 00 00       	mov    $0x61,%edx
  18007f:	89 d8                	mov    %ebx,%eax
  180081:	ff 51 04             	call   *0x4(%ecx)

	while(1)
	{
		uart_poll_out(uart_dev, 'a');

		k_sleep(SLEEP_TIME);
  180084:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  180089:	e8 81 12 00 00       	call   18130f <k_sleep>
  18008e:	eb e7                	jmp    180077 <main+0xd>

00180090 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  180090:	53                   	push   %ebx
  180091:	89 c3                	mov    %eax,%ebx
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  180093:	83 f8 0a             	cmp    $0xa,%eax
  180096:	75 10                	jne    1800a8 <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
  180098:	a1 a0 00 28 00       	mov    0x2800a0,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  18009d:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  1800a0:	ba 0d 00 00 00       	mov    $0xd,%edx
  1800a5:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
  1800a8:	a1 a0 00 28 00       	mov    0x2800a0,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  1800ad:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  1800b0:	0f b6 d3             	movzbl %bl,%edx
  1800b3:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
  1800b6:	89 d8                	mov    %ebx,%eax
  1800b8:	5b                   	pop    %ebx
  1800b9:	c3                   	ret    

001800ba <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
  1800ba:	b8 90 00 18 00       	mov    $0x180090,%eax
  1800bf:	e8 c4 04 00 00       	call   180588 <__printk_hook_install>
  1800c4:	c3                   	ret    

001800c5 <uart_console_init>:
static int uart_console_init(struct device *arg)
{

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  1800c5:	b8 00 1c 18 00       	mov    $0x181c00,%eax
  1800ca:	e8 c7 0e 00 00       	call   180f96 <device_get_binding>
  1800cf:	a3 a0 00 28 00       	mov    %eax,0x2800a0
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  1800d4:	e8 e1 ff ff ff       	call   1800ba <uart_console_hook_install>

	return 0;
}
  1800d9:	b8 00 00 00 00       	mov    $0x0,%eax
  1800de:	c3                   	ret    

001800df <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
  1800df:	56                   	push   %esi
  1800e0:	53                   	push   %ebx
  1800e1:	83 ec 0c             	sub    $0xc,%esp
  1800e4:	89 c6                	mov    %eax,%esi
	const struct uart_qmsi_config_info *config = dev->config->config_info;
  1800e6:	8b 00                	mov    (%eax),%eax
  1800e8:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
  1800eb:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
	cfg.baud_divisor = config->baud_divisor;
  1800f2:	8b 43 08             	mov    0x8(%ebx),%eax
  1800f5:	89 44 24 04          	mov    %eax,0x4(%esp)
	cfg.hw_fc = config->hw_fc;
  1800f9:	8a 43 0c             	mov    0xc(%ebx),%al
  1800fc:	88 44 24 08          	mov    %al,0x8(%esp)

	clk_periph_enable(config->clock_gate);
  180100:	8b 43 04             	mov    0x4(%ebx),%eax
  180103:	e8 e8 06 00 00       	call   1807f0 <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
  180108:	89 e2                	mov    %esp,%edx
  18010a:	8b 03                	mov    (%ebx),%eax
  18010c:	e8 cb 07 00 00       	call   1808dc <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
  180111:	c7 46 04 2c 1c 18 00 	movl   $0x181c2c,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  180118:	b8 00 00 00 00       	mov    $0x0,%eax
  18011d:	83 c4 0c             	add    $0xc,%esp
  180120:	5b                   	pop    %ebx
  180121:	5e                   	pop    %esi
  180122:	c3                   	ret    

00180123 <uart_qmsi_err_check>:
	qm_uart_write(instance, data);
	return data;
}

static int uart_qmsi_err_check(struct device *dev)
{
  180123:	83 ec 04             	sub    $0x4,%esp
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180126:	8b 00                	mov    (%eax),%eax
  180128:	8b 40 08             	mov    0x8(%eax),%eax
  18012b:	8b 00                	mov    (%eax),%eax

	/* QMSI and Zephyr use the same bits to represent UART errors
	 * so we don't need to translate each error bit from QMSI API
	 * to Zephyr API.
	 */
	qm_uart_get_status(instance, &status);
  18012d:	89 e2                	mov    %esp,%edx
  18012f:	e8 1b 08 00 00       	call   18094f <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
  180134:	8b 04 24             	mov    (%esp),%eax
  180137:	83 e0 1e             	and    $0x1e,%eax
}
  18013a:	83 c4 04             	add    $0x4,%esp
  18013d:	c3                   	ret    

0018013e <uart_qmsi_poll_out>:
	return 0;
}

static unsigned char uart_qmsi_poll_out(struct device *dev,
					unsigned char data)
{
  18013e:	53                   	push   %ebx
  18013f:	89 d3                	mov    %edx,%ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180141:	8b 00                	mov    (%eax),%eax
  180143:	8b 40 08             	mov    0x8(%eax),%eax
  180146:	8b 00                	mov    (%eax),%eax

	qm_uart_write(instance, data);
  180148:	0f b6 d2             	movzbl %dl,%edx
  18014b:	e8 42 08 00 00       	call   180992 <qm_uart_write>
	return data;
}
  180150:	88 d8                	mov    %bl,%al
  180152:	5b                   	pop    %ebx
  180153:	c3                   	ret    

00180154 <uart_qmsi_poll_in>:
	      uart_qmsi_device_ctrl, &drv_data_1, &config_info_1, PRE_KERNEL_1,
	      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL);
#endif /* CONFIG_UART_QMSI_1 */

static int uart_qmsi_poll_in(struct device *dev, unsigned char *data)
{
  180154:	56                   	push   %esi
  180155:	53                   	push   %ebx
  180156:	83 ec 04             	sub    $0x4,%esp
  180159:	89 d6                	mov    %edx,%esi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18015b:	8b 00                	mov    (%eax),%eax
  18015d:	8b 40 08             	mov    0x8(%eax),%eax
  180160:	8b 18                	mov    (%eax),%ebx
	qm_uart_status_t status;

	qm_uart_get_status(instance, &status);
  180162:	89 e2                	mov    %esp,%edx
  180164:	89 d8                	mov    %ebx,%eax
  180166:	e8 e4 07 00 00       	call   18094f <qm_uart_get_status>
	/* In order to check if there is any data to read from UART
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
  18016b:	f6 04 24 40          	testb  $0x40,(%esp)
  18016f:	74 15                	je     180186 <uart_qmsi_poll_in+0x32>
		return -1;

	qm_uart_read(instance, data, NULL);
  180171:	b9 00 00 00 00       	mov    $0x0,%ecx
  180176:	89 f2                	mov    %esi,%edx
  180178:	89 d8                	mov    %ebx,%eax
  18017a:	e8 35 08 00 00       	call   1809b4 <qm_uart_read>
	return 0;
  18017f:	b8 00 00 00 00       	mov    $0x0,%eax
  180184:	eb 05                	jmp    18018b <uart_qmsi_poll_in+0x37>
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
		return -1;
  180186:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	qm_uart_read(instance, data, NULL);
	return 0;
}
  18018b:	83 c4 04             	add    $0x4,%esp
  18018e:	5b                   	pop    %ebx
  18018f:	5e                   	pop    %esi
  180190:	c3                   	ret    

00180191 <_timer_int_handler>:
		timer_mode = TIMER_MODE_PERIODIC;
	}

	_sys_clock_final_tick_announce();
#else
	_sys_clock_tick_announce();
  180191:	a1 20 00 28 00       	mov    0x280020,%eax
  180196:	e8 15 13 00 00       	call   1814b0 <_nano_sys_clock_tick_announce>
  18019b:	c3                   	ret    

0018019c <_sys_clock_driver_init>:
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
  18019c:	a1 24 00 28 00       	mov    0x280024,%eax
  1801a1:	48                   	dec    %eax
 * @param count Count from which timer is to count down
 * @return N/A
 */
static inline void initial_count_register_set(uint32_t count)
{
	*_REG_TIMER_ICR = count;
  1801a2:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
 *
 * @return N/A
 */
static inline void periodic_mode_set(void)
{
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
  1801a7:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
  1801ac:	0d 00 00 02 00       	or     $0x20000,%eax
  1801b1:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  1801b6:	b9 00 00 00 00       	mov    $0x0,%ecx
  1801bb:	ba 0a 00 00 00       	mov    $0xa,%edx
  1801c0:	b8 2a 00 00 00       	mov    $0x2a,%eax
  1801c5:	e8 e0 00 00 00       	call   1802aa <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
  1801ca:	b8 0a 00 00 00       	mov    $0xa,%eax
  1801cf:	e8 b1 00 00 00       	call   180285 <_arch_irq_enable>

	return 0;
}
  1801d4:	b8 00 00 00 00       	mov    $0x0,%eax
  1801d9:	c3                   	ret    

001801da <_timer_int_handler_irq10_stub>:
	initial_count_register_set(cycles_per_tick - 1);
	periodic_mode_set();
#ifdef CONFIG_DEVICE_POWER_MANAGEMENT
	loapic_timer_device_power_state = DEVICE_PM_ACTIVE_STATE;
#endif
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);
  1801da:	6a 00                	push   $0x0
  1801dc:	68 91 01 18 00       	push   $0x180191
  1801e1:	e9 34 0a 00 00       	jmp    180c1a <_interrupt_enter>

001801e6 <qm_wdt_0_isr_irq16_stub>:
  1801e6:	6a 00                	push   $0x0
  1801e8:	68 18 08 18 00       	push   $0x180818
  1801ed:	e9 28 0a 00 00       	jmp    180c1a <_interrupt_enter>

001801f2 <_mvic_rte_set>:
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  1801f2:	89 c1                	mov    %eax,%ecx
  1801f4:	83 e1 07             	and    $0x7,%ecx
  1801f7:	01 c9                	add    %ecx,%ecx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  1801f9:	83 e0 18             	and    $0x18,%eax
  1801fc:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  1801ff:	09 c8                	or     %ecx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  180201:	9c                   	pushf  
  180202:	fa                   	cli    
  180203:	59                   	pop    %ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180204:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
  180209:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  18020f:	f6 c5 02             	test   $0x2,%ch
  180212:	74 01                	je     180215 <_mvic_rte_set+0x23>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  180214:	fb                   	sti    
  180215:	c3                   	ret    

00180216 <_mvic_rte_update>:
 * @param mask of bits to be modified
 *
 * @returns N/A
 */
static void _mvic_rte_update(unsigned int irq, uint32_t value, uint32_t mask)
{
  180216:	53                   	push   %ebx
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  180217:	89 c3                	mov    %eax,%ebx
  180219:	83 e3 07             	and    $0x7,%ebx
  18021c:	01 db                	add    %ebx,%ebx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  18021e:	83 e0 18             	and    $0x18,%eax
  180221:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  180224:	09 d8                	or     %ebx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  180226:	9c                   	pushf  
  180227:	fa                   	cli    
  180228:	5b                   	pop    %ebx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180229:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  18022e:	a1 10 00 c0 fe       	mov    0xfec00010,%eax
	key = irq_lock();

	sys_write32(regsel, MVIC_IOREGSEL);

	old_value = sys_read32(MVIC_IOWIN);
	updated_value = (old_value & ~mask) | (value & mask);
  180233:	31 c2                	xor    %eax,%edx
  180235:	21 d1                	and    %edx,%ecx
  180237:	31 c8                	xor    %ecx,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180239:	a3 10 00 c0 fe       	mov    %eax,0xfec00010
  18023e:	f6 c7 02             	test   $0x2,%bh
  180241:	74 01                	je     180244 <_mvic_rte_update+0x2e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  180243:	fb                   	sti    
	sys_write32(updated_value, MVIC_IOWIN);

	irq_unlock(key);
}
  180244:	5b                   	pop    %ebx
  180245:	c3                   	ret    

00180246 <_mvic_init>:
 * This routine replaces the standard Local APIC / IO APIC init routines.
 *
 * @returns: N/A
 */
static int _mvic_init(struct device *unused)
{
  180246:	53                   	push   %ebx
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  180247:	bb 00 00 00 00       	mov    $0x0,%ebx
  18024c:	eb 0d                	jmp    18025b <_mvic_init+0x15>
		_mvic_rte_set(i, MVIC_IOWIN_MASK);
  18024e:	ba 00 00 01 00       	mov    $0x10000,%edx
  180253:	89 d8                	mov    %ebx,%eax
  180255:	e8 98 ff ff ff       	call   1801f2 <_mvic_rte_set>
{
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  18025a:	43                   	inc    %ebx
  18025b:	83 fb 1f             	cmp    $0x1f,%ebx
  18025e:	7e ee                	jle    18024e <_mvic_init+0x8>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180260:	b8 00 00 00 00       	mov    $0x0,%eax
  180265:	a3 80 00 e0 fe       	mov    %eax,0xfee00080
  18026a:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
  18026f:	b8 0a 00 01 00       	mov    $0x1000a,%eax
  180274:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180279:	b8 00 00 00 00       	mov    $0x0,%eax
  18027e:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	/* discard a pending interrupt if any */
	sys_write32(0, MVIC_EOI);

	return 0;

}
  180283:	5b                   	pop    %ebx
  180284:	c3                   	ret    

00180285 <_arch_irq_enable>:
SYS_INIT(_mvic_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


void _arch_irq_enable(unsigned int irq)
{
	if (irq == CONFIG_MVIC_TIMER_IRQ) {
  180285:	83 f8 0a             	cmp    $0xa,%eax
  180288:	75 10                	jne    18029a <_arch_irq_enable+0x15>
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  18028a:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
		sys_write32(sys_read32(MVIC_LVTTIMER) & ~MVIC_LVTTIMER_MASK,
  18028f:	25 ff ff fe ff       	and    $0xfffeffff,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  180294:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180299:	c3                   	ret    
			    MVIC_LVTTIMER);
	} else {
		_mvic_rte_update(irq, 0, MVIC_IOWIN_MASK);
  18029a:	b9 00 00 01 00       	mov    $0x10000,%ecx
  18029f:	ba 00 00 00 00       	mov    $0x0,%edx
  1802a4:	e8 6d ff ff ff       	call   180216 <_mvic_rte_update>
  1802a9:	c3                   	ret    

001802aa <__irq_controller_irq_config>:

	/* Vector argument always ignored. There are no triggering options
	 * for the timer, so nothing to do at all for that case. Other I/O
	 * interrupts need their triggering set
	 */
	if (irq != CONFIG_MVIC_TIMER_IRQ) {
  1802aa:	83 fa 0a             	cmp    $0xa,%edx
  1802ad:	74 0f                	je     1802be <__irq_controller_irq_config+0x14>
  1802af:	89 d0                	mov    %edx,%eax
		_mvic_rte_set(irq, MVIC_IOWIN_MASK | flags);
  1802b1:	81 c9 00 00 01 00    	or     $0x10000,%ecx
  1802b7:	89 ca                	mov    %ecx,%edx
  1802b9:	e8 34 ff ff ff       	call   1801f2 <_mvic_rte_set>
  1802be:	c3                   	ret    

001802bf <__irq_controller_isr_vector_get>:
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1802bf:	a1 10 01 e0 fe       	mov    0xfee00110,%eax
{
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
  1802c4:	85 c0                	test   %eax,%eax
  1802c6:	74 0e                	je     1802d6 <__irq_controller_isr_vector_get+0x17>

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  1802c8:	0f bd c0             	bsr    %eax,%eax
  1802cb:	75 05                	jne    1802d2 <__irq_controller_isr_vector_get+0x13>
  1802cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		return -1;
	}
	return 32 + (find_msb_set(isr) - 1);
  1802d2:	83 c0 20             	add    $0x20,%eax
  1802d5:	c3                   	ret    
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
		return -1;
  1802d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
	return 32 + (find_msb_set(isr) - 1);
}
  1802db:	c3                   	ret    

001802dc <get_config>:

static void (*user_cb)(struct device *dev);

static void get_config(struct device *dev, struct wdt_config *cfg)
{
	cfg->timeout = QM_WDT[QM_WDT_0]->wdt_torr;
  1802dc:	a1 14 00 28 00       	mov    0x280014,%eax
  1802e1:	8b 40 04             	mov    0x4(%eax),%eax
  1802e4:	89 02                	mov    %eax,(%edx)
	cfg->mode = ((QM_WDT[QM_WDT_0]->wdt_cr & QM_WDT_CR_RMOD) >>
  1802e6:	a1 14 00 28 00       	mov    0x280014,%eax
  1802eb:	8b 00                	mov    (%eax),%eax
  1802ed:	83 e0 02             	and    $0x2,%eax
  1802f0:	d1 e8                	shr    %eax
  1802f2:	89 42 04             	mov    %eax,0x4(%edx)
			QM_WDT_CR_RMOD_OFFSET);
	cfg->interrupt_fn = user_cb;
  1802f5:	a1 b4 00 28 00       	mov    0x2800b4,%eax
  1802fa:	89 42 08             	mov    %eax,0x8(%edx)
  1802fd:	c3                   	ret    

001802fe <init>:
  1802fe:	b9 00 00 00 00       	mov    $0x0,%ecx
  180303:	ba 10 00 00 00       	mov    $0x10,%edx
  180308:	b8 30 00 00 00       	mov    $0x30,%eax
  18030d:	e8 98 ff ff ff       	call   1802aa <__irq_controller_irq_config>

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_WDT_0_INT), CONFIG_WDT_0_IRQ_PRI,
		    qm_wdt_0_isr, 0, IOAPIC_EDGE | IOAPIC_HIGH);

	/* Unmask watchdog interrupt */
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_WDT_0_INT));
  180312:	b8 10 00 00 00       	mov    $0x10,%eax
  180317:	e8 69 ff ff ff       	call   180285 <_arch_irq_enable>

	/* Route watchdog interrupt to the current core */
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->wdt_0_int_mask);
  18031c:	a1 7c 04 80 b0       	mov    0xb080047c,%eax
  180321:	83 e0 fe             	and    $0xfffffffe,%eax
  180324:	a3 7c 04 80 b0       	mov    %eax,0xb080047c

	wdt_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  180329:	b8 00 00 00 00       	mov    $0x0,%eax
  18032e:	c3                   	ret    

0018032f <reload>:
	return ret_val;
}

static void reload(struct device *dev)
{
	qm_wdt_reload(QM_WDT_0);
  18032f:	b8 00 00 00 00       	mov    $0x0,%eax
  180334:	e8 f9 04 00 00       	call   180832 <qm_wdt_reload>
  180339:	c3                   	ret    

0018033a <set_config>:
			QM_WDT_CR_RMOD_OFFSET);
	cfg->interrupt_fn = user_cb;
}

static int set_config(struct device *dev, struct wdt_config *cfg)
{
  18033a:	53                   	push   %ebx
  18033b:	83 ec 10             	sub    $0x10,%esp
	int ret_val = 0;
	qm_wdt_config_t qm_cfg;

	user_cb = cfg->interrupt_fn;
  18033e:	8b 4a 08             	mov    0x8(%edx),%ecx
  180341:	89 0d b4 00 28 00    	mov    %ecx,0x2800b4
	qm_cfg.timeout = cfg->timeout;
  180347:	8b 1a                	mov    (%edx),%ebx
  180349:	89 1c 24             	mov    %ebx,(%esp)
	qm_cfg.mode = (cfg->mode == WDT_MODE_RESET) ?
			QM_WDT_MODE_RESET : QM_WDT_MODE_INTERRUPT_RESET;
  18034c:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  180350:	0f 95 c2             	setne  %dl
  180353:	0f b6 d2             	movzbl %dl,%edx
	int ret_val = 0;
	qm_wdt_config_t qm_cfg;

	user_cb = cfg->interrupt_fn;
	qm_cfg.timeout = cfg->timeout;
	qm_cfg.mode = (cfg->mode == WDT_MODE_RESET) ?
  180356:	89 54 24 04          	mov    %edx,0x4(%esp)
			QM_WDT_MODE_RESET : QM_WDT_MODE_INTERRUPT_RESET;
	qm_cfg.callback = (void *)user_cb;
  18035a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	qm_cfg.callback_data = dev;
  18035e:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if (IS_ENABLED(CONFIG_WDT_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(dev), K_FOREVER);
	}

	if (qm_wdt_set_config(QM_WDT_0, &qm_cfg)) {
  180362:	89 e2                	mov    %esp,%edx
  180364:	b8 00 00 00 00       	mov    $0x0,%eax
  180369:	e8 0e 05 00 00       	call   18087c <qm_wdt_set_config>
  18036e:	85 c0                	test   %eax,%eax
  180370:	75 0b                	jne    18037d <set_config+0x43>
		ret_val = -EIO;
		goto wdt_config_return;
	}

	if (qm_wdt_start(QM_WDT_0)) {
  180372:	e8 cf 04 00 00       	call   180846 <qm_wdt_start>
  180377:	85 c0                	test   %eax,%eax
  180379:	75 09                	jne    180384 <set_config+0x4a>
  18037b:	eb 0c                	jmp    180389 <set_config+0x4f>
	if (IS_ENABLED(CONFIG_WDT_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(dev), K_FOREVER);
	}

	if (qm_wdt_set_config(QM_WDT_0, &qm_cfg)) {
		ret_val = -EIO;
  18037d:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  180382:	eb 05                	jmp    180389 <set_config+0x4f>
		goto wdt_config_return;
	}

	if (qm_wdt_start(QM_WDT_0)) {
		ret_val = -EIO;
  180384:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	if (IS_ENABLED(CONFIG_WDT_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(dev));
	}

	return ret_val;
}
  180389:	83 c4 10             	add    $0x10,%esp
  18038c:	5b                   	pop    %ebx
  18038d:	c3                   	ret    

0018038e <disable>:
	clk_periph_enable(CLK_PERIPH_WDT_REGISTER | CLK_PERIPH_CLK);
}

static void disable(struct device *dev)
{
	clk_periph_disable(CLK_PERIPH_WDT_REGISTER);
  18038e:	b8 00 04 00 00       	mov    $0x400,%eax
  180393:	e8 6b 04 00 00       	call   180803 <clk_periph_disable>
  180398:	c3                   	ret    

00180399 <enable>:
	qm_wdt_reload(QM_WDT_0);
}

static void enable(struct device *dev)
{
	clk_periph_enable(CLK_PERIPH_WDT_REGISTER | CLK_PERIPH_CLK);
  180399:	b8 02 04 00 00       	mov    $0x402,%eax
  18039e:	e8 4d 04 00 00       	call   1807f0 <clk_periph_enable>
  1803a3:	c3                   	ret    

001803a4 <pinmux_get>:
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_get(struct device *dev, uint32_t pin,
			  uint32_t *func)
{
  1803a4:	56                   	push   %esi
  1803a5:	53                   	push   %ebx
  1803a6:	89 cb                	mov    %ecx,%ebx
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
  1803a8:	89 d6                	mov    %edx,%esi
  1803aa:	c1 ee 04             	shr    $0x4,%esi

	/* The pin offset within the register */
	uint32_t pin_no = pin % 16;
  1803ad:	83 e2 0f             	and    $0xf,%edx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
  1803b0:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  1803b3:	b8 03 00 00 00       	mov    $0x3,%eax
  1803b8:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
  1803ba:	8b 14 b5 30 09 80 b0 	mov    -0x4f7ff6d0(,%esi,4),%edx
  1803c1:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
  1803c3:	d3 e8                	shr    %cl,%eax

	*func = mode;
  1803c5:	89 03                	mov    %eax,(%ebx)

	return 0;
}
  1803c7:	b8 00 00 00 00       	mov    $0x0,%eax
  1803cc:	5b                   	pop    %ebx
  1803cd:	5e                   	pop    %esi
  1803ce:	c3                   	ret    

001803cf <pinmux_initialize>:
};

static int pinmux_initialize(struct device *port)
{
	return 0;
}
  1803cf:	b8 00 00 00 00       	mov    $0x0,%eax
  1803d4:	c3                   	ret    

001803d5 <pinmux_input>:
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_input(struct device *dev, uint32_t pin,
			    uint8_t func)
{
  1803d5:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
  1803d7:	84 c9                	test   %cl,%cl
  1803d9:	0f 95 c2             	setne  %dl
  1803dc:	0f b6 d2             	movzbl %dl,%edx
  1803df:	e8 a5 06 00 00       	call   180a89 <qm_pmux_input_en>
  1803e4:	85 c0                	test   %eax,%eax
  1803e6:	74 05                	je     1803ed <pinmux_input+0x18>
  1803e8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  1803ed:	c3                   	ret    

001803ee <pinmux_pullup>:
	return 0;
}

static int pinmux_pullup(struct device *dev, uint32_t pin,
			     uint8_t func)
{
  1803ee:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
  1803f0:	84 c9                	test   %cl,%cl
  1803f2:	0f 95 c2             	setne  %dl
  1803f5:	0f b6 d2             	movzbl %dl,%edx
  1803f8:	e8 ed 06 00 00       	call   180aea <qm_pmux_pullup_en>
  1803fd:	85 c0                	test   %eax,%eax
  1803ff:	74 05                	je     180406 <pinmux_pullup+0x18>
  180401:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180406:	c3                   	ret    

00180407 <pinmux_set>:

#define MASK_2_BITS	0x3

static int pinmux_set(struct device *dev, uint32_t pin,
			  uint32_t func)
{
  180407:	89 d0                	mov    %edx,%eax
  180409:	89 ca                	mov    %ecx,%edx
	ARG_UNUSED(dev);

	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
  18040b:	e8 21 06 00 00       	call   180a31 <qm_pmux_select>
  180410:	85 c0                	test   %eax,%eax
  180412:	74 05                	je     180419 <pinmux_set+0x12>
  180414:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180419:	c3                   	ret    

0018041a <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  18041a:	53                   	push   %ebx
	while ((*s1 == *s2) && (*s1 != '\0')) {
  18041b:	eb 02                	jmp    18041f <strcmp+0x5>
		s1++;
  18041d:	40                   	inc    %eax
		s2++;
  18041e:	42                   	inc    %edx
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
  18041f:	8a 08                	mov    (%eax),%cl
  180421:	8a 1a                	mov    (%edx),%bl
  180423:	38 d9                	cmp    %bl,%cl
  180425:	75 04                	jne    18042b <strcmp+0x11>
  180427:	84 c9                	test   %cl,%cl
  180429:	75 f2                	jne    18041d <strcmp+0x3>
		s1++;
		s2++;
	}

	return *s1 - *s2;
  18042b:	0f be c1             	movsbl %cl,%eax
  18042e:	0f be db             	movsbl %bl,%ebx
  180431:	29 d8                	sub    %ebx,%eax
}
  180433:	5b                   	pop    %ebx
  180434:	c3                   	ret    

00180435 <_nop_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  180435:	b8 00 00 00 00       	mov    $0x0,%eax
  18043a:	c3                   	ret    

0018043b <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
  18043b:	8b 0a                	mov    (%edx),%ecx
  18043d:	41                   	inc    %ecx
  18043e:	89 0a                	mov    %ecx,(%edx)
	return _char_out(c);
  180440:	ff 15 10 00 28 00    	call   *0x280010
}
  180446:	c3                   	ret    

00180447 <_printk_hex_ulong>:
 * @return N/A
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  180447:	55                   	push   %ebp
  180448:	57                   	push   %edi
  180449:	56                   	push   %esi
  18044a:	53                   	push   %ebx
  18044b:	83 ec 08             	sub    $0x8,%esp
  18044e:	89 c5                	mov    %eax,%ebp
  180450:	89 14 24             	mov    %edx,(%esp)
  180453:	89 cf                	mov    %ecx,%edi
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
  180455:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  18045c:	00 
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
  18045d:	bb 00 00 00 00       	mov    $0x0,%ebx
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
  180462:	ba 08 00 00 00       	mov    $0x8,%edx
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  180467:	eb 65                	jmp    1804ce <_printk_hex_ulong+0x87>
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  180469:	8d 72 ff             	lea    -0x1(%edx),%esi
  18046c:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  180473:	89 f8                	mov    %edi,%eax
  180475:	d3 e8                	shr    %cl,%eax

		if (nibble || found_largest_digit || size == 1) {
  180477:	83 e0 0f             	and    $0xf,%eax
  18047a:	0f 95 c1             	setne  %cl
  18047d:	08 d9                	or     %bl,%cl
  18047f:	75 05                	jne    180486 <_printk_hex_ulong+0x3f>
  180481:	83 fa 01             	cmp    $0x1,%edx
  180484:	75 1b                	jne    1804a1 <_printk_hex_ulong+0x5a>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
  180486:	3c 09                	cmp    $0x9,%al
  180488:	7e 04                	jle    18048e <_printk_hex_ulong+0x47>
  18048a:	b2 57                	mov    $0x57,%dl
  18048c:	eb 02                	jmp    180490 <_printk_hex_ulong+0x49>
  18048e:	b2 30                	mov    $0x30,%dl
  180490:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
  180492:	0f be c0             	movsbl %al,%eax
  180495:	8b 14 24             	mov    (%esp),%edx
  180498:	ff d5                	call   *%ebp

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  18049a:	bb 01 00 00 00       	mov    $0x1,%ebx
			nibble += nibble > 9 ? 87 : 48;
			out((int)nibble, ctx);
			continue;
  18049f:	eb 2b                	jmp    1804cc <_printk_hex_ulong+0x85>
		}

		if (remaining-- <= min_width) {
  1804a1:	8b 44 24 04          	mov    0x4(%esp),%eax
  1804a5:	8d 48 ff             	lea    -0x1(%eax),%ecx
  1804a8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1804ac:	3b 44 24 20          	cmp    0x20(%esp),%eax
  1804b0:	7f 1a                	jg     1804cc <_printk_hex_ulong+0x85>
			out((int)(pad_zero ? '0' : ' '), ctx);
  1804b2:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  1804b7:	74 07                	je     1804c0 <_printk_hex_ulong+0x79>
  1804b9:	b8 30 00 00 00       	mov    $0x30,%eax
  1804be:	eb 05                	jmp    1804c5 <_printk_hex_ulong+0x7e>
  1804c0:	b8 20 00 00 00       	mov    $0x20,%eax
  1804c5:	8b 14 24             	mov    (%esp),%edx
  1804c8:	ff d5                	call   *%ebp
  1804ca:	eb 00                	jmp    1804cc <_printk_hex_ulong+0x85>

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  1804cc:	89 f2                	mov    %esi,%edx
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  1804ce:	85 d2                	test   %edx,%edx
  1804d0:	75 97                	jne    180469 <_printk_hex_ulong+0x22>

		if (remaining-- <= min_width) {
			out((int)(pad_zero ? '0' : ' '), ctx);
		}
	}
}
  1804d2:	83 c4 08             	add    $0x8,%esp
  1804d5:	5b                   	pop    %ebx
  1804d6:	5e                   	pop    %esi
  1804d7:	5f                   	pop    %edi
  1804d8:	5d                   	pop    %ebp
  1804d9:	c3                   	ret    

001804da <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  1804da:	55                   	push   %ebp
  1804db:	57                   	push   %edi
  1804dc:	56                   	push   %esi
  1804dd:	53                   	push   %ebx
  1804de:	83 ec 08             	sub    $0x8,%esp
  1804e1:	89 c5                	mov    %eax,%ebp
  1804e3:	89 54 24 04          	mov    %edx,0x4(%esp)
	unsigned long remainder = num;
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  1804e7:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  1804ec:	7f 08                	jg     1804f6 <_printk_dec_ulong+0x1c>
		min_width = 1;
  1804ee:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  1804f5:	00 
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  1804f6:	89 0c 24             	mov    %ecx,(%esp)
  1804f9:	bf 0a 00 00 00       	mov    $0xa,%edi
  1804fe:	bb 00 00 00 00       	mov    $0x0,%ebx
  180503:	be ff c9 9a 3b       	mov    $0x3b9ac9ff,%esi
  180508:	eb 65                	jmp    18056f <_printk_dec_ulong+0x95>
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  18050a:	3b 34 24             	cmp    (%esp),%esi
  18050d:	0f 92 c0             	setb   %al
  180510:	08 d8                	or     %bl,%al
  180512:	74 1d                	je     180531 <_printk_dec_ulong+0x57>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
  180514:	8d 4e 01             	lea    0x1(%esi),%ecx
  180517:	8b 04 24             	mov    (%esp),%eax
  18051a:	ba 00 00 00 00       	mov    $0x0,%edx
  18051f:	f7 f1                	div    %ecx
  180521:	83 c0 30             	add    $0x30,%eax
  180524:	8b 54 24 04          	mov    0x4(%esp),%edx
  180528:	ff d5                	call   *%ebp
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  18052a:	bb 01 00 00 00       	mov    $0x1,%ebx
  18052f:	eb 1f                	jmp    180550 <_printk_dec_ulong+0x76>
			out((int)((remainder / (pos + 1)) + 48), ctx);
		} else if (remaining <= min_width) {
  180531:	3b 7c 24 20          	cmp    0x20(%esp),%edi
  180535:	7f 19                	jg     180550 <_printk_dec_ulong+0x76>
			out((int)(pad_zero ? '0' : ' '), ctx);
  180537:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  18053c:	74 07                	je     180545 <_printk_dec_ulong+0x6b>
  18053e:	b8 30 00 00 00       	mov    $0x30,%eax
  180543:	eb 05                	jmp    18054a <_printk_dec_ulong+0x70>
  180545:	b8 20 00 00 00       	mov    $0x20,%eax
  18054a:	8b 54 24 04          	mov    0x4(%esp),%edx
  18054e:	ff d5                	call   *%ebp
		}
		remaining--;
  180550:	4f                   	dec    %edi
		remainder %= (pos + 1);
  180551:	8d 4e 01             	lea    0x1(%esi),%ecx
  180554:	8b 04 24             	mov    (%esp),%eax
  180557:	ba 00 00 00 00       	mov    $0x0,%edx
  18055c:	f7 f1                	div    %ecx
  18055e:	89 14 24             	mov    %edx,(%esp)
		pos /= 10;
  180561:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  180566:	89 f0                	mov    %esi,%eax
  180568:	f7 e2                	mul    %edx
  18056a:	89 d6                	mov    %edx,%esi
  18056c:	c1 ee 03             	shr    $0x3,%esi
	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
  18056f:	83 fe 08             	cmp    $0x8,%esi
  180572:	77 96                	ja     18050a <_printk_dec_ulong+0x30>
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
	}
	out((int)(remainder + 48), ctx);
  180574:	8b 04 24             	mov    (%esp),%eax
  180577:	83 c0 30             	add    $0x30,%eax
  18057a:	8b 54 24 04          	mov    0x4(%esp),%edx
  18057e:	ff d5                	call   *%ebp
}
  180580:	83 c4 08             	add    $0x8,%esp
  180583:	5b                   	pop    %ebx
  180584:	5e                   	pop    %esi
  180585:	5f                   	pop    %edi
  180586:	5d                   	pop    %ebp
  180587:	c3                   	ret    

00180588 <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  180588:	a3 10 00 28 00       	mov    %eax,0x280010
  18058d:	c3                   	ret    

0018058e <_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
  18058e:	55                   	push   %ebp
  18058f:	57                   	push   %edi
  180590:	56                   	push   %esi
  180591:	53                   	push   %ebx
  180592:	83 ec 10             	sub    $0x10,%esp
  180595:	89 c7                	mov    %eax,%edi
  180597:	89 54 24 04          	mov    %edx,0x4(%esp)
  18059b:	89 cb                	mov    %ecx,%ebx
  18059d:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
	int min_width = -1;
  1805a1:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
  1805a8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1805af:	00 
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  1805b0:	be 00 00 00 00       	mov    $0x0,%esi
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  1805b5:	e9 af 01 00 00       	jmp    180769 <_vprintk+0x1db>
		if (!might_format) {
  1805ba:	85 f6                	test   %esi,%esi
  1805bc:	75 16                	jne    1805d4 <_vprintk+0x46>
			if (*fmt != '%') {
  1805be:	3c 25                	cmp    $0x25,%al
  1805c0:	0f 84 84 01 00 00    	je     18074a <_vprintk+0x1bc>
				out((int)*fmt, ctx);
  1805c6:	0f be c0             	movsbl %al,%eax
  1805c9:	8b 54 24 04          	mov    0x4(%esp),%edx
  1805cd:	ff d7                	call   *%edi
  1805cf:	e9 94 01 00 00       	jmp    180768 <_vprintk+0x1da>
				might_format = 1;
				min_width = -1;
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
  1805d4:	8d 50 db             	lea    -0x25(%eax),%edx
  1805d7:	80 fa 55             	cmp    $0x55,%dl
  1805da:	0f 87 4f 01 00 00    	ja     18072f <_vprintk+0x1a1>
  1805e0:	0f b6 d2             	movzbl %dl,%edx
  1805e3:	ff 24 95 6c 1c 18 00 	jmp    *0x181c6c(,%edx,4)
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  1805ea:	8b 14 24             	mov    (%esp),%edx
  1805ed:	c1 ea 1f             	shr    $0x1f,%edx
  1805f0:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  1805f5:	0f 94 c1             	sete   %cl
  1805f8:	84 d1                	test   %dl,%cl
  1805fa:	0f 85 60 01 00 00    	jne    180760 <_vprintk+0x1d2>
					pad_zero = 1;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
  180600:	83 3c 24 00          	cmpl   $0x0,(%esp)
  180604:	79 0e                	jns    180614 <_vprintk+0x86>
					min_width = *fmt - '0';
  180606:	0f be c0             	movsbl %al,%eax
  180609:	83 e8 30             	sub    $0x30,%eax
  18060c:	89 04 24             	mov    %eax,(%esp)
  18060f:	e9 54 01 00 00       	jmp    180768 <_vprintk+0x1da>
				} else {
					min_width = 10 * min_width + *fmt - '0';
  180614:	8b 0c 24             	mov    (%esp),%ecx
  180617:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  18061a:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  18061d:	0f be c0             	movsbl %al,%eax
  180620:	8d 44 02 d0          	lea    -0x30(%edx,%eax,1),%eax
  180624:	89 04 24             	mov    %eax,(%esp)
  180627:	e9 3c 01 00 00       	jmp    180768 <_vprintk+0x1da>
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  18062c:	8d 75 04             	lea    0x4(%ebp),%esi
  18062f:	8b 6d 00             	mov    0x0(%ebp),%ebp

				if (d < 0) {
  180632:	85 ed                	test   %ebp,%ebp
  180634:	79 10                	jns    180646 <_vprintk+0xb8>
					out((int)'-', ctx);
  180636:	8b 54 24 04          	mov    0x4(%esp),%edx
  18063a:	b8 2d 00 00 00       	mov    $0x2d,%eax
  18063f:	ff d7                	call   *%edi
					d = -d;
  180641:	f7 dd                	neg    %ebp
					min_width--;
  180643:	ff 0c 24             	decl   (%esp)
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
  180646:	ff 34 24             	pushl  (%esp)
  180649:	ff 74 24 0c          	pushl  0xc(%esp)
  18064d:	89 e9                	mov    %ebp,%ecx
  18064f:	8b 54 24 0c          	mov    0xc(%esp),%edx
  180653:	89 f8                	mov    %edi,%eax
  180655:	e8 80 fe ff ff       	call   1804da <_printk_dec_ulong>
  18065a:	83 c4 08             	add    $0x8,%esp
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  18065d:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  18065f:	be 00 00 00 00       	mov    $0x0,%esi
					d = -d;
					min_width--;
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
  180664:	e9 ff 00 00 00       	jmp    180768 <_vprintk+0x1da>
			}
			case 'u': {
				unsigned long u = va_arg(
  180669:	8d 75 04             	lea    0x4(%ebp),%esi
  18066c:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
  18066f:	ff 34 24             	pushl  (%esp)
  180672:	ff 74 24 0c          	pushl  0xc(%esp)
  180676:	8b 54 24 0c          	mov    0xc(%esp),%edx
  18067a:	89 f8                	mov    %edi,%eax
  18067c:	e8 59 fe ff ff       	call   1804da <_printk_dec_ulong>
  180681:	83 c4 08             	add    $0x8,%esp
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  180684:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  180686:	be 00 00 00 00       	mov    $0x0,%esi
			case 'u': {
				unsigned long u = va_arg(
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
						  min_width);
				break;
  18068b:	e9 d8 00 00 00       	jmp    180768 <_vprintk+0x1da>
			}
			case 'p':
				  out('0', ctx);
  180690:	8b 74 24 04          	mov    0x4(%esp),%esi
  180694:	89 f2                	mov    %esi,%edx
  180696:	b8 30 00 00 00       	mov    $0x30,%eax
  18069b:	ff d7                	call   *%edi
				  out('x', ctx);
  18069d:	89 f2                	mov    %esi,%edx
  18069f:	b8 78 00 00 00       	mov    $0x78,%eax
  1806a4:	ff d7                	call   *%edi
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
				  min_width = 8;
  1806a6:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
			}
			case 'p':
				  out('0', ctx);
				  out('x', ctx);
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
  1806ad:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1806b4:	00 
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  1806b5:	8d 75 04             	lea    0x4(%ebp),%esi
  1806b8:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
  1806bb:	ff 34 24             	pushl  (%esp)
  1806be:	ff 74 24 0c          	pushl  0xc(%esp)
  1806c2:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1806c6:	89 f8                	mov    %edi,%eax
  1806c8:	e8 7a fd ff ff       	call   180447 <_printk_hex_ulong>
  1806cd:	83 c4 08             	add    $0x8,%esp
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  1806d0:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  1806d2:	be 00 00 00 00       	mov    $0x0,%esi
			case 'X': {
				unsigned long x = va_arg(
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
  1806d7:	e9 8c 00 00 00       	jmp    180768 <_vprintk+0x1da>
			}
			case 's': {
				char *s = va_arg(ap, char *);
  1806dc:	8d 75 04             	lea    0x4(%ebp),%esi
  1806df:	8b 6d 00             	mov    0x0(%ebp),%ebp
  1806e2:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  1806e6:	8b 5c 24 04          	mov    0x4(%esp),%ebx

				while (*s)
  1806ea:	eb 08                	jmp    1806f4 <_vprintk+0x166>
					out((int)(*s++), ctx);
  1806ec:	45                   	inc    %ebp
  1806ed:	0f be c0             	movsbl %al,%eax
  1806f0:	89 da                	mov    %ebx,%edx
  1806f2:	ff d7                	call   *%edi
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);

				while (*s)
  1806f4:	8a 45 00             	mov    0x0(%ebp),%al
  1806f7:	84 c0                	test   %al,%al
  1806f9:	75 f1                	jne    1806ec <_vprintk+0x15e>
  1806fb:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  1806ff:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  180701:	be 00 00 00 00       	mov    $0x0,%esi
  180706:	eb 60                	jmp    180768 <_vprintk+0x1da>
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  180708:	8d 75 04             	lea    0x4(%ebp),%esi
  18070b:	8b 45 00             	mov    0x0(%ebp),%eax

				out(c, ctx);
  18070e:	8b 54 24 04          	mov    0x4(%esp),%edx
  180712:	ff d7                	call   *%edi
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  180714:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  180716:	be 00 00 00 00       	mov    $0x0,%esi
			}
			case 'c': {
				int c = va_arg(ap, int);

				out(c, ctx);
				break;
  18071b:	eb 4b                	jmp    180768 <_vprintk+0x1da>
			}
			case '%': {
				out((int)'%', ctx);
  18071d:	8b 54 24 04          	mov    0x4(%esp),%edx
  180721:	b8 25 00 00 00       	mov    $0x25,%eax
  180726:	ff d7                	call   *%edi
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  180728:	be 00 00 00 00       	mov    $0x0,%esi
				out(c, ctx);
				break;
			}
			case '%': {
				out((int)'%', ctx);
				break;
  18072d:	eb 39                	jmp    180768 <_vprintk+0x1da>
			}
			default:
				out((int)'%', ctx);
  18072f:	8b 74 24 04          	mov    0x4(%esp),%esi
  180733:	89 f2                	mov    %esi,%edx
  180735:	b8 25 00 00 00       	mov    $0x25,%eax
  18073a:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
  18073c:	0f be 03             	movsbl (%ebx),%eax
  18073f:	89 f2                	mov    %esi,%edx
  180741:	ff d7                	call   *%edi
				break;
			}
			might_format = 0;
  180743:	be 00 00 00 00       	mov    $0x0,%esi
				break;
			}
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
  180748:	eb 1e                	jmp    180768 <_vprintk+0x1da>
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
  18074a:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
				pad_zero = 0;
  180751:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180758:	00 
	while (*fmt) {
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
  180759:	be 01 00 00 00       	mov    $0x1,%esi
  18075e:	eb 08                	jmp    180768 <_vprintk+0x1da>
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
					pad_zero = 1;
  180760:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  180767:	00 
				break;
			}
			might_format = 0;
		}
still_might_format:
		++fmt;
  180768:	43                   	inc    %ebx
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  180769:	8a 03                	mov    (%ebx),%al
  18076b:	84 c0                	test   %al,%al
  18076d:	0f 85 47 fe ff ff    	jne    1805ba <_vprintk+0x2c>
			might_format = 0;
		}
still_might_format:
		++fmt;
	}
}
  180773:	83 c4 10             	add    $0x10,%esp
  180776:	5b                   	pop    %ebx
  180777:	5e                   	pop    %esi
  180778:	5f                   	pop    %edi
  180779:	5d                   	pop    %ebp
  18077a:	c3                   	ret    

0018077b <printk>:
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
  18077b:	83 ec 04             	sub    $0x4,%esp
	struct out_context ctx = { 0 };
  18077e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	va_list ap;

	va_start(ap, fmt);
  180785:	8d 44 24 0c          	lea    0xc(%esp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
  180789:	50                   	push   %eax
  18078a:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  18078e:	8d 54 24 04          	lea    0x4(%esp),%edx
  180792:	b8 3b 04 18 00       	mov    $0x18043b,%eax
  180797:	e8 f2 fd ff ff       	call   18058e <_vprintk>
	va_end(ap);

	return ctx.count;
}
  18079c:	8b 44 24 04          	mov    0x4(%esp),%eax
  1807a0:	83 c4 08             	add    $0x8,%esp
  1807a3:	c3                   	ret    

001807a4 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_SOC, 1);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
  1807a4:	c3                   	ret    

001807a5 <_pinmux_defaults>:
/******** End PINMUX mapping **************************/

#define PINMUX_MAX_REGISTERS 2

static void _pinmux_defaults(uint32_t base)
{
  1807a5:	53                   	push   %ebx
  1807a6:	83 ec 08             	sub    $0x8,%esp
	PIN_CONFIG(mux_config,  6, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config,  7, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 12, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 13, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 14, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
  1807a9:	c7 04 24 42 a1 00 aa 	movl   $0xaa00a142,(%esp)
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);
  1807b0:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  1807b7:	00 

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  1807b8:	ba 00 00 00 00       	mov    $0x0,%edx
  1807bd:	eb 0a                	jmp    1807c9 <_pinmux_defaults+0x24>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
  1807bf:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
  1807c2:	8b 0c 94             	mov    (%esp,%edx,4),%ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1807c5:	89 4b 30             	mov    %ecx,0x30(%ebx)
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  1807c8:	42                   	inc    %edx
  1807c9:	83 fa 01             	cmp    $0x1,%edx
  1807cc:	7e f1                	jle    1807bf <_pinmux_defaults+0x1a>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}
  1807ce:	83 c4 08             	add    $0x8,%esp
  1807d1:	5b                   	pop    %ebx
  1807d2:	c3                   	ret    

001807d3 <pinmux_initialize>:

static int pinmux_initialize(struct device *port)
{
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);
  1807d3:	b8 00 09 80 b0       	mov    $0xb0800900,%eax
  1807d8:	e8 c8 ff ff ff       	call   1807a5 <_pinmux_defaults>

	/*
	 * MAGIC NUMBER: 0x1 is used as the pullup is a single bit in a
	 * 32-bit register.
	 */
	(*(mux_register)) = ((*(mux_register)) & ~(0x1 << pin_offset)) |
  1807dd:	a1 20 09 80 b0       	mov    0xb0800920,%eax
  1807e2:	83 c8 20             	or     $0x20,%eax
  1807e5:	a3 20 09 80 b0       	mov    %eax,0xb0800920

	/* Enable the UART RX pin to receive input */
	_quark_mcu_set_mux(PINMUX_BASE_ADDR + PINMUX_INPUT_OFFSET, 5, 0x1);

	return 0;
}
  1807ea:	b8 00 00 00 00       	mov    $0x0,%eax
  1807ef:	c3                   	ret    

001807f0 <clk_periph_enable>:

int clk_periph_enable(const clk_periph_t clocks)
{
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
  1807f0:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
  1807f6:	09 d0                	or     %edx,%eax
  1807f8:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
  1807fd:	b8 00 00 00 00       	mov    $0x0,%eax
  180802:	c3                   	ret    

00180803 <clk_periph_disable>:

int clk_periph_disable(const clk_periph_t clocks)
{
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl &= ~clocks;
  180803:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
  180809:	f7 d0                	not    %eax
  18080b:	21 d0                	and    %edx,%eax
  18080d:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
  180812:	b8 00 00 00 00       	mov    $0x0,%eax
  180817:	c3                   	ret    

00180818 <qm_wdt_0_isr>:
};
#endif /* UNIT_TEST */

QM_ISR_DECLARE(qm_wdt_0_isr)
{
	if (callback[QM_WDT_0]) {
  180818:	8b 15 bc 00 28 00    	mov    0x2800bc,%edx
  18081e:	85 d2                	test   %edx,%edx
  180820:	74 07                	je     180829 <qm_wdt_0_isr+0x11>
		callback[QM_WDT_0](callback_data[QM_WDT_0]);
  180822:	a1 b8 00 28 00       	mov    0x2800b8,%eax
  180827:	ff d2                	call   *%edx
	}

	/* Clear the interrupt by reading. */
	QM_WDT[QM_WDT_0]->wdt_eoi;
  180829:	a1 14 00 28 00       	mov    0x280014,%eax
  18082e:	8b 40 14             	mov    0x14(%eax),%eax
  180831:	c3                   	ret    

00180832 <qm_wdt_reload>:
	/*
	 * This register is used to restart the WDT counter. As a safety feature
	 * to prevent accidental restarts the value 0x76 must be written.
	 * A restart also clears the WDT interrupt.
	 */
	QM_WDT[wdt]->wdt_crr = QM_WDT_RELOAD_VALUE;
  180832:	8b 04 85 14 00 28 00 	mov    0x280014(,%eax,4),%eax
  180839:	c7 40 0c 76 00 00 00 	movl   $0x76,0xc(%eax)

	return 0;
}
  180840:	b8 00 00 00 00       	mov    $0x0,%eax
  180845:	c3                   	ret    

00180846 <qm_wdt_start>:
	QM_ISR_EOI(QM_IRQ_WDT_1_INT_VECTOR);
}
#endif /* (NUM_WDT_CONTROLLERS > 1) */

int qm_wdt_start(const qm_wdt_t wdt)
{
  180846:	53                   	push   %ebx
  180847:	89 c3                	mov    %eax,%ebx
	QM_CHECK(wdt < QM_WDT_NUM, -EINVAL);

	QM_WDT[wdt]->wdt_cr |= QM_WDT_CR_WDT_ENABLE;
  180849:	8b 14 85 14 00 28 00 	mov    0x280014(,%eax,4),%edx
  180850:	8b 02                	mov    (%edx),%eax
  180852:	83 c8 01             	or     $0x1,%eax
  180855:	89 02                	mov    %eax,(%edx)

#if (HAS_WDT_CLOCK_ENABLE)
	clk_periph_enable(CLK_PERIPH_WDT_REGISTER | CLK_PERIPH_CLK);
  180857:	b8 02 04 00 00       	mov    $0x402,%eax
  18085c:	e8 8f ff ff ff       	call   1807f0 <clk_periph_enable>
	QM_SCSS_PERIPHERAL->periph_cfg0 |= BIT(1);
  180861:	a1 04 08 80 b0       	mov    0xb0800804,%eax
  180866:	83 c8 02             	or     $0x2,%eax
  180869:	a3 04 08 80 b0       	mov    %eax,0xb0800804
#endif /* HAS_WDT_CLOCK_ENABLE */

	qm_wdt_reload(wdt);
  18086e:	89 d8                	mov    %ebx,%eax
  180870:	e8 bd ff ff ff       	call   180832 <qm_wdt_reload>

	return 0;
}
  180875:	b8 00 00 00 00       	mov    $0x0,%eax
  18087a:	5b                   	pop    %ebx
  18087b:	c3                   	ret    

0018087c <qm_wdt_set_config>:

int qm_wdt_set_config(const qm_wdt_t wdt, const qm_wdt_config_t *const cfg)
{
  18087c:	56                   	push   %esi
  18087d:	53                   	push   %ebx
  18087e:	89 c3                	mov    %eax,%ebx
  180880:	89 d6                	mov    %edx,%esi
	QM_CHECK(wdt < QM_WDT_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);
	QM_CHECK(cfg->timeout <= QM_WDT_TORR_TOP_MASK, -EINVAL);

	qm_wdt_reload(wdt);
  180882:	e8 ab ff ff ff       	call   180832 <qm_wdt_reload>

	if (cfg->mode == QM_WDT_MODE_INTERRUPT_RESET) {
  180887:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
  18088b:	75 14                	jne    1808a1 <qm_wdt_set_config+0x25>
		callback[wdt] = cfg->callback;
  18088d:	8b 46 08             	mov    0x8(%esi),%eax
  180890:	89 04 9d bc 00 28 00 	mov    %eax,0x2800bc(,%ebx,4)
		callback_data[wdt] = cfg->callback_data;
  180897:	8b 46 0c             	mov    0xc(%esi),%eax
  18089a:	89 04 9d b8 00 28 00 	mov    %eax,0x2800b8(,%ebx,4)
	}

	QM_WDT[wdt]->wdt_cr &= ~QM_WDT_CR_RMOD;
  1808a1:	8b 14 9d 14 00 28 00 	mov    0x280014(,%ebx,4),%edx
  1808a8:	8b 02                	mov    (%edx),%eax
  1808aa:	83 e0 fd             	and    $0xfffffffd,%eax
  1808ad:	89 02                	mov    %eax,(%edx)
	QM_WDT[wdt]->wdt_cr |= cfg->mode << QM_WDT_CR_RMOD_OFFSET;
  1808af:	8b 14 9d 14 00 28 00 	mov    0x280014(,%ebx,4),%edx
  1808b6:	8b 0a                	mov    (%edx),%ecx
  1808b8:	8b 46 04             	mov    0x4(%esi),%eax
  1808bb:	01 c0                	add    %eax,%eax
  1808bd:	09 c8                	or     %ecx,%eax
  1808bf:	89 02                	mov    %eax,(%edx)
	/*
	 * Timeout range register. Select the timeout from the pre-defined
	 * tables. These tables can be found in the SoC databook or register
	 * file.
	 */
	QM_WDT[wdt]->wdt_torr = cfg->timeout;
  1808c1:	8b 04 9d 14 00 28 00 	mov    0x280014(,%ebx,4),%eax
  1808c8:	8b 16                	mov    (%esi),%edx
  1808ca:	89 50 04             	mov    %edx,0x4(%eax)

	/* kick the WDT to load the Timeout Period(TOP) value */
	qm_wdt_reload(wdt);
  1808cd:	89 d8                	mov    %ebx,%eax
  1808cf:	e8 5e ff ff ff       	call   180832 <qm_wdt_reload>

	return 0;
}
  1808d4:	b8 00 00 00 00       	mov    $0x0,%eax
  1808d9:	5b                   	pop    %ebx
  1808da:	5e                   	pop    %esi
  1808db:	c3                   	ret    

001808dc <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
  1808dc:	83 ec 04             	sub    $0x4,%esp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  1808df:	8b 04 85 18 00 28 00 	mov    0x280018(,%eax,4),%eax
	volatile uint32_t unused_lsr __attribute__((unused));

	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;
  1808e6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
  1808ed:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
  1808f4:	8b 4a 04             	mov    0x4(%edx),%ecx
  1808f7:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  1808fd:	c1 e9 10             	shr    $0x10,%ecx
  180900:	89 48 04             	mov    %ecx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
  180903:	8b 4a 04             	mov    0x4(%edx),%ecx
  180906:	0f b6 cd             	movzbl %ch,%ecx
  180909:	89 08                	mov    %ecx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
  18090b:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  18090f:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
  180915:	8b 0a                	mov    (%edx),%ecx
  180917:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
  18091a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
  180921:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  180925:	74 09                	je     180930 <qm_uart_set_config+0x54>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
  180927:	8b 50 10             	mov    0x10(%eax),%edx
  18092a:	83 ca 22             	or     $0x22,%edx
  18092d:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
  180930:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
  180937:	8b 50 04             	mov    0x4(%eax),%edx
  18093a:	80 ca 80             	or     $0x80,%dl
  18093d:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
  180940:	8b 40 14             	mov    0x14(%eax),%eax
  180943:	89 04 24             	mov    %eax,(%esp)

	return 0;
}
  180946:	b8 00 00 00 00       	mov    $0x0,%eax
  18094b:	83 c4 04             	add    $0x4,%esp
  18094e:	c3                   	ret    

0018094f <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
  18094f:	56                   	push   %esi
  180950:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
  180951:	8b 04 85 18 00 28 00 	mov    0x280018(,%eax,4),%eax
	uint32_t lsr = regs->lsr;
  180958:	8b 48 14             	mov    0x14(%eax),%ecx

	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
  18095b:	89 cb                	mov    %ecx,%ebx
  18095d:	83 e3 1e             	and    $0x1e,%ebx
  180960:	89 1a                	mov    %ebx,(%edx)

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
  180962:	8b 70 1c             	mov    0x1c(%eax),%esi
  180965:	f7 c6 01 00 00 00    	test   $0x1,%esi
  18096b:	74 0b                	je     180978 <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
  18096d:	8b 58 1c             	mov    0x1c(%eax),%ebx
  180970:	83 e3 fe             	and    $0xfffffffe,%ebx
  180973:	89 58 1c             	mov    %ebx,0x1c(%eax)
  180976:	eb 0a                	jmp    180982 <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
  180978:	f6 c1 40             	test   $0x40,%cl
  18097b:	75 05                	jne    180982 <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
  18097d:	83 cb 20             	or     $0x20,%ebx
  180980:	89 1a                	mov    %ebx,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
  180982:	f6 c1 01             	test   $0x1,%cl
  180985:	74 03                	je     18098a <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
  180987:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
  18098a:	b8 00 00 00 00       	mov    $0x0,%eax
  18098f:	5b                   	pop    %ebx
  180990:	5e                   	pop    %esi
  180991:	c3                   	ret    

00180992 <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  180992:	8b 04 85 18 00 28 00 	mov    0x280018(,%eax,4),%eax

	while (regs->lsr & QM_UART_LSR_THRE) {
  180999:	8b 48 14             	mov    0x14(%eax),%ecx
  18099c:	f6 c1 20             	test   $0x20,%cl
  18099f:	75 f8                	jne    180999 <qm_uart_write+0x7>
	}
	regs->rbr_thr_dll = data;
  1809a1:	0f b6 d2             	movzbl %dl,%edx
  1809a4:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
  1809a6:	8b 50 14             	mov    0x14(%eax),%edx
  1809a9:	f6 c2 40             	test   $0x40,%dl
  1809ac:	74 f8                	je     1809a6 <qm_uart_write+0x14>
	}

	return 0;
}
  1809ae:	b8 00 00 00 00       	mov    $0x0,%eax
  1809b3:	c3                   	ret    

001809b4 <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
  1809b4:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  1809b5:	8b 1c 85 18 00 28 00 	mov    0x280018(,%eax,4),%ebx

	uint32_t lsr = regs->lsr;
  1809bc:	8b 43 14             	mov    0x14(%ebx),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
  1809bf:	eb 03                	jmp    1809c4 <qm_uart_read+0x10>
		lsr = regs->lsr;
  1809c1:	8b 43 14             	mov    0x14(%ebx),%eax
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
  1809c4:	a8 01                	test   $0x1,%al
  1809c6:	74 f9                	je     1809c1 <qm_uart_read+0xd>
		lsr = regs->lsr;
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
  1809c8:	83 e0 1e             	and    $0x1e,%eax
  1809cb:	74 0d                	je     1809da <qm_uart_read+0x26>
		if (status) {
  1809cd:	85 c9                	test   %ecx,%ecx
  1809cf:	74 14                	je     1809e5 <qm_uart_read+0x31>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
  1809d1:	89 01                	mov    %eax,(%ecx)
		}
		return -EIO;
  1809d3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  1809d8:	eb 10                	jmp    1809ea <qm_uart_read+0x36>
	}
	*data = regs->rbr_thr_dll;
  1809da:	8b 03                	mov    (%ebx),%eax
  1809dc:	88 02                	mov    %al,(%edx)

	return 0;
  1809de:	b8 00 00 00 00       	mov    $0x0,%eax
  1809e3:	eb 05                	jmp    1809ea <qm_uart_read+0x36>
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
  1809e5:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}
	*data = regs->rbr_thr_dll;

	return 0;
}
  1809ea:	5b                   	pop    %ebx
  1809eb:	c3                   	ret    

001809ec <pin_to_register>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The register index of the given pin.
 */
static uint32_t pin_to_register(uint32_t pin, uint32_t width)
{
  1809ec:	56                   	push   %esi
  1809ed:	53                   	push   %ebx
  1809ee:	89 c3                	mov    %eax,%ebx
  1809f0:	89 d6                	mov    %edx,%esi
	return (pin / (32 / width));
  1809f2:	b8 20 00 00 00       	mov    $0x20,%eax
  1809f7:	ba 00 00 00 00       	mov    $0x0,%edx
  1809fc:	f7 f6                	div    %esi
  1809fe:	89 c1                	mov    %eax,%ecx
  180a00:	89 d8                	mov    %ebx,%eax
  180a02:	ba 00 00 00 00       	mov    $0x0,%edx
  180a07:	f7 f1                	div    %ecx
}
  180a09:	5b                   	pop    %ebx
  180a0a:	5e                   	pop    %esi
  180a0b:	c3                   	ret    

00180a0c <pin_to_offset>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
  180a0c:	56                   	push   %esi
  180a0d:	53                   	push   %ebx
  180a0e:	89 c6                	mov    %eax,%esi
  180a10:	89 d3                	mov    %edx,%ebx
	return ((pin % (32 / width)) * width);
  180a12:	b8 20 00 00 00       	mov    $0x20,%eax
  180a17:	ba 00 00 00 00       	mov    $0x0,%edx
  180a1c:	f7 f3                	div    %ebx
  180a1e:	89 c1                	mov    %eax,%ecx
  180a20:	89 f0                	mov    %esi,%eax
  180a22:	ba 00 00 00 00       	mov    $0x0,%edx
  180a27:	f7 f1                	div    %ecx
  180a29:	89 d8                	mov    %ebx,%eax
  180a2b:	0f af c2             	imul   %edx,%eax
}
  180a2e:	5b                   	pop    %ebx
  180a2f:	5e                   	pop    %esi
  180a30:	c3                   	ret    

00180a31 <qm_pmux_select>:

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
  180a31:	57                   	push   %edi
  180a32:	56                   	push   %esi
  180a33:	53                   	push   %ebx
  180a34:	89 c7                	mov    %eax,%edi
  180a36:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
  180a38:	ba 02 00 00 00       	mov    $0x2,%edx
  180a3d:	e8 aa ff ff ff       	call   1809ec <pin_to_register>
  180a42:	89 c3                	mov    %eax,%ebx
	uint32_t offs = pin_to_offset(pin, 2);
  180a44:	ba 02 00 00 00       	mov    $0x2,%edx
  180a49:	89 f8                	mov    %edi,%eax
  180a4b:	e8 bc ff ff ff       	call   180a0c <pin_to_offset>
  180a50:	89 c1                	mov    %eax,%ecx

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
  180a52:	83 c3 0c             	add    $0xc,%ebx
  180a55:	8b 3c 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edi
  180a5c:	ba 03 00 00 00       	mov    $0x3,%edx
  180a61:	d3 e2                	shl    %cl,%edx
  180a63:	f7 d2                	not    %edx
  180a65:	21 fa                	and    %edi,%edx
  180a67:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
  180a6e:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  180a75:	d3 e6                	shl    %cl,%esi
  180a77:	09 c6                	or     %eax,%esi
  180a79:	89 34 9d 00 09 80 b0 	mov    %esi,-0x4f7ff700(,%ebx,4)

	return 0;
}
  180a80:	b8 00 00 00 00       	mov    $0x0,%eax
  180a85:	5b                   	pop    %ebx
  180a86:	5e                   	pop    %esi
  180a87:	5f                   	pop    %edi
  180a88:	c3                   	ret    

00180a89 <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
  180a89:	57                   	push   %edi
  180a8a:	56                   	push   %esi
  180a8b:	53                   	push   %ebx
  180a8c:	89 c7                	mov    %eax,%edi
  180a8e:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  180a90:	ba 01 00 00 00       	mov    $0x1,%edx
  180a95:	e8 52 ff ff ff       	call   1809ec <pin_to_register>
  180a9a:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  180a9c:	ba 01 00 00 00       	mov    $0x1,%edx
  180aa1:	89 f8                	mov    %edi,%eax
  180aa3:	e8 64 ff ff ff       	call   180a0c <pin_to_offset>
  180aa8:	ba 01 00 00 00       	mov    $0x1,%edx
  180aad:	88 c1                	mov    %al,%cl
  180aaf:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  180ab1:	89 f0                	mov    %esi,%eax
  180ab3:	84 c0                	test   %al,%al
  180ab5:	75 17                	jne    180ace <qm_pmux_input_en+0x45>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
  180ab7:	83 c3 08             	add    $0x8,%ebx
  180aba:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  180ac1:	f7 d2                	not    %edx
  180ac3:	21 c2                	and    %eax,%edx
  180ac5:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  180acc:	eb 13                	jmp    180ae1 <qm_pmux_input_en+0x58>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
  180ace:	83 c3 08             	add    $0x8,%ebx
  180ad1:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  180ad8:	09 c2                	or     %eax,%edx
  180ada:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  180ae1:	b8 00 00 00 00       	mov    $0x0,%eax
  180ae6:	5b                   	pop    %ebx
  180ae7:	5e                   	pop    %esi
  180ae8:	5f                   	pop    %edi
  180ae9:	c3                   	ret    

00180aea <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
  180aea:	57                   	push   %edi
  180aeb:	56                   	push   %esi
  180aec:	53                   	push   %ebx
  180aed:	89 c7                	mov    %eax,%edi
  180aef:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  180af1:	ba 01 00 00 00       	mov    $0x1,%edx
  180af6:	e8 f1 fe ff ff       	call   1809ec <pin_to_register>
  180afb:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  180afd:	ba 01 00 00 00       	mov    $0x1,%edx
  180b02:	89 f8                	mov    %edi,%eax
  180b04:	e8 03 ff ff ff       	call   180a0c <pin_to_offset>
  180b09:	ba 01 00 00 00       	mov    $0x1,%edx
  180b0e:	88 c1                	mov    %al,%cl
  180b10:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  180b12:	89 f0                	mov    %esi,%eax
  180b14:	84 c0                	test   %al,%al
  180b16:	75 14                	jne    180b2c <qm_pmux_pullup_en+0x42>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
  180b18:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  180b1f:	f7 d2                	not    %edx
  180b21:	21 c2                	and    %eax,%edx
  180b23:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  180b2a:	eb 10                	jmp    180b3c <qm_pmux_pullup_en+0x52>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
  180b2c:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  180b33:	09 c2                	or     %eax,%edx
  180b35:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  180b3c:	b8 00 00 00 00       	mov    $0x0,%eax
  180b41:	5b                   	pop    %ebx
  180b42:	5e                   	pop    %esi
  180b43:	5f                   	pop    %edi
  180b44:	c3                   	ret    

00180b45 <k_cpu_idle>:
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  180b45:	fb                   	sti    
  180b46:	f4                   	hlt    
  180b47:	c3                   	ret    

00180b48 <_SysFatalErrorHandler>:
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
  180b48:	e8 dd 0c 00 00       	call   18182a <k_is_in_isr>
  180b4d:	85 c0                	test   %eax,%eax
  180b4f:	75 09                	jne    180b5a <_SysFatalErrorHandler+0x12>
  180b51:	e8 e2 0c 00 00       	call   181838 <_is_thread_essential>
  180b56:	85 c0                	test   %eax,%eax
  180b58:	74 25                	je     180b7f <_SysFatalErrorHandler+0x37>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  180b5a:	e8 cb 0c 00 00       	call   18182a <k_is_in_isr>
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  180b5f:	85 c0                	test   %eax,%eax
  180b61:	74 07                	je     180b6a <_SysFatalErrorHandler+0x22>
  180b63:	b8 c4 1d 18 00       	mov    $0x181dc4,%eax
  180b68:	eb 05                	jmp    180b6f <_SysFatalErrorHandler+0x27>
  180b6a:	b8 c8 1d 18 00       	mov    $0x181dc8,%eax
  180b6f:	50                   	push   %eax
  180b70:	68 18 1e 18 00       	push   $0x181e18
  180b75:	e8 01 fc ff ff       	call   18077b <printk>
  180b7a:	83 c4 08             	add    $0x8,%esp
  180b7d:	eb fe                	jmp    180b7d <_SysFatalErrorHandler+0x35>
		       k_is_in_isr() ? "ISR" : "essential thread");
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  180b7f:	ff 35 c8 00 28 00    	pushl  0x2800c8
  180b85:	68 38 1e 18 00       	push   $0x181e38
  180b8a:	e8 ec fb ff ff       	call   18077b <printk>
  180b8f:	83 c4 08             	add    $0x8,%esp
	k_thread_abort(_current);
  180b92:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  180b97:	e8 e6 0e 00 00       	call   181a82 <k_thread_abort>

00180b9c <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  180b9c:	53                   	push   %ebx
	movl $1, %eax
  180b9d:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  180ba2:	0f a2                	cpuid  
	movl %ebx, %eax
  180ba4:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  180ba6:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  180bab:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  180bae:	5b                   	pop    %ebx
	ret
  180baf:	c3                   	ret    

00180bb0 <init_cache_line_size>:

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  180bb0:	e8 e7 ff ff ff       	call   180b9c <_cache_line_size_get>
  180bb5:	a3 ec 01 28 00       	mov    %eax,0x2801ec
  180bba:	c3                   	ret    

00180bbb <init_cache>:
static int init_cache(struct device *unused)
{
	ARG_UNUSED(unused);

	init_cache_flush();
	init_cache_line_size();
  180bbb:	e8 f0 ff ff ff       	call   180bb0 <init_cache_line_size>

	return 0;
}
  180bc0:	b8 00 00 00 00       	mov    $0x0,%eax
  180bc5:	c3                   	ret    

00180bc6 <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  180bc6:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  180bc7:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  180bca:	50                   	push   %eax
	pushl	%edx
  180bcb:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  180bcc:	57                   	push   %edi
	pushl	%esi
  180bcd:	56                   	push   %esi
	pushl	%ebx
  180bce:	53                   	push   %ebx
	pushl	%ebp
  180bcf:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  180bd0:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  180bd4:	50                   	push   %eax

	/* ESP is pointing to the ESF at this point */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %edx
  180bd5:	8b 15 c8 00 28 00    	mov    0x2800c8,%edx

	/* inc exception nest count */
	incl	_thread_offset_to_excNestCount(%edx)
  180bdb:	ff 42 44             	incl   0x44(%edx)
     * the current execution context if this is the outermost exception.
     * The ESF pointer is used by debug tools to locate the volatile
     * registers and the stack of the preempted thread.
     */

	testb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  180bde:	f6 42 09 40          	testb  $0x40,0x9(%edx)
	jne	alreadyInException
  180be2:	75 03                	jne    180be7 <alreadyInException>
	movl	%esp, _thread_offset_to_esf(%edx)
  180be4:	89 62 40             	mov    %esp,0x40(%edx)

00180be7 <alreadyInException>:
	 * (where needed) if the exception handler causes a context switch.
	 * It also indicates to debug tools that an exception is being
	 * handled in the event of a context switch.
	 */

	orb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  180be7:	80 4a 09 40          	orb    $0x40,0x9(%edx)
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  180beb:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  180bf2:	00 
	je	allDone
  180bf3:	74 01                	je     180bf6 <allDone>
	sti
  180bf5:	fb                   	sti    

00180bf6 <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
  180bf6:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
  180bf8:	ff d1                	call   *%ecx
	addl	$0x4, %esp
#endif

#if defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %ecx
  180bfa:	8b 0d c8 00 28 00    	mov    0x2800c8,%ecx
	 * Must lock interrupts to prevent outside interference.
	 * (Using "lock" prefix would be nicer, but this won't work
	 * on platforms that don't respect the CPU's bus lock signal.)
	 */

	cli
  180c00:	fa                   	cli    

	/*
	 * Determine whether exiting from a nested interrupt.
	 */

	decl	_thread_offset_to_excNestCount(%ecx)
  180c01:	ff 49 44             	decl   0x44(%ecx)

	cmpl	$0, _thread_offset_to_excNestCount(%ecx)
  180c04:	83 79 44 00          	cmpl   $0x0,0x44(%ecx)
	jne	nestedException
  180c08:	75 04                	jne    180c0e <nestedException>
	 * Clear the _EXC_ACTIVE bit in the k_thread of the current execution
	 * context if we are not in a nested exception (ie, when we exit the
	 * outermost exception).
	 */

	andb	$~_EXC_ACTIVE, _thread_offset_to_thread_state(%ecx)
  180c0a:	80 61 09 bf          	andb   $0xbf,0x9(%ecx)

00180c0e <nestedException>:
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  180c0e:	5d                   	pop    %ebp
	popl	%ebp
  180c0f:	5d                   	pop    %ebp
	popl	%ebx
  180c10:	5b                   	pop    %ebx
	popl	%esi
  180c11:	5e                   	pop    %esi
	popl	%edi
  180c12:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  180c13:	5a                   	pop    %edx
	popl	%eax
  180c14:	58                   	pop    %eax
	popl	%ecx
  180c15:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  180c16:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  180c19:	cf                   	iret   

00180c1a <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  180c1a:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  180c1b:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  180c1f:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  180c22:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  180c23:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  180c24:	b9 c0 00 28 00       	mov    $0x2800c0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  180c29:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  180c2b:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  180c2e:	75 06                	jne    180c36 <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  180c30:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  180c32:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  180c35:	57                   	push   %edi

00180c36 <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  180c36:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  180c37:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  180c39:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
  180c3a:	31 c0                	xor    %eax,%eax
  180c3c:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  180c41:	b9 c0 00 28 00       	mov    $0x2800c0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  180c46:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  180c48:	75 2b                	jne    180c75 <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  180c4a:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
  180c4d:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
  180c53:	73 1f                	jae    180c74 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  180c55:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
  180c58:	74 1a                	je     180c74 <noReschedule>
	 * preserved using the lazy save/restore algorithm, or to indicate to
	 * debug tools that a preemptive context switch has occurred.
	 */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)
	orb	$_INT_ACTIVE, _thread_offset_to_thread_state(%edx)
  180c5a:	80 4a 09 80          	orb    $0x80,0x9(%edx)
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  180c5e:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  180c5f:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
  180c60:	58                   	pop    %eax
#endif
	call	_Swap
  180c61:	e8 30 00 00 00       	call   180c96 <_Swap>
	 * _Swap() has restored the floating point registers, if needed.
	 * Clear the _INT_ACTIVE bit in the interrupted thread's state
	 * since it has served its purpose.
	 */

	movl	_kernel + _kernel_offset_to_current, %eax
  180c66:	a1 c8 00 28 00       	mov    0x2800c8,%eax
	andb	$~_INT_ACTIVE, _thread_offset_to_thread_state(%eax)
  180c6b:	80 60 09 7f          	andb   $0x7f,0x9(%eax)

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  180c6f:	5f                   	pop    %edi
	popl	%ecx
  180c70:	59                   	pop    %ecx
	popl	%edx
  180c71:	5a                   	pop    %edx
	popl	%eax
  180c72:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  180c73:	cf                   	iret   

00180c74 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  180c74:	5c                   	pop    %esp

00180c75 <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  180c75:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  180c76:	59                   	pop    %ecx
	popl	%edx
  180c77:	5a                   	pop    %edx
	popl	%eax
  180c78:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  180c79:	cf                   	iret   

00180c7a <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  180c7a:	6a 00                	push   $0x0

00180c7c <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  180c7c:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  180c7d:	50                   	push   %eax
	pushl %ecx
  180c7e:	51                   	push   %ecx
	pushl %edx
  180c7f:	52                   	push   %edx
	pushl %edi
  180c80:	57                   	push   %edi
	pushl %esi
  180c81:	56                   	push   %esi
	pushl %ebx
  180c82:	53                   	push   %ebx
	pushl %ebp
  180c83:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  180c84:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  180c88:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
  180c89:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
  180c8b:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
  180c8c:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  180c91:	e8 d5 00 00 00       	call   180d6b <_NanoFatalErrorHandler>

00180c96 <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
  180c96:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
  180c99:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  180c9d:	57                   	push   %edi

	movl	$_kernel, %edi
  180c9e:	bf c0 00 28 00       	mov    $0x2800c0,%edi

	pushl	%esi
  180ca3:	56                   	push   %esi
	pushl	%ebx
  180ca4:	53                   	push   %ebx
	pushl	%ebp
  180ca5:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
  180ca6:	ff 35 04 20 18 00    	pushl  0x182004


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  180cac:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  180caf:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  180cb2:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  180cb5:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  180cb8:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
  180cbb:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  180cbc:	5d                   	pop    %ebp
	popl	%ebx
  180cbd:	5b                   	pop    %ebx
	popl	%esi
  180cbe:	5e                   	pop    %esi
	popl	%edi
  180cbf:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  180cc0:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  180cc4:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
  180cc5:	5a                   	pop    %edx
	movl	%edx, (%esp)
  180cc6:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
  180cc9:	c3                   	ret    

00180cca <_new_thread_internal>:
 * @return N/A
 */
static void _new_thread_internal(char *pStackMem, unsigned stackSize,
				 int priority,
				 unsigned options)
{
  180cca:	56                   	push   %esi
  180ccb:	53                   	push   %ebx
  180ccc:	89 c3                	mov    %eax,%ebx
  180cce:	89 d6                	mov    %edx,%esi
  180cd0:	89 ca                	mov    %ecx,%edx
	unsigned long *pInitialCtx;
	/* ptr to the new task's k_thread */
	struct k_thread *thread = (struct k_thread *)pStackMem;

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
  180cd2:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
  180cd9:	ff 74 24 0c          	pushl  0xc(%esp)
  180cdd:	b9 04 00 00 00       	mov    $0x4,%ecx
  180ce2:	e8 6b 0d 00 00       	call   181a52 <_init_thread_base>
  180ce7:	83 c4 04             	add    $0x4,%esp

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  180cea:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	thread->fn_abort = NULL;
  180cf1:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
	 * the base address of the stack which is past the initial stack frame.
	 * Therefore some of the calculations done in the other routines that
	 * initialize the stack frame need to be repeated.
	 */

	pInitialCtx = (unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  180cf8:	8d 14 33             	lea    (%ebx,%esi,1),%edx
  180cfb:	83 e2 fc             	and    $0xfffffffc,%edx
#ifdef CONFIG_THREAD_MONITOR
	/*
	 * In debug mode thread->entry give direct access to the thread entry
	 * and the corresponding parameters.
	 */
	thread->entry = (struct __thread_entry *)(pInitialCtx -
  180cfe:	8d 42 c0             	lea    -0x40(%edx),%eax
  180d01:	89 43 34             	mov    %eax,0x34(%ebx)
	 *  - 4 thread entry routine parameters
	 *  - eflags
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;
  180d04:	83 ea 2c             	sub    $0x2c,%edx

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  180d07:	89 53 28             	mov    %edx,0x28(%ebx)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  180d0a:	9c                   	pushf  
  180d0b:	fa                   	cli    
  180d0c:	58                   	pop    %eax
static ALWAYS_INLINE void thread_monitor_init(struct k_thread *thread)
{
	unsigned int key;

	key = irq_lock();
	thread->next_thread = _kernel.threads;
  180d0d:	8b 15 dc 01 28 00    	mov    0x2801dc,%edx
  180d13:	89 53 38             	mov    %edx,0x38(%ebx)
	_kernel.threads = thread;
  180d16:	89 1d dc 01 28 00    	mov    %ebx,0x2801dc
  180d1c:	f6 c4 02             	test   $0x2,%ah
  180d1f:	74 01                	je     180d22 <_new_thread_internal+0x58>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  180d21:	fb                   	sti    
	PRINTK("\nInitial context ESP = 0x%x\n", thread->coopReg.esp);

	PRINTK("\nstruct thread * = 0x%x", thread);

	thread_monitor_init(thread);
}
  180d22:	5b                   	pop    %ebx
  180d23:	5e                   	pop    %esi
  180d24:	c3                   	ret    

00180d25 <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  180d25:	56                   	push   %esi
  180d26:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  180d27:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  180d2a:	83 e3 fc             	and    $0xfffffffc,%ebx
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  180d2d:	8b 74 24 14          	mov    0x14(%esp),%esi
  180d31:	89 73 fc             	mov    %esi,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  180d34:	8b 74 24 10          	mov    0x10(%esp),%esi
  180d38:	89 73 f8             	mov    %esi,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  180d3b:	8b 74 24 0c          	mov    0xc(%esp),%esi
  180d3f:	89 73 f4             	mov    %esi,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  180d42:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  180d45:	9c                   	pushf  
  180d46:	59                   	pop    %ecx

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  180d47:	80 e5 cd             	and    $0xcd,%ch
  180d4a:	80 cd 02             	or     $0x2,%ch
  180d4d:	89 4b ec             	mov    %ecx,-0x14(%ebx)
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
  180d50:	c7 43 e8 60 00 18 00 	movl   $0x180060,-0x18(%ebx)
	/*
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
  180d57:	ff 74 24 1c          	pushl  0x1c(%esp)
  180d5b:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  180d5f:	e8 66 ff ff ff       	call   180cca <_new_thread_internal>
  180d64:	83 c4 04             	add    $0x4,%esp
}
  180d67:	5b                   	pop    %ebx
  180d68:	5e                   	pop    %esi
  180d69:	c3                   	ret    

00180d6a <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  180d6a:	c3                   	ret    

00180d6b <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  180d6b:	55                   	push   %ebp
  180d6c:	57                   	push   %edi
  180d6d:	56                   	push   %esi
  180d6e:	53                   	push   %ebx
  180d6f:	83 ec 24             	sub    $0x24,%esp
  180d72:	89 c6                	mov    %eax,%esi
  180d74:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
  180d76:	89 d0                	mov    %edx,%eax
  180d78:	e8 ed ff ff ff       	call   180d6a <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  180d7d:	83 fe 03             	cmp    $0x3,%esi
  180d80:	74 4c                	je     180dce <_NanoFatalErrorHandler+0x63>
  180d82:	83 fe 03             	cmp    $0x3,%esi
  180d85:	77 06                	ja     180d8d <_NanoFatalErrorHandler+0x22>
  180d87:	85 f6                	test   %esi,%esi
  180d89:	74 0e                	je     180d99 <_NanoFatalErrorHandler+0x2e>
  180d8b:	eb 5f                	jmp    180dec <_NanoFatalErrorHandler+0x81>
  180d8d:	83 fe 05             	cmp    $0x5,%esi
  180d90:	74 4b                	je     180ddd <_NanoFatalErrorHandler+0x72>
  180d92:	83 fe 06             	cmp    $0x6,%esi
  180d95:	74 63                	je     180dfa <_NanoFatalErrorHandler+0x8f>
  180d97:	eb 53                	jmp    180dec <_NanoFatalErrorHandler+0x81>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  180d99:	e8 21 f5 ff ff       	call   1802bf <__irq_controller_isr_vector_get>
  180d9e:	89 c3                	mov    %eax,%ebx
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  180da0:	68 60 1e 18 00       	push   $0x181e60
  180da5:	e8 d1 f9 ff ff       	call   18077b <printk>
  180daa:	83 c4 04             	add    $0x4,%esp
		if (vector >= 0) {
  180dad:	85 db                	test   %ebx,%ebx
  180daf:	78 0e                	js     180dbf <_NanoFatalErrorHandler+0x54>
			printk("%d ", vector);
  180db1:	53                   	push   %ebx
  180db2:	68 d9 1d 18 00       	push   $0x181dd9
  180db7:	e8 bf f9 ff ff       	call   18077b <printk>
  180dbc:	83 c4 08             	add    $0x8,%esp
		}
		printk("*****\n");
  180dbf:	68 dd 1d 18 00       	push   $0x181ddd
  180dc4:	e8 b2 f9 ff ff       	call   18077b <printk>
  180dc9:	83 c4 04             	add    $0x4,%esp
		break;
  180dcc:	eb 2c                	jmp    180dfa <_NanoFatalErrorHandler+0x8f>
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  180dce:	68 84 1e 18 00       	push   $0x181e84
  180dd3:	e8 a3 f9 ff ff       	call   18077b <printk>
  180dd8:	83 c4 04             	add    $0x4,%esp
		break;
  180ddb:	eb 1d                	jmp    180dfa <_NanoFatalErrorHandler+0x8f>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  180ddd:	68 b0 1e 18 00       	push   $0x181eb0
  180de2:	e8 94 f9 ff ff       	call   18077b <printk>
  180de7:	83 c4 04             	add    $0x4,%esp
		break;
  180dea:	eb 0e                	jmp    180dfa <_NanoFatalErrorHandler+0x8f>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  180dec:	56                   	push   %esi
  180ded:	68 d8 1e 18 00       	push   $0x181ed8
  180df2:	e8 84 f9 ff ff       	call   18077b <printk>
  180df7:	83 c4 08             	add    $0x8,%esp
		break;
	}

	printk("Current thread ID = %p\n"
  180dfa:	8b 6f 2c             	mov    0x2c(%edi),%ebp
  180dfd:	8b 07                	mov    (%edi),%eax
  180dff:	89 04 24             	mov    %eax,(%esp)
  180e02:	8b 4f 04             	mov    0x4(%edi),%ecx
  180e05:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  180e09:	8b 5f 10             	mov    0x10(%edi),%ebx
  180e0c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  180e10:	8b 57 0c             	mov    0xc(%edi),%edx
  180e13:	89 54 24 0c          	mov    %edx,0xc(%esp)
  180e17:	8b 47 14             	mov    0x14(%edi),%eax
  180e1a:	89 44 24 10          	mov    %eax,0x10(%esp)
  180e1e:	8b 4f 1c             	mov    0x1c(%edi),%ecx
  180e21:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  180e25:	8b 5f 08             	mov    0x8(%edi),%ebx
  180e28:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  180e2c:	8b 57 18             	mov    0x18(%edi),%edx
  180e2f:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  180e33:	8b 47 24             	mov    0x24(%edi),%eax
  180e36:	89 44 24 20          	mov    %eax,0x20(%esp)
	       "Faulting segment:address = 0x%x:0x%x\n"
	       "eax: 0x%x, ebx: 0x%x, ecx: 0x%x, edx: 0x%x\n"
	       "esi: 0x%x, edi: 0x%x, ebp: 0%x, esp: 0x%x\n"
	       "eflags: 0x%x\n",
	       k_current_get(),
	       pEsf->cs & 0xFFFF, pEsf->eip,
  180e3a:	8b 5f 28             	mov    0x28(%edi),%ebx
	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}

	printk("Current thread ID = %p\n"
  180e3d:	e8 0d 06 00 00       	call   18144f <k_current_get>
  180e42:	55                   	push   %ebp
  180e43:	ff 74 24 04          	pushl  0x4(%esp)
  180e47:	ff 74 24 0c          	pushl  0xc(%esp)
  180e4b:	ff 74 24 14          	pushl  0x14(%esp)
  180e4f:	ff 74 24 1c          	pushl  0x1c(%esp)
  180e53:	ff 74 24 24          	pushl  0x24(%esp)
  180e57:	ff 74 24 2c          	pushl  0x2c(%esp)
  180e5b:	ff 74 24 34          	pushl  0x34(%esp)
  180e5f:	ff 74 24 3c          	pushl  0x3c(%esp)
  180e63:	ff 74 24 44          	pushl  0x44(%esp)
  180e67:	0f b7 d3             	movzwl %bx,%edx
  180e6a:	52                   	push   %edx
  180e6b:	50                   	push   %eax
  180e6c:	68 fc 1e 18 00       	push   $0x181efc
  180e71:	e8 05 f9 ff ff       	call   18077b <printk>
  180e76:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  180e79:	89 fa                	mov    %edi,%edx
  180e7b:	89 f0                	mov    %esi,%eax
  180e7d:	e8 c6 fc ff ff       	call   180b48 <_SysFatalErrorHandler>

00180e82 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  180e82:	56                   	push   %esi
  180e83:	53                   	push   %ebx
  180e84:	89 c3                	mov    %eax,%ebx
  180e86:	89 d6                	mov    %edx,%esi
	printk("***** CPU exception %d\n", vector);
  180e88:	50                   	push   %eax
  180e89:	68 e4 1d 18 00       	push   $0x181de4
  180e8e:	e8 e8 f8 ff ff       	call   18077b <printk>
  180e93:	83 c4 08             	add    $0x8,%esp
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  180e96:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  180e9b:	88 d9                	mov    %bl,%cl
  180e9d:	d3 f8                	sar    %cl,%eax
  180e9f:	a8 01                	test   $0x1,%al
  180ea1:	74 10                	je     180eb3 <generic_exc_handle+0x31>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  180ea3:	ff 76 20             	pushl  0x20(%esi)
  180ea6:	68 fc 1d 18 00       	push   $0x181dfc
  180eab:	e8 cb f8 ff ff       	call   18077b <printk>
  180eb0:	83 c4 08             	add    $0x8,%esp
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  180eb3:	89 f2                	mov    %esi,%edx
  180eb5:	b8 06 00 00 00       	mov    $0x6,%eax
  180eba:	e8 ac fe ff ff       	call   180d6b <_NanoFatalErrorHandler>

00180ebf <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  180ebf:	89 c2                	mov    %eax,%edx
  180ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  180ec6:	e8 b7 ff ff ff       	call   180e82 <generic_exc_handle>

00180ecb <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  180ecb:	89 c2                	mov    %eax,%edx
  180ecd:	b8 02 00 00 00       	mov    $0x2,%eax
  180ed2:	e8 ab ff ff ff       	call   180e82 <generic_exc_handle>

00180ed7 <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  180ed7:	89 c2                	mov    %eax,%edx
  180ed9:	b8 04 00 00 00       	mov    $0x4,%eax
  180ede:	e8 9f ff ff ff       	call   180e82 <generic_exc_handle>

00180ee3 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  180ee3:	89 c2                	mov    %eax,%edx
  180ee5:	b8 05 00 00 00       	mov    $0x5,%eax
  180eea:	e8 93 ff ff ff       	call   180e82 <generic_exc_handle>

00180eef <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  180eef:	89 c2                	mov    %eax,%edx
  180ef1:	b8 06 00 00 00       	mov    $0x6,%eax
  180ef6:	e8 87 ff ff ff       	call   180e82 <generic_exc_handle>

00180efb <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  180efb:	89 c2                	mov    %eax,%edx
  180efd:	b8 07 00 00 00       	mov    $0x7,%eax
  180f02:	e8 7b ff ff ff       	call   180e82 <generic_exc_handle>

00180f07 <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  180f07:	89 c2                	mov    %eax,%edx
  180f09:	b8 08 00 00 00       	mov    $0x8,%eax
  180f0e:	e8 6f ff ff ff       	call   180e82 <generic_exc_handle>

00180f13 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  180f13:	89 c2                	mov    %eax,%edx
  180f15:	b8 0a 00 00 00       	mov    $0xa,%eax
  180f1a:	e8 63 ff ff ff       	call   180e82 <generic_exc_handle>

00180f1f <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  180f1f:	89 c2                	mov    %eax,%edx
  180f21:	b8 0b 00 00 00       	mov    $0xb,%eax
  180f26:	e8 57 ff ff ff       	call   180e82 <generic_exc_handle>

00180f2b <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  180f2b:	89 c2                	mov    %eax,%edx
  180f2d:	b8 0c 00 00 00       	mov    $0xc,%eax
  180f32:	e8 4b ff ff ff       	call   180e82 <generic_exc_handle>

00180f37 <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  180f37:	89 c2                	mov    %eax,%edx
  180f39:	b8 0d 00 00 00       	mov    $0xd,%eax
  180f3e:	e8 3f ff ff ff       	call   180e82 <generic_exc_handle>

00180f43 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  180f43:	89 c2                	mov    %eax,%edx
  180f45:	b8 0e 00 00 00       	mov    $0xe,%eax
  180f4a:	e8 33 ff ff ff       	call   180e82 <generic_exc_handle>

00180f4f <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  180f4f:	89 c2                	mov    %eax,%edx
  180f51:	b8 10 00 00 00       	mov    $0x10,%eax
  180f56:	e8 27 ff ff ff       	call   180e82 <generic_exc_handle>

00180f5b <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  180f5b:	89 c2                	mov    %eax,%edx
  180f5d:	b8 11 00 00 00       	mov    $0x11,%eax
  180f62:	e8 1b ff ff ff       	call   180e82 <generic_exc_handle>

00180f67 <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  180f67:	89 c2                	mov    %eax,%edx
  180f69:	b8 12 00 00 00       	mov    $0x12,%eax
  180f6e:	e8 0f ff ff ff       	call   180e82 <generic_exc_handle>

00180f73 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  180f73:	56                   	push   %esi
  180f74:	53                   	push   %ebx
  180f75:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  180f77:	8b 1c 85 e0 1f 18 00 	mov    0x181fe0(,%eax,4),%ebx
  180f7e:	eb 0a                	jmp    180f8a <_sys_device_do_config_level+0x17>
		struct device_config *device = info->config;
  180f80:	8b 13                	mov    (%ebx),%edx

		device->init(info);
  180f82:	89 d8                	mov    %ebx,%eax
  180f84:	ff 52 04             	call   *0x4(%edx)
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  180f87:	83 c3 0c             	add    $0xc,%ebx
  180f8a:	3b 1c b5 e4 1f 18 00 	cmp    0x181fe4(,%esi,4),%ebx
  180f91:	72 ed                	jb     180f80 <_sys_device_do_config_level+0xd>
		struct device_config *device = info->config;

		device->init(info);
	}
}
  180f93:	5b                   	pop    %ebx
  180f94:	5e                   	pop    %esi
  180f95:	c3                   	ret    

00180f96 <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  180f96:	56                   	push   %esi
  180f97:	53                   	push   %ebx
  180f98:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  180f9a:	bb 28 00 28 00       	mov    $0x280028,%ebx
  180f9f:	eb 18                	jmp    180fb9 <device_get_binding+0x23>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  180fa1:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  180fa5:	74 0f                	je     180fb6 <device_get_binding+0x20>
  180fa7:	8b 03                	mov    (%ebx),%eax
  180fa9:	8b 10                	mov    (%eax),%edx
  180fab:	89 f0                	mov    %esi,%eax
  180fad:	e8 68 f4 ff ff       	call   18041a <strcmp>
  180fb2:	85 c0                	test   %eax,%eax
  180fb4:	74 12                	je     180fc8 <device_get_binding+0x32>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  180fb6:	83 c3 0c             	add    $0xc,%ebx
  180fb9:	81 fb 94 00 28 00    	cmp    $0x280094,%ebx
  180fbf:	75 e0                	jne    180fa1 <device_get_binding+0xb>
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
  180fc1:	b8 00 00 00 00       	mov    $0x0,%eax
  180fc6:	eb 02                	jmp    180fca <device_get_binding+0x34>
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
  180fc8:	89 d8                	mov    %ebx,%eax
		}
	}

	return NULL;
}
  180fca:	5b                   	pop    %ebx
  180fcb:	5e                   	pop    %esi
  180fcc:	c3                   	ret    

00180fcd <prepare_multithreading>:
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  180fcd:	a3 c8 00 28 00       	mov    %eax,0x2800c8

	dummy_thread->base.user_options = K_ESSENTIAL;
  180fd2:	c6 40 08 01          	movb   $0x1,0x8(%eax)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  180fd6:	b8 00 00 00 00       	mov    $0x0,%eax
  180fdb:	eb 1a                	jmp    180ff7 <prepare_multithreading+0x2a>
		sys_dlist_init(&_ready_q.q[ii]);
  180fdd:	8d 50 01             	lea    0x1(%eax),%edx
  180fe0:	8d 0c d5 d4 00 28 00 	lea    0x2800d4(,%edx,8),%ecx
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  180fe7:	89 0c d5 d4 00 28 00 	mov    %ecx,0x2800d4(,%edx,8)
	list->tail = (sys_dnode_t *)list;
  180fee:	89 0c c5 e0 00 28 00 	mov    %ecx,0x2800e0(,%eax,8)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  180ff5:	89 d0                	mov    %edx,%eax
  180ff7:	83 f8 1f             	cmp    $0x1f,%eax
  180ffa:	7e e1                	jle    180fdd <prepare_multithreading+0x10>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
  180ffc:	c7 05 d4 00 28 00 04 	movl   $0x280404,0x2800d4
  181003:	04 28 00 

	_new_thread(_main_stack, MAIN_STACK_SIZE,
  181006:	6a 01                	push   $0x1
  181008:	6a 00                	push   $0x0
  18100a:	6a 00                	push   $0x0
  18100c:	6a 00                	push   $0x0
  18100e:	6a 00                	push   $0x0
  181010:	b9 bc 10 18 00       	mov    $0x1810bc,%ecx
  181015:	ba 00 02 00 00       	mov    $0x200,%edx
  18101a:	b8 04 04 28 00       	mov    $0x280404,%eax
  18101f:	e8 01 fd ff ff       	call   180d25 <_new_thread>
  181024:	83 c4 14             	add    $0x14,%esp
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  181027:	a0 0d 04 28 00       	mov    0x28040d,%al
  18102c:	83 e0 fb             	and    $0xfffffffb,%eax
  18102f:	a2 0d 04 28 00       	mov    %al,0x28040d
		    _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
  181034:	b8 04 04 28 00       	mov    $0x280404,%eax
  181039:	e8 3b 01 00 00       	call   181179 <_add_thread_to_ready_q>

#ifdef CONFIG_MULTITHREADING
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  18103e:	6a 01                	push   $0x1
  181040:	6a 0f                	push   $0xf
  181042:	6a 00                	push   $0x0
  181044:	6a 00                	push   $0x0
  181046:	6a 00                	push   $0x0
  181048:	b9 b4 1a 18 00       	mov    $0x181ab4,%ecx
  18104d:	ba 00 01 00 00       	mov    $0x100,%edx
  181052:	b8 04 03 28 00       	mov    $0x280304,%eax
  181057:	e8 c9 fc ff ff       	call   180d25 <_new_thread>
  18105c:	83 c4 14             	add    $0x14,%esp
  18105f:	a0 0d 03 28 00       	mov    0x28030d,%al
  181064:	83 e0 fb             	and    $0xfffffffb,%eax
  181067:	a2 0d 03 28 00       	mov    %al,0x28030d
		    idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
  18106c:	b8 04 03 28 00       	mov    $0x280304,%eax
  181071:	e8 03 01 00 00       	call   181179 <_add_thread_to_ready_q>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  181076:	c7 05 cc 00 28 00 cc 	movl   $0x2800cc,0x2800cc
  18107d:	00 28 00 
	list->tail = (sys_dnode_t *)list;
  181080:	c7 05 d0 00 28 00 cc 	movl   $0x2800cc,0x2800d0
  181087:	00 28 00 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
  18108a:	c7 05 c0 00 28 00 00 	movl   $0x0,0x2800c0
  181091:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  181094:	c7 05 c4 00 28 00 04 	movl   $0x280304,0x2800c4
  18109b:	03 28 00 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  18109e:	c7 05 f0 01 28 00 00 	movl   $0x200,0x2801f0
  1810a5:	02 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
  1810a8:	c7 05 e8 01 28 00 c6 	movl   $0x180bc6,0x2801e8
  1810af:	0b 18 00 
  1810b2:	c3                   	ret    

001810b3 <switch_to_main_thread>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1810b3:	9c                   	pushf  
  1810b4:	fa                   	cli    
  1810b5:	58                   	pop    %eax
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */

	_Swap(irq_lock());
  1810b6:	e8 db fb ff ff       	call   180c96 <_Swap>
  1810bb:	c3                   	ret    

001810bc <_main>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  1810bc:	b8 02 00 00 00       	mov    $0x2,%eax
  1810c1:	e8 ad fe ff ff       	call   180f73 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  1810c6:	b8 05 00 00 00       	mov    $0x5,%eax
  1810cb:	e8 a3 fe ff ff       	call   180f73 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  1810d0:	b8 06 00 00 00       	mov    $0x6,%eax
  1810d5:	e8 99 fe ff ff       	call   180f73 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  1810da:	b8 07 00 00 00       	mov    $0x7,%eax
  1810df:	e8 8f fe ff ff       	call   180f73 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  1810e4:	b8 03 00 00 00       	mov    $0x3,%eax
  1810e9:	e8 85 fe ff ff       	call   180f73 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  1810ee:	e8 d6 08 00 00       	call   1819c9 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  1810f3:	e8 72 ef ff ff       	call   18006a <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
  1810f8:	a0 0c 04 28 00       	mov    0x28040c,%al
  1810fd:	83 e0 fe             	and    $0xfffffffe,%eax
  181100:	a2 0c 04 28 00       	mov    %al,0x28040c
  181105:	c3                   	ret    

00181106 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  181106:	83 ec 48             	sub    $0x48,%esp
	 * Initialize kernel data structures. This step includes
	 * initializing the interrupt subsystem, which must be performed
	 * before the hardware initialization phase.
	 */

	prepare_multithreading(dummy_thread);
  181109:	89 e0                	mov    %esp,%eax
  18110b:	e8 bd fe ff ff       	call   180fcd <prepare_multithreading>

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  181110:	b8 04 00 00 00       	mov    $0x4,%eax
  181115:	e8 59 fe ff ff       	call   180f73 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  18111a:	b8 00 00 00 00       	mov    $0x0,%eax
  18111f:	e8 4f fe ff ff       	call   180f73 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  181124:	b8 01 00 00 00       	mov    $0x1,%eax
  181129:	e8 45 fe ff ff       	call   180f73 <_sys_device_do_config_level>

	/* display boot banner */

	PRINT_BOOT_BANNER();

	switch_to_main_thread();
  18112e:	e8 80 ff ff ff       	call   1810b3 <switch_to_main_thread>

00181133 <_set_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  181133:	8d 48 10             	lea    0x10(%eax),%ecx
  181136:	89 ca                	mov    %ecx,%edx
  181138:	c1 fa 05             	sar    $0x5,%edx
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  18113b:	b8 01 00 00 00       	mov    $0x1,%eax
  181140:	d3 e0                	shl    %cl,%eax
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  181142:	09 04 95 d8 00 28 00 	or     %eax,0x2800d8(,%edx,4)
  181149:	c3                   	ret    

0018114a <_clear_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  18114a:	8d 48 10             	lea    0x10(%eax),%ecx
  18114d:	89 c8                	mov    %ecx,%eax
  18114f:	c1 f8 05             	sar    $0x5,%eax
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  181152:	ba 01 00 00 00       	mov    $0x1,%edx
  181157:	d3 e2                	shl    %cl,%edx
static void _clear_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap &= ~_get_ready_q_prio_bit(prio);
  181159:	f7 d2                	not    %edx
  18115b:	21 14 85 d8 00 28 00 	and    %edx,0x2800d8(,%eax,4)
  181162:	c3                   	ret    

00181163 <_get_ready_q_head>:

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  181163:	0f bc 05 d8 00 28 00 	bsf    0x2800d8,%eax
  18116a:	75 05                	jne    181171 <_get_ready_q_head+0xe>
  18116c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 * @return a pointer to the head element
 */

static inline sys_dnode_t *sys_dlist_peek_head_not_empty(sys_dlist_t *list)
{
	return list->head;
  181171:	8b 04 c5 dc 00 28 00 	mov    0x2800dc(,%eax,8),%eax

	struct k_thread *thread =
		(struct k_thread *)sys_dlist_peek_head_not_empty(list);

	return thread;
}
  181178:	c3                   	ret    

00181179 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  181179:	57                   	push   %edi
  18117a:	56                   	push   %esi
  18117b:	53                   	push   %ebx
  18117c:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  18117e:	0f be 58 0a          	movsbl 0xa(%eax),%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
  181182:	8d 3c dd 5c 01 28 00 	lea    0x28015c(,%ebx,8),%edi

	_set_ready_q_prio_bit(thread->base.prio);
  181189:	89 d8                	mov    %ebx,%eax
  18118b:	e8 a3 ff ff ff       	call   181133 <_set_ready_q_prio_bit>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  181190:	89 3e                	mov    %edi,(%esi)
	node->prev = list->tail;
  181192:	83 c3 14             	add    $0x14,%ebx
  181195:	8b 04 dd c0 00 28 00 	mov    0x2800c0(,%ebx,8),%eax
  18119c:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  18119f:	8b 04 dd c0 00 28 00 	mov    0x2800c0(,%ebx,8),%eax
  1811a6:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  1811a8:	89 34 dd c0 00 28 00 	mov    %esi,0x2800c0(,%ebx,8)
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
  1811af:	a1 d4 00 28 00       	mov    0x2800d4,%eax
  1811b4:	8a 50 0a             	mov    0xa(%eax),%dl
  1811b7:	38 56 0a             	cmp    %dl,0xa(%esi)
  1811ba:	7d 02                	jge    1811be <_add_thread_to_ready_q+0x45>
  1811bc:	89 f0                	mov    %esi,%eax
  1811be:	a3 d4 00 28 00       	mov    %eax,0x2800d4
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
  1811c3:	5b                   	pop    %ebx
  1811c4:	5e                   	pop    %esi
  1811c5:	5f                   	pop    %edi
  1811c6:	c3                   	ret    

001811c7 <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  1811c7:	56                   	push   %esi
  1811c8:	53                   	push   %ebx
  1811c9:	89 c3                	mov    %eax,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  1811cb:	0f be 40 0a          	movsbl 0xa(%eax),%eax
	sys_dlist_t *q = &_ready_q.q[q_index];
  1811cf:	83 c0 11             	add    $0x11,%eax
  1811d2:	8d 14 c5 d4 00 28 00 	lea    0x2800d4(,%eax,8),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1811d9:	8b 4b 04             	mov    0x4(%ebx),%ecx
  1811dc:	8b 33                	mov    (%ebx),%esi
  1811de:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  1811e0:	8b 0b                	mov    (%ebx),%ecx
  1811e2:	8b 73 04             	mov    0x4(%ebx),%esi
  1811e5:	89 71 04             	mov    %esi,0x4(%ecx)

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  1811e8:	3b 14 c5 d4 00 28 00 	cmp    0x2800d4(,%eax,8),%edx
  1811ef:	75 09                	jne    1811fa <_remove_thread_from_ready_q+0x33>
		_clear_ready_q_prio_bit(thread->base.prio);
  1811f1:	0f be 43 0a          	movsbl 0xa(%ebx),%eax
  1811f5:	e8 50 ff ff ff       	call   18114a <_clear_ready_q_prio_bit>
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  1811fa:	a1 d4 00 28 00       	mov    0x2800d4,%eax
  1811ff:	39 c3                	cmp    %eax,%ebx
  181201:	75 05                	jne    181208 <_remove_thread_from_ready_q+0x41>
  181203:	e8 5b ff ff ff       	call   181163 <_get_ready_q_head>
  181208:	a3 d4 00 28 00       	mov    %eax,0x2800d4
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
  18120d:	5b                   	pop    %ebx
  18120e:	5e                   	pop    %esi
  18120f:	c3                   	ret    

00181210 <__must_switch_threads>:
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  181210:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  181215:	0f be 50 0a          	movsbl 0xa(%eax),%edx
  181219:	0f bc 05 d8 00 28 00 	bsf    0x2800d8,%eax
  181220:	75 05                	jne    181227 <__must_switch_threads+0x17>
  181222:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	int abs_prio = (find_lsb_set(ready_range) - 1) + (bitmap << 5);

	__ASSERT(abs_prio < K_NUM_PRIORITIES, "prio out-of-range\n");

	return abs_prio - _NUM_COOP_PRIO;
  181227:	83 e8 10             	sub    $0x10,%eax
	return _is_prio1_higher_than_or_equal_to_prio2(prio1, prio2);
}

static inline int _is_prio1_higher_than_prio2(int prio1, int prio2)
{
	return prio1 < prio2;
  18122a:	39 c2                	cmp    %eax,%edx
  18122c:	0f 9f c0             	setg   %al
  18122f:	0f b6 c0             	movzbl %al,%eax
#else
	return 0;
#endif
}
  181232:	c3                   	ret    

00181233 <_reschedule_threads>:

/* reschedule threads if the scheduler is not locked */
/* not callable from ISR */
/* must be called with interrupts locked */
void _reschedule_threads(int key)
{
  181233:	53                   	push   %ebx
  181234:	89 c3                	mov    %eax,%ebx
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  181236:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  18123b:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  181240:	77 10                	ja     181252 <_reschedule_threads+0x1f>
  181242:	e8 c9 ff ff ff       	call   181210 <__must_switch_threads>
  181247:	85 c0                	test   %eax,%eax
  181249:	74 0c                	je     181257 <_reschedule_threads+0x24>
  18124b:	b8 01 00 00 00       	mov    $0x1,%eax
  181250:	eb 05                	jmp    181257 <_reschedule_threads+0x24>
  181252:	b8 00 00 00 00       	mov    $0x0,%eax
#ifdef CONFIG_PREEMPT_ENABLED
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
  181257:	85 c0                	test   %eax,%eax
  181259:	74 09                	je     181264 <_reschedule_threads+0x31>
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  18125b:	89 d8                	mov    %ebx,%eax
  18125d:	e8 34 fa ff ff       	call   180c96 <_Swap>
  181262:	eb 06                	jmp    18126a <_reschedule_threads+0x37>
  181264:	f6 c7 02             	test   $0x2,%bh
  181267:	74 01                	je     18126a <_reschedule_threads+0x37>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181269:	fb                   	sti    
		irq_unlock(key);
	}
#else
	irq_unlock(key);
#endif
}
  18126a:	5b                   	pop    %ebx
  18126b:	c3                   	ret    

0018126c <k_sched_unlock>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18126c:	9c                   	pushf  
  18126d:	fa                   	cli    
  18126e:	58                   	pop    %eax

	int key = irq_lock();

	/* compiler_barrier() not needed, comes from irq_lock() */

	++_current->base.sched_locked;
  18126f:	8b 0d c8 00 28 00    	mov    0x2800c8,%ecx
  181275:	8a 51 0b             	mov    0xb(%ecx),%dl
  181278:	42                   	inc    %edx
  181279:	88 51 0b             	mov    %dl,0xb(%ecx)

	K_DEBUG("scheduler unlocked (%p:%d)\n",
		_current, _current->base.sched_locked);

	_reschedule_threads(key);
  18127c:	e8 b2 ff ff ff       	call   181233 <_reschedule_threads>
  181281:	c3                   	ret    

00181282 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  181282:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	sys_dlist_t *q = &_ready_q.q[q_index];

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  181286:	3b 04 cd 60 01 28 00 	cmp    0x280160(,%ecx,8),%eax
  18128d:	74 53                	je     1812e2 <_move_thread_to_end_of_prio_q+0x60>
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  18128f:	56                   	push   %esi
  181290:	53                   	push   %ebx
  181291:	8d 51 10             	lea    0x10(%ecx),%edx
  181294:	8d 1c cd 5c 01 28 00 	lea    0x28015c(,%ecx,8),%ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  18129b:	8b 48 04             	mov    0x4(%eax),%ecx
  18129e:	8b 30                	mov    (%eax),%esi
  1812a0:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  1812a2:	8b 08                	mov    (%eax),%ecx
  1812a4:	8b 70 04             	mov    0x4(%eax),%esi
  1812a7:	89 71 04             	mov    %esi,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1812aa:	89 18                	mov    %ebx,(%eax)
	node->prev = list->tail;
  1812ac:	83 c2 04             	add    $0x4,%edx
  1812af:	8b 0c d5 c0 00 28 00 	mov    0x2800c0(,%edx,8),%ecx
  1812b6:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  1812b9:	8b 0c d5 c0 00 28 00 	mov    0x2800c0(,%edx,8),%ecx
  1812c0:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  1812c2:	89 04 d5 c0 00 28 00 	mov    %eax,0x2800c0(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  1812c9:	8b 15 d4 00 28 00    	mov    0x2800d4,%edx
  1812cf:	39 d0                	cmp    %edx,%eax
  1812d1:	75 07                	jne    1812da <_move_thread_to_end_of_prio_q+0x58>
  1812d3:	e8 8b fe ff ff       	call   181163 <_get_ready_q_head>
  1812d8:	89 c2                	mov    %eax,%edx
  1812da:	89 15 d4 00 28 00    	mov    %edx,0x2800d4
#endif
}
  1812e0:	5b                   	pop    %ebx
  1812e1:	5e                   	pop    %esi
  1812e2:	c3                   	ret    

001812e3 <k_yield>:

void k_yield(void)
{
  1812e3:	53                   	push   %ebx
  1812e4:	9c                   	pushf  
  1812e5:	fa                   	cli    
  1812e6:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	int key = irq_lock();

	_move_thread_to_end_of_prio_q(_current);
  1812e7:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  1812ec:	e8 91 ff ff ff       	call   181282 <_move_thread_to_end_of_prio_q>

	if (_current == _get_next_ready_thread()) {
  1812f1:	a1 d4 00 28 00       	mov    0x2800d4,%eax
  1812f6:	39 05 c8 00 28 00    	cmp    %eax,0x2800c8
  1812fc:	75 08                	jne    181306 <k_yield+0x23>
  1812fe:	f6 c7 02             	test   $0x2,%bh
  181301:	74 0a                	je     18130d <k_yield+0x2a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181303:	fb                   	sti    
  181304:	eb 07                	jmp    18130d <k_yield+0x2a>
		irq_unlock(key);
	} else {
		_Swap(key);
  181306:	89 d8                	mov    %ebx,%eax
  181308:	e8 89 f9 ff ff       	call   180c96 <_Swap>
	}
}
  18130d:	5b                   	pop    %ebx
  18130e:	c3                   	ret    

0018130f <k_sleep>:

void k_sleep(int32_t duration)
{
  18130f:	57                   	push   %edi
  181310:	56                   	push   %esi
  181311:	53                   	push   %ebx
  181312:	83 ec 04             	sub    $0x4,%esp
	__ASSERT(duration != K_FOREVER, "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
  181315:	85 c0                	test   %eax,%eax
  181317:	75 0a                	jne    181323 <k_sleep+0x14>
		k_yield();
  181319:	e8 c5 ff ff ff       	call   1812e3 <k_yield>
		return;
  18131e:	e9 25 01 00 00       	jmp    181448 <k_sleep+0x139>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  181323:	83 c0 09             	add    $0x9,%eax
  181326:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  18132b:	f7 e2                	mul    %edx
  18132d:	c1 ea 03             	shr    $0x3,%edx
	}

	ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  181330:	42                   	inc    %edx
  181331:	89 14 24             	mov    %edx,(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  181334:	9c                   	pushf  
  181335:	fa                   	cli    
  181336:	5b                   	pop    %ebx
	key = irq_lock();

	_remove_thread_from_ready_q(_current);
  181337:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  18133c:	e8 86 fe ff ff       	call   1811c7 <_remove_thread_from_ready_q>
	_add_thread_timeout(_current, NULL, ticks);
  181341:	8b 04 24             	mov    (%esp),%eax
  181344:	8b 3d c8 00 28 00    	mov    0x2800c8,%edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  18134a:	8d 77 10             	lea    0x10(%edi),%esi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  18134d:	89 46 10             	mov    %eax,0x10(%esi)
	timeout->thread = thread;
  181350:	89 7e 08             	mov    %edi,0x8(%esi)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  181353:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  18135a:	a1 cc 00 28 00       	mov    0x2800cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  18135f:	3d cc 00 28 00       	cmp    $0x2800cc,%eax
  181364:	75 07                	jne    18136d <k_sleep+0x5e>
  181366:	ba 00 00 00 00       	mov    $0x0,%edx
  18136b:	eb 02                	jmp    18136f <k_sleep+0x60>
  18136d:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  18136f:	85 d2                	test   %edx,%edx
  181371:	74 15                	je     181388 <k_sleep+0x79>
  181373:	3d cc 00 28 00       	cmp    $0x2800cc,%eax
  181378:	0f 85 9f 00 00 00    	jne    18141d <k_sleep+0x10e>
  18137e:	b8 00 00 00 00       	mov    $0x0,%eax
  181383:	e9 95 00 00 00       	jmp    18141d <k_sleep+0x10e>
  181388:	b8 00 00 00 00       	mov    $0x0,%eax
  18138d:	e9 8b 00 00 00       	jmp    18141d <k_sleep+0x10e>
		if (*delta <= in_q->delta_ticks_from_prev) {
  181392:	8b 56 10             	mov    0x10(%esi),%edx
  181395:	8b 48 10             	mov    0x10(%eax),%ecx
  181398:	39 ca                	cmp    %ecx,%edx
  18139a:	7f 3a                	jg     1813d6 <k_sleep+0xc7>
			in_q->delta_ticks_from_prev -= *delta;
  18139c:	29 d1                	sub    %edx,%ecx
  18139e:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  1813a1:	85 c0                	test   %eax,%eax
  1813a3:	75 1e                	jne    1813c3 <k_sleep+0xb4>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1813a5:	c7 47 10 cc 00 28 00 	movl   $0x2800cc,0x10(%edi)
	node->prev = list->tail;
  1813ac:	a1 d0 00 28 00       	mov    0x2800d0,%eax
  1813b1:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  1813b4:	a1 d0 00 28 00       	mov    0x2800d0,%eax
  1813b9:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  1813bb:	89 35 d0 00 28 00    	mov    %esi,0x2800d0
  1813c1:	eb 7e                	jmp    181441 <k_sleep+0x132>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  1813c3:	8b 50 04             	mov    0x4(%eax),%edx
  1813c6:	89 56 04             	mov    %edx,0x4(%esi)
		node->next = insert_point;
  1813c9:	89 47 10             	mov    %eax,0x10(%edi)
		insert_point->prev->next = node;
  1813cc:	8b 50 04             	mov    0x4(%eax),%edx
  1813cf:	89 32                	mov    %esi,(%edx)
		insert_point->prev = node;
  1813d1:	89 70 04             	mov    %esi,0x4(%eax)
  1813d4:	eb 6b                	jmp    181441 <k_sleep+0x132>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  1813d6:	29 ca                	sub    %ecx,%edx
  1813d8:	89 56 10             	mov    %edx,0x10(%esi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1813db:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1813dd:	85 c0                	test   %eax,%eax
  1813df:	74 0c                	je     1813ed <k_sleep+0xde>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1813e1:	3b 05 d0 00 28 00    	cmp    0x2800d0,%eax
  1813e7:	74 08                	je     1813f1 <k_sleep+0xe2>
  1813e9:	8b 08                	mov    (%eax),%ecx
  1813eb:	eb 09                	jmp    1813f6 <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1813ed:	89 c1                	mov    %eax,%ecx
  1813ef:	eb 05                	jmp    1813f6 <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1813f1:	b9 00 00 00 00       	mov    $0x0,%ecx
  1813f6:	85 c9                	test   %ecx,%ecx
  1813f8:	74 1e                	je     181418 <k_sleep+0x109>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1813fa:	85 d2                	test   %edx,%edx
  1813fc:	74 0c                	je     18140a <k_sleep+0xfb>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1813fe:	3b 15 d0 00 28 00    	cmp    0x2800d0,%edx
  181404:	74 0b                	je     181411 <k_sleep+0x102>
  181406:	8b 00                	mov    (%eax),%eax
  181408:	eb 13                	jmp    18141d <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18140a:	b8 00 00 00 00       	mov    $0x0,%eax
  18140f:	eb 0c                	jmp    18141d <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  181411:	b8 00 00 00 00       	mov    $0x0,%eax
  181416:	eb 05                	jmp    18141d <k_sleep+0x10e>
  181418:	b8 00 00 00 00       	mov    $0x0,%eax
  18141d:	85 c0                	test   %eax,%eax
  18141f:	0f 85 6d ff ff ff    	jne    181392 <k_sleep+0x83>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  181425:	c7 47 10 cc 00 28 00 	movl   $0x2800cc,0x10(%edi)
	node->prev = list->tail;
  18142c:	a1 d0 00 28 00       	mov    0x2800d0,%eax
  181431:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  181434:	a1 d0 00 28 00       	mov    0x2800d0,%eax
  181439:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  18143b:	89 35 d0 00 28 00    	mov    %esi,0x2800d0

	_Swap(key);
  181441:	89 d8                	mov    %ebx,%eax
  181443:	e8 4e f8 ff ff       	call   180c96 <_Swap>
#endif
}
  181448:	83 c4 04             	add    $0x4,%esp
  18144b:	5b                   	pop    %ebx
  18144c:	5e                   	pop    %esi
  18144d:	5f                   	pop    %edi
  18144e:	c3                   	ret    

0018144f <k_current_get>:
}

k_tid_t k_current_get(void)
{
	return _current;
}
  18144f:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  181454:	c3                   	ret    

00181455 <handle_time_slicing>:
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
	if (_time_slice_duration == 0) {
  181455:	8b 15 e4 01 28 00    	mov    0x2801e4,%edx
  18145b:	85 d2                	test   %edx,%edx
  18145d:	74 50                	je     1814af <handle_time_slicing+0x5a>
		return;
	}

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  18145f:	8b 0d c8 00 28 00    	mov    0x2800c8,%ecx
  181465:	0f be 49 0a          	movsbl 0xa(%ecx),%ecx
  181469:	39 0d e0 01 28 00    	cmp    %ecx,0x2801e0
  18146f:	7f 3e                	jg     1814af <handle_time_slicing+0x5a>
 *   in this function and at thread level
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
  181471:	57                   	push   %edi
  181472:	56                   	push   %esi
  181473:	53                   	push   %ebx
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
  181474:	89 c1                	mov    %eax,%ecx
  181476:	89 c6                	mov    %eax,%esi
  181478:	01 c6                	add    %eax,%esi
  18147a:	c1 e1 03             	shl    $0x3,%ecx
  18147d:	01 f1                	add    %esi,%ecx

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
  18147f:	03 0d f8 01 28 00    	add    0x2801f8,%ecx
  181485:	89 0d f8 01 28 00    	mov    %ecx,0x2801f8
	if (_time_slice_elapsed >= _time_slice_duration) {
  18148b:	39 ca                	cmp    %ecx,%edx
  18148d:	7f 1d                	jg     1814ac <handle_time_slicing+0x57>

		unsigned int key;

		_time_slice_elapsed = 0;
  18148f:	c7 05 f8 01 28 00 00 	movl   $0x0,0x2801f8
  181496:	00 00 00 
  181499:	9c                   	pushf  
  18149a:	fa                   	cli    
  18149b:	5b                   	pop    %ebx

		key = irq_lock();
		_move_thread_to_end_of_prio_q(_current);
  18149c:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  1814a1:	e8 dc fd ff ff       	call   181282 <_move_thread_to_end_of_prio_q>
  1814a6:	f6 c7 02             	test   $0x2,%bh
  1814a9:	74 01                	je     1814ac <handle_time_slicing+0x57>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1814ab:	fb                   	sti    
		irq_unlock(key);
	}
}
  1814ac:	5b                   	pop    %ebx
  1814ad:	5e                   	pop    %esi
  1814ae:	5f                   	pop    %edi
  1814af:	c3                   	ret    

001814b0 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  1814b0:	57                   	push   %edi
  1814b1:	56                   	push   %esi
  1814b2:	53                   	push   %ebx
  1814b3:	83 ec 08             	sub    $0x8,%esp
  1814b6:	89 c6                	mov    %eax,%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1814b8:	9c                   	pushf  
  1814b9:	fa                   	cli    
  1814ba:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
  1814bb:	89 f3                	mov    %esi,%ebx
  1814bd:	c1 fb 1f             	sar    $0x1f,%ebx
  1814c0:	01 35 fc 01 28 00    	add    %esi,0x2801fc
  1814c6:	11 1d 00 02 28 00    	adc    %ebx,0x280200
  1814cc:	f6 c4 02             	test   $0x2,%ah
  1814cf:	74 01                	je     1814d2 <_nano_sys_clock_tick_announce+0x22>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1814d1:	fb                   	sti    
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  1814d2:	89 24 24             	mov    %esp,(%esp)
	list->tail = (sys_dnode_t *)list;
  1814d5:	89 64 24 04          	mov    %esp,0x4(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1814d9:	9c                   	pushf  
  1814da:	fa                   	cli    
  1814db:	59                   	pop    %ecx
  1814dc:	89 ca                	mov    %ecx,%edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1814de:	a1 cc 00 28 00       	mov    0x2800cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1814e3:	3d cc 00 28 00       	cmp    $0x2800cc,%eax
  1814e8:	75 05                	jne    1814ef <_nano_sys_clock_tick_announce+0x3f>
  1814ea:	b8 00 00 00 00       	mov    $0x0,%eax
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (!head) {
  1814ef:	85 c0                	test   %eax,%eax
  1814f1:	75 0f                	jne    181502 <_nano_sys_clock_tick_announce+0x52>
  1814f3:	f6 c5 02             	test   $0x2,%ch
  1814f6:	0f 84 52 01 00 00    	je     18164e <_nano_sys_clock_tick_announce+0x19e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1814fc:	fb                   	sti    
  1814fd:	e9 4c 01 00 00       	jmp    18164e <_nano_sys_clock_tick_announce+0x19e>
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
  181502:	29 70 10             	sub    %esi,0x10(%eax)
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
  181505:	c7 05 f4 01 28 00 01 	movl   $0x1,0x2801f4
  18150c:	00 00 00 
  18150f:	eb 41                	jmp    181552 <_nano_sys_clock_tick_announce+0xa2>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  181511:	8b 48 04             	mov    0x4(%eax),%ecx
  181514:	8b 18                	mov    (%eax),%ebx
  181516:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  181518:	8b 08                	mov    (%eax),%ecx
  18151a:	8b 58 04             	mov    0x4(%eax),%ebx
  18151d:	89 59 04             	mov    %ebx,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
  181520:	8b 0c 24             	mov    (%esp),%ecx
  181523:	89 08                	mov    %ecx,(%eax)
	node->prev = list;
  181525:	89 60 04             	mov    %esp,0x4(%eax)

	list->head->prev = node;
  181528:	8b 0c 24             	mov    (%esp),%ecx
  18152b:	89 41 04             	mov    %eax,0x4(%ecx)
	list->head = node;
  18152e:	89 04 24             	mov    %eax,(%esp)
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
  181531:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
  181538:	f6 c6 02             	test   $0x2,%dh
  18153b:	74 01                	je     18153e <_nano_sys_clock_tick_announce+0x8e>
  18153d:	fb                   	sti    

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18153e:	9c                   	pushf  
  18153f:	fa                   	cli    
  181540:	5a                   	pop    %edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  181541:	a1 cc 00 28 00       	mov    0x2800cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  181546:	3d cc 00 28 00       	cmp    $0x2800cc,%eax
  18154b:	75 05                	jne    181552 <_nano_sys_clock_tick_announce+0xa2>
  18154d:	b8 00 00 00 00       	mov    $0x0,%eax
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
  181552:	85 c0                	test   %eax,%eax
  181554:	74 06                	je     18155c <_nano_sys_clock_tick_announce+0xac>
  181556:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  18155a:	74 b5                	je     181511 <_nano_sys_clock_tick_announce+0x61>
  18155c:	f6 c6 02             	test   $0x2,%dh
  18155f:	74 01                	je     181562 <_nano_sys_clock_tick_announce+0xb2>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181561:	fb                   	sti    
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  181562:	8b 14 24             	mov    (%esp),%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  181565:	39 e2                	cmp    %esp,%edx
  181567:	75 05                	jne    18156e <_nano_sys_clock_tick_announce+0xbe>
  181569:	ba 00 00 00 00       	mov    $0x0,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18156e:	85 d2                	test   %edx,%edx
  181570:	74 0d                	je     18157f <_nano_sys_clock_tick_announce+0xcf>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  181572:	3b 54 24 04          	cmp    0x4(%esp),%edx
  181576:	74 0e                	je     181586 <_nano_sys_clock_tick_announce+0xd6>
  181578:	8b 1a                	mov    (%edx),%ebx
  18157a:	e9 bd 00 00 00       	jmp    18163c <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18157f:	89 d3                	mov    %edx,%ebx
  181581:	e9 b6 00 00 00       	jmp    18163c <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  181586:	bb 00 00 00 00       	mov    $0x0,%ebx
  18158b:	e9 ac 00 00 00       	jmp    18163c <_nano_sys_clock_tick_announce+0x18c>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  181590:	8b 42 04             	mov    0x4(%edx),%eax
  181593:	8b 0a                	mov    (%edx),%ecx
  181595:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  181597:	8b 02                	mov    (%edx),%eax
  181599:	8b 4a 04             	mov    0x4(%edx),%ecx
  18159c:	89 48 04             	mov    %ecx,0x4(%eax)
 * kept as -EAGAIN, set previously in _Swap().
 */

static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
  18159f:	8b 42 08             	mov    0x8(%edx),%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1815a2:	9c                   	pushf  
  1815a3:	fa                   	cli    
  1815a4:	5f                   	pop    %edi
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
  1815a5:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	K_DEBUG("timeout %p\n", timeout);
	if (thread) {
  1815ac:	85 c0                	test   %eax,%eax
  1815ae:	74 5d                	je     18160d <_nano_sys_clock_tick_announce+0x15d>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
  1815b0:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  1815b4:	74 1a                	je     1815d0 <_nano_sys_clock_tick_announce+0x120>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1815b6:	8b 50 04             	mov    0x4(%eax),%edx
  1815b9:	8b 08                	mov    (%eax),%ecx
  1815bb:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1815bd:	8b 10                	mov    (%eax),%edx
  1815bf:	8b 48 04             	mov    0x4(%eax),%ecx
  1815c2:	89 4a 04             	mov    %ecx,0x4(%edx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  1815c5:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
  1815c9:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1815d0:	8a 50 09             	mov    0x9(%eax),%dl
  1815d3:	88 d1                	mov    %dl,%cl
  1815d5:	83 e1 fb             	and    $0xfffffffb,%ecx
  1815d8:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1815db:	f6 c2 1b             	test   $0x1b,%dl
  1815de:	75 0d                	jne    1815ed <_nano_sys_clock_tick_announce+0x13d>
  1815e0:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1815e4:	75 0e                	jne    1815f4 <_nano_sys_clock_tick_announce+0x144>
  1815e6:	ba 01 00 00 00       	mov    $0x1,%edx
  1815eb:	eb 0c                	jmp    1815f9 <_nano_sys_clock_tick_announce+0x149>
  1815ed:	ba 00 00 00 00       	mov    $0x0,%edx
  1815f2:	eb 05                	jmp    1815f9 <_nano_sys_clock_tick_announce+0x149>
  1815f4:	ba 00 00 00 00       	mov    $0x0,%edx
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  1815f9:	85 d2                	test   %edx,%edx
  1815fb:	74 05                	je     181602 <_nano_sys_clock_tick_announce+0x152>
		_add_thread_to_ready_q(thread);
  1815fd:	e8 77 fb ff ff       	call   181179 <_add_thread_to_ready_q>
  181602:	f7 c7 00 02 00 00    	test   $0x200,%edi
  181608:	74 17                	je     181621 <_nano_sys_clock_tick_announce+0x171>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18160a:	fb                   	sti    
  18160b:	eb 14                	jmp    181621 <_nano_sys_clock_tick_announce+0x171>
  18160d:	f7 c7 00 02 00 00    	test   $0x200,%edi
  181613:	74 01                	je     181616 <_nano_sys_clock_tick_announce+0x166>
  181615:	fb                   	sti    
		_unpend_thread_timing_out(thread, timeout);
		_ready_thread(thread);
		irq_unlock(key);
	} else {
		irq_unlock(key);
		if (timeout->func) {
  181616:	8b 4a 14             	mov    0x14(%edx),%ecx
  181619:	85 c9                	test   %ecx,%ecx
  18161b:	74 04                	je     181621 <_nano_sys_clock_tick_announce+0x171>
			timeout->func(timeout);
  18161d:	89 d0                	mov    %edx,%eax
  18161f:	ff d1                	call   *%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  181621:	85 db                	test   %ebx,%ebx
  181623:	74 0a                	je     18162f <_nano_sys_clock_tick_announce+0x17f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  181625:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
  181629:	74 08                	je     181633 <_nano_sys_clock_tick_announce+0x183>
  18162b:	8b 03                	mov    (%ebx),%eax
  18162d:	eb 09                	jmp    181638 <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18162f:	89 d8                	mov    %ebx,%eax
  181631:	eb 05                	jmp    181638 <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  181633:	b8 00 00 00 00       	mov    $0x0,%eax

static inline void _handle_expired_timeouts(sys_dlist_t *expired)
{
	sys_dnode_t *timeout, *next;

	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
  181638:	89 da                	mov    %ebx,%edx
  18163a:	89 c3                	mov    %eax,%ebx
  18163c:	85 d2                	test   %edx,%edx
  18163e:	0f 85 4c ff ff ff    	jne    181590 <_nano_sys_clock_tick_announce+0xe0>

	irq_unlock(key);

	_handle_expired_timeouts(&expired);

	_handling_timeouts = 0;
  181644:	c7 05 f4 01 28 00 00 	movl   $0x0,0x2801f4
  18164b:	00 00 00 
	irq_unlock(key);

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
  18164e:	89 f0                	mov    %esi,%eax
  181650:	e8 00 fe ff ff       	call   181455 <handle_time_slicing>
}
  181655:	83 c4 08             	add    $0x8,%esp
  181658:	5b                   	pop    %ebx
  181659:	5e                   	pop    %esi
  18165a:	5f                   	pop    %edi
  18165b:	c3                   	ret    

0018165c <_k_thread_single_start>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  18165c:	8a 50 09             	mov    0x9(%eax),%dl
  18165f:	88 d1                	mov    %dl,%cl
  181661:	83 e1 fb             	and    $0xfffffffb,%ecx
  181664:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  181667:	f6 c2 1b             	test   $0x1b,%dl
  18166a:	75 0d                	jne    181679 <_k_thread_single_start+0x1d>
  18166c:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  181670:	75 0e                	jne    181680 <_k_thread_single_start+0x24>
  181672:	ba 01 00 00 00       	mov    $0x1,%edx
  181677:	eb 0c                	jmp    181685 <_k_thread_single_start+0x29>
  181679:	ba 00 00 00 00       	mov    $0x0,%edx
  18167e:	eb 05                	jmp    181685 <_k_thread_single_start+0x29>
  181680:	ba 00 00 00 00       	mov    $0x0,%edx

void _k_thread_single_start(struct k_thread *thread)
{
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  181685:	85 d2                	test   %edx,%edx
  181687:	74 05                	je     18168e <_k_thread_single_start+0x32>
		_add_thread_to_ready_q(thread);
  181689:	e8 eb fa ff ff       	call   181179 <_add_thread_to_ready_q>
  18168e:	c3                   	ret    

0018168f <start_thread>:
	CODE_UNREACHABLE;
}

#ifdef CONFIG_MULTITHREADING
static void start_thread(struct k_thread *thread)
{
  18168f:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  181690:	9c                   	pushf  
  181691:	fa                   	cli    
  181692:	5b                   	pop    %ebx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  181693:	8a 50 09             	mov    0x9(%eax),%dl
  181696:	88 d1                	mov    %dl,%cl
  181698:	83 e1 fb             	and    $0xfffffffb,%ecx
  18169b:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  18169e:	f6 c2 1b             	test   $0x1b,%dl
  1816a1:	75 0d                	jne    1816b0 <start_thread+0x21>
  1816a3:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1816a7:	75 0e                	jne    1816b7 <start_thread+0x28>
  1816a9:	ba 01 00 00 00       	mov    $0x1,%edx
  1816ae:	eb 0c                	jmp    1816bc <start_thread+0x2d>
  1816b0:	ba 00 00 00 00       	mov    $0x0,%edx
  1816b5:	eb 05                	jmp    1816bc <start_thread+0x2d>
  1816b7:	ba 00 00 00 00       	mov    $0x0,%edx
	int key = irq_lock(); /* protect kernel queues */

	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  1816bc:	85 d2                	test   %edx,%edx
  1816be:	74 33                	je     1816f3 <start_thread+0x64>
		_add_thread_to_ready_q(thread);
  1816c0:	e8 b4 fa ff ff       	call   181179 <_add_thread_to_ready_q>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  1816c5:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  1816ca:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  1816cf:	77 10                	ja     1816e1 <start_thread+0x52>
  1816d1:	e8 3a fb ff ff       	call   181210 <__must_switch_threads>
  1816d6:	85 c0                	test   %eax,%eax
  1816d8:	74 0c                	je     1816e6 <start_thread+0x57>
  1816da:	b8 01 00 00 00       	mov    $0x1,%eax
  1816df:	eb 05                	jmp    1816e6 <start_thread+0x57>
  1816e1:	b8 00 00 00 00       	mov    $0x0,%eax
		if (_must_switch_threads()) {
  1816e6:	85 c0                	test   %eax,%eax
  1816e8:	74 09                	je     1816f3 <start_thread+0x64>
			_Swap(key);
  1816ea:	89 d8                	mov    %ebx,%eax
  1816ec:	e8 a5 f5 ff ff       	call   180c96 <_Swap>
			return;
  1816f1:	eb 06                	jmp    1816f9 <start_thread+0x6a>
  1816f3:	f6 c7 02             	test   $0x2,%bh
  1816f6:	74 01                	je     1816f9 <start_thread+0x6a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1816f8:	fb                   	sti    
		}
	}

	irq_unlock(key);
}
  1816f9:	5b                   	pop    %ebx
  1816fa:	c3                   	ret    

001816fb <schedule_new_thread>:
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
  1816fb:	57                   	push   %edi
  1816fc:	56                   	push   %esi
  1816fd:	53                   	push   %ebx
  1816fe:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  181700:	85 d2                	test   %edx,%edx
  181702:	75 0a                	jne    18170e <schedule_new_thread+0x13>
		start_thread(thread);
  181704:	e8 86 ff ff ff       	call   18168f <start_thread>
  181709:	e9 18 01 00 00       	jmp    181826 <schedule_new_thread+0x12b>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  18170e:	83 c2 09             	add    $0x9,%edx
  181711:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  181716:	89 d0                	mov    %edx,%eax
  181718:	f7 e1                	mul    %ecx
  18171a:	c1 ea 03             	shr    $0x3,%edx
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  18171d:	42                   	inc    %edx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18171e:	9c                   	pushf  
  18171f:	fa                   	cli    
  181720:	5f                   	pop    %edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  181721:	8d 46 10             	lea    0x10(%esi),%eax
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  181724:	89 50 10             	mov    %edx,0x10(%eax)
	timeout->thread = thread;
  181727:	89 70 08             	mov    %esi,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  18172a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  181731:	8b 15 cc 00 28 00    	mov    0x2800cc,%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  181737:	81 fa cc 00 28 00    	cmp    $0x2800cc,%edx
  18173d:	75 07                	jne    181746 <schedule_new_thread+0x4b>
  18173f:	b9 00 00 00 00       	mov    $0x0,%ecx
  181744:	eb 02                	jmp    181748 <schedule_new_thread+0x4d>
  181746:	89 d1                	mov    %edx,%ecx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  181748:	85 c9                	test   %ecx,%ecx
  18174a:	74 16                	je     181762 <schedule_new_thread+0x67>
  18174c:	81 fa cc 00 28 00    	cmp    $0x2800cc,%edx
  181752:	0f 85 a0 00 00 00    	jne    1817f8 <schedule_new_thread+0xfd>
  181758:	ba 00 00 00 00       	mov    $0x0,%edx
  18175d:	e9 96 00 00 00       	jmp    1817f8 <schedule_new_thread+0xfd>
  181762:	ba 00 00 00 00       	mov    $0x0,%edx
  181767:	e9 8c 00 00 00       	jmp    1817f8 <schedule_new_thread+0xfd>
		if (*delta <= in_q->delta_ticks_from_prev) {
  18176c:	8b 48 10             	mov    0x10(%eax),%ecx
  18176f:	8b 5a 10             	mov    0x10(%edx),%ebx
  181772:	39 d9                	cmp    %ebx,%ecx
  181774:	7f 3b                	jg     1817b1 <schedule_new_thread+0xb6>
			in_q->delta_ticks_from_prev -= *delta;
  181776:	29 cb                	sub    %ecx,%ebx
  181778:	89 5a 10             	mov    %ebx,0x10(%edx)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  18177b:	85 d2                	test   %edx,%edx
  18177d:	75 1f                	jne    18179e <schedule_new_thread+0xa3>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  18177f:	c7 46 10 cc 00 28 00 	movl   $0x2800cc,0x10(%esi)
	node->prev = list->tail;
  181786:	8b 15 d0 00 28 00    	mov    0x2800d0,%edx
  18178c:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  18178f:	8b 15 d0 00 28 00    	mov    0x2800d0,%edx
  181795:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  181797:	a3 d0 00 28 00       	mov    %eax,0x2800d0
  18179c:	eb 7f                	jmp    18181d <schedule_new_thread+0x122>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  18179e:	8b 4a 04             	mov    0x4(%edx),%ecx
  1817a1:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
  1817a4:	89 56 10             	mov    %edx,0x10(%esi)
		insert_point->prev->next = node;
  1817a7:	8b 4a 04             	mov    0x4(%edx),%ecx
  1817aa:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
  1817ac:	89 42 04             	mov    %eax,0x4(%edx)
  1817af:	eb 6c                	jmp    18181d <schedule_new_thread+0x122>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  1817b1:	29 d9                	sub    %ebx,%ecx
  1817b3:	89 48 10             	mov    %ecx,0x10(%eax)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1817b6:	89 d1                	mov    %edx,%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1817b8:	85 d2                	test   %edx,%edx
  1817ba:	74 0c                	je     1817c8 <schedule_new_thread+0xcd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1817bc:	3b 15 d0 00 28 00    	cmp    0x2800d0,%edx
  1817c2:	74 08                	je     1817cc <schedule_new_thread+0xd1>
  1817c4:	8b 1a                	mov    (%edx),%ebx
  1817c6:	eb 09                	jmp    1817d1 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1817c8:	89 d3                	mov    %edx,%ebx
  1817ca:	eb 05                	jmp    1817d1 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1817cc:	bb 00 00 00 00       	mov    $0x0,%ebx
  1817d1:	85 db                	test   %ebx,%ebx
  1817d3:	74 1e                	je     1817f3 <schedule_new_thread+0xf8>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1817d5:	85 c9                	test   %ecx,%ecx
  1817d7:	74 0c                	je     1817e5 <schedule_new_thread+0xea>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1817d9:	3b 0d d0 00 28 00    	cmp    0x2800d0,%ecx
  1817df:	74 0b                	je     1817ec <schedule_new_thread+0xf1>
  1817e1:	8b 12                	mov    (%edx),%edx
  1817e3:	eb 13                	jmp    1817f8 <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1817e5:	ba 00 00 00 00       	mov    $0x0,%edx
  1817ea:	eb 0c                	jmp    1817f8 <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1817ec:	ba 00 00 00 00       	mov    $0x0,%edx
  1817f1:	eb 05                	jmp    1817f8 <schedule_new_thread+0xfd>
  1817f3:	ba 00 00 00 00       	mov    $0x0,%edx
  1817f8:	85 d2                	test   %edx,%edx
  1817fa:	0f 85 6c ff ff ff    	jne    18176c <schedule_new_thread+0x71>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  181800:	c7 46 10 cc 00 28 00 	movl   $0x2800cc,0x10(%esi)
	node->prev = list->tail;
  181807:	8b 15 d0 00 28 00    	mov    0x2800d0,%edx
  18180d:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  181810:	8b 15 d0 00 28 00    	mov    0x2800d0,%edx
  181816:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  181818:	a3 d0 00 28 00       	mov    %eax,0x2800d0
  18181d:	f7 c7 00 02 00 00    	test   $0x200,%edi
  181823:	74 01                	je     181826 <schedule_new_thread+0x12b>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181825:	fb                   	sti    
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  181826:	5b                   	pop    %ebx
  181827:	5e                   	pop    %esi
  181828:	5f                   	pop    %edi
  181829:	c3                   	ret    

0018182a <k_is_in_isr>:
}
#endif

int k_is_in_isr(void)
{
	return _is_in_isr();
  18182a:	83 3d c0 00 28 00 00 	cmpl   $0x0,0x2800c0
  181831:	0f 95 c0             	setne  %al
  181834:	0f b6 c0             	movzbl %al,%eax
}
  181837:	c3                   	ret    

00181838 <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.user_options & K_ESSENTIAL;
  181838:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  18183d:	8a 40 08             	mov    0x8(%eax),%al
  181840:	83 e0 01             	and    $0x1,%eax
}
  181843:	c3                   	ret    

00181844 <_thread_monitor_exit>:
#if defined(CONFIG_THREAD_MONITOR)
/*
 * Remove a thread from the kernel's list of active threads.
 */
void _thread_monitor_exit(struct k_thread *thread)
{
  181844:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  181845:	9c                   	pushf  
  181846:	fa                   	cli    
  181847:	5b                   	pop    %ebx
	unsigned int key = irq_lock();

	if (thread == _kernel.threads) {
  181848:	8b 0d dc 01 28 00    	mov    0x2801dc,%ecx
  18184e:	39 c1                	cmp    %eax,%ecx
  181850:	75 0c                	jne    18185e <_thread_monitor_exit+0x1a>
		_kernel.threads = _kernel.threads->next_thread;
  181852:	8b 41 38             	mov    0x38(%ecx),%eax
  181855:	a3 dc 01 28 00       	mov    %eax,0x2801dc
  18185a:	eb 0f                	jmp    18186b <_thread_monitor_exit+0x27>
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
			prev_thread = prev_thread->next_thread;
  18185c:	89 d1                	mov    %edx,%ecx
		_kernel.threads = _kernel.threads->next_thread;
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
  18185e:	8b 51 38             	mov    0x38(%ecx),%edx
  181861:	39 d0                	cmp    %edx,%eax
  181863:	75 f7                	jne    18185c <_thread_monitor_exit+0x18>
			prev_thread = prev_thread->next_thread;
		}
		prev_thread->next_thread = thread->next_thread;
  181865:	8b 40 38             	mov    0x38(%eax),%eax
  181868:	89 41 38             	mov    %eax,0x38(%ecx)
  18186b:	f6 c7 02             	test   $0x2,%bh
  18186e:	74 01                	je     181871 <_thread_monitor_exit+0x2d>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181870:	fb                   	sti    
	}

	irq_unlock(key);
}
  181871:	5b                   	pop    %ebx
  181872:	c3                   	ret    

00181873 <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
  181873:	53                   	push   %ebx
  181874:	89 c3                	mov    %eax,%ebx
  181876:	89 d0                	mov    %edx,%eax
  181878:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
  18187a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  18187e:	ff d3                	call   *%ebx

#ifdef CONFIG_MULTITHREADING
	if (_is_thread_essential()) {
  181880:	e8 b3 ff ff ff       	call   181838 <_is_thread_essential>
  181885:	85 c0                	test   %eax,%eax
  181887:	74 0f                	je     181898 <_thread_entry+0x25>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  181889:	ba a0 1f 18 00       	mov    $0x181fa0,%edx
  18188e:	b8 03 00 00 00       	mov    $0x3,%eax
  181893:	e8 d3 f4 ff ff       	call   180d6b <_NanoFatalErrorHandler>
				       &_default_esf);
	}

	k_thread_abort(_current);
  181898:	a1 c8 00 28 00       	mov    0x2800c8,%eax
  18189d:	e8 e0 01 00 00       	call   181a82 <k_thread_abort>

001818a2 <_k_thread_group_op>:
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  1818a2:	55                   	push   %ebp
  1818a3:	57                   	push   %edi
  1818a4:	56                   	push   %esi
  1818a5:	53                   	push   %ebx
  1818a6:	89 c6                	mov    %eax,%esi
  1818a8:	89 d5                	mov    %edx,%ebp
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  1818aa:	8b 15 c8 00 28 00    	mov    0x2800c8,%edx
  1818b0:	8a 42 0b             	mov    0xb(%edx),%al
  1818b3:	48                   	dec    %eax
  1818b4:	88 42 0b             	mov    %al,0xb(%edx)

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  1818b7:	bb 94 00 28 00       	mov    $0x280094,%ebx
  1818bc:	eb 18                	jmp    1818d6 <_k_thread_group_op+0x34>
		if (is_in_any_group(thread_data, groups)) {
  1818be:	85 73 28             	test   %esi,0x28(%ebx)
  1818c1:	74 10                	je     1818d3 <_k_thread_group_op+0x31>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1818c3:	9c                   	pushf  
  1818c4:	fa                   	cli    
  1818c5:	5f                   	pop    %edi
			key = irq_lock();
			func(thread_data->thread);
  1818c6:	8b 03                	mov    (%ebx),%eax
  1818c8:	ff d5                	call   *%ebp
  1818ca:	f7 c7 00 02 00 00    	test   $0x200,%edi
  1818d0:	74 01                	je     1818d3 <_k_thread_group_op+0x31>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1818d2:	fb                   	sti    

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  1818d3:	83 c3 2c             	add    $0x2c,%ebx
  1818d6:	81 fb 94 00 28 00    	cmp    $0x280094,%ebx
  1818dc:	72 e0                	jb     1818be <_k_thread_group_op+0x1c>

	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
  1818de:	a1 c8 00 28 00       	mov    0x2800c8,%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1818e3:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  1818e7:	75 0d                	jne    1818f6 <_k_thread_group_op+0x54>
  1818e9:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1818ed:	75 0e                	jne    1818fd <_k_thread_group_op+0x5b>
  1818ef:	b8 01 00 00 00       	mov    $0x1,%eax
  1818f4:	eb 0c                	jmp    181902 <_k_thread_group_op+0x60>
  1818f6:	b8 00 00 00 00       	mov    $0x0,%eax
  1818fb:	eb 05                	jmp    181902 <_k_thread_group_op+0x60>
  1818fd:	b8 00 00 00 00       	mov    $0x0,%eax
  181902:	85 c0                	test   %eax,%eax
  181904:	74 07                	je     18190d <_k_thread_group_op+0x6b>
		k_sched_unlock();
  181906:	e8 61 f9 ff ff       	call   18126c <k_sched_unlock>
		return;
  18190b:	eb 15                	jmp    181922 <_k_thread_group_op+0x80>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18190d:	9c                   	pushf  
  18190e:	fa                   	cli    
  18190f:	58                   	pop    %eax
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 0, "");

	compiler_barrier();

	++_current->base.sched_locked;
  181910:	8b 0d c8 00 28 00    	mov    0x2800c8,%ecx
  181916:	8a 51 0b             	mov    0xb(%ecx),%dl
  181919:	42                   	inc    %edx
  18191a:	88 51 0b             	mov    %dl,0xb(%ecx)
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  18191d:	e8 74 f3 ff ff       	call   180c96 <_Swap>
}
  181922:	5b                   	pop    %ebx
  181923:	5e                   	pop    %esi
  181924:	5f                   	pop    %edi
  181925:	5d                   	pop    %ebp
  181926:	c3                   	ret    

00181927 <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  181927:	56                   	push   %esi
  181928:	53                   	push   %ebx
  181929:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
  18192b:	8b 40 30             	mov    0x30(%eax),%eax
  18192e:	85 c0                	test   %eax,%eax
  181930:	74 02                	je     181934 <_k_thread_single_abort+0xd>
		thread->fn_abort();
  181932:	ff d0                	call   *%eax
	return !(thread->base.thread_state & _THREAD_PRESTART);
}

static inline int _is_thread_prevented_from_running(struct k_thread *thread)
{
	uint8_t state = thread->base.thread_state;
  181934:	8a 43 09             	mov    0x9(%ebx),%al
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  181937:	a8 1f                	test   $0x1f,%al
  181939:	75 0d                	jne    181948 <_k_thread_single_abort+0x21>
  18193b:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  18193f:	75 0e                	jne    18194f <_k_thread_single_abort+0x28>
  181941:	ba 01 00 00 00       	mov    $0x1,%edx
  181946:	eb 0c                	jmp    181954 <_k_thread_single_abort+0x2d>
  181948:	ba 00 00 00 00       	mov    $0x0,%edx
  18194d:	eb 05                	jmp    181954 <_k_thread_single_abort+0x2d>
  18194f:	ba 00 00 00 00       	mov    $0x0,%edx
	}

	if (_is_thread_ready(thread)) {
  181954:	85 d2                	test   %edx,%edx
  181956:	74 09                	je     181961 <_k_thread_single_abort+0x3a>
		_remove_thread_from_ready_q(thread);
  181958:	89 d8                	mov    %ebx,%eax
  18195a:	e8 68 f8 ff ff       	call   1811c7 <_remove_thread_from_ready_q>
  18195f:	eb 61                	jmp    1819c2 <_k_thread_single_abort+0x9b>
	} else {
		if (_is_thread_pending(thread)) {
  181961:	a8 02                	test   $0x2,%al
  181963:	74 13                	je     181978 <_k_thread_single_abort+0x51>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  181965:	8b 43 04             	mov    0x4(%ebx),%eax
  181968:	8b 13                	mov    (%ebx),%edx
  18196a:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  18196c:	8b 03                	mov    (%ebx),%eax
  18196e:	8b 53 04             	mov    0x4(%ebx),%edx
  181971:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  181974:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  181978:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  18197c:	74 44                	je     1819c2 <_k_thread_single_abort+0x9b>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  18197e:	8d 43 10             	lea    0x10(%ebx),%eax
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  181981:	8b 48 10             	mov    0x10(%eax),%ecx
  181984:	83 f9 ff             	cmp    $0xffffffff,%ecx
  181987:	74 39                	je     1819c2 <_k_thread_single_abort+0x9b>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  181989:	89 c2                	mov    %eax,%edx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  18198b:	8b 35 d0 00 28 00    	mov    0x2800d0,%esi
  181991:	39 f0                	cmp    %esi,%eax
  181993:	74 15                	je     1819aa <_k_thread_single_abort+0x83>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  181995:	85 c0                	test   %eax,%eax
  181997:	74 0e                	je     1819a7 <_k_thread_single_abort+0x80>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  181999:	39 f0                	cmp    %esi,%eax
  18199b:	74 05                	je     1819a2 <_k_thread_single_abort+0x7b>
  18199d:	8b 53 10             	mov    0x10(%ebx),%edx
  1819a0:	eb 05                	jmp    1819a7 <_k_thread_single_abort+0x80>
  1819a2:	ba 00 00 00 00       	mov    $0x0,%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  1819a7:	01 4a 10             	add    %ecx,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1819aa:	8b 50 04             	mov    0x4(%eax),%edx
  1819ad:	8b 4b 10             	mov    0x10(%ebx),%ecx
  1819b0:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  1819b2:	8b 53 10             	mov    0x10(%ebx),%edx
  1819b5:	8b 48 04             	mov    0x4(%eax),%ecx
  1819b8:	89 4a 04             	mov    %ecx,0x4(%edx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  1819bb:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_DEAD;
  1819c2:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  1819c6:	5b                   	pop    %ebx
  1819c7:	5e                   	pop    %esi
  1819c8:	c3                   	ret    

001819c9 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
  1819c9:	56                   	push   %esi
  1819ca:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  1819cb:	bb 94 00 28 00       	mov    $0x280094,%ebx
  1819d0:	eb 27                	jmp    1819f9 <_init_static_threads+0x30>
		_task_group_adjust(thread_data);
		_new_thread(
  1819d2:	8b 4b 08             	mov    0x8(%ebx),%ecx
  1819d5:	8b 53 04             	mov    0x4(%ebx),%edx
  1819d8:	ff 73 1c             	pushl  0x1c(%ebx)
  1819db:	ff 73 18             	pushl  0x18(%ebx)
  1819de:	ff 73 14             	pushl  0x14(%ebx)
  1819e1:	ff 73 10             	pushl  0x10(%ebx)
  1819e4:	ff 73 0c             	pushl  0xc(%ebx)
  1819e7:	8b 03                	mov    (%ebx),%eax
  1819e9:	e8 37 f3 ff ff       	call   180d25 <_new_thread>
  1819ee:	83 c4 14             	add    $0x14,%esp
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  1819f1:	8b 03                	mov    (%ebx),%eax
  1819f3:	89 58 2c             	mov    %ebx,0x2c(%eax)
#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  1819f6:	83 c3 2c             	add    $0x2c,%ebx
  1819f9:	81 fb 94 00 28 00    	cmp    $0x280094,%ebx
  1819ff:	72 d1                	jb     1819d2 <_init_static_threads+0x9>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  181a01:	8b 15 c8 00 28 00    	mov    0x2800c8,%edx
  181a07:	8a 42 0b             	mov    0xb(%edx),%al
  181a0a:	48                   	dec    %eax
  181a0b:	88 42 0b             	mov    %al,0xb(%edx)
	}

	_sched_lock();
#if defined(CONFIG_LEGACY_KERNEL)
	/* Start all (legacy) threads that are part of the EXE task group */
	_k_thread_group_op(K_TASK_GROUP_EXE, _k_thread_single_start);
  181a0e:	ba 5c 16 18 00       	mov    $0x18165c,%edx
  181a13:	b8 01 00 00 00       	mov    $0x1,%eax
  181a18:	e8 85 fe ff ff       	call   1818a2 <_k_thread_group_op>
  181a1d:	9c                   	pushf  
  181a1e:	fa                   	cli    
  181a1f:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  181a20:	bb 94 00 28 00       	mov    $0x280094,%ebx
  181a25:	eb 12                	jmp    181a39 <_init_static_threads+0x70>
		if (thread_data->init_delay != K_FOREVER) {
  181a27:	8b 53 20             	mov    0x20(%ebx),%edx
  181a2a:	83 fa ff             	cmp    $0xffffffff,%edx
  181a2d:	74 07                	je     181a36 <_init_static_threads+0x6d>
			schedule_new_thread(thread_data->thread,
  181a2f:	8b 03                	mov    (%ebx),%eax
  181a31:	e8 c5 fc ff ff       	call   1816fb <schedule_new_thread>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  181a36:	83 c3 2c             	add    $0x2c,%ebx
  181a39:	81 fb 94 00 28 00    	cmp    $0x280094,%ebx
  181a3f:	72 e6                	jb     181a27 <_init_static_threads+0x5e>
  181a41:	f7 c6 00 02 00 00    	test   $0x200,%esi
  181a47:	74 01                	je     181a4a <_init_static_threads+0x81>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181a49:	fb                   	sti    
			schedule_new_thread(thread_data->thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
  181a4a:	e8 1d f8 ff ff       	call   18126c <k_sched_unlock>
}
  181a4f:	5b                   	pop    %ebx
  181a50:	5e                   	pop    %esi
  181a51:	c3                   	ret    

00181a52 <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  181a52:	53                   	push   %ebx
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
  181a53:	8a 5c 24 08          	mov    0x8(%esp),%bl
  181a57:	88 58 08             	mov    %bl,0x8(%eax)
	thread_base->thread_state = (uint8_t)initial_state;
  181a5a:	88 48 09             	mov    %cl,0x9(%eax)

	thread_base->prio = priority;
  181a5d:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
  181a60:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
  181a64:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  181a6b:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  181a72:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  181a79:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  181a80:	5b                   	pop    %ebx
  181a81:	c3                   	ret    

00181a82 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
  181a82:	56                   	push   %esi
  181a83:	53                   	push   %ebx
  181a84:	89 c3                	mov    %eax,%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  181a86:	9c                   	pushf  
  181a87:	fa                   	cli    
  181a88:	5e                   	pop    %esi
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  181a89:	e8 99 fe ff ff       	call   181927 <_k_thread_single_abort>
	_thread_monitor_exit(thread);
  181a8e:	89 d8                	mov    %ebx,%eax
  181a90:	e8 af fd ff ff       	call   181844 <_thread_monitor_exit>

	if (_current == thread) {
  181a95:	3b 1d c8 00 28 00    	cmp    0x2800c8,%ebx
  181a9b:	75 07                	jne    181aa4 <k_thread_abort+0x22>
		_Swap(key);
  181a9d:	89 f0                	mov    %esi,%eax
  181a9f:	e8 f2 f1 ff ff       	call   180c96 <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  181aa4:	89 f0                	mov    %esi,%eax
  181aa6:	e8 88 f7 ff ff       	call   181233 <_reschedule_threads>
}
  181aab:	5b                   	pop    %ebx
  181aac:	5e                   	pop    %esi
  181aad:	c3                   	ret    

00181aae <_sys_power_save_idle>:
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
  181aae:	e8 92 f0 ff ff       	call   180b45 <k_cpu_idle>
  181ab3:	c3                   	ret    

00181ab4 <idle>:
  181ab4:	9c                   	pushf  
  181ab5:	fa                   	cli    
  181ab6:	58                   	pop    %eax
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  181ab7:	a1 cc 00 28 00       	mov    0x2800cc,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  181abc:	3d cc 00 28 00       	cmp    $0x2800cc,%eax
  181ac1:	75 05                	jne    181ac8 <idle+0x14>
  181ac3:	b8 00 00 00 00       	mov    $0x0,%eax
static inline int32_t _get_next_timeout_expiry(void)
{
	struct _timeout *t = (struct _timeout *)
			     sys_dlist_peek_head(&_timeout_q);

	return t ? t->delta_ticks_from_prev : K_FOREVER;
  181ac8:	85 c0                	test   %eax,%eax
  181aca:	74 05                	je     181ad1 <idle+0x1d>
  181acc:	8b 40 10             	mov    0x10(%eax),%eax
  181acf:	eb 05                	jmp    181ad6 <idle+0x22>
  181ad1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	__idle_tsc = _tsc_read();
#endif

	for (;;) {
		(void)irq_lock();
		_sys_power_save_idle(_get_next_timeout_expiry());
  181ad6:	e8 d3 ff ff ff       	call   181aae <_sys_power_save_idle>

		IDLE_YIELD_IF_COOP();
	}
  181adb:	eb d7                	jmp    181ab4 <idle>

00181add <_OffsetAbsSyms>:
/* tTaskStateSegment structure member offsets */


/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));
  181add:	c3                   	ret    

00181ade <_handle_exc_0_vector_0_stub>:
  181ade:	6a 00                	push   $0x0
  181ae0:	68 bf 0e 18 00       	push   $0x180ebf
  181ae5:	e9 dc f0 ff ff       	jmp    180bc6 <_exception_enter>

00181aea <_handle_exc_2_vector_2_stub>:
  181aea:	6a 00                	push   $0x0
  181aec:	68 cb 0e 18 00       	push   $0x180ecb
  181af1:	e9 d0 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181af6 <_handle_exc_4_vector_4_stub>:
  181af6:	6a 00                	push   $0x0
  181af8:	68 d7 0e 18 00       	push   $0x180ed7
  181afd:	e9 c4 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b02 <_handle_exc_5_vector_5_stub>:
  181b02:	6a 00                	push   $0x0
  181b04:	68 e3 0e 18 00       	push   $0x180ee3
  181b09:	e9 b8 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b0e <_handle_exc_6_vector_6_stub>:
  181b0e:	6a 00                	push   $0x0
  181b10:	68 ef 0e 18 00       	push   $0x180eef
  181b15:	e9 ac f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b1a <_handle_exc_7_vector_7_stub>:
  181b1a:	6a 00                	push   $0x0
  181b1c:	68 fb 0e 18 00       	push   $0x180efb
  181b21:	e9 a0 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b26 <_handle_exc_8_vector_8_stub>:
  181b26:	68 07 0f 18 00       	push   $0x180f07
  181b2b:	e9 96 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b30 <_handle_exc_10_vector_10_stub>:
  181b30:	68 13 0f 18 00       	push   $0x180f13
  181b35:	e9 8c f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b3a <_handle_exc_11_vector_11_stub>:
  181b3a:	68 1f 0f 18 00       	push   $0x180f1f
  181b3f:	e9 82 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b44 <_handle_exc_12_vector_12_stub>:
  181b44:	68 2b 0f 18 00       	push   $0x180f2b
  181b49:	e9 78 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b4e <_handle_exc_13_vector_13_stub>:
  181b4e:	68 37 0f 18 00       	push   $0x180f37
  181b53:	e9 6e f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b58 <_handle_exc_14_vector_14_stub>:
  181b58:	68 43 0f 18 00       	push   $0x180f43
  181b5d:	e9 64 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b62 <_handle_exc_16_vector_16_stub>:
  181b62:	6a 00                	push   $0x0
  181b64:	68 4f 0f 18 00       	push   $0x180f4f
  181b69:	e9 58 f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b6e <_handle_exc_17_vector_17_stub>:
  181b6e:	68 5b 0f 18 00       	push   $0x180f5b
  181b73:	e9 4e f0 ff ff       	jmp    180bc6 <_exception_enter>

00181b78 <_handle_exc_18_vector_18_stub>:
  181b78:	6a 00                	push   $0x0
  181b7a:	68 67 0f 18 00       	push   $0x180f67
  181b7f:	e9 42 f0 ff ff       	jmp    180bc6 <_exception_enter>
