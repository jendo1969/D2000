
zephyr.elf:     ファイル形式 elf32-iamcu


セクション text の逆アセンブル:

00180000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  180000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  180003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  180008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  18000b:	fa                   	cli    
	 * booted operating systems to setup their own IDT and GDT.
	 */
#if CONFIG_SET_GDT
	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
#endif
	lidt	_Idt		/* load 32-bit operand size IDT */
  18000c:	0f 01 1d 4c 00 18 00 	lidtl  0x18004c
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  180013:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  180016:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  180019:	0f 22 c0             	mov    %eax,%cr0
	stack_size_dwords = (CONFIG_ISR_STACK_SIZE / 4)
	movl $stack_size_dwords, %ecx
	rep  stosl
#endif

	movl	$_interrupt_stack, %esp
  18001c:	bc 24 04 28 00       	mov    $0x280424,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  180021:	81 c4 00 01 00 00    	add    $0x100,%esp
	/*
	 * copy DATA section from ROM to RAM region
	 *	 DATA is followed by BSS section.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
  180027:	bf 00 00 28 00       	mov    $0x280000,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
  18002c:	be c8 36 18 00       	mov    $0x1836c8,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
  180031:	b9 26 00 00 00       	mov    $0x26,%ecx
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
  180036:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  180038:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  18003a:	bf a0 00 28 00       	mov    $0x2800a0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  18003f:	b9 e1 00 00 00       	mov    $0xe1,%ecx
	cld
  180044:	fc                   	cld    
	rep
  180045:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  180047:	e9 01 22 00 00       	jmp    18224d <_Cstart>

0018004c <_Idt>:
  18004c:	ff 01 c8 34 18 00 66 90 66 90 66 90 66 90 66 90     ...4..f.f.f.f.f.
  18005c:	66 90 66 90                                         f.f.

00180060 <_thread_entry_wrapper>:
  180060:	58                   	pop    %eax
  180061:	5a                   	pop    %edx
  180062:	59                   	pop    %ecx
  180063:	6a 00                	push   $0x0
  180065:	e9 50 29 00 00       	jmp    1829ba <_thread_entry>

0018006a <msg_dump>:
static struct device *uart0_dev;
static unsigned char rx_buf[BUF_MAXSIZE];
static unsigned char tx_buf[BUF_MAXSIZE];

static void msg_dump(const char *s, unsigned char *data, unsigned len)
{
  18006a:	57                   	push   %edi
  18006b:	56                   	push   %esi
  18006c:	53                   	push   %ebx
  18006d:	89 d7                	mov    %edx,%edi
  18006f:	89 ce                	mov    %ecx,%esi
	unsigned i;

	printf("%s: ", s);
  180071:	50                   	push   %eax
  180072:	68 40 2d 18 00       	push   $0x182d40
  180077:	e8 e4 06 00 00       	call   180760 <printf>
  18007c:	83 c4 08             	add    $0x8,%esp
	for (i = 0; i < len; i++) {
  18007f:	bb 00 00 00 00       	mov    $0x0,%ebx
  180084:	eb 13                	jmp    180099 <msg_dump+0x2f>
		printf("%02x ", data[i]);
  180086:	0f b6 04 1f          	movzbl (%edi,%ebx,1),%eax
  18008a:	50                   	push   %eax
  18008b:	68 45 2d 18 00       	push   $0x182d45
  180090:	e8 cb 06 00 00       	call   180760 <printf>
  180095:	83 c4 08             	add    $0x8,%esp
static void msg_dump(const char *s, unsigned char *data, unsigned len)
{
	unsigned i;

	printf("%s: ", s);
	for (i = 0; i < len; i++) {
  180098:	43                   	inc    %ebx
  180099:	39 f3                	cmp    %esi,%ebx
  18009b:	72 e9                	jb     180086 <msg_dump+0x1c>
		printf("%02x ", data[i]);
	}
	printf("(%u bytes)\n", len);
  18009d:	56                   	push   %esi
  18009e:	68 4b 2d 18 00       	push   $0x182d4b
  1800a3:	e8 b8 06 00 00       	call   180760 <printf>
  1800a8:	83 c4 08             	add    $0x8,%esp
	uart_fifo_fill(uart0_dev, data, len);
  1800ab:	a1 a0 02 28 00       	mov    0x2802a0,%eax
 * @return Number of bytes sent.
 */
static inline int uart_fifo_fill(struct device *dev, const uint8_t *tx_data,
				 int size)
{
	const struct uart_driver_api *api = dev->driver_api;
  1800b0:	8b 50 04             	mov    0x4(%eax),%edx

	if (api->fifo_fill) {
  1800b3:	8b 5a 0c             	mov    0xc(%edx),%ebx
  1800b6:	85 db                	test   %ebx,%ebx
  1800b8:	74 06                	je     1800c0 <msg_dump+0x56>
		return api->fifo_fill(dev, tx_data, size);
  1800ba:	89 f1                	mov    %esi,%ecx
  1800bc:	89 fa                	mov    %edi,%edx
  1800be:	ff d3                	call   *%ebx
}
  1800c0:	5b                   	pop    %ebx
  1800c1:	5e                   	pop    %esi
  1800c2:	5f                   	pop    %edi
  1800c3:	c3                   	ret    

001800c4 <uart0_isr>:

static void uart0_isr(struct device *x)
{
  1800c4:	53                   	push   %ebx
	int len = uart_fifo_read(uart0_dev, rx_buf, BUF_MAXSIZE);
  1800c5:	a1 a0 02 28 00       	mov    0x2802a0,%eax
 * @return Number of bytes read.
 */
static inline int uart_fifo_read(struct device *dev, uint8_t *rx_data,
				 const int size)
{
	const struct uart_driver_api *api = dev->driver_api;
  1800ca:	8b 50 04             	mov    0x4(%eax),%edx

	if (api->fifo_read) {
  1800cd:	8b 5a 10             	mov    0x10(%edx),%ebx
  1800d0:	85 db                	test   %ebx,%ebx
  1800d2:	74 10                	je     1800e4 <uart0_isr+0x20>
		return api->fifo_read(dev, rx_data, size);
  1800d4:	b9 00 01 00 00       	mov    $0x100,%ecx
  1800d9:	ba a0 01 28 00       	mov    $0x2801a0,%edx
  1800de:	ff d3                	call   *%ebx
  1800e0:	89 c1                	mov    %eax,%ecx
  1800e2:	eb 05                	jmp    1800e9 <uart0_isr+0x25>
	}

	return 0;
  1800e4:	b9 00 00 00 00       	mov    $0x0,%ecx

	ARG_UNUSED(x);
	msg_dump(__func__, rx_buf, len);
  1800e9:	ba a0 01 28 00       	mov    $0x2801a0,%edx
  1800ee:	b8 90 2d 18 00       	mov    $0x182d90,%eax
  1800f3:	e8 72 ff ff ff       	call   18006a <msg_dump>
}
  1800f8:	5b                   	pop    %ebx
  1800f9:	c3                   	ret    

001800fa <uart0_init>:

static void uart0_init(void)
{
	uart0_dev = device_get_binding("UART_0");
  1800fa:	b8 57 2d 18 00       	mov    $0x182d57,%eax
  1800ff:	e8 d7 1f 00 00       	call   1820db <device_get_binding>
  180104:	a3 a0 02 28 00       	mov    %eax,0x2802a0
 * @return N/A
 */
static inline void uart_irq_callback_set(struct device *dev,
					 uart_irq_callback_t cb)
{
	const struct uart_driver_api *api = dev->driver_api;
  180109:	8b 50 04             	mov    0x4(%eax),%edx

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
  18010c:	85 d2                	test   %edx,%edx
  18010e:	74 0e                	je     18011e <uart0_init+0x24>
  180110:	8b 4a 40             	mov    0x40(%edx),%ecx
  180113:	85 c9                	test   %ecx,%ecx
  180115:	74 07                	je     18011e <uart0_init+0x24>
		api->irq_callback_set(dev, cb);
  180117:	ba c4 00 18 00       	mov    $0x1800c4,%edx
  18011c:	ff d1                	call   *%ecx

	uart_irq_callback_set(uart0_dev, uart0_isr);
	uart_irq_rx_enable(uart0_dev);
  18011e:	a1 a0 02 28 00       	mov    0x2802a0,%eax
 *
 * @return N/A
 */
static inline void uart_irq_rx_enable(struct device *dev)
{
	const struct uart_driver_api *api = dev->driver_api;
  180123:	8b 50 04             	mov    0x4(%eax),%edx

	if (api->irq_rx_enable) {
  180126:	8b 52 20             	mov    0x20(%edx),%edx
  180129:	85 d2                	test   %edx,%edx
  18012b:	74 02                	je     18012f <uart0_init+0x35>
		api->irq_rx_enable(dev);
  18012d:	ff d2                	call   *%edx

	printf("%s() done\n", __func__);
  18012f:	68 9c 2d 18 00       	push   $0x182d9c
  180134:	68 5e 2d 18 00       	push   $0x182d5e
  180139:	e8 22 06 00 00       	call   180760 <printf>
  18013e:	83 c4 08             	add    $0x8,%esp
  180141:	c3                   	ret    

00180142 <main>:
}


void main(void)
{
  180142:	53                   	push   %ebx
	unsigned int *size = (unsigned int *)tx_buf;

	printf("Sample app running on: %s\n", CONFIG_ARCH);
  180143:	68 69 2d 18 00       	push   $0x182d69
  180148:	68 6d 2d 18 00       	push   $0x182d6d
  18014d:	e8 0e 06 00 00       	call   180760 <printf>
  180152:	83 c4 08             	add    $0x8,%esp

	uart0_init();
  180155:	e8 a0 ff ff ff       	call   1800fa <uart0_init>

	memcpy(tx_buf, "TEST\n", 5);
  18015a:	b9 05 00 00 00       	mov    $0x5,%ecx
  18015f:	ba 88 2d 18 00       	mov    $0x182d88,%edx
  180164:	b8 a0 00 28 00       	mov    $0x2800a0,%eax
  180169:	e8 b9 13 00 00       	call   181527 <memcpy>

	uart_fifo_fill(uart0_dev, tx_buf, 5);
  18016e:	a1 a0 02 28 00       	mov    0x2802a0,%eax
 * @return Number of bytes sent.
 */
static inline int uart_fifo_fill(struct device *dev, const uint8_t *tx_data,
				 int size)
{
	const struct uart_driver_api *api = dev->driver_api;
  180173:	8b 50 04             	mov    0x4(%eax),%edx

	if (api->fifo_fill) {
  180176:	8b 5a 0c             	mov    0xc(%edx),%ebx
  180179:	85 db                	test   %ebx,%ebx
  18017b:	74 0c                	je     180189 <main+0x47>
		return api->fifo_fill(dev, tx_data, size);
  18017d:	b9 05 00 00 00       	mov    $0x5,%ecx
  180182:	ba a0 00 28 00       	mov    $0x2800a0,%edx
  180187:	ff d3                	call   *%ebx

	while (1)
	{
		k_sleep(SLEEP_TIME);
  180189:	b8 f4 01 00 00       	mov    $0x1f4,%eax
  18018e:	e8 c3 22 00 00       	call   182456 <k_sleep>
  180193:	eb f4                	jmp    180189 <main+0x47>

00180195 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  180195:	53                   	push   %ebx
  180196:	89 c3                	mov    %eax,%ebx
		return c;
	}

#endif /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
  180198:	83 f8 0a             	cmp    $0xa,%eax
  18019b:	75 10                	jne    1801ad <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
  18019d:	a1 a4 02 28 00       	mov    0x2802a4,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  1801a2:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  1801a5:	ba 0d 00 00 00       	mov    $0xd,%edx
  1801aa:	ff 51 04             	call   *0x4(%ecx)
	}
	uart_poll_out(uart_console_dev, c);
  1801ad:	a1 a4 02 28 00       	mov    0x2802a4,%eax
 * @retval char Sent character.
 */
static inline unsigned char uart_poll_out(struct device *dev,
					  unsigned char out_char)
{
	const struct uart_driver_api *api = dev->driver_api;
  1801b2:	8b 48 04             	mov    0x4(%eax),%ecx

	return api->poll_out(dev, out_char);
  1801b5:	0f b6 d3             	movzbl %bl,%edx
  1801b8:	ff 51 04             	call   *0x4(%ecx)

	return c;
}
  1801bb:	89 d8                	mov    %ebx,%eax
  1801bd:	5b                   	pop    %ebx
  1801be:	c3                   	ret    

001801bf <uart_console_hook_install>:
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
  1801bf:	b8 95 01 18 00       	mov    $0x180195,%eax
  1801c4:	e8 04 15 00 00       	call   1816cd <__printk_hook_install>
  1801c9:	c3                   	ret    

001801ca <uart_console_init>:
static int uart_console_init(struct device *arg)
{

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  1801ca:	b8 57 2d 18 00       	mov    $0x182d57,%eax
  1801cf:	e8 07 1f 00 00       	call   1820db <device_get_binding>
  1801d4:	a3 a4 02 28 00       	mov    %eax,0x2802a4
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
  1801d9:	e8 e1 ff ff ff       	call   1801bf <uart_console_hook_install>

	return 0;
}
  1801de:	b8 00 00 00 00       	mov    $0x0,%eax
  1801e3:	c3                   	ret    

001801e4 <is_tx_fifo_full>:
}

#if CONFIG_UART_INTERRUPT_DRIVEN
static bool is_tx_fifo_full(qm_uart_t instance)
{
	return !!(QM_UART[instance]->lsr & QM_UART_LSR_THRE);
  1801e4:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
  1801eb:	8b 40 14             	mov    0x14(%eax),%eax
  1801ee:	a8 20                	test   $0x20,%al
  1801f0:	0f 95 c0             	setne  %al
}
  1801f3:	c3                   	ret    

001801f4 <is_data_ready>:
	return i;
}

static bool is_data_ready(qm_uart_t instance)
{
	return QM_UART[instance]->lsr & QM_UART_LSR_DR;
  1801f4:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
  1801fb:	8b 40 14             	mov    0x14(%eax),%eax
  1801fe:	83 e0 01             	and    $0x1,%eax
}
  180201:	c3                   	ret    

00180202 <uart_qmsi_irq_tx_enable>:
	return i;
}

static void uart_qmsi_irq_tx_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180202:	8b 00                	mov    (%eax),%eax
  180204:	8b 40 08             	mov    0x8(%eax),%eax
  180207:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ETBEI;
  180209:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  180210:	8b 42 04             	mov    0x4(%edx),%eax
  180213:	83 c8 02             	or     $0x2,%eax
  180216:	89 42 04             	mov    %eax,0x4(%edx)
  180219:	c3                   	ret    

0018021a <uart_qmsi_irq_tx_disable>:
}

static void uart_qmsi_irq_tx_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18021a:	8b 00                	mov    (%eax),%eax
  18021c:	8b 40 08             	mov    0x8(%eax),%eax
  18021f:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ETBEI;
  180221:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  180228:	8b 42 04             	mov    0x4(%edx),%eax
  18022b:	83 e0 fd             	and    $0xfffffffd,%eax
  18022e:	89 42 04             	mov    %eax,0x4(%edx)
  180231:	c3                   	ret    

00180232 <uart_qmsi_irq_tx_ready>:
}

static int uart_qmsi_irq_tx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180232:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  180235:	8a 40 04             	mov    0x4(%eax),%al

	return id == QM_UART_IIR_THR_EMPTY;
  180238:	83 e0 0f             	and    $0xf,%eax
  18023b:	3c 02                	cmp    $0x2,%al
  18023d:	0f 94 c0             	sete   %al
  180240:	0f b6 c0             	movzbl %al,%eax
}
  180243:	c3                   	ret    

00180244 <uart_qmsi_irq_tx_empty>:

static int uart_qmsi_irq_tx_empty(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180244:	8b 00                	mov    (%eax),%eax
  180246:	8b 40 08             	mov    0x8(%eax),%eax
  180249:	8b 00                	mov    (%eax),%eax
	const uint32_t mask = (QM_UART_LSR_TEMT | QM_UART_LSR_THRE);

	return (QM_UART[instance]->lsr & mask) == mask;
  18024b:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
  180252:	8b 40 14             	mov    0x14(%eax),%eax
  180255:	83 e0 60             	and    $0x60,%eax
  180258:	83 f8 60             	cmp    $0x60,%eax
  18025b:	0f 94 c0             	sete   %al
  18025e:	0f b6 c0             	movzbl %al,%eax
}
  180261:	c3                   	ret    

00180262 <uart_qmsi_irq_rx_enable>:

static void uart_qmsi_irq_rx_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180262:	8b 00                	mov    (%eax),%eax
  180264:	8b 40 08             	mov    0x8(%eax),%eax
  180267:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ERBFI;
  180269:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  180270:	8b 42 04             	mov    0x4(%edx),%eax
  180273:	83 c8 01             	or     $0x1,%eax
  180276:	89 42 04             	mov    %eax,0x4(%edx)
  180279:	c3                   	ret    

0018027a <uart_qmsi_irq_rx_disable>:
}

static void uart_qmsi_irq_rx_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18027a:	8b 00                	mov    (%eax),%eax
  18027c:	8b 40 08             	mov    0x8(%eax),%eax
  18027f:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ERBFI;
  180281:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  180288:	8b 42 04             	mov    0x4(%edx),%eax
  18028b:	83 e0 fe             	and    $0xfffffffe,%eax
  18028e:	89 42 04             	mov    %eax,0x4(%edx)
  180291:	c3                   	ret    

00180292 <uart_qmsi_irq_rx_ready>:
}

static int uart_qmsi_irq_rx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180292:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  180295:	8a 50 04             	mov    0x4(%eax),%dl
  180298:	83 e2 0f             	and    $0xf,%edx

	return (id == QM_UART_IIR_RECV_DATA_AVAIL) ||
  18029b:	83 fa 04             	cmp    $0x4,%edx
  18029e:	0f 94 c1             	sete   %cl
	       (id == QM_UART_IIR_CHAR_TIMEOUT);
  1802a1:	83 fa 0c             	cmp    $0xc,%edx
  1802a4:	0f 94 c0             	sete   %al
static int uart_qmsi_irq_rx_ready(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);

	return (id == QM_UART_IIR_RECV_DATA_AVAIL) ||
  1802a7:	09 c8                	or     %ecx,%eax
  1802a9:	0f b6 c0             	movzbl %al,%eax
	       (id == QM_UART_IIR_CHAR_TIMEOUT);
}
  1802ac:	c3                   	ret    

001802ad <uart_qmsi_irq_err_enable>:

static void uart_qmsi_irq_err_enable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1802ad:	8b 00                	mov    (%eax),%eax
  1802af:	8b 40 08             	mov    0x8(%eax),%eax
  1802b2:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh |= QM_UART_IER_ELSI;
  1802b4:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  1802bb:	8b 42 04             	mov    0x4(%edx),%eax
  1802be:	83 c8 04             	or     $0x4,%eax
  1802c1:	89 42 04             	mov    %eax,0x4(%edx)
  1802c4:	c3                   	ret    

001802c5 <uart_qmsi_irq_err_disable>:
}

static void uart_qmsi_irq_err_disable(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1802c5:	8b 00                	mov    (%eax),%eax
  1802c7:	8b 40 08             	mov    0x8(%eax),%eax
  1802ca:	8b 00                	mov    (%eax),%eax

	QM_UART[instance]->ier_dlh &= ~QM_UART_IER_ELSI;
  1802cc:	8b 14 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%edx
  1802d3:	8b 42 04             	mov    0x4(%edx),%eax
  1802d6:	83 e0 fb             	and    $0xfffffffb,%eax
  1802d9:	89 42 04             	mov    %eax,0x4(%edx)
  1802dc:	c3                   	ret    

001802dd <uart_qmsi_irq_is_pending>:
}

static int uart_qmsi_irq_is_pending(struct device *dev)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  1802dd:	8b 40 08             	mov    0x8(%eax),%eax
	uint32_t id = (drv_data->iir_cache & QM_UART_IIR_IID_MASK);
  1802e0:	8a 40 04             	mov    0x4(%eax),%al

	return !(id == IIR_IID_NO_INTERRUPT_PENDING);
  1802e3:	83 e0 0f             	and    $0xf,%eax
  1802e6:	3c 01                	cmp    $0x1,%al
  1802e8:	0f 95 c0             	setne  %al
  1802eb:	0f b6 c0             	movzbl %al,%eax
}
  1802ee:	c3                   	ret    

001802ef <uart_qmsi_irq_update>:

static int uart_qmsi_irq_update(struct device *dev)
{
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1802ef:	8b 10                	mov    (%eax),%edx
  1802f1:	8b 52 08             	mov    0x8(%edx),%edx
  1802f4:	8b 12                	mov    (%edx),%edx
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  1802f6:	8b 40 08             	mov    0x8(%eax),%eax

	drv_data->iir_cache = QM_UART[instance]->iir_fcr;
  1802f9:	8b 14 95 1c 00 28 00 	mov    0x28001c(,%edx,4),%edx
  180300:	8b 52 08             	mov    0x8(%edx),%edx
  180303:	88 50 04             	mov    %dl,0x4(%eax)
	return 1;
}
  180306:	b8 01 00 00 00       	mov    $0x1,%eax
  18030b:	c3                   	ret    

0018030c <uart_qmsi_irq_callback_set>:

static void uart_qmsi_irq_callback_set(struct device *dev,
				       uart_irq_callback_t cb)
{
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  18030c:	8b 40 08             	mov    0x8(%eax),%eax

	drv_data->user_cb = cb;
  18030f:	89 10                	mov    %edx,(%eax)
  180311:	c3                   	ret    

00180312 <uart_qmsi_isr>:
}

static void uart_qmsi_isr(void *arg)
{
  180312:	53                   	push   %ebx
  180313:	89 c3                	mov    %eax,%ebx
	struct device *dev = arg;
	struct uart_qmsi_drv_data *drv_data = dev->driver_data;
  180315:	8b 40 08             	mov    0x8(%eax),%eax

	if (drv_data->user_cb)
  180318:	8b 10                	mov    (%eax),%edx
  18031a:	85 d2                	test   %edx,%edx
  18031c:	74 04                	je     180322 <uart_qmsi_isr+0x10>
		drv_data->user_cb(dev);
  18031e:	89 d8                	mov    %ebx,%eax
  180320:	ff d2                	call   *%edx

	device_busy_clear(dev);
  180322:	89 d8                	mov    %ebx,%eax
  180324:	e8 ea 1d 00 00       	call   182113 <device_busy_clear>
}
  180329:	5b                   	pop    %ebx
  18032a:	c3                   	ret    

0018032b <irq_config_func_0>:
 * @returns: N/A
 */
static inline void _irq_controller_irq_config(unsigned int vector,
					      unsigned int irq, uint32_t flags)
{
	__irq_controller_irq_config(vector, irq, flags);
  18032b:	b9 00 80 00 00       	mov    $0x8000,%ecx
  180330:	ba 08 00 00 00       	mov    $0x8,%edx
  180335:	b8 28 00 00 00       	mov    $0x28,%eax
  18033a:	e8 b1 02 00 00       	call   1805f0 <__irq_controller_irq_config>
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT),
		    CONFIG_UART_QMSI_0_IRQ_PRI, uart_qmsi_isr,
		    DEVICE_GET(uart_0), UART_IRQ_FLAGS);
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT));
  18033f:	b8 08 00 00 00       	mov    $0x8,%eax
  180344:	e8 82 02 00 00       	call   1805cb <_arch_irq_enable>
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->uart_0_int_mask);
  180349:	a1 60 04 80 b0       	mov    0xb0800460,%eax
  18034e:	83 e0 fe             	and    $0xfffffffe,%eax
  180351:	a3 60 04 80 b0       	mov    %eax,0xb0800460
  180356:	c3                   	ret    

00180357 <uart_qmsi_isr_irq8_stub>:
#ifdef CONFIG_UART_QMSI_0
static void irq_config_func_0(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_0_INT),
  180357:	68 50 00 28 00       	push   $0x280050
  18035c:	68 12 03 18 00       	push   $0x180312
  180361:	e9 f9 19 00 00       	jmp    181d5f <_interrupt_enter>

00180366 <uart_qmsi_isr_irq6_stub>:
#ifdef CONFIG_UART_QMSI_1
static void irq_config_func_1(struct device *dev)
{
	ARG_UNUSED(dev);

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_UART_1_INT),
  180366:	68 44 00 28 00       	push   $0x280044
  18036b:	68 12 03 18 00       	push   $0x180312
  180370:	e9 ea 19 00 00       	jmp    181d5f <_interrupt_enter>

00180375 <_timer_int_handler_irq10_stub>:
  180375:	6a 00                	push   $0x0
  180377:	68 ef 04 18 00       	push   $0x1804ef
  18037c:	e9 de 19 00 00       	jmp    181d5f <_interrupt_enter>

00180381 <qm_wdt_0_isr_irq16_stub>:
  180381:	6a 00                	push   $0x0
  180383:	68 5d 19 18 00       	push   $0x18195d
  180388:	e9 d2 19 00 00       	jmp    181d5f <_interrupt_enter>

0018038d <irq_config_func_1>:
  18038d:	b9 00 80 00 00       	mov    $0x8000,%ecx
  180392:	ba 06 00 00 00       	mov    $0x6,%edx
  180397:	b8 26 00 00 00       	mov    $0x26,%eax
  18039c:	e8 4f 02 00 00       	call   1805f0 <__irq_controller_irq_config>
		    CONFIG_UART_QMSI_1_IRQ_PRI, uart_qmsi_isr,
		    DEVICE_GET(uart_1), UART_IRQ_FLAGS);
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_UART_1_INT));
  1803a1:	b8 06 00 00 00       	mov    $0x6,%eax
  1803a6:	e8 20 02 00 00       	call   1805cb <_arch_irq_enable>
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->uart_1_int_mask);
  1803ab:	a1 64 04 80 b0       	mov    0xb0800464,%eax
  1803b0:	83 e0 fe             	and    $0xfffffffe,%eax
  1803b3:	a3 64 04 80 b0       	mov    %eax,0xb0800464
  1803b8:	c3                   	ret    

001803b9 <uart_qmsi_init>:
	.drv_cmd = uart_qmsi_drv_cmd,
#endif /* CONFIG_UART_DRV_CMD */
};

static int uart_qmsi_init(struct device *dev)
{
  1803b9:	56                   	push   %esi
  1803ba:	53                   	push   %ebx
  1803bb:	83 ec 0c             	sub    $0xc,%esp
  1803be:	89 c6                	mov    %eax,%esi
	const struct uart_qmsi_config_info *config = dev->config->config_info;
  1803c0:	8b 00                	mov    (%eax),%eax
  1803c2:	8b 58 08             	mov    0x8(%eax),%ebx
	qm_uart_config_t cfg;

	cfg.line_control = QM_UART_LC_8N1;
  1803c5:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
	cfg.baud_divisor = config->baud_divisor;
  1803cc:	8b 43 08             	mov    0x8(%ebx),%eax
  1803cf:	89 44 24 04          	mov    %eax,0x4(%esp)
	cfg.hw_fc = config->hw_fc;
  1803d3:	8a 43 0c             	mov    0xc(%ebx),%al
  1803d6:	88 44 24 08          	mov    %al,0x8(%esp)

	clk_periph_enable(config->clock_gate);
  1803da:	8b 43 04             	mov    0x4(%ebx),%eax
  1803dd:	e8 53 15 00 00       	call   181935 <clk_periph_enable>

	qm_uart_set_config(config->instance, &cfg);
  1803e2:	89 e2                	mov    %esp,%edx
  1803e4:	8b 03                	mov    (%ebx),%eax
  1803e6:	e8 36 16 00 00       	call   181a21 <qm_uart_set_config>

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	config->irq_config_func(dev);
  1803eb:	89 f0                	mov    %esi,%eax
  1803ed:	ff 53 10             	call   *0x10(%ebx)
#endif /* CONFIG_UART_INTERRUPT_DRIVEN */

	dev->driver_api = &api;
  1803f0:	c7 46 04 e0 2d 18 00 	movl   $0x182de0,0x4(%esi)
	uart_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  1803f7:	b8 00 00 00 00       	mov    $0x0,%eax
  1803fc:	83 c4 0c             	add    $0xc,%esp
  1803ff:	5b                   	pop    %ebx
  180400:	5e                   	pop    %esi
  180401:	c3                   	ret    

00180402 <uart_qmsi_fifo_read>:
	return QM_UART[instance]->lsr & QM_UART_LSR_DR;
}

static int uart_qmsi_fifo_read(struct device *dev, uint8_t *rx_data,
				  const int size)
{
  180402:	55                   	push   %ebp
  180403:	57                   	push   %edi
  180404:	56                   	push   %esi
  180405:	53                   	push   %ebx
  180406:	89 d5                	mov    %edx,%ebp
  180408:	89 cf                	mov    %ecx,%edi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18040a:	8b 10                	mov    (%eax),%edx
  18040c:	8b 52 08             	mov    0x8(%edx),%edx
  18040f:	8b 32                	mov    (%edx),%esi
	int i;

	device_busy_set(dev);
  180411:	e8 fc 1c 00 00       	call   182112 <device_busy_set>

	for (i = 0; i < size && is_data_ready(instance); i++) {
  180416:	bb 00 00 00 00       	mov    $0x0,%ebx
  18041b:	eb 0e                	jmp    18042b <uart_qmsi_fifo_read+0x29>
		rx_data[i] = QM_UART[instance]->rbr_thr_dll;
  18041d:	8b 04 b5 1c 00 28 00 	mov    0x28001c(,%esi,4),%eax
  180424:	8b 00                	mov    (%eax),%eax
  180426:	88 44 1d 00          	mov    %al,0x0(%ebp,%ebx,1)
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
	int i;

	device_busy_set(dev);

	for (i = 0; i < size && is_data_ready(instance); i++) {
  18042a:	43                   	inc    %ebx
  18042b:	39 fb                	cmp    %edi,%ebx
  18042d:	7d 0b                	jge    18043a <uart_qmsi_fifo_read+0x38>
  18042f:	89 f0                	mov    %esi,%eax
  180431:	e8 be fd ff ff       	call   1801f4 <is_data_ready>
  180436:	84 c0                	test   %al,%al
  180438:	75 e3                	jne    18041d <uart_qmsi_fifo_read+0x1b>
		rx_data[i] = QM_UART[instance]->rbr_thr_dll;
	}

	return i;
}
  18043a:	89 d8                	mov    %ebx,%eax
  18043c:	5b                   	pop    %ebx
  18043d:	5e                   	pop    %esi
  18043e:	5f                   	pop    %edi
  18043f:	5d                   	pop    %ebp
  180440:	c3                   	ret    

00180441 <uart_qmsi_fifo_fill>:
	return !!(QM_UART[instance]->lsr & QM_UART_LSR_THRE);
}

static int uart_qmsi_fifo_fill(struct device *dev, const uint8_t *tx_data,
				  int size)
{
  180441:	55                   	push   %ebp
  180442:	57                   	push   %edi
  180443:	56                   	push   %esi
  180444:	53                   	push   %ebx
  180445:	89 d5                	mov    %edx,%ebp
  180447:	89 cf                	mov    %ecx,%edi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180449:	8b 10                	mov    (%eax),%edx
  18044b:	8b 52 08             	mov    0x8(%edx),%edx
  18044e:	8b 32                	mov    (%edx),%esi
	int i;

	device_busy_set(dev);
  180450:	e8 bd 1c 00 00       	call   182112 <device_busy_set>

	for (i = 0; i < size && !is_tx_fifo_full(instance); i++) {
  180455:	bb 00 00 00 00       	mov    $0x0,%ebx
  18045a:	eb 0f                	jmp    18046b <uart_qmsi_fifo_fill+0x2a>
		QM_UART[instance]->rbr_thr_dll = tx_data[i];
  18045c:	8b 04 b5 1c 00 28 00 	mov    0x28001c(,%esi,4),%eax
  180463:	0f b6 54 1d 00       	movzbl 0x0(%ebp,%ebx,1),%edx
  180468:	89 10                	mov    %edx,(%eax)
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
	int i;

	device_busy_set(dev);

	for (i = 0; i < size && !is_tx_fifo_full(instance); i++) {
  18046a:	43                   	inc    %ebx
  18046b:	39 fb                	cmp    %edi,%ebx
  18046d:	7d 0b                	jge    18047a <uart_qmsi_fifo_fill+0x39>
  18046f:	89 f0                	mov    %esi,%eax
  180471:	e8 6e fd ff ff       	call   1801e4 <is_tx_fifo_full>
  180476:	84 c0                	test   %al,%al
  180478:	74 e2                	je     18045c <uart_qmsi_fifo_fill+0x1b>
		QM_UART[instance]->rbr_thr_dll = tx_data[i];
	}

	return i;
}
  18047a:	89 d8                	mov    %ebx,%eax
  18047c:	5b                   	pop    %ebx
  18047d:	5e                   	pop    %esi
  18047e:	5f                   	pop    %edi
  18047f:	5d                   	pop    %ebp
  180480:	c3                   	ret    

00180481 <uart_qmsi_err_check>:
	qm_uart_write(instance, data);
	return data;
}

static int uart_qmsi_err_check(struct device *dev)
{
  180481:	83 ec 04             	sub    $0x4,%esp
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  180484:	8b 00                	mov    (%eax),%eax
  180486:	8b 40 08             	mov    0x8(%eax),%eax
  180489:	8b 00                	mov    (%eax),%eax

	/* QMSI and Zephyr use the same bits to represent UART errors
	 * so we don't need to translate each error bit from QMSI API
	 * to Zephyr API.
	 */
	qm_uart_get_status(instance, &status);
  18048b:	89 e2                	mov    %esp,%edx
  18048d:	e8 02 16 00 00       	call   181a94 <qm_uart_get_status>
	return (status & QM_UART_LSR_ERROR_BITS);
  180492:	8b 04 24             	mov    (%esp),%eax
  180495:	83 e0 1e             	and    $0x1e,%eax
}
  180498:	83 c4 04             	add    $0x4,%esp
  18049b:	c3                   	ret    

0018049c <uart_qmsi_poll_out>:
	return 0;
}

static unsigned char uart_qmsi_poll_out(struct device *dev,
					unsigned char data)
{
  18049c:	53                   	push   %ebx
  18049d:	89 d3                	mov    %edx,%ebx
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  18049f:	8b 00                	mov    (%eax),%eax
  1804a1:	8b 40 08             	mov    0x8(%eax),%eax
  1804a4:	8b 00                	mov    (%eax),%eax

	qm_uart_write(instance, data);
  1804a6:	0f b6 d2             	movzbl %dl,%edx
  1804a9:	e8 29 16 00 00       	call   181ad7 <qm_uart_write>
	return data;
}
  1804ae:	88 d8                	mov    %bl,%al
  1804b0:	5b                   	pop    %ebx
  1804b1:	c3                   	ret    

001804b2 <uart_qmsi_poll_in>:
	      uart_qmsi_device_ctrl, &drv_data_1, &config_info_1, PRE_KERNEL_1,
	      CONFIG_KERNEL_INIT_PRIORITY_DEVICE, NULL);
#endif /* CONFIG_UART_QMSI_1 */

static int uart_qmsi_poll_in(struct device *dev, unsigned char *data)
{
  1804b2:	56                   	push   %esi
  1804b3:	53                   	push   %ebx
  1804b4:	83 ec 04             	sub    $0x4,%esp
  1804b7:	89 d6                	mov    %edx,%esi
	qm_uart_t instance = GET_CONTROLLER_INSTANCE(dev);
  1804b9:	8b 00                	mov    (%eax),%eax
  1804bb:	8b 40 08             	mov    0x8(%eax),%eax
  1804be:	8b 18                	mov    (%eax),%ebx
	qm_uart_status_t status;

	qm_uart_get_status(instance, &status);
  1804c0:	89 e2                	mov    %esp,%edx
  1804c2:	89 d8                	mov    %ebx,%eax
  1804c4:	e8 cb 15 00 00       	call   181a94 <qm_uart_get_status>
	/* In order to check if there is any data to read from UART
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
  1804c9:	f6 04 24 40          	testb  $0x40,(%esp)
  1804cd:	74 15                	je     1804e4 <uart_qmsi_poll_in+0x32>
		return -1;

	qm_uart_read(instance, data, NULL);
  1804cf:	b9 00 00 00 00       	mov    $0x0,%ecx
  1804d4:	89 f2                	mov    %esi,%edx
  1804d6:	89 d8                	mov    %ebx,%eax
  1804d8:	e8 1c 16 00 00       	call   181af9 <qm_uart_read>
	return 0;
  1804dd:	b8 00 00 00 00       	mov    $0x0,%eax
  1804e2:	eb 05                	jmp    1804e9 <uart_qmsi_poll_in+0x37>
	 * controller we should check if the QM_UART_RX_BUSY bit from
	 * 'status' is not set. This bit is set only if there is any
	 * pending character to read.
	 */
	if (!(status & QM_UART_RX_BUSY))
		return -1;
  1804e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	qm_uart_read(instance, data, NULL);
	return 0;
}
  1804e9:	83 c4 04             	add    $0x4,%esp
  1804ec:	5b                   	pop    %ebx
  1804ed:	5e                   	pop    %esi
  1804ee:	c3                   	ret    

001804ef <_timer_int_handler>:
		timer_mode = TIMER_MODE_PERIODIC;
	}

	_sys_clock_final_tick_announce();
#else
	_sys_clock_tick_announce();
  1804ef:	a1 24 00 28 00       	mov    0x280024,%eax
  1804f4:	e8 fe 20 00 00       	call   1825f7 <_nano_sys_clock_tick_announce>
  1804f9:	c3                   	ret    

001804fa <_sys_clock_driver_init>:
	tickless_idle_init();

#ifndef CONFIG_MVIC
	divide_configuration_register_set();
#endif
	initial_count_register_set(cycles_per_tick - 1);
  1804fa:	a1 28 00 28 00       	mov    0x280028,%eax
  1804ff:	48                   	dec    %eax
 * @param count Count from which timer is to count down
 * @return N/A
 */
static inline void initial_count_register_set(uint32_t count)
{
	*_REG_TIMER_ICR = count;
  180500:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
 *
 * @return N/A
 */
static inline void periodic_mode_set(void)
{
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
  180505:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
  18050a:	0d 00 00 02 00       	or     $0x20000,%eax
  18050f:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  180514:	b9 00 00 00 00       	mov    $0x0,%ecx
  180519:	ba 0a 00 00 00       	mov    $0xa,%edx
  18051e:	b8 2a 00 00 00       	mov    $0x2a,%eax
  180523:	e8 c8 00 00 00       	call   1805f0 <__irq_controller_irq_config>
	IRQ_CONNECT(TIMER_IRQ, TIMER_IRQ_PRIORITY, _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(TIMER_IRQ);
  180528:	b8 0a 00 00 00       	mov    $0xa,%eax
  18052d:	e8 99 00 00 00       	call   1805cb <_arch_irq_enable>

	return 0;
}
  180532:	b8 00 00 00 00       	mov    $0x0,%eax
  180537:	c3                   	ret    

00180538 <_mvic_rte_set>:
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  180538:	89 c1                	mov    %eax,%ecx
  18053a:	83 e1 07             	and    $0x7,%ecx
  18053d:	01 c9                	add    %ecx,%ecx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  18053f:	83 e0 18             	and    $0x18,%eax
  180542:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  180545:	09 c8                	or     %ecx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  180547:	9c                   	pushf  
  180548:	fa                   	cli    
  180549:	59                   	pop    %ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  18054a:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
  18054f:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
 *
 */

static ALWAYS_INLINE void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  180555:	f6 c5 02             	test   $0x2,%ch
  180558:	74 01                	je     18055b <_mvic_rte_set+0x23>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18055a:	fb                   	sti    
  18055b:	c3                   	ret    

0018055c <_mvic_rte_update>:
 * @param mask of bits to be modified
 *
 * @returns N/A
 */
static void _mvic_rte_update(unsigned int irq, uint32_t value, uint32_t mask)
{
  18055c:	53                   	push   %ebx
	unsigned int low_nibble;
	unsigned int high_nibble;

	__ASSERT(irq < MVIC_NUM_RTES, "invalid irq line %d", irq);

	low_nibble = ((irq & MVIC_LOW_NIBBLE_MASK) << 0x1);
  18055d:	89 c3                	mov    %eax,%ebx
  18055f:	83 e3 07             	and    $0x7,%ebx
  180562:	01 db                	add    %ebx,%ebx
	high_nibble = ((irq & MVIC_HIGH_NIBBLE_MASK) << 0x2);
  180564:	83 e0 18             	and    $0x18,%eax
  180567:	c1 e0 02             	shl    $0x2,%eax
	return low_nibble | high_nibble;
  18056a:	09 d8                	or     %ebx,%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18056c:	9c                   	pushf  
  18056d:	fa                   	cli    
  18056e:	5b                   	pop    %ebx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  18056f:	a3 00 00 c0 fe       	mov    %eax,0xfec00000
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180574:	a1 10 00 c0 fe       	mov    0xfec00010,%eax
	key = irq_lock();

	sys_write32(regsel, MVIC_IOREGSEL);

	old_value = sys_read32(MVIC_IOWIN);
	updated_value = (old_value & ~mask) | (value & mask);
  180579:	31 c2                	xor    %eax,%edx
  18057b:	21 d1                	and    %edx,%ecx
  18057d:	31 c8                	xor    %ecx,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  18057f:	a3 10 00 c0 fe       	mov    %eax,0xfec00010
  180584:	f6 c7 02             	test   $0x2,%bh
  180587:	74 01                	je     18058a <_mvic_rte_update+0x2e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  180589:	fb                   	sti    
	sys_write32(updated_value, MVIC_IOWIN);

	irq_unlock(key);
}
  18058a:	5b                   	pop    %ebx
  18058b:	c3                   	ret    

0018058c <_mvic_init>:
 * This routine replaces the standard Local APIC / IO APIC init routines.
 *
 * @returns: N/A
 */
static int _mvic_init(struct device *unused)
{
  18058c:	53                   	push   %ebx
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  18058d:	bb 00 00 00 00       	mov    $0x0,%ebx
  180592:	eb 0d                	jmp    1805a1 <_mvic_init+0x15>
		_mvic_rte_set(i, MVIC_IOWIN_MASK);
  180594:	ba 00 00 01 00       	mov    $0x10000,%edx
  180599:	89 d8                	mov    %ebx,%eax
  18059b:	e8 98 ff ff ff       	call   180538 <_mvic_rte_set>
{
	ARG_UNUSED(unused);
	int i;

	/* By default mask all interrupt lines */
	for (i = 0; i < MVIC_NUM_RTES; i++) {
  1805a0:	43                   	inc    %ebx
  1805a1:	83 fb 1f             	cmp    $0x1f,%ebx
  1805a4:	7e ee                	jle    180594 <_mvic_init+0x8>
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1805a6:	b8 00 00 00 00       	mov    $0x0,%eax
  1805ab:	a3 80 00 e0 fe       	mov    %eax,0xfee00080
  1805b0:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
  1805b5:	b8 0a 00 01 00       	mov    $0x1000a,%eax
  1805ba:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  1805bf:	b8 00 00 00 00       	mov    $0x0,%eax
  1805c4:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
	/* discard a pending interrupt if any */
	sys_write32(0, MVIC_EOI);

	return 0;

}
  1805c9:	5b                   	pop    %ebx
  1805ca:	c3                   	ret    

001805cb <_arch_irq_enable>:
SYS_INIT(_mvic_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);


void _arch_irq_enable(unsigned int irq)
{
	if (irq == CONFIG_MVIC_TIMER_IRQ) {
  1805cb:	83 f8 0a             	cmp    $0xa,%eax
  1805ce:	75 10                	jne    1805e0 <_arch_irq_enable+0x15>
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  1805d0:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
		sys_write32(sys_read32(MVIC_LVTTIMER) & ~MVIC_LVTTIMER_MASK,
  1805d5:	25 ff ff fe ff       	and    $0xfffeffff,%eax
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  1805da:	a3 20 03 e0 fe       	mov    %eax,0xfee00320
  1805df:	c3                   	ret    
			    MVIC_LVTTIMER);
	} else {
		_mvic_rte_update(irq, 0, MVIC_IOWIN_MASK);
  1805e0:	b9 00 00 01 00       	mov    $0x10000,%ecx
  1805e5:	ba 00 00 00 00       	mov    $0x0,%edx
  1805ea:	e8 6d ff ff ff       	call   18055c <_mvic_rte_update>
  1805ef:	c3                   	ret    

001805f0 <__irq_controller_irq_config>:

	/* Vector argument always ignored. There are no triggering options
	 * for the timer, so nothing to do at all for that case. Other I/O
	 * interrupts need their triggering set
	 */
	if (irq != CONFIG_MVIC_TIMER_IRQ) {
  1805f0:	83 fa 0a             	cmp    $0xa,%edx
  1805f3:	74 0f                	je     180604 <__irq_controller_irq_config+0x14>
  1805f5:	89 d0                	mov    %edx,%eax
		_mvic_rte_set(irq, MVIC_IOWIN_MASK | flags);
  1805f7:	81 c9 00 00 01 00    	or     $0x10000,%ecx
  1805fd:	89 ca                	mov    %ecx,%edx
  1805ff:	e8 34 ff ff ff       	call   180538 <_mvic_rte_set>
  180604:	c3                   	ret    

00180605 <__irq_controller_isr_vector_get>:
static ALWAYS_INLINE
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
  180605:	a1 10 01 e0 fe       	mov    0xfee00110,%eax
{
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
  18060a:	85 c0                	test   %eax,%eax
  18060c:	74 0e                	je     18061c <__irq_controller_isr_vector_get+0x17>

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  18060e:	0f bd c0             	bsr    %eax,%eax
  180611:	75 05                	jne    180618 <__irq_controller_isr_vector_get+0x13>
  180613:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
		return -1;
	}
	return 32 + (find_msb_set(isr) - 1);
  180618:	83 c0 20             	add    $0x20,%eax
  18061b:	c3                   	ret    
	/* In-service register value */
	int isr;

	isr = sys_read32(MVIC_ISR);
	if (unlikely(!isr)) {
		return -1;
  18061c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
	return 32 + (find_msb_set(isr) - 1);
}
  180621:	c3                   	ret    

00180622 <get_config>:

static void (*user_cb)(struct device *dev);

static void get_config(struct device *dev, struct wdt_config *cfg)
{
	cfg->timeout = QM_WDT[QM_WDT_0]->wdt_torr;
  180622:	a1 18 00 28 00       	mov    0x280018,%eax
  180627:	8b 40 04             	mov    0x4(%eax),%eax
  18062a:	89 02                	mov    %eax,(%edx)
	cfg->mode = ((QM_WDT[QM_WDT_0]->wdt_cr & QM_WDT_CR_RMOD) >>
  18062c:	a1 18 00 28 00       	mov    0x280018,%eax
  180631:	8b 00                	mov    (%eax),%eax
  180633:	83 e0 02             	and    $0x2,%eax
  180636:	d1 e8                	shr    %eax
  180638:	89 42 04             	mov    %eax,0x4(%edx)
			QM_WDT_CR_RMOD_OFFSET);
	cfg->interrupt_fn = user_cb;
  18063b:	a1 b8 02 28 00       	mov    0x2802b8,%eax
  180640:	89 42 08             	mov    %eax,0x8(%edx)
  180643:	c3                   	ret    

00180644 <init>:
  180644:	b9 00 00 00 00       	mov    $0x0,%ecx
  180649:	ba 10 00 00 00       	mov    $0x10,%edx
  18064e:	b8 30 00 00 00       	mov    $0x30,%eax
  180653:	e8 98 ff ff ff       	call   1805f0 <__irq_controller_irq_config>

	IRQ_CONNECT(IRQ_GET_NUMBER(QM_IRQ_WDT_0_INT), CONFIG_WDT_0_IRQ_PRI,
		    qm_wdt_0_isr, 0, IOAPIC_EDGE | IOAPIC_HIGH);

	/* Unmask watchdog interrupt */
	irq_enable(IRQ_GET_NUMBER(QM_IRQ_WDT_0_INT));
  180658:	b8 10 00 00 00       	mov    $0x10,%eax
  18065d:	e8 69 ff ff ff       	call   1805cb <_arch_irq_enable>

	/* Route watchdog interrupt to the current core */
	QM_IR_UNMASK_INTERRUPTS(QM_INTERRUPT_ROUTER->wdt_0_int_mask);
  180662:	a1 7c 04 80 b0       	mov    0xb080047c,%eax
  180667:	83 e0 fe             	and    $0xfffffffe,%eax
  18066a:	a3 7c 04 80 b0       	mov    %eax,0xb080047c

	wdt_qmsi_set_power_state(dev, DEVICE_PM_ACTIVE_STATE);

	return 0;
}
  18066f:	b8 00 00 00 00       	mov    $0x0,%eax
  180674:	c3                   	ret    

00180675 <reload>:
	return ret_val;
}

static void reload(struct device *dev)
{
	qm_wdt_reload(QM_WDT_0);
  180675:	b8 00 00 00 00       	mov    $0x0,%eax
  18067a:	e8 f8 12 00 00       	call   181977 <qm_wdt_reload>
  18067f:	c3                   	ret    

00180680 <set_config>:
			QM_WDT_CR_RMOD_OFFSET);
	cfg->interrupt_fn = user_cb;
}

static int set_config(struct device *dev, struct wdt_config *cfg)
{
  180680:	53                   	push   %ebx
  180681:	83 ec 10             	sub    $0x10,%esp
	int ret_val = 0;
	qm_wdt_config_t qm_cfg;

	user_cb = cfg->interrupt_fn;
  180684:	8b 4a 08             	mov    0x8(%edx),%ecx
  180687:	89 0d b8 02 28 00    	mov    %ecx,0x2802b8
	qm_cfg.timeout = cfg->timeout;
  18068d:	8b 1a                	mov    (%edx),%ebx
  18068f:	89 1c 24             	mov    %ebx,(%esp)
	qm_cfg.mode = (cfg->mode == WDT_MODE_RESET) ?
			QM_WDT_MODE_RESET : QM_WDT_MODE_INTERRUPT_RESET;
  180692:	83 7a 04 00          	cmpl   $0x0,0x4(%edx)
  180696:	0f 95 c2             	setne  %dl
  180699:	0f b6 d2             	movzbl %dl,%edx
	int ret_val = 0;
	qm_wdt_config_t qm_cfg;

	user_cb = cfg->interrupt_fn;
	qm_cfg.timeout = cfg->timeout;
	qm_cfg.mode = (cfg->mode == WDT_MODE_RESET) ?
  18069c:	89 54 24 04          	mov    %edx,0x4(%esp)
			QM_WDT_MODE_RESET : QM_WDT_MODE_INTERRUPT_RESET;
	qm_cfg.callback = (void *)user_cb;
  1806a0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	qm_cfg.callback_data = dev;
  1806a4:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if (IS_ENABLED(CONFIG_WDT_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(dev), K_FOREVER);
	}

	if (qm_wdt_set_config(QM_WDT_0, &qm_cfg)) {
  1806a8:	89 e2                	mov    %esp,%edx
  1806aa:	b8 00 00 00 00       	mov    $0x0,%eax
  1806af:	e8 0d 13 00 00       	call   1819c1 <qm_wdt_set_config>
  1806b4:	85 c0                	test   %eax,%eax
  1806b6:	75 0b                	jne    1806c3 <set_config+0x43>
		ret_val = -EIO;
		goto wdt_config_return;
	}

	if (qm_wdt_start(QM_WDT_0)) {
  1806b8:	e8 ce 12 00 00       	call   18198b <qm_wdt_start>
  1806bd:	85 c0                	test   %eax,%eax
  1806bf:	75 09                	jne    1806ca <set_config+0x4a>
  1806c1:	eb 0c                	jmp    1806cf <set_config+0x4f>
	if (IS_ENABLED(CONFIG_WDT_QMSI_API_REENTRANCY)) {
		k_sem_take(RP_GET(dev), K_FOREVER);
	}

	if (qm_wdt_set_config(QM_WDT_0, &qm_cfg)) {
		ret_val = -EIO;
  1806c3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  1806c8:	eb 05                	jmp    1806cf <set_config+0x4f>
		goto wdt_config_return;
	}

	if (qm_wdt_start(QM_WDT_0)) {
		ret_val = -EIO;
  1806ca:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	if (IS_ENABLED(CONFIG_WDT_QMSI_API_REENTRANCY)) {
		k_sem_give(RP_GET(dev));
	}

	return ret_val;
}
  1806cf:	83 c4 10             	add    $0x10,%esp
  1806d2:	5b                   	pop    %ebx
  1806d3:	c3                   	ret    

001806d4 <disable>:
	clk_periph_enable(CLK_PERIPH_WDT_REGISTER | CLK_PERIPH_CLK);
}

static void disable(struct device *dev)
{
	clk_periph_disable(CLK_PERIPH_WDT_REGISTER);
  1806d4:	b8 00 04 00 00       	mov    $0x400,%eax
  1806d9:	e8 6a 12 00 00       	call   181948 <clk_periph_disable>
  1806de:	c3                   	ret    

001806df <enable>:
	qm_wdt_reload(QM_WDT_0);
}

static void enable(struct device *dev)
{
	clk_periph_enable(CLK_PERIPH_WDT_REGISTER | CLK_PERIPH_CLK);
  1806df:	b8 02 04 00 00       	mov    $0x402,%eax
  1806e4:	e8 4c 12 00 00       	call   181935 <clk_periph_enable>
  1806e9:	c3                   	ret    

001806ea <pinmux_get>:
	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_get(struct device *dev, uint32_t pin,
			  uint32_t *func)
{
  1806ea:	56                   	push   %esi
  1806eb:	53                   	push   %ebx
  1806ec:	89 cb                	mov    %ecx,%ebx
	/*
	 * pinmux control registers are 32-bit wide, but each pin requires
	 * 2 bits to set the mode (A, B, C, or D).  As such we only get 16
	 * pins per register.
	 */
	uint32_t reg_offset = pin >> 4;
  1806ee:	89 d6                	mov    %edx,%esi
  1806f0:	c1 ee 04             	shr    $0x4,%esi

	/* The pin offset within the register */
	uint32_t pin_no = pin % 16;
  1806f3:	83 e2 0f             	and    $0xf,%edx

	/*
	 * MASK_2_BITS (the value of which is 3) is used because there are
	 * 2 bits for the mode of each pin.
	 */
	uint32_t pin_mask = MASK_2_BITS << (pin_no << 1);
  1806f6:	8d 0c 12             	lea    (%edx,%edx,1),%ecx
  1806f9:	b8 03 00 00 00       	mov    $0x3,%eax
  1806fe:	d3 e0                	shl    %cl,%eax
	uint32_t mode_mask = *mux_register & pin_mask;
  180700:	8b 14 b5 30 09 80 b0 	mov    -0x4f7ff6d0(,%esi,4),%edx
  180707:	21 d0                	and    %edx,%eax
	uint32_t mode = mode_mask >> (pin_no << 1);
  180709:	d3 e8                	shr    %cl,%eax

	*func = mode;
  18070b:	89 03                	mov    %eax,(%ebx)

	return 0;
}
  18070d:	b8 00 00 00 00       	mov    $0x0,%eax
  180712:	5b                   	pop    %ebx
  180713:	5e                   	pop    %esi
  180714:	c3                   	ret    

00180715 <pinmux_initialize>:
};

static int pinmux_initialize(struct device *port)
{
	return 0;
}
  180715:	b8 00 00 00 00       	mov    $0x0,%eax
  18071a:	c3                   	ret    

0018071b <pinmux_input>:
	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
}

static int pinmux_input(struct device *dev, uint32_t pin,
			    uint8_t func)
{
  18071b:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_input_en(pin, func) == 0 ? 0 : -EIO;
  18071d:	84 c9                	test   %cl,%cl
  18071f:	0f 95 c2             	setne  %dl
  180722:	0f b6 d2             	movzbl %dl,%edx
  180725:	e8 a4 14 00 00       	call   181bce <qm_pmux_input_en>
  18072a:	85 c0                	test   %eax,%eax
  18072c:	74 05                	je     180733 <pinmux_input+0x18>
  18072e:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  180733:	c3                   	ret    

00180734 <pinmux_pullup>:
	return 0;
}

static int pinmux_pullup(struct device *dev, uint32_t pin,
			     uint8_t func)
{
  180734:	89 d0                	mov    %edx,%eax
	ARG_UNUSED(dev);

	return qm_pmux_pullup_en(pin, func) == 0 ? 0 : -EIO;
  180736:	84 c9                	test   %cl,%cl
  180738:	0f 95 c2             	setne  %dl
  18073b:	0f b6 d2             	movzbl %dl,%edx
  18073e:	e8 ec 14 00 00       	call   181c2f <qm_pmux_pullup_en>
  180743:	85 c0                	test   %eax,%eax
  180745:	74 05                	je     18074c <pinmux_pullup+0x18>
  180747:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  18074c:	c3                   	ret    

0018074d <pinmux_set>:

#define MASK_2_BITS	0x3

static int pinmux_set(struct device *dev, uint32_t pin,
			  uint32_t func)
{
  18074d:	89 d0                	mov    %edx,%eax
  18074f:	89 ca                	mov    %ecx,%edx
	ARG_UNUSED(dev);

	return qm_pmux_select(pin, func) == 0 ? 0 : -EIO;
  180751:	e8 20 14 00 00       	call   181b76 <qm_pmux_select>
  180756:	85 c0                	test   %eax,%eax
  180758:	74 05                	je     18075f <pinmux_set+0x12>
  18075a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  18075f:	c3                   	ret    

00180760 <printf>:
int printf(const char *_MLIBC_RESTRICT format, ...)
{
	va_list vargs;
	int     r;

	va_start(vargs, format);
  180760:	8d 44 24 08          	lea    0x8(%esp),%eax
	r = _prf(fputc, DESC(stdout), format, vargs);
  180764:	50                   	push   %eax
  180765:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  180769:	ba 02 00 00 00       	mov    $0x2,%edx
  18076e:	b8 b2 14 18 00       	mov    $0x1814b2,%eax
  180773:	e8 05 07 00 00       	call   180e7d <_prf>
  180778:	83 c4 04             	add    $0x4,%esp
	va_end(vargs);

	return r;
}
  18077b:	c3                   	ret    

0018077c <_uc>:
#define EOF  -1
#endif

static void _uc(char *buf)
{
	for (/**/; *buf; buf++) {
  18077c:	eb 0e                	jmp    18078c <_uc+0x10>
		if (*buf >= 'a' && *buf <= 'z') {
  18077e:	8d 4a 9f             	lea    -0x61(%edx),%ecx
  180781:	80 f9 19             	cmp    $0x19,%cl
  180784:	77 05                	ja     18078b <_uc+0xf>
			*buf += 'A' - 'a';
  180786:	83 ea 20             	sub    $0x20,%edx
  180789:	88 10                	mov    %dl,(%eax)
#define EOF  -1
#endif

static void _uc(char *buf)
{
	for (/**/; *buf; buf++) {
  18078b:	40                   	inc    %eax
  18078c:	8a 10                	mov    (%eax),%dl
  18078e:	84 d2                	test   %dl,%dl
  180790:	75 ec                	jne    18077e <_uc+0x2>
		if (*buf >= 'a' && *buf <= 'z') {
			*buf += 'A' - 'a';
		}
	}
}
  180792:	c3                   	ret    

00180793 <_reverse_and_pad>:

/* Convention note: "end" as passed in is the standard "byte after
 * last character" style, but...
 */
static int _reverse_and_pad(char *start, char *end, int minlen)
{
  180793:	56                   	push   %esi
  180794:	53                   	push   %ebx
	int len;

	while (end - start < minlen) {
  180795:	eb 06                	jmp    18079d <_reverse_and_pad+0xa>
		*end++ = '0';
  180797:	c6 02 30             	movb   $0x30,(%edx)
  18079a:	8d 52 01             	lea    0x1(%edx),%edx
 */
static int _reverse_and_pad(char *start, char *end, int minlen)
{
	int len;

	while (end - start < minlen) {
  18079d:	89 d3                	mov    %edx,%ebx
  18079f:	29 c3                	sub    %eax,%ebx
  1807a1:	39 cb                	cmp    %ecx,%ebx
  1807a3:	7c f2                	jl     180797 <_reverse_and_pad+0x4>
		*end++ = '0';
	}

	*end = 0;
  1807a5:	c6 02 00             	movb   $0x0,(%edx)
	len = end - start;
	for (end--; end > start; end--, start++) {
  1807a8:	4a                   	dec    %edx
  1807a9:	eb 0d                	jmp    1807b8 <_reverse_and_pad+0x25>
		char tmp = *end;
  1807ab:	0f b6 32             	movzbl (%edx),%esi
		*end = *start;
  1807ae:	8a 08                	mov    (%eax),%cl
  1807b0:	88 0a                	mov    %cl,(%edx)
		*start = tmp;
  1807b2:	89 f1                	mov    %esi,%ecx
  1807b4:	88 08                	mov    %cl,(%eax)
		*end++ = '0';
	}

	*end = 0;
	len = end - start;
	for (end--; end > start; end--, start++) {
  1807b6:	4a                   	dec    %edx
  1807b7:	40                   	inc    %eax
  1807b8:	39 d0                	cmp    %edx,%eax
  1807ba:	72 ef                	jb     1807ab <_reverse_and_pad+0x18>
		char tmp = *end;
		*end = *start;
		*start = tmp;
	}
	return len;
}
  1807bc:	89 d8                	mov    %ebx,%eax
  1807be:	5b                   	pop    %ebx
  1807bf:	5e                   	pop    %esi
  1807c0:	c3                   	ret    

001807c1 <_to_x>:
/* Writes the specified number into the buffer in the given base,
 * using the digit characters 0-9a-z (i.e. base>36 will start writing
 * odd bytes), padding with leading zeros up to the minimum length.
 */
static int _to_x(char *buf, uint32_t n, int base, int minlen)
{
  1807c1:	55                   	push   %ebp
  1807c2:	57                   	push   %edi
  1807c3:	56                   	push   %esi
  1807c4:	53                   	push   %ebx
  1807c5:	83 ec 04             	sub    $0x4,%esp
  1807c8:	89 04 24             	mov    %eax,(%esp)
  1807cb:	89 d6                	mov    %edx,%esi
  1807cd:	89 c3                	mov    %eax,%ebx
	char *buf0 = buf;

	do {
		int d = n % base;
  1807cf:	89 f0                	mov    %esi,%eax
  1807d1:	ba 00 00 00 00       	mov    $0x0,%edx
  1807d6:	f7 f1                	div    %ecx

		n /= base;
  1807d8:	89 c6                	mov    %eax,%esi
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
  1807da:	8d 7b 01             	lea    0x1(%ebx),%edi
  1807dd:	83 fa 09             	cmp    $0x9,%edx
  1807e0:	7e 07                	jle    1807e9 <_to_x+0x28>
  1807e2:	bd 27 00 00 00       	mov    $0x27,%ebp
  1807e7:	eb 05                	jmp    1807ee <_to_x+0x2d>
  1807e9:	bd 00 00 00 00       	mov    $0x0,%ebp
  1807ee:	8d 54 15 30          	lea    0x30(%ebp,%edx,1),%edx
  1807f2:	88 13                	mov    %dl,(%ebx)
  1807f4:	89 fb                	mov    %edi,%ebx
	} while (n);
  1807f6:	85 c0                	test   %eax,%eax
  1807f8:	75 d5                	jne    1807cf <_to_x+0xe>
	return _reverse_and_pad(buf0, buf, minlen);
  1807fa:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  1807fe:	89 fa                	mov    %edi,%edx
  180800:	8b 04 24             	mov    (%esp),%eax
  180803:	e8 8b ff ff ff       	call   180793 <_reverse_and_pad>
}
  180808:	83 c4 04             	add    $0x4,%esp
  18080b:	5b                   	pop    %ebx
  18080c:	5e                   	pop    %esi
  18080d:	5f                   	pop    %edi
  18080e:	5d                   	pop    %ebp
  18080f:	c3                   	ret    

00180810 <_to_hex>:

static int _to_hex(char *buf, uint32_t value,
		   int alt_form, int precision, int prefix)
{
  180810:	57                   	push   %edi
  180811:	56                   	push   %esi
  180812:	53                   	push   %ebx
  180813:	89 c6                	mov    %eax,%esi
	int len;
	char *buf0 = buf;

	if (alt_form) {
  180815:	85 c9                	test   %ecx,%ecx
  180817:	74 0c                	je     180825 <_to_hex+0x15>
		*buf++ = '0';
  180819:	c6 00 30             	movb   $0x30,(%eax)
		*buf++ = 'x';
  18081c:	8d 58 02             	lea    0x2(%eax),%ebx
  18081f:	c6 40 01 78          	movb   $0x78,0x1(%eax)
  180823:	eb 02                	jmp    180827 <_to_hex+0x17>
  180825:	89 c3                	mov    %eax,%ebx
	}

	len = _to_x(buf, value, 16, precision);
  180827:	ff 74 24 10          	pushl  0x10(%esp)
  18082b:	b9 10 00 00 00       	mov    $0x10,%ecx
  180830:	89 d8                	mov    %ebx,%eax
  180832:	e8 8a ff ff ff       	call   1807c1 <_to_x>
  180837:	83 c4 04             	add    $0x4,%esp
  18083a:	89 c7                	mov    %eax,%edi
	if (prefix == 'X') {
  18083c:	83 7c 24 14 58       	cmpl   $0x58,0x14(%esp)
  180841:	75 07                	jne    18084a <_to_hex+0x3a>
		_uc(buf0);
  180843:	89 f0                	mov    %esi,%eax
  180845:	e8 32 ff ff ff       	call   18077c <_uc>
	}

	return len + (buf - buf0);
  18084a:	29 f3                	sub    %esi,%ebx
  18084c:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
}
  18084f:	5b                   	pop    %ebx
  180850:	5e                   	pop    %esi
  180851:	5f                   	pop    %edi
  180852:	c3                   	ret    

00180853 <_to_octal>:

static int _to_octal(char *buf, uint32_t value, int alt_form, int precision)
{
  180853:	53                   	push   %ebx
  180854:	89 c3                	mov    %eax,%ebx
	char *buf0 = buf;

	if (alt_form) {
  180856:	85 c9                	test   %ecx,%ecx
  180858:	74 15                	je     18086f <_to_octal+0x1c>
		*buf++ = '0';
  18085a:	8d 40 01             	lea    0x1(%eax),%eax
  18085d:	c6 03 30             	movb   $0x30,(%ebx)
		if (!value) {
  180860:	85 d2                	test   %edx,%edx
  180862:	75 0b                	jne    18086f <_to_octal+0x1c>
			/* So we don't return "00" for a value == 0. */
			*buf++ = 0;
  180864:	c6 43 01 00          	movb   $0x0,0x1(%ebx)
			return 1;
  180868:	b8 01 00 00 00       	mov    $0x1,%eax
  18086d:	eb 19                	jmp    180888 <_to_octal+0x35>
		}
	}
	return (buf - buf0) + _to_x(buf, value, 8, precision);
  18086f:	89 c1                	mov    %eax,%ecx
  180871:	29 d9                	sub    %ebx,%ecx
  180873:	89 cb                	mov    %ecx,%ebx
  180875:	ff 74 24 08          	pushl  0x8(%esp)
  180879:	b9 08 00 00 00       	mov    $0x8,%ecx
  18087e:	e8 3e ff ff ff       	call   1807c1 <_to_x>
  180883:	83 c4 04             	add    $0x4,%esp
  180886:	01 d8                	add    %ebx,%eax
}
  180888:	5b                   	pop    %ebx
  180889:	c3                   	ret    

0018088a <_to_udec>:

static int _to_udec(char *buf, uint32_t value, int precision)
{
	return _to_x(buf, value, 10, precision);
  18088a:	51                   	push   %ecx
  18088b:	b9 0a 00 00 00       	mov    $0xa,%ecx
  180890:	e8 2c ff ff ff       	call   1807c1 <_to_x>
  180895:	83 c4 04             	add    $0x4,%esp
}
  180898:	c3                   	ret    

00180899 <_to_dec>:

static int _to_dec(char *buf, int32_t value, int fplus, int fspace, int precision)
{
  180899:	56                   	push   %esi
  18089a:	53                   	push   %ebx
  18089b:	89 c3                	mov    %eax,%ebx

#if (MAXFLD < 10)
  #error buffer size MAXFLD is too small
#endif

	if (value < 0) {
  18089d:	85 d2                	test   %edx,%edx
  18089f:	79 12                	jns    1808b3 <_to_dec+0x1a>
		*buf++ = '-';
  1808a1:	8d 70 01             	lea    0x1(%eax),%esi
  1808a4:	c6 00 2d             	movb   $0x2d,(%eax)
		if (value != 0x80000000)
  1808a7:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
  1808ad:	74 21                	je     1808d0 <_to_dec+0x37>
			value = -value;
  1808af:	f7 da                	neg    %edx
  1808b1:	eb 1d                	jmp    1808d0 <_to_dec+0x37>
	} else if (fplus)
  1808b3:	85 c9                	test   %ecx,%ecx
  1808b5:	74 08                	je     1808bf <_to_dec+0x26>
		*buf++ = '+';
  1808b7:	8d 70 01             	lea    0x1(%eax),%esi
  1808ba:	c6 00 2b             	movb   $0x2b,(%eax)
  1808bd:	eb 11                	jmp    1808d0 <_to_dec+0x37>
	else if (fspace)
  1808bf:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  1808c4:	74 08                	je     1808ce <_to_dec+0x35>
		*buf++ = ' ';
  1808c6:	8d 70 01             	lea    0x1(%eax),%esi
  1808c9:	c6 00 20             	movb   $0x20,(%eax)
  1808cc:	eb 02                	jmp    1808d0 <_to_dec+0x37>
  1808ce:	89 c6                	mov    %eax,%esi

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
  1808d0:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  1808d4:	89 f0                	mov    %esi,%eax
  1808d6:	e8 af ff ff ff       	call   18088a <_to_udec>
  1808db:	01 f0                	add    %esi,%eax
  1808dd:	29 d8                	sub    %ebx,%eax
}
  1808df:	5b                   	pop    %ebx
  1808e0:	5e                   	pop    %esi
  1808e1:	c3                   	ret    

001808e2 <_rlrshift>:

static	void _rlrshift(uint64_t *v)
{
  1808e2:	57                   	push   %edi
  1808e3:	56                   	push   %esi
  1808e4:	53                   	push   %ebx
	*v = (*v & 1) + (*v >> 1);
  1808e5:	8b 08                	mov    (%eax),%ecx
  1808e7:	8b 58 04             	mov    0x4(%eax),%ebx
  1808ea:	89 ca                	mov    %ecx,%edx
  1808ec:	83 e2 01             	and    $0x1,%edx
  1808ef:	bf 00 00 00 00       	mov    $0x0,%edi
  1808f4:	0f ac d9 01          	shrd   $0x1,%ebx,%ecx
  1808f8:	d1 eb                	shr    %ebx
  1808fa:	01 d1                	add    %edx,%ecx
  1808fc:	11 fb                	adc    %edi,%ebx
  1808fe:	89 08                	mov    %ecx,(%eax)
  180900:	89 58 04             	mov    %ebx,0x4(%eax)
}
  180903:	5b                   	pop    %ebx
  180904:	5e                   	pop    %esi
  180905:	5f                   	pop    %edi
  180906:	c3                   	ret    

00180907 <_ldiv5>:
 * six.  This was tested exhaustively through the first ~10B values in
 * the input space, and for ~2e12 (4 hours runtime) random inputs
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
  180907:	55                   	push   %ebp
  180908:	57                   	push   %edi
  180909:	56                   	push   %esi
  18090a:	53                   	push   %ebx
  18090b:	83 ec 10             	sub    $0x10,%esp
  18090e:	89 c5                	mov    %eax,%ebp
	static const char shifts[] = { 32, 3, 0 };

	/* Usage in this file wants rounded behavior, not truncation.  So add
	 * two to get the threshold right.
	 */
	rem += 2;
  180910:	8b 00                	mov    (%eax),%eax
  180912:	8b 55 04             	mov    0x4(%ebp),%edx
  180915:	83 c0 02             	add    $0x2,%eax
  180918:	83 d2 00             	adc    $0x0,%edx
  18091b:	89 04 24             	mov    %eax,(%esp)
  18091e:	89 54 24 04          	mov    %edx,0x4(%esp)
 * taken from the full 64 bit space.
 */
static void _ldiv5(uint64_t *v)
{
	uint32_t i, hi;
	uint64_t rem = *v, quot = 0, q;
  180922:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180929:	00 
  18092a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  180931:	00 
	/* Usage in this file wants rounded behavior, not truncation.  So add
	 * two to get the threshold right.
	 */
	rem += 2;

	for (i = 0; i < 3; i++) {
  180932:	bb 00 00 00 00       	mov    $0x0,%ebx
  180937:	eb 5d                	jmp    180996 <_ldiv5+0x8f>
		hi = rem >> shifts[i];
  180939:	8b 04 24             	mov    (%esp),%eax
  18093c:	8b 54 24 04          	mov    0x4(%esp),%edx
  180940:	8a 8b 14 31 18 00    	mov    0x183114(%ebx),%cl
  180946:	0f ad d0             	shrd   %cl,%edx,%eax
  180949:	d3 ea                	shr    %cl,%edx
  18094b:	f6 c1 20             	test   $0x20,%cl
  18094e:	74 02                	je     180952 <_ldiv5+0x4b>
  180950:	89 d0                	mov    %edx,%eax
		q = (uint64_t)(hi / 5) << shifts[i];
  180952:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  180957:	f7 e1                	mul    %ecx
  180959:	c1 ea 02             	shr    $0x2,%edx
  18095c:	89 d0                	mov    %edx,%eax
  18095e:	ba 00 00 00 00       	mov    $0x0,%edx
  180963:	8a 8b 14 31 18 00    	mov    0x183114(%ebx),%cl
  180969:	0f a5 c2             	shld   %cl,%eax,%edx
  18096c:	d3 e0                	shl    %cl,%eax
  18096e:	f6 c1 20             	test   $0x20,%cl
  180971:	74 04                	je     180977 <_ldiv5+0x70>
  180973:	89 c2                	mov    %eax,%edx
  180975:	31 c0                	xor    %eax,%eax
		rem -= q * 5;
  180977:	89 c6                	mov    %eax,%esi
  180979:	89 d7                	mov    %edx,%edi
  18097b:	0f a4 c7 02          	shld   $0x2,%eax,%edi
  18097f:	c1 e6 02             	shl    $0x2,%esi
  180982:	01 c6                	add    %eax,%esi
  180984:	11 d7                	adc    %edx,%edi
  180986:	29 34 24             	sub    %esi,(%esp)
  180989:	19 7c 24 04          	sbb    %edi,0x4(%esp)
		quot += q;
  18098d:	01 44 24 08          	add    %eax,0x8(%esp)
  180991:	11 54 24 0c          	adc    %edx,0xc(%esp)
	/* Usage in this file wants rounded behavior, not truncation.  So add
	 * two to get the threshold right.
	 */
	rem += 2;

	for (i = 0; i < 3; i++) {
  180995:	43                   	inc    %ebx
  180996:	83 fb 02             	cmp    $0x2,%ebx
  180999:	76 9e                	jbe    180939 <_ldiv5+0x32>
		q = (uint64_t)(hi / 5) << shifts[i];
		rem -= q * 5;
		quot += q;
	}

	*v = quot;
  18099b:	8b 44 24 08          	mov    0x8(%esp),%eax
  18099f:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1809a3:	89 45 00             	mov    %eax,0x0(%ebp)
  1809a6:	89 55 04             	mov    %edx,0x4(%ebp)
}
  1809a9:	83 c4 10             	add    $0x10,%esp
  1809ac:	5b                   	pop    %ebx
  1809ad:	5e                   	pop    %esi
  1809ae:	5f                   	pop    %edi
  1809af:	5d                   	pop    %ebp
  1809b0:	c3                   	ret    

001809b1 <_get_digit>:

static	char _get_digit(uint64_t *fr, int *digit_count)
{
	int		rval;

	if (*digit_count > 0) {
  1809b1:	8b 0a                	mov    (%edx),%ecx
  1809b3:	85 c9                	test   %ecx,%ecx
  1809b5:	7e 39                	jle    1809f0 <_get_digit+0x3f>

	*v = quot;
}

static	char _get_digit(uint64_t *fr, int *digit_count)
{
  1809b7:	57                   	push   %edi
  1809b8:	56                   	push   %esi
  1809b9:	53                   	push   %ebx
	int		rval;

	if (*digit_count > 0) {
		*digit_count -= 1;
  1809ba:	49                   	dec    %ecx
  1809bb:	89 0a                	mov    %ecx,(%edx)
		*fr = *fr * 10;
  1809bd:	8b 30                	mov    (%eax),%esi
  1809bf:	8b 78 04             	mov    0x4(%eax),%edi
  1809c2:	89 f1                	mov    %esi,%ecx
  1809c4:	89 fb                	mov    %edi,%ebx
  1809c6:	0f a4 f3 01          	shld   $0x1,%esi,%ebx
  1809ca:	01 f1                	add    %esi,%ecx
  1809cc:	0f a4 f7 03          	shld   $0x3,%esi,%edi
  1809d0:	c1 e6 03             	shl    $0x3,%esi
  1809d3:	01 f1                	add    %esi,%ecx
  1809d5:	11 fb                	adc    %edi,%ebx
  1809d7:	89 ce                	mov    %ecx,%esi
  1809d9:	89 da                	mov    %ebx,%edx
		rval = ((*fr >> 60) & 0xF) + '0';
  1809db:	89 d9                	mov    %ebx,%ecx
  1809dd:	c1 e9 1c             	shr    $0x1c,%ecx
  1809e0:	83 c1 30             	add    $0x30,%ecx
		*fr &= 0x0FFFFFFFFFFFFFFFull;
  1809e3:	89 30                	mov    %esi,(%eax)
  1809e5:	81 e2 ff ff ff 0f    	and    $0xfffffff,%edx
  1809eb:	89 50 04             	mov    %edx,0x4(%eax)
  1809ee:	eb 08                	jmp    1809f8 <_get_digit+0x47>
	} else
		rval = '0';
  1809f0:	b9 30 00 00 00       	mov    $0x30,%ecx
	return (char) (rval);
}
  1809f5:	88 c8                	mov    %cl,%al
  1809f7:	c3                   	ret    
  1809f8:	88 c8                	mov    %cl,%al
  1809fa:	5b                   	pop    %ebx
  1809fb:	5e                   	pop    %esi
  1809fc:	5f                   	pop    %edi
  1809fd:	c3                   	ret    

001809fe <_to_float>:
#define	MAXFP1	0xFFFFFFFF	/* Largest # if first fp format */
#define HIGHBIT64 (1ull<<63)

static int _to_float(char *buf, uint64_t double_temp, int c,
					 int falt, int fplus, int fspace, int precision)
{
  1809fe:	55                   	push   %ebp
  1809ff:	57                   	push   %edi
  180a00:	56                   	push   %esi
  180a01:	53                   	push   %ebx
  180a02:	83 ec 24             	sub    $0x24,%esp
  180a05:	89 c6                	mov    %eax,%esi
	uint64_t        fract;
	uint64_t        ltemp;
	int             prune_zero;
	char           *start = buf;

	exp = double_temp >> 52 & 0x7ff;
  180a07:	89 cb                	mov    %ecx,%ebx
  180a09:	c1 eb 14             	shr    $0x14,%ebx
  180a0c:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
	fract = (double_temp << 11) & ~HIGHBIT64;
  180a12:	89 d7                	mov    %edx,%edi
  180a14:	89 cd                	mov    %ecx,%ebp
  180a16:	0f a4 d5 0b          	shld   $0xb,%edx,%ebp
  180a1a:	c1 e7 0b             	shl    $0xb,%edi
  180a1d:	89 f8                	mov    %edi,%eax
  180a1f:	89 ea                	mov    %ebp,%edx
  180a21:	89 fd                	mov    %edi,%ebp
  180a23:	89 d7                	mov    %edx,%edi
  180a25:	81 e7 ff ff ff 7f    	and    $0x7fffffff,%edi
  180a2b:	89 44 24 18          	mov    %eax,0x18(%esp)
  180a2f:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
	sign = !!(double_temp & HIGHBIT64);
  180a33:	89 c8                	mov    %ecx,%eax
  180a35:	c1 e9 1f             	shr    $0x1f,%ecx


	if (exp == 0x7ff) {
  180a38:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
  180a3e:	75 39                	jne    180a79 <_to_float+0x7b>
		if (!fract) {
  180a40:	09 ef                	or     %ebp,%edi
  180a42:	75 1d                	jne    180a61 <_to_float+0x63>
			*buf++ = sign ? '-' : '+';
  180a44:	85 c0                	test   %eax,%eax
  180a46:	79 04                	jns    180a4c <_to_float+0x4e>
  180a48:	b0 2d                	mov    $0x2d,%al
  180a4a:	eb 02                	jmp    180a4e <_to_float+0x50>
  180a4c:	b0 2b                	mov    $0x2b,%al
  180a4e:	88 06                	mov    %al,(%esi)
			*buf++ = 'I';
  180a50:	c6 46 01 49          	movb   $0x49,0x1(%esi)
			*buf++ = 'N';
  180a54:	c6 46 02 4e          	movb   $0x4e,0x2(%esi)
			*buf++ = 'F';
  180a58:	8d 46 04             	lea    0x4(%esi),%eax
  180a5b:	c6 46 03 46          	movb   $0x46,0x3(%esi)
  180a5f:	eb 0e                	jmp    180a6f <_to_float+0x71>
		} else {
			*buf++ = 'N';
  180a61:	c6 06 4e             	movb   $0x4e,(%esi)
			*buf++ = 'a';
  180a64:	c6 46 01 61          	movb   $0x61,0x1(%esi)
			*buf++ = 'N';
  180a68:	8d 46 03             	lea    0x3(%esi),%eax
  180a6b:	c6 46 02 4e          	movb   $0x4e,0x2(%esi)
		}
		*buf = 0;
  180a6f:	c6 00 00             	movb   $0x0,(%eax)
		return buf - start;
  180a72:	29 f0                	sub    %esi,%eax
  180a74:	e9 ce 03 00 00       	jmp    180e47 <_to_float+0x449>
	}

	if ((exp | fract) != 0) {
  180a79:	89 da                	mov    %ebx,%edx
  180a7b:	c1 fa 1f             	sar    $0x1f,%edx
  180a7e:	89 1c 24             	mov    %ebx,(%esp)
  180a81:	89 54 24 04          	mov    %edx,0x4(%esp)
  180a85:	89 d8                	mov    %ebx,%eax
  180a87:	09 e8                	or     %ebp,%eax
  180a89:	8b 54 24 04          	mov    0x4(%esp),%edx
  180a8d:	09 fa                	or     %edi,%edx
  180a8f:	09 c2                	or     %eax,%edx
  180a91:	74 1b                	je     180aae <_to_float+0xb0>
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
  180a93:	81 eb fe 03 00 00    	sub    $0x3fe,%ebx
		fract |= HIGHBIT64;
  180a99:	89 6c 24 18          	mov    %ebp,0x18(%esp)
  180a9d:	81 cf 00 00 00 80    	or     $0x80000000,%edi
  180aa3:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
		decexp = true;		/* Wasn't zero */
  180aa7:	b8 01 00 00 00       	mov    $0x1,%eax
  180aac:	eb 05                	jmp    180ab3 <_to_float+0xb5>
	} else
		decexp = false;		/* It was zero */
  180aae:	b8 00 00 00 00       	mov    $0x0,%eax

	if (decexp && sign) {
  180ab3:	84 c8                	test   %cl,%al
  180ab5:	74 0b                	je     180ac2 <_to_float+0xc4>
		*buf++ = '-';
  180ab7:	8d 46 01             	lea    0x1(%esi),%eax
  180aba:	89 04 24             	mov    %eax,(%esp)
  180abd:	c6 06 2d             	movb   $0x2d,(%esi)
  180ac0:	eb 27                	jmp    180ae9 <_to_float+0xeb>
	} else if (fplus) {
  180ac2:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
  180ac7:	74 0b                	je     180ad4 <_to_float+0xd6>
		*buf++ = '+';
  180ac9:	8d 46 01             	lea    0x1(%esi),%eax
  180acc:	89 04 24             	mov    %eax,(%esp)
  180acf:	c6 06 2b             	movb   $0x2b,(%esi)
  180ad2:	eb 15                	jmp    180ae9 <_to_float+0xeb>
	} else if (fspace) {
  180ad4:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  180ad9:	74 0b                	je     180ae6 <_to_float+0xe8>
		*buf++ = ' ';
  180adb:	8d 46 01             	lea    0x1(%esi),%eax
  180ade:	89 04 24             	mov    %eax,(%esp)
  180ae1:	c6 06 20             	movb   $0x20,(%esi)
  180ae4:	eb 03                	jmp    180ae9 <_to_float+0xeb>
  180ae6:	89 34 24             	mov    %esi,(%esp)
  180ae9:	89 74 24 0c          	mov    %esi,0xc(%esp)
	}

	decexp = 0;
  180aed:	bd 00 00 00 00       	mov    $0x0,%ebp
	while (exp <= -3) {
  180af2:	eb 54                	jmp    180b48 <_to_float+0x14a>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
			_rlrshift(&fract);
  180af4:	8d 44 24 18          	lea    0x18(%esp),%eax
  180af8:	e8 e5 fd ff ff       	call   1808e2 <_rlrshift>
			exp++;
  180afd:	43                   	inc    %ebx
		*buf++ = ' ';
	}

	decexp = 0;
	while (exp <= -3) {
		while ((fract >> 32) >= (MAXFP1 / 5)) {
  180afe:	8b 44 24 18          	mov    0x18(%esp),%eax
  180b02:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  180b06:	81 fa 32 33 33 33    	cmp    $0x33333332,%edx
  180b0c:	77 e6                	ja     180af4 <_to_float+0xf6>
			_rlrshift(&fract);
			exp++;
		}
		fract *= 5;
  180b0e:	89 c6                	mov    %eax,%esi
  180b10:	89 d7                	mov    %edx,%edi
  180b12:	0f a4 c7 02          	shld   $0x2,%eax,%edi
  180b16:	c1 e6 02             	shl    $0x2,%esi
  180b19:	01 f0                	add    %esi,%eax
  180b1b:	11 fa                	adc    %edi,%edx
  180b1d:	89 44 24 18          	mov    %eax,0x18(%esp)
  180b21:	89 54 24 1c          	mov    %edx,0x1c(%esp)
		exp++;
  180b25:	43                   	inc    %ebx
		decexp--;
  180b26:	4d                   	dec    %ebp

		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180b27:	eb 0f                	jmp    180b38 <_to_float+0x13a>
			fract <<= 1;
  180b29:	0f a4 c2 01          	shld   $0x1,%eax,%edx
  180b2d:	01 c0                	add    %eax,%eax
  180b2f:	89 44 24 18          	mov    %eax,0x18(%esp)
  180b33:	89 54 24 1c          	mov    %edx,0x1c(%esp)
			exp--;
  180b37:	4b                   	dec    %ebx
		}
		fract *= 5;
		exp++;
		decexp--;

		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180b38:	8b 44 24 18          	mov    0x18(%esp),%eax
  180b3c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  180b40:	81 fa ff ff ff 7f    	cmp    $0x7fffffff,%edx
  180b46:	76 e1                	jbe    180b29 <_to_float+0x12b>
	} else if (fspace) {
		*buf++ = ' ';
	}

	decexp = 0;
	while (exp <= -3) {
  180b48:	83 fb fe             	cmp    $0xfffffffe,%ebx
  180b4b:	7c b1                	jl     180afe <_to_float+0x100>
  180b4d:	eb 2c                	jmp    180b7b <_to_float+0x17d>
			exp--;
		}
	}

	while (exp > 0) {
		_ldiv5(&fract);
  180b4f:	8d 44 24 18          	lea    0x18(%esp),%eax
  180b53:	e8 af fd ff ff       	call   180907 <_ldiv5>
		exp--;
  180b58:	4b                   	dec    %ebx
		decexp++;
  180b59:	45                   	inc    %ebp
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180b5a:	eb 0f                	jmp    180b6b <_to_float+0x16d>
			fract <<= 1;
  180b5c:	0f a4 c2 01          	shld   $0x1,%eax,%edx
  180b60:	01 c0                	add    %eax,%eax
  180b62:	89 44 24 18          	mov    %eax,0x18(%esp)
  180b66:	89 54 24 1c          	mov    %edx,0x1c(%esp)
			exp--;
  180b6a:	4b                   	dec    %ebx

	while (exp > 0) {
		_ldiv5(&fract);
		exp--;
		decexp++;
		while ((fract >> 32) <= (MAXFP1 / 2)) {
  180b6b:	8b 44 24 18          	mov    0x18(%esp),%eax
  180b6f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  180b73:	81 fa ff ff ff 7f    	cmp    $0x7fffffff,%edx
  180b79:	76 e1                	jbe    180b5c <_to_float+0x15e>
			fract <<= 1;
			exp--;
		}
	}

	while (exp > 0) {
  180b7b:	85 db                	test   %ebx,%ebx
  180b7d:	7f d0                	jg     180b4f <_to_float+0x151>
  180b7f:	eb 0a                	jmp    180b8b <_to_float+0x18d>
			exp--;
		}
	}

	while (exp < (0 + 4)) {
		_rlrshift(&fract);
  180b81:	8d 44 24 18          	lea    0x18(%esp),%eax
  180b85:	e8 58 fd ff ff       	call   1808e2 <_rlrshift>
		exp++;
  180b8a:	43                   	inc    %ebx
			fract <<= 1;
			exp--;
		}
	}

	while (exp < (0 + 4)) {
  180b8b:	83 fb 03             	cmp    $0x3,%ebx
  180b8e:	7e f1                	jle    180b81 <_to_float+0x183>
		_rlrshift(&fract);
		exp++;
	}

	if (precision < 0)
  180b90:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  180b95:	79 08                	jns    180b9f <_to_float+0x1a1>
		precision = 6;		/* Default precision if none given */
  180b97:	c7 44 24 48 06 00 00 	movl   $0x6,0x48(%esp)
  180b9e:	00 
	prune_zero = false;		/* Assume trailing 0's allowed     */
	if ((c == 'g') || (c == 'G')) {
  180b9f:	83 7c 24 38 67       	cmpl   $0x67,0x38(%esp)
  180ba4:	0f 94 c2             	sete   %dl
  180ba7:	83 7c 24 38 47       	cmpl   $0x47,0x38(%esp)
  180bac:	0f 94 c0             	sete   %al
  180baf:	08 c2                	or     %al,%dl
  180bb1:	74 45                	je     180bf8 <_to_float+0x1fa>
		if (!falt && (precision > 0))
  180bb3:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  180bb8:	0f 94 c2             	sete   %dl
  180bbb:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  180bc0:	0f 9f c0             	setg   %al
  180bc3:	84 c2                	test   %al,%dl
  180bc5:	75 0a                	jne    180bd1 <_to_float+0x1d3>
		exp++;
	}

	if (precision < 0)
		precision = 6;		/* Default precision if none given */
	prune_zero = false;		/* Assume trailing 0's allowed     */
  180bc7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180bce:	00 
  180bcf:	eb 08                	jmp    180bd9 <_to_float+0x1db>
	if ((c == 'g') || (c == 'G')) {
		if (!falt && (precision > 0))
			prune_zero = true;
  180bd1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  180bd8:	00 
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
  180bd9:	83 fd fd             	cmp    $0xfffffffd,%ebp
  180bdc:	7c 09                	jl     180be7 <_to_float+0x1e9>
  180bde:	8b 44 24 48          	mov    0x48(%esp),%eax
  180be2:	40                   	inc    %eax
  180be3:	39 c5                	cmp    %eax,%ebp
  180be5:	7e 1b                	jle    180c02 <_to_float+0x204>
			if (c == 'g')
  180be7:	83 7c 24 38 67       	cmpl   $0x67,0x38(%esp)
  180bec:	75 1e                	jne    180c0c <_to_float+0x20e>
				c = 'e';
  180bee:	c7 44 24 38 65 00 00 	movl   $0x65,0x38(%esp)
  180bf5:	00 
  180bf6:	eb 1c                	jmp    180c14 <_to_float+0x216>
		exp++;
	}

	if (precision < 0)
		precision = 6;		/* Default precision if none given */
	prune_zero = false;		/* Assume trailing 0's allowed     */
  180bf8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  180bff:	00 
  180c00:	eb 12                	jmp    180c14 <_to_float+0x216>
			if (c == 'g')
				c = 'e';
			else
				c = 'E';
		} else
			c = 'f';
  180c02:	c7 44 24 38 66 00 00 	movl   $0x66,0x38(%esp)
  180c09:	00 
  180c0a:	eb 08                	jmp    180c14 <_to_float+0x216>
			prune_zero = true;
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
			if (c == 'g')
				c = 'e';
			else
				c = 'E';
  180c0c:	c7 44 24 38 45 00 00 	movl   $0x45,0x38(%esp)
  180c13:	00 
		} else
			c = 'f';
	}

	if (c == 'f') {
  180c14:	83 7c 24 38 66       	cmpl   $0x66,0x38(%esp)
  180c19:	75 0a                	jne    180c25 <_to_float+0x227>
		exp = precision + decexp;
		if (exp < 0)
  180c1b:	89 e8                	mov    %ebp,%eax
  180c1d:	03 44 24 48          	add    0x48(%esp),%eax
  180c21:	79 0e                	jns    180c31 <_to_float+0x233>
  180c23:	eb 07                	jmp    180c2c <_to_float+0x22e>
			exp = 0;
	} else
		exp = precision + 1;
  180c25:	8b 44 24 48          	mov    0x48(%esp),%eax
  180c29:	40                   	inc    %eax
  180c2a:	eb 05                	jmp    180c31 <_to_float+0x233>
	}

	if (c == 'f') {
		exp = precision + decexp;
		if (exp < 0)
			exp = 0;
  180c2c:	b8 00 00 00 00       	mov    $0x0,%eax
	} else
		exp = precision + 1;
	digit_count = 16;
  180c31:	c7 44 24 20 10 00 00 	movl   $0x10,0x20(%esp)
  180c38:	00 
	if (exp > 16)
  180c39:	83 f8 10             	cmp    $0x10,%eax
  180c3c:	7e 05                	jle    180c43 <_to_float+0x245>
		exp = 16;
  180c3e:	b8 10 00 00 00       	mov    $0x10,%eax

	ltemp = 0x0800000000000000;
  180c43:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  180c4a:	00 
  180c4b:	c7 44 24 14 00 00 00 	movl   $0x8000000,0x14(%esp)
  180c52:	08 
	while (exp--) {
  180c53:	eb 14                	jmp    180c69 <_to_float+0x26b>
		_ldiv5(&ltemp);
  180c55:	8d 44 24 10          	lea    0x10(%esp),%eax
  180c59:	e8 a9 fc ff ff       	call   180907 <_ldiv5>
		_rlrshift(&ltemp);
  180c5e:	8d 44 24 10          	lea    0x10(%esp),%eax
  180c62:	e8 7b fc ff ff       	call   1808e2 <_rlrshift>
	digit_count = 16;
	if (exp > 16)
		exp = 16;

	ltemp = 0x0800000000000000;
	while (exp--) {
  180c67:	89 d8                	mov    %ebx,%eax
  180c69:	8d 58 ff             	lea    -0x1(%eax),%ebx
  180c6c:	85 c0                	test   %eax,%eax
  180c6e:	75 e5                	jne    180c55 <_to_float+0x257>
		_ldiv5(&ltemp);
		_rlrshift(&ltemp);
	}

	fract += ltemp;
  180c70:	8b 44 24 10          	mov    0x10(%esp),%eax
  180c74:	8b 54 24 14          	mov    0x14(%esp),%edx
  180c78:	03 44 24 18          	add    0x18(%esp),%eax
  180c7c:	13 54 24 1c          	adc    0x1c(%esp),%edx
  180c80:	89 44 24 18          	mov    %eax,0x18(%esp)
  180c84:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	if ((fract >> 32) & 0xF0000000) {
  180c88:	89 d0                	mov    %edx,%eax
  180c8a:	a9 00 00 00 f0       	test   $0xf0000000,%eax
  180c8f:	74 13                	je     180ca4 <_to_float+0x2a6>
		_ldiv5(&fract);
  180c91:	8d 44 24 18          	lea    0x18(%esp),%eax
  180c95:	e8 6d fc ff ff       	call   180907 <_ldiv5>
		_rlrshift(&fract);
  180c9a:	8d 44 24 18          	lea    0x18(%esp),%eax
  180c9e:	e8 3f fc ff ff       	call   1808e2 <_rlrshift>
		decexp++;
  180ca3:	45                   	inc    %ebp
	}

	if (c == 'f') {
  180ca4:	83 7c 24 38 66       	cmpl   $0x66,0x38(%esp)
  180ca9:	0f 85 8a 00 00 00    	jne    180d39 <_to_float+0x33b>
		if (decexp > 0) {
  180caf:	85 ed                	test   %ebp,%ebp
  180cb1:	7f 19                	jg     180ccc <_to_float+0x2ce>
  180cb3:	eb 23                	jmp    180cd8 <_to_float+0x2da>
			while (decexp > 0) {
				*buf++ = _get_digit(&fract, &digit_count);
  180cb5:	8d 73 01             	lea    0x1(%ebx),%esi
  180cb8:	8d 54 24 20          	lea    0x20(%esp),%edx
  180cbc:	8d 44 24 18          	lea    0x18(%esp),%eax
  180cc0:	e8 ec fc ff ff       	call   1809b1 <_get_digit>
  180cc5:	88 03                	mov    %al,(%ebx)
				decexp--;
  180cc7:	4d                   	dec    %ebp
	}

	if (c == 'f') {
		if (decexp > 0) {
			while (decexp > 0) {
				*buf++ = _get_digit(&fract, &digit_count);
  180cc8:	89 f3                	mov    %esi,%ebx
  180cca:	eb 03                	jmp    180ccf <_to_float+0x2d1>
  180ccc:	8b 1c 24             	mov    (%esp),%ebx
		decexp++;
	}

	if (c == 'f') {
		if (decexp > 0) {
			while (decexp > 0) {
  180ccf:	85 ed                	test   %ebp,%ebp
  180cd1:	7f e2                	jg     180cb5 <_to_float+0x2b7>
  180cd3:	89 1c 24             	mov    %ebx,(%esp)
  180cd6:	eb 0c                	jmp    180ce4 <_to_float+0x2e6>
				*buf++ = _get_digit(&fract, &digit_count);
				decexp--;
			}
		} else
			*buf++ = '0';
  180cd8:	8b 04 24             	mov    (%esp),%eax
  180cdb:	c6 00 30             	movb   $0x30,(%eax)
  180cde:	8d 40 01             	lea    0x1(%eax),%eax
  180ce1:	89 04 24             	mov    %eax,(%esp)
		if (falt || (precision > 0))
  180ce4:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  180ce9:	0f 95 c2             	setne  %dl
  180cec:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  180cf1:	0f 9f c0             	setg   %al
  180cf4:	08 c2                	or     %al,%dl
  180cf6:	74 0c                	je     180d04 <_to_float+0x306>
			*buf++ = '.';
  180cf8:	8b 04 24             	mov    (%esp),%eax
  180cfb:	c6 00 2e             	movb   $0x2e,(%eax)
  180cfe:	8d 40 01             	lea    0x1(%eax),%eax
  180d01:	89 04 24             	mov    %eax,(%esp)
		while (precision-- > 0) {
			if (decexp < 0) {
				*buf++ = '0';
  180d04:	8b 1c 24             	mov    (%esp),%ebx
  180d07:	8b 44 24 48          	mov    0x48(%esp),%eax
  180d0b:	eb 23                	jmp    180d30 <_to_float+0x332>
		} else
			*buf++ = '0';
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0) {
			if (decexp < 0) {
  180d0d:	85 ed                	test   %ebp,%ebp
  180d0f:	79 09                	jns    180d1a <_to_float+0x31c>
				*buf++ = '0';
  180d11:	c6 03 30             	movb   $0x30,(%ebx)
				decexp++;
  180d14:	45                   	inc    %ebp
			*buf++ = '0';
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0) {
			if (decexp < 0) {
				*buf++ = '0';
  180d15:	8d 5b 01             	lea    0x1(%ebx),%ebx
  180d18:	eb 14                	jmp    180d2e <_to_float+0x330>
				decexp++;
			} else
				*buf++ = _get_digit(&fract, &digit_count);
  180d1a:	8d 7b 01             	lea    0x1(%ebx),%edi
  180d1d:	8d 54 24 20          	lea    0x20(%esp),%edx
  180d21:	8d 44 24 18          	lea    0x18(%esp),%eax
  180d25:	e8 87 fc ff ff       	call   1809b1 <_get_digit>
  180d2a:	88 03                	mov    %al,(%ebx)
  180d2c:	89 fb                	mov    %edi,%ebx
  180d2e:	89 f0                	mov    %esi,%eax
			}
		} else
			*buf++ = '0';
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0) {
  180d30:	8d 70 ff             	lea    -0x1(%eax),%esi
  180d33:	85 c0                	test   %eax,%eax
  180d35:	7f d6                	jg     180d0d <_to_float+0x30f>
  180d37:	eb 61                	jmp    180d9a <_to_float+0x39c>
				decexp++;
			} else
				*buf++ = _get_digit(&fract, &digit_count);
		}
	} else {
		*buf = _get_digit(&fract, &digit_count);
  180d39:	8d 54 24 20          	lea    0x20(%esp),%edx
  180d3d:	8d 44 24 18          	lea    0x18(%esp),%eax
  180d41:	e8 6b fc ff ff       	call   1809b1 <_get_digit>
  180d46:	8b 3c 24             	mov    (%esp),%edi
  180d49:	88 07                	mov    %al,(%edi)
		if (*buf++ != '0')
  180d4b:	8d 5f 01             	lea    0x1(%edi),%ebx
  180d4e:	3c 30                	cmp    $0x30,%al
  180d50:	74 01                	je     180d53 <_to_float+0x355>
			decexp--;
  180d52:	4d                   	dec    %ebp
		if (falt || (precision > 0))
  180d53:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
  180d58:	0f 95 c2             	setne  %dl
  180d5b:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
  180d60:	0f 9f c0             	setg   %al
  180d63:	08 c2                	or     %al,%dl
  180d65:	74 28                	je     180d8f <_to_float+0x391>
			*buf++ = '.';
  180d67:	8b 04 24             	mov    (%esp),%eax
  180d6a:	8d 58 02             	lea    0x2(%eax),%ebx
  180d6d:	c6 40 01 2e          	movb   $0x2e,0x1(%eax)
  180d71:	8b 44 24 48          	mov    0x48(%esp),%eax
  180d75:	eb 1c                	jmp    180d93 <_to_float+0x395>
		while (precision-- > 0)
			*buf++ = _get_digit(&fract, &digit_count);
  180d77:	8d 7b 01             	lea    0x1(%ebx),%edi
  180d7a:	8d 54 24 20          	lea    0x20(%esp),%edx
  180d7e:	8d 44 24 18          	lea    0x18(%esp),%eax
  180d82:	e8 2a fc ff ff       	call   1809b1 <_get_digit>
  180d87:	88 03                	mov    %al,(%ebx)
		*buf = _get_digit(&fract, &digit_count);
		if (*buf++ != '0')
			decexp--;
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0)
  180d89:	89 f0                	mov    %esi,%eax
			*buf++ = _get_digit(&fract, &digit_count);
  180d8b:	89 fb                	mov    %edi,%ebx
  180d8d:	eb 04                	jmp    180d93 <_to_float+0x395>
  180d8f:	8b 44 24 48          	mov    0x48(%esp),%eax
		*buf = _get_digit(&fract, &digit_count);
		if (*buf++ != '0')
			decexp--;
		if (falt || (precision > 0))
			*buf++ = '.';
		while (precision-- > 0)
  180d93:	8d 70 ff             	lea    -0x1(%eax),%esi
  180d96:	85 c0                	test   %eax,%eax
  180d98:	7f dd                	jg     180d77 <_to_float+0x379>
			*buf++ = _get_digit(&fract, &digit_count);
	}

	if (prune_zero) {
  180d9a:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  180d9f:	74 14                	je     180db5 <_to_float+0x3b7>
  180da1:	eb 02                	jmp    180da5 <_to_float+0x3a7>
		while (*--buf == '0')
  180da3:	89 d3                	mov    %edx,%ebx
  180da5:	8d 53 ff             	lea    -0x1(%ebx),%edx
  180da8:	8a 43 ff             	mov    -0x1(%ebx),%al
  180dab:	3c 30                	cmp    $0x30,%al
  180dad:	74 f4                	je     180da3 <_to_float+0x3a5>
			;
		if (*buf != '.')
  180daf:	3c 2e                	cmp    $0x2e,%al
  180db1:	75 02                	jne    180db5 <_to_float+0x3b7>
		while (precision-- > 0)
			*buf++ = _get_digit(&fract, &digit_count);
	}

	if (prune_zero) {
		while (*--buf == '0')
  180db3:	89 d3                	mov    %edx,%ebx
			;
		if (*buf != '.')
			buf++;
	}

	if ((c == 'e') || (c == 'E')) {
  180db5:	83 7c 24 38 65       	cmpl   $0x65,0x38(%esp)
  180dba:	0f 94 c2             	sete   %dl
  180dbd:	83 7c 24 38 45       	cmpl   $0x45,0x38(%esp)
  180dc2:	0f 94 c0             	sete   %al
  180dc5:	08 c2                	or     %al,%dl
  180dc7:	74 75                	je     180e3e <_to_float+0x440>
		*buf++ = (char) c;
  180dc9:	8a 44 24 38          	mov    0x38(%esp),%al
  180dcd:	88 03                	mov    %al,(%ebx)
		if (decexp < 0) {
  180dcf:	85 ed                	test   %ebp,%ebp
  180dd1:	79 0b                	jns    180dde <_to_float+0x3e0>
			decexp = -decexp;
  180dd3:	f7 dd                	neg    %ebp
			*buf++ = '-';
  180dd5:	8d 4b 02             	lea    0x2(%ebx),%ecx
  180dd8:	c6 43 01 2d          	movb   $0x2d,0x1(%ebx)
  180ddc:	eb 07                	jmp    180de5 <_to_float+0x3e7>
		} else
			*buf++ = '+';
  180dde:	8d 4b 02             	lea    0x2(%ebx),%ecx
  180de1:	c6 43 01 2b          	movb   $0x2b,0x1(%ebx)
		*buf++ = (char) ((decexp / 100) + '0');
  180de5:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
  180dea:	89 e8                	mov    %ebp,%eax
  180dec:	f7 ea                	imul   %edx
  180dee:	89 d0                	mov    %edx,%eax
  180df0:	c1 f8 05             	sar    $0x5,%eax
  180df3:	89 ea                	mov    %ebp,%edx
  180df5:	c1 fa 1f             	sar    $0x1f,%edx
  180df8:	29 d0                	sub    %edx,%eax
  180dfa:	8d 50 30             	lea    0x30(%eax),%edx
  180dfd:	88 11                	mov    %dl,(%ecx)
		decexp %= 100;
  180dff:	8d 04 80             	lea    (%eax,%eax,4),%eax
  180e02:	8d 14 80             	lea    (%eax,%eax,4),%edx
  180e05:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
  180e0c:	89 eb                	mov    %ebp,%ebx
  180e0e:	29 c3                	sub    %eax,%ebx
		*buf++ = (char) ((decexp / 10) + '0');
  180e10:	ba 67 66 66 66       	mov    $0x66666667,%edx
  180e15:	89 d8                	mov    %ebx,%eax
  180e17:	f7 ea                	imul   %edx
  180e19:	89 d0                	mov    %edx,%eax
  180e1b:	c1 f8 02             	sar    $0x2,%eax
  180e1e:	89 da                	mov    %ebx,%edx
  180e20:	c1 fa 1f             	sar    $0x1f,%edx
  180e23:	29 d0                	sub    %edx,%eax
  180e25:	8d 50 30             	lea    0x30(%eax),%edx
  180e28:	88 51 01             	mov    %dl,0x1(%ecx)
		decexp %= 10;
  180e2b:	8d 14 80             	lea    (%eax,%eax,4),%edx
  180e2e:	8d 04 12             	lea    (%edx,%edx,1),%eax
  180e31:	89 da                	mov    %ebx,%edx
  180e33:	29 c2                	sub    %eax,%edx
		*buf++ = (char) (decexp + '0');
  180e35:	8d 59 03             	lea    0x3(%ecx),%ebx
  180e38:	83 c2 30             	add    $0x30,%edx
  180e3b:	88 51 02             	mov    %dl,0x2(%ecx)
	}
	*buf = 0;
  180e3e:	c6 03 00             	movb   $0x0,(%ebx)

	return buf - start;
  180e41:	89 d8                	mov    %ebx,%eax
  180e43:	2b 44 24 0c          	sub    0xc(%esp),%eax
}
  180e47:	83 c4 24             	add    $0x24,%esp
  180e4a:	5b                   	pop    %ebx
  180e4b:	5e                   	pop    %esi
  180e4c:	5f                   	pop    %edi
  180e4d:	5d                   	pop    %ebp
  180e4e:	c3                   	ret    

00180e4f <_atoi>:

static int _atoi(char **sptr)
{
  180e4f:	56                   	push   %esi
  180e50:	53                   	push   %ebx
	register char *p;
	register int   i;

	i = 0;
	p = *sptr;
	p--;
  180e51:	8b 18                	mov    (%eax),%ebx
  180e53:	4b                   	dec    %ebx
static int _atoi(char **sptr)
{
	register char *p;
	register int   i;

	i = 0;
  180e54:	be 00 00 00 00       	mov    $0x0,%esi
	p = *sptr;
	p--;
	while (isdigit(((int) *p)))
  180e59:	eb 0e                	jmp    180e69 <_atoi+0x1a>
		i = 10 * i + *p++ - '0';
  180e5b:	8d 34 b6             	lea    (%esi,%esi,4),%esi
  180e5e:	8d 0c 36             	lea    (%esi,%esi,1),%ecx
  180e61:	43                   	inc    %ebx
  180e62:	0f be d2             	movsbl %dl,%edx
  180e65:	8d 74 11 d0          	lea    -0x30(%ecx,%edx,1),%esi
	register int   i;

	i = 0;
	p = *sptr;
	p--;
	while (isdigit(((int) *p)))
  180e69:	8a 13                	mov    (%ebx),%dl
	return ((((unsigned)c) >= ' ') && (((unsigned)c) <= '~'));
}

static inline int isdigit(int a)
{
	return (((unsigned)(a)-'0') < 10);
  180e6b:	0f be ca             	movsbl %dl,%ecx
  180e6e:	83 e9 30             	sub    $0x30,%ecx
  180e71:	83 f9 09             	cmp    $0x9,%ecx
  180e74:	76 e5                	jbe    180e5b <_atoi+0xc>
		i = 10 * i + *p++ - '0';
	*sptr = p;
  180e76:	89 18                	mov    %ebx,(%eax)
	return i;
}
  180e78:	89 f0                	mov    %esi,%eax
  180e7a:	5b                   	pop    %ebx
  180e7b:	5e                   	pop    %esi
  180e7c:	c3                   	ret    

00180e7d <_prf>:

int _prf(int (*func)(), void *dest, char *format, va_list vargs)
{
  180e7d:	55                   	push   %ebp
  180e7e:	57                   	push   %edi
  180e7f:	56                   	push   %esi
  180e80:	53                   	push   %ebx
  180e81:	81 ec f0 00 00 00    	sub    $0xf0,%esp
  180e87:	89 c5                	mov    %eax,%ebp
  180e89:	89 14 24             	mov    %edx,(%esp)
  180e8c:	89 4c 24 20          	mov    %ecx,0x20(%esp)
	int32_t			*int32ptr_temp;
	int32_t			int32_temp;
	uint32_t			uint32_temp;
	uint64_t			double_temp;

	count = 0;
  180e90:	bf 00 00 00 00       	mov    $0x0,%edi

	while ((c = *format++)) {
  180e95:	e9 e0 05 00 00       	jmp    18147a <_prf+0x5fd>
		if (c != '%') {
  180e9a:	83 f8 25             	cmp    $0x25,%eax
  180e9d:	74 52                	je     180ef1 <_prf+0x74>
			if ((*func) (c, dest) == EOF) {
  180e9f:	8b 14 24             	mov    (%esp),%edx
  180ea2:	ff d5                	call   *%ebp
  180ea4:	83 f8 ff             	cmp    $0xffffffff,%eax
  180ea7:	0f 84 f4 05 00 00    	je     1814a1 <_prf+0x624>
				return EOF;
			}

			count++;
  180ead:	47                   	inc    %edi
  180eae:	e9 c7 05 00 00       	jmp    18147a <_prf+0x5fd>
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
  180eb3:	80 fb 30             	cmp    $0x30,%bl
  180eb6:	77 5e                	ja     180f16 <_prf+0x99>
  180eb8:	0f b6 db             	movzbl %bl,%ebx
  180ebb:	ff 24 9d 6c 2e 18 00 	jmp    *0x182e6c(,%ebx,4)
				case '-':
					fminus = true;
					break;

				case '+':
					fplus = true;
  180ec2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  180ec9:	00 
					break;
  180eca:	eb 4a                	jmp    180f16 <_prf+0x99>

				case ' ':
					fspace = true;
  180ecc:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  180ed3:	00 
					break;
  180ed4:	eb 40                	jmp    180f16 <_prf+0x99>

				case '#':
					falt = true;
  180ed6:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  180edd:	00 
					break;
  180ede:	eb 36                	jmp    180f16 <_prf+0x99>

				case '0':
					pad = '0';
  180ee0:	c6 44 24 0b 30       	movb   $0x30,0xb(%esp)
					break;
  180ee5:	eb 2f                	jmp    180f16 <_prf+0x99>
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
				case '-':
					fminus = true;
  180ee7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  180eee:	00 
  180eef:	eb 25                	jmp    180f16 <_prf+0x99>
  180ef1:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
  180ef6:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  180efd:	00 
  180efe:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  180f05:	00 
  180f06:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  180f0d:	00 
  180f0e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  180f15:	00 
		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
  180f16:	8b 44 24 20          	mov    0x20(%esp),%eax
  180f1a:	8d 50 01             	lea    0x1(%eax),%edx
  180f1d:	89 54 24 20          	mov    %edx,0x20(%esp)
  180f21:	8a 18                	mov    (%eax),%bl
  180f23:	0f be f3             	movsbl %bl,%esi
  180f26:	89 f2                	mov    %esi,%edx
  180f28:	b8 60 2e 18 00       	mov    $0x182e60,%eax
  180f2d:	e8 92 05 00 00       	call   1814c4 <strchr>
  180f32:	85 c0                	test   %eax,%eax
  180f34:	0f 85 79 ff ff ff    	jne    180eb3 <_prf+0x36>
				case '\0':
					return count;
				}
			}

			if (c == '*') {
  180f3a:	83 fe 2a             	cmp    $0x2a,%esi
  180f3d:	75 37                	jne    180f76 <_prf+0xf9>
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
  180f3f:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  180f46:	8d 50 04             	lea    0x4(%eax),%edx
  180f49:	8b 00                	mov    (%eax),%eax
  180f4b:	89 44 24 18          	mov    %eax,0x18(%esp)
				if (width < 0) {
  180f4f:	85 c0                	test   %eax,%eax
  180f51:	79 0c                	jns    180f5f <_prf+0xe2>
					fminus = true;
					width = -width;
  180f53:	f7 5c 24 18          	negl   0x18(%esp)

			if (c == '*') {
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
				if (width < 0) {
					fminus = true;
  180f57:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  180f5e:	00 
					width = -width;
				}
				c = *format++;
  180f5f:	8b 44 24 20          	mov    0x20(%esp),%eax
  180f63:	8d 48 01             	lea    0x1(%eax),%ecx
  180f66:	89 4c 24 20          	mov    %ecx,0x20(%esp)
  180f6a:	0f be 30             	movsbl (%eax),%esi
				}
			}

			if (c == '*') {
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
  180f6d:	89 94 24 04 01 00 00 	mov    %edx,0x104(%esp)
  180f74:	eb 30                	jmp    180fa6 <_prf+0x129>
  180f76:	0f be db             	movsbl %bl,%ebx
  180f79:	83 eb 30             	sub    $0x30,%ebx
				if (width < 0) {
					fminus = true;
					width = -width;
				}
				c = *format++;
			} else if (!isdigit(c))
  180f7c:	83 fb 09             	cmp    $0x9,%ebx
  180f7f:	77 1d                	ja     180f9e <_prf+0x121>
				width = 0;
			else {
				width = _atoi(&format);	/* Find width */
  180f81:	8d 44 24 20          	lea    0x20(%esp),%eax
  180f85:	e8 c5 fe ff ff       	call   180e4f <_atoi>
  180f8a:	89 44 24 18          	mov    %eax,0x18(%esp)
				c = *format++;
  180f8e:	8b 44 24 20          	mov    0x20(%esp),%eax
  180f92:	8d 50 01             	lea    0x1(%eax),%edx
  180f95:	89 54 24 20          	mov    %edx,0x20(%esp)
  180f99:	0f be 30             	movsbl (%eax),%esi
  180f9c:	eb 08                	jmp    180fa6 <_prf+0x129>
					fminus = true;
					width = -width;
				}
				c = *format++;
			} else if (!isdigit(c))
				width = 0;
  180f9e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  180fa5:	00 
			 * If <width> is INT_MIN, then its absolute value can
			 * not be expressed as a positive number using 32-bit
			 * two's complement.  To cover that case, cast it to
			 * an unsigned before comparing it against MAXFLD.
			 */
			if ((unsigned) width > MAXFLD) {
  180fa6:	81 7c 24 18 c8 00 00 	cmpl   $0xc8,0x18(%esp)
  180fad:	00 
  180fae:	76 08                	jbe    180fb8 <_prf+0x13b>
				width = MAXFLD;
  180fb0:	c7 44 24 18 c8 00 00 	movl   $0xc8,0x18(%esp)
  180fb7:	00 
			}

			if (c == '.') {
  180fb8:	83 fe 2e             	cmp    $0x2e,%esi
  180fbb:	75 5f                	jne    18101c <_prf+0x19f>
				c = *format++;
  180fbd:	8b 44 24 20          	mov    0x20(%esp),%eax
  180fc1:	8d 50 01             	lea    0x1(%eax),%edx
  180fc4:	89 54 24 20          	mov    %edx,0x20(%esp)
				if (c == '*') {
  180fc8:	80 38 2a             	cmpb   $0x2a,(%eax)
  180fcb:	75 20                	jne    180fed <_prf+0x170>
					precision = (int32_t)
  180fcd:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  180fd4:	8b 00                	mov    (%eax),%eax
  180fd6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  180fda:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  180fe1:	8d 40 04             	lea    0x4(%eax),%eax
  180fe4:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
  180feb:	eb 0d                	jmp    180ffa <_prf+0x17d>
					va_arg(vargs, int32_t);
				} else
					precision = _atoi(&format);
  180fed:	8d 44 24 20          	lea    0x20(%esp),%eax
  180ff1:	e8 59 fe ff ff       	call   180e4f <_atoi>
  180ff6:	89 44 24 1c          	mov    %eax,0x1c(%esp)

				if (precision > MAXFLD)
  180ffa:	81 7c 24 1c c8 00 00 	cmpl   $0xc8,0x1c(%esp)
  181001:	00 
  181002:	7e 08                	jle    18100c <_prf+0x18f>
					precision = -1;
  181004:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp)
  18100b:	ff 
				c = *format++;
  18100c:	8b 44 24 20          	mov    0x20(%esp),%eax
  181010:	8d 50 01             	lea    0x1(%eax),%edx
  181013:	89 54 24 20          	mov    %edx,0x20(%esp)
  181017:	0f be 30             	movsbl (%eax),%esi
  18101a:	eb 08                	jmp    181024 <_prf+0x1a7>
			count++;

		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */
  18101c:	c7 44 24 1c ff ff ff 	movl   $0xffffffff,0x1c(%esp)
  181023:	ff 
			 *    L: long double
			 *    z: size_t or ssize_t
			 * No further special processing is done for them.
			 */

			if (strchr("hlLz", c) != NULL) {
  181024:	89 f2                	mov    %esi,%edx
  181026:	b8 66 2e 18 00       	mov    $0x182e66,%eax
  18102b:	e8 94 04 00 00       	call   1814c4 <strchr>
  181030:	85 c0                	test   %eax,%eax
  181032:	74 0e                	je     181042 <_prf+0x1c5>
				i = c;
				c = *format++;
  181034:	8b 44 24 20          	mov    0x20(%esp),%eax
  181038:	8d 50 01             	lea    0x1(%eax),%edx
  18103b:	89 54 24 20          	mov    %edx,0x20(%esp)
  18103f:	0f be 30             	movsbl (%eax),%esi
				 */
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
  181042:	83 fe 78             	cmp    $0x78,%esi
  181045:	0f 87 e3 02 00 00    	ja     18132e <_prf+0x4b1>
  18104b:	ff 24 b5 30 2f 18 00 	jmp    *0x182f30(,%esi,4)
			case 'c':
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
  181052:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181059:	8b 00                	mov    (%eax),%eax
  18105b:	88 44 24 27          	mov    %al,0x27(%esp)
				buf[1] = '\0';
  18105f:	c6 44 24 28 00       	movb   $0x0,0x28(%esp)

			need_justifying = false;
			prefix = 0;
			switch (c) {
			case 'c':
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
  181064:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18106b:	8d 40 04             	lea    0x4(%eax),%eax
  18106e:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181075:	bb 00 00 00 00       	mov    $0x0,%ebx
			switch (c) {
			case 'c':
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
				buf[1] = '\0';
				need_justifying = true;
  18107a:	b8 01 00 00 00       	mov    $0x1,%eax
				c = 1;
  18107f:	be 01 00 00 00       	mov    $0x1,%esi
				break;
  181084:	e9 67 03 00 00       	jmp    1813f0 <_prf+0x573>

			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
  181089:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181090:	83 c0 04             	add    $0x4,%eax
  181093:	89 44 24 14          	mov    %eax,0x14(%esp)
  181097:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18109e:	8b 18                	mov    (%eax),%ebx
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
  1810a0:	ff 74 24 1c          	pushl  0x1c(%esp)
  1810a4:	ff 74 24 14          	pushl  0x14(%esp)
  1810a8:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  1810ac:	89 da                	mov    %ebx,%edx
  1810ae:	8d 44 24 2f          	lea    0x2f(%esp),%eax
  1810b2:	e8 e2 f7 ff ff       	call   180899 <_to_dec>
  1810b7:	83 c4 08             	add    $0x8,%esp
  1810ba:	89 c6                	mov    %eax,%esi
				if (fplus || fspace || (int32_temp < 0))
  1810bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1810c0:	0b 44 24 10          	or     0x10(%esp),%eax
  1810c4:	75 0b                	jne    1810d1 <_prf+0x254>
  1810c6:	85 db                	test   %ebx,%ebx
  1810c8:	78 0e                	js     1810d8 <_prf+0x25b>
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1810ca:	bb 00 00 00 00       	mov    $0x0,%ebx
  1810cf:	eb 0c                	jmp    1810dd <_prf+0x260>
			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
  1810d1:	bb 01 00 00 00       	mov    $0x1,%ebx
  1810d6:	eb 05                	jmp    1810dd <_prf+0x260>
  1810d8:	bb 01 00 00 00       	mov    $0x1,%ebx
				need_justifying = true;
				if (precision != -1)
  1810dd:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1810e2:	0f 85 55 02 00 00    	jne    18133d <_prf+0x4c0>
				c = 1;
				break;

			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
  1810e8:	8b 44 24 14          	mov    0x14(%esp),%eax
  1810ec:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
				need_justifying = true;
  1810f3:	b8 01 00 00 00       	mov    $0x1,%eax
  1810f8:	e9 f3 02 00 00       	jmp    1813f0 <_prf+0x573>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  1810fd:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181104:	8d 58 08             	lea    0x8(%eax),%ebx
  181107:	8b 10                	mov    (%eax),%edx
  181109:	8b 48 04             	mov    0x4(%eax),%ecx
				double_temp = u.i;
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
  18110c:	ff 74 24 1c          	pushl  0x1c(%esp)
  181110:	ff 74 24 14          	pushl  0x14(%esp)
  181114:	ff 74 24 14          	pushl  0x14(%esp)
  181118:	ff 74 24 20          	pushl  0x20(%esp)
  18111c:	56                   	push   %esi
  18111d:	8d 44 24 3b          	lea    0x3b(%esp),%eax
  181121:	e8 d8 f8 ff ff       	call   1809fe <_to_float>
  181126:	83 c4 14             	add    $0x14,%esp
  181129:	89 c6                	mov    %eax,%esi
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
  18112b:	8b 44 24 0c          	mov    0xc(%esp),%eax
  18112f:	0b 44 24 10          	or     0x10(%esp),%eax
  181133:	0f 85 1e 02 00 00    	jne    181357 <_prf+0x4da>
  181139:	80 7c 24 27 2d       	cmpb   $0x2d,0x27(%esp)
  18113e:	0f 84 29 02 00 00    	je     18136d <_prf+0x4f0>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  181144:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18114b:	bb 00 00 00 00       	mov    $0x0,%ebx

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
					prefix = 1;
				need_justifying = true;
  181150:	b8 01 00 00 00       	mov    $0x1,%eax
  181155:	e9 96 02 00 00       	jmp    1813f0 <_prf+0x573>
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
  18115a:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181161:	8b 00                	mov    (%eax),%eax
				*int32ptr_temp = count;
  181163:	89 38                	mov    %edi,(%eax)
					prefix = 1;
				need_justifying = true;
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
  181165:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18116c:	8d 40 04             	lea    0x4(%eax),%eax
  18116f:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181176:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  18117b:	b8 00 00 00 00       	mov    $0x0,%eax
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;
  181180:	e9 6b 02 00 00       	jmp    1813f0 <_prf+0x573>

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181185:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  18118c:	8d 58 04             	lea    0x4(%eax),%ebx
  18118f:	8b 10                	mov    (%eax),%edx
				c = _to_octal(buf, uint32_temp, falt, precision);
  181191:	ff 74 24 1c          	pushl  0x1c(%esp)
  181195:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  181199:	8d 44 24 2b          	lea    0x2b(%esp),%eax
  18119d:	e8 b1 f6 ff ff       	call   180853 <_to_octal>
  1811a2:	83 c4 04             	add    $0x4,%esp
  1811a5:	89 c6                	mov    %eax,%esi
				need_justifying = true;
				if (precision != -1)
  1811a7:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1811ac:	0f 85 ce 01 00 00    	jne    181380 <_prf+0x503>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1811b2:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1811b9:	bb 00 00 00 00       	mov    $0x0,%ebx
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_octal(buf, uint32_temp, falt, precision);
				need_justifying = true;
  1811be:	b8 01 00 00 00       	mov    $0x1,%eax
  1811c3:	e9 28 02 00 00       	jmp    1813f0 <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1811c8:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1811cf:	8d 58 04             	lea    0x4(%eax),%ebx
  1811d2:	8b 10                	mov    (%eax),%edx
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
  1811d4:	6a 78                	push   $0x78
  1811d6:	6a 08                	push   $0x8
  1811d8:	b9 01 00 00 00       	mov    $0x1,%ecx
  1811dd:	8d 44 24 2f          	lea    0x2f(%esp),%eax
  1811e1:	e8 2a f6 ff ff       	call   180810 <_to_hex>
  1811e6:	83 c4 08             	add    $0x8,%esp
  1811e9:	89 c6                	mov    %eax,%esi
				need_justifying = true;
				if (precision != -1)
  1811eb:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1811f0:	0f 85 a2 01 00 00    	jne    181398 <_prf+0x51b>
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1811f6:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1811fd:	bb 00 00 00 00       	mov    $0x0,%ebx
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
				need_justifying = true;
  181202:	b8 01 00 00 00       	mov    $0x1,%eax
  181207:	e9 e4 01 00 00       	jmp    1813f0 <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
  18120c:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181213:	8d 58 04             	lea    0x4(%eax),%ebx
  181216:	8b 10                	mov    (%eax),%edx
				/* Get the string length */
				for (c = 0; c < MAXFLD; c++) {
  181218:	be 00 00 00 00       	mov    $0x0,%esi
  18121d:	eb 07                	jmp    181226 <_prf+0x3a9>
					if (cptr_temp[c] == '\0') {
  18121f:	80 3c 32 00          	cmpb   $0x0,(%edx,%esi,1)
  181223:	74 09                	je     18122e <_prf+0x3b1>
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
				/* Get the string length */
				for (c = 0; c < MAXFLD; c++) {
  181225:	46                   	inc    %esi
  181226:	81 fe c7 00 00 00    	cmp    $0xc7,%esi
  18122c:	7e f1                	jle    18121f <_prf+0x3a2>
					if (cptr_temp[c] == '\0') {
						break;
					}
				}
				if ((precision >= 0) && (precision < c))
  18122e:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  181232:	89 c8                	mov    %ecx,%eax
  181234:	f7 d0                	not    %eax
  181236:	c1 e8 1f             	shr    $0x1f,%eax
  181239:	39 ce                	cmp    %ecx,%esi
  18123b:	0f 9f c1             	setg   %cl
  18123e:	84 c1                	test   %al,%cl
  181240:	74 04                	je     181246 <_prf+0x3c9>
					c = precision;
  181242:	8b 74 24 1c          	mov    0x1c(%esp),%esi
				if (c > 0) {
  181246:	85 f6                	test   %esi,%esi
  181248:	0f 8e 62 01 00 00    	jle    1813b0 <_prf+0x533>
					memcpy(buf, cptr_temp, (size_t) c);
  18124e:	89 f1                	mov    %esi,%ecx
  181250:	8d 44 24 27          	lea    0x27(%esp),%eax
  181254:	e8 ce 02 00 00       	call   181527 <memcpy>
				if (precision != -1)
					pad = ' ';
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
  181259:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181260:	bb 00 00 00 00       	mov    $0x0,%ebx
				}
				if ((precision >= 0) && (precision < c))
					c = precision;
				if (c > 0) {
					memcpy(buf, cptr_temp, (size_t) c);
					need_justifying = true;
  181265:	b8 01 00 00 00       	mov    $0x1,%eax
  18126a:	e9 81 01 00 00       	jmp    1813f0 <_prf+0x573>
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  18126f:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  181276:	8d 58 04             	lea    0x4(%eax),%ebx
  181279:	8b 10                	mov    (%eax),%edx
				c = _to_udec(buf, uint32_temp, precision);
  18127b:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  18127f:	8d 44 24 27          	lea    0x27(%esp),%eax
  181283:	e8 02 f6 ff ff       	call   18088a <_to_udec>
  181288:	89 c6                	mov    %eax,%esi
				need_justifying = true;
				if (precision != -1)
  18128a:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  18128f:	0f 85 2e 01 00 00    	jne    1813c3 <_prf+0x546>
					need_justifying = true;
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181295:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18129c:	bb 00 00 00 00       	mov    $0x0,%ebx
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_udec(buf, uint32_temp, precision);
				need_justifying = true;
  1812a1:	b8 01 00 00 00       	mov    $0x1,%eax
  1812a6:	e9 45 01 00 00       	jmp    1813f0 <_prf+0x573>
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1812ab:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1812b2:	83 c0 04             	add    $0x4,%eax
  1812b5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1812b9:	8b 84 24 04 01 00 00 	mov    0x104(%esp),%eax
  1812c0:	8b 10                	mov    (%eax),%edx
				c = _to_hex(buf, uint32_temp, falt, precision, c);
  1812c2:	56                   	push   %esi
  1812c3:	ff 74 24 20          	pushl  0x20(%esp)
  1812c7:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  1812cb:	89 d9                	mov    %ebx,%ecx
  1812cd:	8d 44 24 2f          	lea    0x2f(%esp),%eax
  1812d1:	e8 3a f5 ff ff       	call   180810 <_to_hex>
  1812d6:	83 c4 08             	add    $0x8,%esp
  1812d9:	89 c6                	mov    %eax,%esi
				if (falt)
  1812db:	85 db                	test   %ebx,%ebx
  1812dd:	75 07                	jne    1812e6 <_prf+0x469>
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1812df:	bb 00 00 00 00       	mov    $0x0,%ebx
  1812e4:	eb 05                	jmp    1812eb <_prf+0x46e>
			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
  1812e6:	bb 02 00 00 00       	mov    $0x2,%ebx
				need_justifying = true;
				if (precision != -1)
  1812eb:	83 7c 24 1c ff       	cmpl   $0xffffffff,0x1c(%esp)
  1812f0:	0f 85 e5 00 00 00    	jne    1813db <_prf+0x55e>
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1812f6:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1812fa:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
				need_justifying = true;
  181301:	b8 01 00 00 00       	mov    $0x1,%eax
  181306:	e9 e5 00 00 00       	jmp    1813f0 <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case '%':
				if ((*func)('%', dest) == EOF) {
  18130b:	8b 14 24             	mov    (%esp),%edx
  18130e:	b8 25 00 00 00       	mov    $0x25,%eax
  181313:	ff d5                	call   *%ebp
  181315:	83 f8 ff             	cmp    $0xffffffff,%eax
  181318:	0f 84 83 01 00 00    	je     1814a1 <_prf+0x624>
					return EOF;
				}

				count++;
  18131e:	47                   	inc    %edi
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18131f:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  181324:	b8 00 00 00 00       	mov    $0x0,%eax
				if ((*func)('%', dest) == EOF) {
					return EOF;
				}

				count++;
				break;
  181329:	e9 c2 00 00 00       	jmp    1813f0 <_prf+0x573>
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18132e:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  181333:	b8 00 00 00 00       	mov    $0x0,%eax
  181338:	e9 b3 00 00 00       	jmp    1813f0 <_prf+0x573>
				c = 1;
				break;

			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
  18133d:	8b 44 24 14          	mov    0x14(%esp),%eax
  181341:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  181348:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
				c = _to_dec(buf, int32_temp, fplus, fspace, precision);
				if (fplus || fspace || (int32_temp < 0))
					prefix = 1;
				need_justifying = true;
  18134d:	b8 01 00 00 00       	mov    $0x1,%eax
  181352:	e9 99 00 00 00       	jmp    1813f0 <_prf+0x573>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  181357:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
					prefix = 1;
  18135e:	bb 01 00 00 00       	mov    $0x1,%ebx
				need_justifying = true;
  181363:	b8 01 00 00 00       	mov    $0x1,%eax
  181368:	e9 83 00 00 00       	jmp    1813f0 <_prf+0x573>
				union {
					double d;
					uint64_t i;
				} u;

				u.d = (double) va_arg(vargs, double);
  18136d:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
			}

				c = _to_float(buf, double_temp, c, falt, fplus,
					      fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
					prefix = 1;
  181374:	bb 01 00 00 00       	mov    $0x1,%ebx
				need_justifying = true;
  181379:	b8 01 00 00 00       	mov    $0x1,%eax
  18137e:	eb 70                	jmp    1813f0 <_prf+0x573>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181380:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  181387:	bb 00 00 00 00       	mov    $0x0,%ebx
			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_octal(buf, uint32_temp, falt, precision);
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  18138c:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_octal(buf, uint32_temp, falt, precision);
				need_justifying = true;
  181391:	b8 01 00 00 00       	mov    $0x1,%eax
  181396:	eb 58                	jmp    1813f0 <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  181398:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  18139f:	bb 00 00 00 00       	mov    $0x0,%ebx
			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  1813a4:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
				need_justifying = true;
  1813a9:	b8 01 00 00 00       	mov    $0x1,%eax
  1813ae:	eb 40                	jmp    1813f0 <_prf+0x573>
				if (precision != -1)
					pad = ' ';
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
  1813b0:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1813b7:	bb 00 00 00 00       	mov    $0x0,%ebx
				 * current form, it was being
				 * optimized out.
				 */
			}

			need_justifying = false;
  1813bc:	b8 00 00 00 00       	mov    $0x0,%eax
  1813c1:	eb 2d                	jmp    1813f0 <_prf+0x573>
					need_justifying = true;
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1813c3:	89 9c 24 04 01 00 00 	mov    %ebx,0x104(%esp)
				 * optimized out.
				 */
			}

			need_justifying = false;
			prefix = 0;
  1813ca:	bb 00 00 00 00       	mov    $0x0,%ebx
			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_udec(buf, uint32_temp, precision);
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  1813cf:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_udec(buf, uint32_temp, precision);
				need_justifying = true;
  1813d4:	b8 01 00 00 00       	mov    $0x1,%eax
  1813d9:	eb 15                	jmp    1813f0 <_prf+0x573>
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
  1813db:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1813df:	89 84 24 04 01 00 00 	mov    %eax,0x104(%esp)
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
				need_justifying = true;
				if (precision != -1)
					pad = ' ';
  1813e6:	c6 44 24 0b 20       	movb   $0x20,0xb(%esp)
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, falt, precision, c);
				if (falt)
					prefix = 2;
				need_justifying = true;
  1813eb:	b8 01 00 00 00       	mov    $0x1,%eax

			case 0:
				return count;
			}

			if (c >= MAXFLD + 1)
  1813f0:	81 fe c8 00 00 00    	cmp    $0xc8,%esi
  1813f6:	0f 8f a0 00 00 00    	jg     18149c <_prf+0x61f>
				return EOF;

			if (need_justifying) {
  1813fc:	85 c0                	test   %eax,%eax
  1813fe:	74 7a                	je     18147a <_prf+0x5fd>
				if (c < width) {
  181400:	3b 74 24 18          	cmp    0x18(%esp),%esi
  181404:	7d 5a                	jge    181460 <_prf+0x5e3>
					if (fminus)	{
  181406:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  18140b:	75 0a                	jne    181417 <_prf+0x59a>
  18140d:	eb 16                	jmp    181425 <_prf+0x5a8>
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
  18140f:	c6 44 34 27 20       	movb   $0x20,0x27(%esp,%esi,1)

			if (need_justifying) {
				if (c < width) {
					if (fminus)	{
						/* Left justify? */
						for (i = c; i < width; i++)
  181414:	46                   	inc    %esi
  181415:	eb 04                	jmp    18141b <_prf+0x59e>
  181417:	8b 44 24 18          	mov    0x18(%esp),%eax
  18141b:	39 c6                	cmp    %eax,%esi
  18141d:	7c f0                	jl     18140f <_prf+0x592>
							prefix = 0;
						c = width - c + prefix;
						for (i = prefix; i < c; i++)
							buf[i] = pad;
					}
					c = width;
  18141f:	8b 74 24 18          	mov    0x18(%esp),%esi
  181423:	eb 3b                	jmp    181460 <_prf+0x5e3>
						for (i = c; i < width; i++)
							buf[i] = ' ';
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
  181425:	8d 4e 01             	lea    0x1(%esi),%ecx
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
  181428:	8b 44 24 18          	mov    0x18(%esp),%eax
  18142c:	29 f0                	sub    %esi,%eax
  18142e:	89 c6                	mov    %eax,%esi
  181430:	8d 44 24 27          	lea    0x27(%esp),%eax
  181434:	01 f0                	add    %esi,%eax
  181436:	8d 54 24 27          	lea    0x27(%esp),%edx
  18143a:	e8 bb 00 00 00       	call   1814fa <memmove>
										+ 1));
						if (pad == ' ')
  18143f:	80 7c 24 0b 20       	cmpb   $0x20,0xb(%esp)
  181444:	75 05                	jne    18144b <_prf+0x5ce>
							prefix = 0;
  181446:	bb 00 00 00 00       	mov    $0x0,%ebx
						c = width - c + prefix;
  18144b:	01 de                	add    %ebx,%esi
  18144d:	8a 44 24 0b          	mov    0xb(%esp),%al
						for (i = prefix; i < c; i++)
  181451:	eb 05                	jmp    181458 <_prf+0x5db>
							buf[i] = pad;
  181453:	88 44 1c 27          	mov    %al,0x27(%esp,%ebx,1)
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
						if (pad == ' ')
							prefix = 0;
						c = width - c + prefix;
						for (i = prefix; i < c; i++)
  181457:	43                   	inc    %ebx
  181458:	39 f3                	cmp    %esi,%ebx
  18145a:	7c f7                	jl     181453 <_prf+0x5d6>
							buf[i] = pad;
					}
					c = width;
  18145c:	8b 74 24 18          	mov    0x18(%esp),%esi
  181460:	8d 5c 24 27          	lea    0x27(%esp),%ebx
  181464:	eb 10                	jmp    181476 <_prf+0x5f9>
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
					if ((*func)(*cptr, dest) == EOF)
  181466:	0f be 03             	movsbl (%ebx),%eax
  181469:	8b 14 24             	mov    (%esp),%edx
  18146c:	ff d5                	call   *%ebp
  18146e:	83 f8 ff             	cmp    $0xffffffff,%eax
  181471:	74 2e                	je     1814a1 <_prf+0x624>
							buf[i] = pad;
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
  181473:	4e                   	dec    %esi
  181474:	43                   	inc    %ebx
  181475:	47                   	inc    %edi
  181476:	85 f6                	test   %esi,%esi
  181478:	7f ec                	jg     181466 <_prf+0x5e9>
	uint32_t			uint32_temp;
	uint64_t			double_temp;

	count = 0;

	while ((c = *format++)) {
  18147a:	8b 44 24 20          	mov    0x20(%esp),%eax
  18147e:	8d 50 01             	lea    0x1(%eax),%edx
  181481:	89 54 24 20          	mov    %edx,0x20(%esp)
  181485:	0f be 00             	movsbl (%eax),%eax
  181488:	85 c0                	test   %eax,%eax
  18148a:	0f 85 0a fa ff ff    	jne    180e9a <_prf+0x1d>
						return EOF;
				}
			}
		}
	}
	return count;
  181490:	89 f8                	mov    %edi,%eax
  181492:	eb 0d                	jmp    1814a1 <_prf+0x624>
				case '0':
					pad = '0';
					break;

				case '\0':
					return count;
  181494:	89 f8                	mov    %edi,%eax
  181496:	eb 09                	jmp    1814a1 <_prf+0x624>

				count++;
				break;

			case 0:
				return count;
  181498:	89 f8                	mov    %edi,%eax
  18149a:	eb 05                	jmp    1814a1 <_prf+0x624>
			}

			if (c >= MAXFLD + 1)
				return EOF;
  18149c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
				}
			}
		}
	}
	return count;
}
  1814a1:	81 c4 f0 00 00 00    	add    $0xf0,%esp
  1814a7:	5b                   	pop    %ebx
  1814a8:	5e                   	pop    %esi
  1814a9:	5f                   	pop    %edi
  1814aa:	5d                   	pop    %ebp
  1814ab:	c3                   	ret    

001814ac <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
  1814ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1814b1:	c3                   	ret    

001814b2 <fputc>:
	_stdout_hook = hook;
}

int fputc(int c, FILE *stream)
{
	return (stdout == stream) ? _stdout_hook(c) : EOF;
  1814b2:	83 fa 02             	cmp    $0x2,%edx
  1814b5:	75 07                	jne    1814be <fputc+0xc>
  1814b7:	ff 15 10 00 28 00    	call   *0x280010
  1814bd:	c3                   	ret    
  1814be:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  1814c3:	c3                   	ret    

001814c4 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
  1814c4:	53                   	push   %ebx
	char tmp = (char) c;
  1814c5:	88 d3                	mov    %dl,%bl

	while ((*s != tmp) && (*s != '\0'))
  1814c7:	eb 01                	jmp    1814ca <strchr+0x6>
		s++;
  1814c9:	40                   	inc    %eax

char *strchr(const char *s, int c)
{
	char tmp = (char) c;

	while ((*s != tmp) && (*s != '\0'))
  1814ca:	8a 08                	mov    (%eax),%cl
  1814cc:	38 cb                	cmp    %cl,%bl
  1814ce:	74 04                	je     1814d4 <strchr+0x10>
  1814d0:	84 c9                	test   %cl,%cl
  1814d2:	75 f5                	jne    1814c9 <strchr+0x5>
		s++;

	return (*s == tmp) ? (char *) s : NULL;
  1814d4:	38 ca                	cmp    %cl,%dl
  1814d6:	74 05                	je     1814dd <strchr+0x19>
  1814d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1814dd:	5b                   	pop    %ebx
  1814de:	c3                   	ret    

001814df <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  1814df:	53                   	push   %ebx
	while ((*s1 == *s2) && (*s1 != '\0')) {
  1814e0:	eb 02                	jmp    1814e4 <strcmp+0x5>
		s1++;
  1814e2:	40                   	inc    %eax
		s2++;
  1814e3:	42                   	inc    %edx
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
  1814e4:	8a 08                	mov    (%eax),%cl
  1814e6:	8a 1a                	mov    (%edx),%bl
  1814e8:	38 d9                	cmp    %bl,%cl
  1814ea:	75 04                	jne    1814f0 <strcmp+0x11>
  1814ec:	84 c9                	test   %cl,%cl
  1814ee:	75 f2                	jne    1814e2 <strcmp+0x3>
		s1++;
		s2++;
	}

	return *s1 - *s2;
  1814f0:	0f be c1             	movsbl %cl,%eax
  1814f3:	0f be db             	movsbl %bl,%ebx
  1814f6:	29 d8                	sub    %ebx,%eax
}
  1814f8:	5b                   	pop    %ebx
  1814f9:	c3                   	ret    

001814fa <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
  1814fa:	56                   	push   %esi
  1814fb:	53                   	push   %ebx
  1814fc:	89 c6                	mov    %eax,%esi
	char *dest = d;
	const char *src  = s;

	if ((size_t) (d - s) < n) {
  1814fe:	89 c3                	mov    %eax,%ebx
  181500:	29 d3                	sub    %edx,%ebx
  181502:	39 cb                	cmp    %ecx,%ebx
  181504:	72 0b                	jb     181511 <memmove+0x17>
  181506:	89 c3                	mov    %eax,%ebx
  181508:	eb 14                	jmp    18151e <memmove+0x24>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
  18150a:	49                   	dec    %ecx
			dest[n] = src[n];
  18150b:	8a 1c 0a             	mov    (%edx,%ecx,1),%bl
  18150e:	88 1c 0e             	mov    %bl,(%esi,%ecx,1)
		/*
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
  181511:	85 c9                	test   %ecx,%ecx
  181513:	75 f5                	jne    18150a <memmove+0x10>
  181515:	eb 0b                	jmp    181522 <memmove+0x28>
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
			*dest = *src;
  181517:	8a 02                	mov    (%edx),%al
  181519:	88 03                	mov    %al,(%ebx)
			dest++;
  18151b:	43                   	inc    %ebx
			src++;
  18151c:	42                   	inc    %edx
			n--;
  18151d:	49                   	dec    %ecx
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
  18151e:	85 c9                	test   %ecx,%ecx
  181520:	75 f5                	jne    181517 <memmove+0x1d>
			n--;
		}
	}

	return d;
}
  181522:	89 f0                	mov    %esi,%eax
  181524:	5b                   	pop    %ebx
  181525:	5e                   	pop    %esi
  181526:	c3                   	ret    

00181527 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
  181527:	56                   	push   %esi
  181528:	53                   	push   %ebx
  181529:	89 c6                	mov    %eax,%esi
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
  18152b:	89 c3                	mov    %eax,%ebx
  18152d:	31 d3                	xor    %edx,%ebx
  18152f:	f6 c3 03             	test   $0x3,%bl
  181532:	74 15                	je     181549 <memcpy+0x22>

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
  181534:	89 c3                	mov    %eax,%ebx
  181536:	eb 39                	jmp    181571 <memcpy+0x4a>
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
			if (n == 0) {
  181538:	85 c9                	test   %ecx,%ecx
  18153a:	74 39                	je     181575 <memcpy+0x4e>
				return d;
			}
			*(d_byte++) = *(s_byte++);
  18153c:	8a 02                	mov    (%edx),%al
  18153e:	88 03                	mov    %al,(%ebx)
			n--;
  181540:	49                   	dec    %ecx

		while (((unsigned int)d_byte) & 0x3) {
			if (n == 0) {
				return d;
			}
			*(d_byte++) = *(s_byte++);
  181541:	8d 52 01             	lea    0x1(%edx),%edx
  181544:	8d 5b 01             	lea    0x1(%ebx),%ebx
  181547:	eb 02                	jmp    18154b <memcpy+0x24>
  181549:	89 c3                	mov    %eax,%ebx

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
  18154b:	f6 c3 03             	test   $0x3,%bl
  18154e:	75 e8                	jne    181538 <memcpy+0x11>
  181550:	eb 0d                	jmp    18155f <memcpy+0x38>

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
			*(d_word++) = *(s_word++);
  181552:	8b 02                	mov    (%edx),%eax
  181554:	89 03                	mov    %eax,(%ebx)
			n -= sizeof(unsigned int);
  181556:	83 e9 04             	sub    $0x4,%ecx

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
			*(d_word++) = *(s_word++);
  181559:	8d 52 04             	lea    0x4(%edx),%edx
  18155c:	8d 5b 04             	lea    0x4(%ebx),%ebx
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
  18155f:	83 f9 03             	cmp    $0x3,%ecx
  181562:	77 ee                	ja     181552 <memcpy+0x2b>
  181564:	eb 0b                	jmp    181571 <memcpy+0x4a>
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
  181566:	8a 02                	mov    (%edx),%al
  181568:	88 03                	mov    %al,(%ebx)
		n--;
  18156a:	49                   	dec    %ecx
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
  18156b:	8d 52 01             	lea    0x1(%edx),%edx
  18156e:	8d 5b 01             	lea    0x1(%ebx),%ebx
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
  181571:	85 c9                	test   %ecx,%ecx
  181573:	75 f1                	jne    181566 <memcpy+0x3f>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
  181575:	89 f0                	mov    %esi,%eax
  181577:	5b                   	pop    %ebx
  181578:	5e                   	pop    %esi
  181579:	c3                   	ret    

0018157a <_nop_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  18157a:	b8 00 00 00 00       	mov    $0x0,%eax
  18157f:	c3                   	ret    

00181580 <char_out>:
	int count;
};

static int char_out(int c, struct out_context *ctx)
{
	ctx->count++;
  181580:	8b 0a                	mov    (%edx),%ecx
  181582:	41                   	inc    %ecx
  181583:	89 0a                	mov    %ecx,(%edx)
	return _char_out(c);
  181585:	ff 15 14 00 28 00    	call   *0x280014
}
  18158b:	c3                   	ret    

0018158c <_printk_hex_ulong>:
 * @return N/A
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  18158c:	55                   	push   %ebp
  18158d:	57                   	push   %edi
  18158e:	56                   	push   %esi
  18158f:	53                   	push   %ebx
  181590:	83 ec 08             	sub    $0x8,%esp
  181593:	89 c5                	mov    %eax,%ebp
  181595:	89 14 24             	mov    %edx,(%esp)
  181598:	89 cf                	mov    %ecx,%edi
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */
  18159a:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  1815a1:	00 
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
  1815a2:	bb 00 00 00 00       	mov    $0x0,%ebx
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
	int size = sizeof(num) * 2;
  1815a7:	ba 08 00 00 00       	mov    $0x8,%edx
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  1815ac:	eb 65                	jmp    181613 <_printk_hex_ulong+0x87>
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  1815ae:	8d 72 ff             	lea    -0x1(%edx),%esi
  1815b1:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
  1815b8:	89 f8                	mov    %edi,%eax
  1815ba:	d3 e8                	shr    %cl,%eax

		if (nibble || found_largest_digit || size == 1) {
  1815bc:	83 e0 0f             	and    $0xf,%eax
  1815bf:	0f 95 c1             	setne  %cl
  1815c2:	08 d9                	or     %bl,%cl
  1815c4:	75 05                	jne    1815cb <_printk_hex_ulong+0x3f>
  1815c6:	83 fa 01             	cmp    $0x1,%edx
  1815c9:	75 1b                	jne    1815e6 <_printk_hex_ulong+0x5a>
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
  1815cb:	3c 09                	cmp    $0x9,%al
  1815cd:	7e 04                	jle    1815d3 <_printk_hex_ulong+0x47>
  1815cf:	b2 57                	mov    $0x57,%dl
  1815d1:	eb 02                	jmp    1815d5 <_printk_hex_ulong+0x49>
  1815d3:	b2 30                	mov    $0x30,%dl
  1815d5:	01 d0                	add    %edx,%eax
			out((int)nibble, ctx);
  1815d7:	0f be c0             	movsbl %al,%eax
  1815da:	8b 14 24             	mov    (%esp),%edx
  1815dd:	ff d5                	call   *%ebp

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  1815df:	bb 01 00 00 00       	mov    $0x1,%ebx
			nibble += nibble > 9 ? 87 : 48;
			out((int)nibble, ctx);
			continue;
  1815e4:	eb 2b                	jmp    181611 <_printk_hex_ulong+0x85>
		}

		if (remaining-- <= min_width) {
  1815e6:	8b 44 24 04          	mov    0x4(%esp),%eax
  1815ea:	8d 48 ff             	lea    -0x1(%eax),%ecx
  1815ed:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1815f1:	3b 44 24 20          	cmp    0x20(%esp),%eax
  1815f5:	7f 1a                	jg     181611 <_printk_hex_ulong+0x85>
			out((int)(pad_zero ? '0' : ' '), ctx);
  1815f7:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  1815fc:	74 07                	je     181605 <_printk_hex_ulong+0x79>
  1815fe:	b8 30 00 00 00       	mov    $0x30,%eax
  181603:	eb 05                	jmp    18160a <_printk_hex_ulong+0x7e>
  181605:	b8 20 00 00 00       	mov    $0x20,%eax
  18160a:	8b 14 24             	mov    (%esp),%edx
  18160d:	ff d5                	call   *%ebp
  18160f:	eb 00                	jmp    181611 <_printk_hex_ulong+0x85>

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);

		if (nibble || found_largest_digit || size == 1) {
			found_largest_digit = 1;
  181611:	89 f2                	mov    %esi,%edx
{
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 8; /* 8 digits max */

	for (; size; size--) {
  181613:	85 d2                	test   %edx,%edx
  181615:	75 97                	jne    1815ae <_printk_hex_ulong+0x22>

		if (remaining-- <= min_width) {
			out((int)(pad_zero ? '0' : ' '), ctx);
		}
	}
}
  181617:	83 c4 08             	add    $0x8,%esp
  18161a:	5b                   	pop    %ebx
  18161b:	5e                   	pop    %esi
  18161c:	5f                   	pop    %edi
  18161d:	5d                   	pop    %ebp
  18161e:	c3                   	ret    

0018161f <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, int pad_zero,
			      int min_width)
{
  18161f:	55                   	push   %ebp
  181620:	57                   	push   %edi
  181621:	56                   	push   %esi
  181622:	53                   	push   %ebx
  181623:	83 ec 08             	sub    $0x8,%esp
  181626:	89 c5                	mov    %eax,%ebp
  181628:	89 54 24 04          	mov    %edx,0x4(%esp)
	unsigned long remainder = num;
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
  18162c:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  181631:	7f 08                	jg     18163b <_printk_dec_ulong+0x1c>
		min_width = 1;
  181633:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  18163a:	00 
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  18163b:	89 0c 24             	mov    %ecx,(%esp)
  18163e:	bf 0a 00 00 00       	mov    $0xa,%edi
  181643:	bb 00 00 00 00       	mov    $0x0,%ebx
  181648:	be ff c9 9a 3b       	mov    $0x3b9ac9ff,%esi
  18164d:	eb 65                	jmp    1816b4 <_printk_dec_ulong+0x95>
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  18164f:	3b 34 24             	cmp    (%esp),%esi
  181652:	0f 92 c0             	setb   %al
  181655:	08 d8                	or     %bl,%al
  181657:	74 1d                	je     181676 <_printk_dec_ulong+0x57>
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
  181659:	8d 4e 01             	lea    0x1(%esi),%ecx
  18165c:	8b 04 24             	mov    (%esp),%eax
  18165f:	ba 00 00 00 00       	mov    $0x0,%edx
  181664:	f7 f1                	div    %ecx
  181666:	83 c0 30             	add    $0x30,%eax
  181669:	8b 54 24 04          	mov    0x4(%esp),%edx
  18166d:	ff d5                	call   *%ebp
		min_width = 1;
	}

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  18166f:	bb 01 00 00 00       	mov    $0x1,%ebx
  181674:	eb 1f                	jmp    181695 <_printk_dec_ulong+0x76>
			out((int)((remainder / (pos + 1)) + 48), ctx);
		} else if (remaining <= min_width) {
  181676:	3b 7c 24 20          	cmp    0x20(%esp),%edi
  18167a:	7f 19                	jg     181695 <_printk_dec_ulong+0x76>
			out((int)(pad_zero ? '0' : ' '), ctx);
  18167c:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  181681:	74 07                	je     18168a <_printk_dec_ulong+0x6b>
  181683:	b8 30 00 00 00       	mov    $0x30,%eax
  181688:	eb 05                	jmp    18168f <_printk_dec_ulong+0x70>
  18168a:	b8 20 00 00 00       	mov    $0x20,%eax
  18168f:	8b 54 24 04          	mov    0x4(%esp),%edx
  181693:	ff d5                	call   *%ebp
		}
		remaining--;
  181695:	4f                   	dec    %edi
		remainder %= (pos + 1);
  181696:	8d 4e 01             	lea    0x1(%esi),%ecx
  181699:	8b 04 24             	mov    (%esp),%eax
  18169c:	ba 00 00 00 00       	mov    $0x0,%edx
  1816a1:	f7 f1                	div    %ecx
  1816a3:	89 14 24             	mov    %edx,(%esp)
		pos /= 10;
  1816a6:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  1816ab:	89 f0                	mov    %esi,%eax
  1816ad:	f7 e2                	mul    %edx
  1816af:	89 d6                	mov    %edx,%esi
  1816b1:	c1 ee 03             	shr    $0x3,%esi
	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 9) {
  1816b4:	83 fe 08             	cmp    $0x8,%esi
  1816b7:	77 96                	ja     18164f <_printk_dec_ulong+0x30>
		}
		remaining--;
		remainder %= (pos + 1);
		pos /= 10;
	}
	out((int)(remainder + 48), ctx);
  1816b9:	8b 04 24             	mov    (%esp),%eax
  1816bc:	83 c0 30             	add    $0x30,%eax
  1816bf:	8b 54 24 04          	mov    0x4(%esp),%edx
  1816c3:	ff d5                	call   *%ebp
}
  1816c5:	83 c4 08             	add    $0x8,%esp
  1816c8:	5b                   	pop    %ebx
  1816c9:	5e                   	pop    %esi
  1816ca:	5f                   	pop    %edi
  1816cb:	5d                   	pop    %ebp
  1816cc:	c3                   	ret    

001816cd <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  1816cd:	a3 14 00 28 00       	mov    %eax,0x280014
  1816d2:	c3                   	ret    

001816d3 <_vprintk>:
 * @param ap Variable parameters
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
  1816d3:	55                   	push   %ebp
  1816d4:	57                   	push   %edi
  1816d5:	56                   	push   %esi
  1816d6:	53                   	push   %ebx
  1816d7:	83 ec 10             	sub    $0x10,%esp
  1816da:	89 c7                	mov    %eax,%edi
  1816dc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1816e0:	89 cb                	mov    %ecx,%ebx
  1816e2:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
	int min_width = -1;
  1816e6:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
	int pad_zero = 0;
  1816ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1816f4:	00 
 *
 * @return N/A
 */
void _vprintk(out_func_t out, void *ctx, const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  1816f5:	be 00 00 00 00       	mov    $0x0,%esi
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  1816fa:	e9 af 01 00 00       	jmp    1818ae <_vprintk+0x1db>
		if (!might_format) {
  1816ff:	85 f6                	test   %esi,%esi
  181701:	75 16                	jne    181719 <_vprintk+0x46>
			if (*fmt != '%') {
  181703:	3c 25                	cmp    $0x25,%al
  181705:	0f 84 84 01 00 00    	je     18188f <_vprintk+0x1bc>
				out((int)*fmt, ctx);
  18170b:	0f be c0             	movsbl %al,%eax
  18170e:	8b 54 24 04          	mov    0x4(%esp),%edx
  181712:	ff d7                	call   *%edi
  181714:	e9 94 01 00 00       	jmp    1818ad <_vprintk+0x1da>
				might_format = 1;
				min_width = -1;
				pad_zero = 0;
			}
		} else {
			switch (*fmt) {
  181719:	8d 50 db             	lea    -0x25(%eax),%edx
  18171c:	80 fa 55             	cmp    $0x55,%dl
  18171f:	0f 87 4f 01 00 00    	ja     181874 <_vprintk+0x1a1>
  181725:	0f b6 d2             	movzbl %dl,%edx
  181728:	ff 24 95 18 31 18 00 	jmp    *0x183118(,%edx,4)
			case '0':
				if (min_width < 0 && pad_zero == 0) {
  18172f:	8b 14 24             	mov    (%esp),%edx
  181732:	c1 ea 1f             	shr    $0x1f,%edx
  181735:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  18173a:	0f 94 c1             	sete   %cl
  18173d:	84 d1                	test   %dl,%cl
  18173f:	0f 85 60 01 00 00    	jne    1818a5 <_vprintk+0x1d2>
					pad_zero = 1;
					goto still_might_format;
				}
				/* Fall through */
			case '1' ... '9':
				if (min_width < 0) {
  181745:	83 3c 24 00          	cmpl   $0x0,(%esp)
  181749:	79 0e                	jns    181759 <_vprintk+0x86>
					min_width = *fmt - '0';
  18174b:	0f be c0             	movsbl %al,%eax
  18174e:	83 e8 30             	sub    $0x30,%eax
  181751:	89 04 24             	mov    %eax,(%esp)
  181754:	e9 54 01 00 00       	jmp    1818ad <_vprintk+0x1da>
				} else {
					min_width = 10 * min_width + *fmt - '0';
  181759:	8b 0c 24             	mov    (%esp),%ecx
  18175c:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  18175f:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  181762:	0f be c0             	movsbl %al,%eax
  181765:	8d 44 02 d0          	lea    -0x30(%edx,%eax,1),%eax
  181769:	89 04 24             	mov    %eax,(%esp)
  18176c:	e9 3c 01 00 00       	jmp    1818ad <_vprintk+0x1da>
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  181771:	8d 75 04             	lea    0x4(%ebp),%esi
  181774:	8b 6d 00             	mov    0x0(%ebp),%ebp

				if (d < 0) {
  181777:	85 ed                	test   %ebp,%ebp
  181779:	79 10                	jns    18178b <_vprintk+0xb8>
					out((int)'-', ctx);
  18177b:	8b 54 24 04          	mov    0x4(%esp),%edx
  18177f:	b8 2d 00 00 00       	mov    $0x2d,%eax
  181784:	ff d7                	call   *%edi
					d = -d;
  181786:	f7 dd                	neg    %ebp
					min_width--;
  181788:	ff 0c 24             	decl   (%esp)
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
  18178b:	ff 34 24             	pushl  (%esp)
  18178e:	ff 74 24 0c          	pushl  0xc(%esp)
  181792:	89 e9                	mov    %ebp,%ecx
  181794:	8b 54 24 0c          	mov    0xc(%esp),%edx
  181798:	89 f8                	mov    %edi,%eax
  18179a:	e8 80 fe ff ff       	call   18161f <_printk_dec_ulong>
  18179f:	83 c4 08             	add    $0x8,%esp
			case 'h':
				/* FIXME: do nothing for these modifiers */
				goto still_might_format;
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  1817a2:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  1817a4:	be 00 00 00 00       	mov    $0x0,%esi
					d = -d;
					min_width--;
				}
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
  1817a9:	e9 ff 00 00 00       	jmp    1818ad <_vprintk+0x1da>
			}
			case 'u': {
				unsigned long u = va_arg(
  1817ae:	8d 75 04             	lea    0x4(%ebp),%esi
  1817b1:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
  1817b4:	ff 34 24             	pushl  (%esp)
  1817b7:	ff 74 24 0c          	pushl  0xc(%esp)
  1817bb:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1817bf:	89 f8                	mov    %edi,%eax
  1817c1:	e8 59 fe ff ff       	call   18161f <_printk_dec_ulong>
  1817c6:	83 c4 08             	add    $0x8,%esp
				_printk_dec_ulong(out, ctx, d, pad_zero,
						  min_width);
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  1817c9:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  1817cb:	be 00 00 00 00       	mov    $0x0,%esi
			case 'u': {
				unsigned long u = va_arg(
					ap, unsigned long);
				_printk_dec_ulong(out, ctx, u, pad_zero,
						  min_width);
				break;
  1817d0:	e9 d8 00 00 00       	jmp    1818ad <_vprintk+0x1da>
			}
			case 'p':
				  out('0', ctx);
  1817d5:	8b 74 24 04          	mov    0x4(%esp),%esi
  1817d9:	89 f2                	mov    %esi,%edx
  1817db:	b8 30 00 00 00       	mov    $0x30,%eax
  1817e0:	ff d7                	call   *%edi
				  out('x', ctx);
  1817e2:	89 f2                	mov    %esi,%edx
  1817e4:	b8 78 00 00 00       	mov    $0x78,%eax
  1817e9:	ff d7                	call   *%edi
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
				  min_width = 8;
  1817eb:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
			}
			case 'p':
				  out('0', ctx);
				  out('x', ctx);
				  /* left-pad pointers with zeros */
				  pad_zero = 1;
  1817f2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1817f9:	00 
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  1817fa:	8d 75 04             	lea    0x4(%ebp),%esi
  1817fd:	8b 4d 00             	mov    0x0(%ebp),%ecx
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
  181800:	ff 34 24             	pushl  (%esp)
  181803:	ff 74 24 0c          	pushl  0xc(%esp)
  181807:	8b 54 24 0c          	mov    0xc(%esp),%edx
  18180b:	89 f8                	mov    %edi,%eax
  18180d:	e8 7a fd ff ff       	call   18158c <_printk_hex_ulong>
  181812:	83 c4 08             	add    $0x8,%esp
				  pad_zero = 1;
				  min_width = 8;
				  /* Fall through */
			case 'x':
			case 'X': {
				unsigned long x = va_arg(
  181815:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181817:	be 00 00 00 00       	mov    $0x0,%esi
			case 'X': {
				unsigned long x = va_arg(
					ap, unsigned long);
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
  18181c:	e9 8c 00 00 00       	jmp    1818ad <_vprintk+0x1da>
			}
			case 's': {
				char *s = va_arg(ap, char *);
  181821:	8d 75 04             	lea    0x4(%ebp),%esi
  181824:	8b 6d 00             	mov    0x0(%ebp),%ebp
  181827:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  18182b:	8b 5c 24 04          	mov    0x4(%esp),%ebx

				while (*s)
  18182f:	eb 08                	jmp    181839 <_vprintk+0x166>
					out((int)(*s++), ctx);
  181831:	45                   	inc    %ebp
  181832:	0f be c0             	movsbl %al,%eax
  181835:	89 da                	mov    %ebx,%edx
  181837:	ff d7                	call   *%edi
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);

				while (*s)
  181839:	8a 45 00             	mov    0x0(%ebp),%al
  18183c:	84 c0                	test   %al,%al
  18183e:	75 f1                	jne    181831 <_vprintk+0x15e>
  181840:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
				_printk_hex_ulong(out, ctx, x, pad_zero,
						  min_width);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  181844:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  181846:	be 00 00 00 00       	mov    $0x0,%esi
  18184b:	eb 60                	jmp    1818ad <_vprintk+0x1da>
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  18184d:	8d 75 04             	lea    0x4(%ebp),%esi
  181850:	8b 45 00             	mov    0x0(%ebp),%eax

				out(c, ctx);
  181853:	8b 54 24 04          	mov    0x4(%esp),%edx
  181857:	ff d7                	call   *%edi
				while (*s)
					out((int)(*s++), ctx);
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  181859:	89 f5                	mov    %esi,%ebp
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  18185b:	be 00 00 00 00       	mov    $0x0,%esi
			}
			case 'c': {
				int c = va_arg(ap, int);

				out(c, ctx);
				break;
  181860:	eb 4b                	jmp    1818ad <_vprintk+0x1da>
			}
			case '%': {
				out((int)'%', ctx);
  181862:	8b 54 24 04          	mov    0x4(%esp),%edx
  181866:	b8 25 00 00 00       	mov    $0x25,%eax
  18186b:	ff d7                	call   *%edi
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
			}
			might_format = 0;
  18186d:	be 00 00 00 00       	mov    $0x0,%esi
				out(c, ctx);
				break;
			}
			case '%': {
				out((int)'%', ctx);
				break;
  181872:	eb 39                	jmp    1818ad <_vprintk+0x1da>
			}
			default:
				out((int)'%', ctx);
  181874:	8b 74 24 04          	mov    0x4(%esp),%esi
  181878:	89 f2                	mov    %esi,%edx
  18187a:	b8 25 00 00 00       	mov    $0x25,%eax
  18187f:	ff d7                	call   *%edi
				out((int)*fmt, ctx);
  181881:	0f be 03             	movsbl (%ebx),%eax
  181884:	89 f2                	mov    %esi,%edx
  181886:	ff d7                	call   *%edi
				break;
			}
			might_format = 0;
  181888:	be 00 00 00 00       	mov    $0x0,%esi
				break;
			}
			default:
				out((int)'%', ctx);
				out((int)*fmt, ctx);
				break;
  18188d:	eb 1e                	jmp    1818ad <_vprintk+0x1da>
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
				min_width = -1;
  18188f:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
				pad_zero = 0;
  181896:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  18189d:	00 
	while (*fmt) {
		if (!might_format) {
			if (*fmt != '%') {
				out((int)*fmt, ctx);
			} else {
				might_format = 1;
  18189e:	be 01 00 00 00       	mov    $0x1,%esi
  1818a3:	eb 08                	jmp    1818ad <_vprintk+0x1da>
			}
		} else {
			switch (*fmt) {
			case '0':
				if (min_width < 0 && pad_zero == 0) {
					pad_zero = 1;
  1818a5:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1818ac:	00 
				break;
			}
			might_format = 0;
		}
still_might_format:
		++fmt;
  1818ad:	43                   	inc    %ebx
	int pad_zero = 0;
	int min_width = -1;

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  1818ae:	8a 03                	mov    (%ebx),%al
  1818b0:	84 c0                	test   %al,%al
  1818b2:	0f 85 47 fe ff ff    	jne    1816ff <_vprintk+0x2c>
			might_format = 0;
		}
still_might_format:
		++fmt;
	}
}
  1818b8:	83 c4 10             	add    $0x10,%esp
  1818bb:	5b                   	pop    %ebx
  1818bc:	5e                   	pop    %esi
  1818bd:	5f                   	pop    %edi
  1818be:	5d                   	pop    %ebp
  1818bf:	c3                   	ret    

001818c0 <printk>:
 * @param fmt formatted string to output
 *
 * @return Number of characters printed
 */
int printk(const char *fmt, ...)
{
  1818c0:	83 ec 04             	sub    $0x4,%esp
	struct out_context ctx = { 0 };
  1818c3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
	va_list ap;

	va_start(ap, fmt);
  1818ca:	8d 44 24 0c          	lea    0xc(%esp),%eax
	_vprintk((out_func_t)char_out, &ctx, fmt, ap);
  1818ce:	50                   	push   %eax
  1818cf:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  1818d3:	8d 54 24 04          	lea    0x4(%esp),%edx
  1818d7:	b8 80 15 18 00       	mov    $0x181580,%eax
  1818dc:	e8 f2 fd ff ff       	call   1816d3 <_vprintk>
	va_end(ap);

	return ctx.count;
}
  1818e1:	8b 44 24 04          	mov    0x4(%esp),%eax
  1818e5:	83 c4 08             	add    $0x8,%esp
  1818e8:	c3                   	ret    

001818e9 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_SOC, 1);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_SOC_FAMILY, 1);
GEN_ABSOLUTE_SYM(CONFIG_SYS_LOG_IEEE802154_DRIVER_LEVEL, 0);
GEN_ABSOLUTE_SYM(CONFIG_MEM_POOL_SPLIT_BEFORE_DEFRAG, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);
  1818e9:	c3                   	ret    

001818ea <_pinmux_defaults>:
/******** End PINMUX mapping **************************/

#define PINMUX_MAX_REGISTERS 2

static void _pinmux_defaults(uint32_t base)
{
  1818ea:	53                   	push   %ebx
  1818eb:	83 ec 08             	sub    $0x8,%esp
	PIN_CONFIG(mux_config,  6, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config,  7, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 12, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 13, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 14, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
  1818ee:	c7 04 24 42 a1 00 aa 	movl   $0xaa00a142,(%esp)
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);
  1818f5:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  1818fc:	00 

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  1818fd:	ba 00 00 00 00       	mov    $0x0,%edx
  181902:	eb 0a                	jmp    18190e <_pinmux_defaults+0x24>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
  181904:	8d 1c 90             	lea    (%eax,%edx,4),%ebx
  181907:	8b 0c 94             	mov    (%esp,%edx,4),%ecx
}

static ALWAYS_INLINE
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
  18190a:	89 4b 30             	mov    %ecx,0x30(%ebx)
	PIN_CONFIG(mux_config, 15, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 16, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17, PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 18, PINMUX_FUNC_C);

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
  18190d:	42                   	inc    %edx
  18190e:	83 fa 01             	cmp    $0x1,%edx
  181911:	7e f1                	jle    181904 <_pinmux_defaults+0x1a>
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}
  181913:	83 c4 08             	add    $0x8,%esp
  181916:	5b                   	pop    %ebx
  181917:	c3                   	ret    

00181918 <pinmux_initialize>:

static int pinmux_initialize(struct device *port)
{
	ARG_UNUSED(port);

	_pinmux_defaults(PINMUX_BASE_ADDR);
  181918:	b8 00 09 80 b0       	mov    $0xb0800900,%eax
  18191d:	e8 c8 ff ff ff       	call   1818ea <_pinmux_defaults>

	/*
	 * MAGIC NUMBER: 0x1 is used as the pullup is a single bit in a
	 * 32-bit register.
	 */
	(*(mux_register)) = ((*(mux_register)) & ~(0x1 << pin_offset)) |
  181922:	a1 20 09 80 b0       	mov    0xb0800920,%eax
  181927:	83 c8 20             	or     $0x20,%eax
  18192a:	a3 20 09 80 b0       	mov    %eax,0xb0800920

	/* Enable the UART RX pin to receive input */
	_quark_mcu_set_mux(PINMUX_BASE_ADDR + PINMUX_INPUT_OFFSET, 5, 0x1);

	return 0;
}
  18192f:	b8 00 00 00 00       	mov    $0x0,%eax
  181934:	c3                   	ret    

00181935 <clk_periph_enable>:

int clk_periph_enable(const clk_periph_t clocks)
{
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl |= clocks;
  181935:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
  18193b:	09 d0                	or     %edx,%eax
  18193d:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
  181942:	b8 00 00 00 00       	mov    $0x0,%eax
  181947:	c3                   	ret    

00181948 <clk_periph_disable>:

int clk_periph_disable(const clk_periph_t clocks)
{
	QM_CHECK(clocks <= CLK_PERIPH_ALL, -EINVAL);

	QM_SCSS_CCU->ccu_periph_clk_gate_ctl &= ~clocks;
  181948:	8b 15 18 00 80 b0    	mov    0xb0800018,%edx
  18194e:	f7 d0                	not    %eax
  181950:	21 d0                	and    %edx,%eax
  181952:	a3 18 00 80 b0       	mov    %eax,0xb0800018
	SOC_WATCH_LOG_EVENT(SOCW_EVENT_REGISTER,
			    SOCW_REG_CCU_PERIPH_CLK_GATE_CTL);
#endif /* HAS_SW_SOCWATCH */

	return 0;
}
  181957:	b8 00 00 00 00       	mov    $0x0,%eax
  18195c:	c3                   	ret    

0018195d <qm_wdt_0_isr>:
};
#endif /* UNIT_TEST */

QM_ISR_DECLARE(qm_wdt_0_isr)
{
	if (callback[QM_WDT_0]) {
  18195d:	8b 15 c0 02 28 00    	mov    0x2802c0,%edx
  181963:	85 d2                	test   %edx,%edx
  181965:	74 07                	je     18196e <qm_wdt_0_isr+0x11>
		callback[QM_WDT_0](callback_data[QM_WDT_0]);
  181967:	a1 bc 02 28 00       	mov    0x2802bc,%eax
  18196c:	ff d2                	call   *%edx
	}

	/* Clear the interrupt by reading. */
	QM_WDT[QM_WDT_0]->wdt_eoi;
  18196e:	a1 18 00 28 00       	mov    0x280018,%eax
  181973:	8b 40 14             	mov    0x14(%eax),%eax
  181976:	c3                   	ret    

00181977 <qm_wdt_reload>:
	/*
	 * This register is used to restart the WDT counter. As a safety feature
	 * to prevent accidental restarts the value 0x76 must be written.
	 * A restart also clears the WDT interrupt.
	 */
	QM_WDT[wdt]->wdt_crr = QM_WDT_RELOAD_VALUE;
  181977:	8b 04 85 18 00 28 00 	mov    0x280018(,%eax,4),%eax
  18197e:	c7 40 0c 76 00 00 00 	movl   $0x76,0xc(%eax)

	return 0;
}
  181985:	b8 00 00 00 00       	mov    $0x0,%eax
  18198a:	c3                   	ret    

0018198b <qm_wdt_start>:
	QM_ISR_EOI(QM_IRQ_WDT_1_INT_VECTOR);
}
#endif /* (NUM_WDT_CONTROLLERS > 1) */

int qm_wdt_start(const qm_wdt_t wdt)
{
  18198b:	53                   	push   %ebx
  18198c:	89 c3                	mov    %eax,%ebx
	QM_CHECK(wdt < QM_WDT_NUM, -EINVAL);

	QM_WDT[wdt]->wdt_cr |= QM_WDT_CR_WDT_ENABLE;
  18198e:	8b 14 85 18 00 28 00 	mov    0x280018(,%eax,4),%edx
  181995:	8b 02                	mov    (%edx),%eax
  181997:	83 c8 01             	or     $0x1,%eax
  18199a:	89 02                	mov    %eax,(%edx)

#if (HAS_WDT_CLOCK_ENABLE)
	clk_periph_enable(CLK_PERIPH_WDT_REGISTER | CLK_PERIPH_CLK);
  18199c:	b8 02 04 00 00       	mov    $0x402,%eax
  1819a1:	e8 8f ff ff ff       	call   181935 <clk_periph_enable>
	QM_SCSS_PERIPHERAL->periph_cfg0 |= BIT(1);
  1819a6:	a1 04 08 80 b0       	mov    0xb0800804,%eax
  1819ab:	83 c8 02             	or     $0x2,%eax
  1819ae:	a3 04 08 80 b0       	mov    %eax,0xb0800804
#endif /* HAS_WDT_CLOCK_ENABLE */

	qm_wdt_reload(wdt);
  1819b3:	89 d8                	mov    %ebx,%eax
  1819b5:	e8 bd ff ff ff       	call   181977 <qm_wdt_reload>

	return 0;
}
  1819ba:	b8 00 00 00 00       	mov    $0x0,%eax
  1819bf:	5b                   	pop    %ebx
  1819c0:	c3                   	ret    

001819c1 <qm_wdt_set_config>:

int qm_wdt_set_config(const qm_wdt_t wdt, const qm_wdt_config_t *const cfg)
{
  1819c1:	56                   	push   %esi
  1819c2:	53                   	push   %ebx
  1819c3:	89 c3                	mov    %eax,%ebx
  1819c5:	89 d6                	mov    %edx,%esi
	QM_CHECK(wdt < QM_WDT_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);
	QM_CHECK(cfg->timeout <= QM_WDT_TORR_TOP_MASK, -EINVAL);

	qm_wdt_reload(wdt);
  1819c7:	e8 ab ff ff ff       	call   181977 <qm_wdt_reload>

	if (cfg->mode == QM_WDT_MODE_INTERRUPT_RESET) {
  1819cc:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
  1819d0:	75 14                	jne    1819e6 <qm_wdt_set_config+0x25>
		callback[wdt] = cfg->callback;
  1819d2:	8b 46 08             	mov    0x8(%esi),%eax
  1819d5:	89 04 9d c0 02 28 00 	mov    %eax,0x2802c0(,%ebx,4)
		callback_data[wdt] = cfg->callback_data;
  1819dc:	8b 46 0c             	mov    0xc(%esi),%eax
  1819df:	89 04 9d bc 02 28 00 	mov    %eax,0x2802bc(,%ebx,4)
	}

	QM_WDT[wdt]->wdt_cr &= ~QM_WDT_CR_RMOD;
  1819e6:	8b 14 9d 18 00 28 00 	mov    0x280018(,%ebx,4),%edx
  1819ed:	8b 02                	mov    (%edx),%eax
  1819ef:	83 e0 fd             	and    $0xfffffffd,%eax
  1819f2:	89 02                	mov    %eax,(%edx)
	QM_WDT[wdt]->wdt_cr |= cfg->mode << QM_WDT_CR_RMOD_OFFSET;
  1819f4:	8b 14 9d 18 00 28 00 	mov    0x280018(,%ebx,4),%edx
  1819fb:	8b 0a                	mov    (%edx),%ecx
  1819fd:	8b 46 04             	mov    0x4(%esi),%eax
  181a00:	01 c0                	add    %eax,%eax
  181a02:	09 c8                	or     %ecx,%eax
  181a04:	89 02                	mov    %eax,(%edx)
	/*
	 * Timeout range register. Select the timeout from the pre-defined
	 * tables. These tables can be found in the SoC databook or register
	 * file.
	 */
	QM_WDT[wdt]->wdt_torr = cfg->timeout;
  181a06:	8b 04 9d 18 00 28 00 	mov    0x280018(,%ebx,4),%eax
  181a0d:	8b 16                	mov    (%esi),%edx
  181a0f:	89 50 04             	mov    %edx,0x4(%eax)

	/* kick the WDT to load the Timeout Period(TOP) value */
	qm_wdt_reload(wdt);
  181a12:	89 d8                	mov    %ebx,%eax
  181a14:	e8 5e ff ff ff       	call   181977 <qm_wdt_reload>

	return 0;
}
  181a19:	b8 00 00 00 00       	mov    $0x0,%eax
  181a1e:	5b                   	pop    %ebx
  181a1f:	5e                   	pop    %esi
  181a20:	c3                   	ret    

00181a21 <qm_uart_set_config>:
	qm_uart_isr_handler(QM_UART_1);
	QM_ISR_EOI(QM_IRQ_UART_1_INT_VECTOR);
}

int qm_uart_set_config(const qm_uart_t uart, const qm_uart_config_t *cfg)
{
  181a21:	83 ec 04             	sub    $0x4,%esp
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(cfg != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181a24:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
	volatile uint32_t unused_lsr __attribute__((unused));

	/* Clear DLAB by unsetting line parameters */
	regs->lcr = 0;
  181a2b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/* Set divisor latch registers (integer + fractional part) */
	regs->lcr = QM_UART_LCR_DLAB;
  181a32:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
	regs->ier_dlh = QM_UART_CFG_BAUD_DLH_UNPACK(cfg->baud_divisor);
  181a39:	8b 4a 04             	mov    0x4(%edx),%ecx
  181a3c:	81 e1 00 00 ff 00    	and    $0xff0000,%ecx
  181a42:	c1 e9 10             	shr    $0x10,%ecx
  181a45:	89 48 04             	mov    %ecx,0x4(%eax)
	regs->rbr_thr_dll = QM_UART_CFG_BAUD_DLL_UNPACK(cfg->baud_divisor);
  181a48:	8b 4a 04             	mov    0x4(%edx),%ecx
  181a4b:	0f b6 cd             	movzbl %ch,%ecx
  181a4e:	89 08                	mov    %ecx,(%eax)
	regs->dlf = QM_UART_CFG_BAUD_DLF_UNPACK(cfg->baud_divisor);
  181a50:	0f b6 4a 04          	movzbl 0x4(%edx),%ecx
  181a54:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%eax)

	/* Set line parameters. This also unsets the DLAB */
	regs->lcr = cfg->line_control;
  181a5a:	8b 0a                	mov    (%edx),%ecx
  181a5c:	89 48 0c             	mov    %ecx,0xc(%eax)

	/* Hardware automatic flow control */
	regs->mcr = 0;
  181a5f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	if (true == cfg->hw_fc) {
  181a66:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  181a6a:	74 09                	je     181a75 <qm_uart_set_config+0x54>
		regs->mcr |= QM_UART_MCR_AFCE | QM_UART_MCR_RTS;
  181a6c:	8b 50 10             	mov    0x10(%eax),%edx
  181a6f:	83 ca 22             	or     $0x22,%edx
  181a72:	89 50 10             	mov    %edx,0x10(%eax)
	}

	/* FIFO's enable and reset, set interrupt threshold */
	regs->iir_fcr =
  181a75:	c7 40 08 b7 00 00 00 	movl   $0xb7,0x8(%eax)
	    (QM_UART_FCR_FIFOE | QM_UART_FCR_RFIFOR | QM_UART_FCR_XFIFOR |
	     QM_UART_FCR_DEFAULT_TX_RX_THRESHOLD);
	regs->ier_dlh |= QM_UART_IER_PTIME;
  181a7c:	8b 50 04             	mov    0x4(%eax),%edx
  181a7f:	80 ca 80             	or     $0x80,%dl
  181a82:	89 50 04             	mov    %edx,0x4(%eax)

	/* Clear LSR */
	unused_lsr = regs->lsr;
  181a85:	8b 40 14             	mov    0x14(%eax),%eax
  181a88:	89 04 24             	mov    %eax,(%esp)

	return 0;
}
  181a8b:	b8 00 00 00 00       	mov    $0x0,%eax
  181a90:	83 c4 04             	add    $0x4,%esp
  181a93:	c3                   	ret    

00181a94 <qm_uart_get_status>:

int qm_uart_get_status(const qm_uart_t uart, qm_uart_status_t *const status)
{
  181a94:	56                   	push   %esi
  181a95:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(status != NULL, -EINVAL);
	qm_uart_reg_t *const regs = QM_UART[uart];
  181a96:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax
	uint32_t lsr = regs->lsr;
  181a9d:	8b 48 14             	mov    0x14(%eax),%ecx

	*status = (lsr & (QM_UART_LSR_OE | QM_UART_LSR_PE | QM_UART_LSR_FE |
  181aa0:	89 cb                	mov    %ecx,%ebx
  181aa2:	83 e3 1e             	and    $0x1e,%ebx
  181aa5:	89 1a                	mov    %ebx,(%edx)

	/*
	 * Check as an IRQ TX completed, if so, the Shift register may still be
	 * busy.
	 */
	if (regs->scr & BIT(0)) {
  181aa7:	8b 70 1c             	mov    0x1c(%eax),%esi
  181aaa:	f7 c6 01 00 00 00    	test   $0x1,%esi
  181ab0:	74 0b                	je     181abd <qm_uart_get_status+0x29>
		regs->scr &= ~BIT(0);
  181ab2:	8b 58 1c             	mov    0x1c(%eax),%ebx
  181ab5:	83 e3 fe             	and    $0xfffffffe,%ebx
  181ab8:	89 58 1c             	mov    %ebx,0x1c(%eax)
  181abb:	eb 0a                	jmp    181ac7 <qm_uart_get_status+0x33>
	} else if (!(lsr & (QM_UART_LSR_TEMT))) {
  181abd:	f6 c1 40             	test   $0x40,%cl
  181ac0:	75 05                	jne    181ac7 <qm_uart_get_status+0x33>
		*status |= QM_UART_TX_BUSY;
  181ac2:	83 cb 20             	or     $0x20,%ebx
  181ac5:	89 1a                	mov    %ebx,(%edx)
	}

	if (lsr & QM_UART_LSR_DR) {
  181ac7:	f6 c1 01             	test   $0x1,%cl
  181aca:	74 03                	je     181acf <qm_uart_get_status+0x3b>
		*status |= QM_UART_RX_BUSY;
  181acc:	83 0a 40             	orl    $0x40,(%edx)
	}

	return 0;
}
  181acf:	b8 00 00 00 00       	mov    $0x0,%eax
  181ad4:	5b                   	pop    %ebx
  181ad5:	5e                   	pop    %esi
  181ad6:	c3                   	ret    

00181ad7 <qm_uart_write>:

int qm_uart_write(const qm_uart_t uart, const uint8_t data)
{
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181ad7:	8b 04 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%eax

	while (regs->lsr & QM_UART_LSR_THRE) {
  181ade:	8b 48 14             	mov    0x14(%eax),%ecx
  181ae1:	f6 c1 20             	test   $0x20,%cl
  181ae4:	75 f8                	jne    181ade <qm_uart_write+0x7>
	}
	regs->rbr_thr_dll = data;
  181ae6:	0f b6 d2             	movzbl %dl,%edx
  181ae9:	89 10                	mov    %edx,(%eax)
	/* Wait for transaction to complete. */
	while (!(regs->lsr & QM_UART_LSR_TEMT)) {
  181aeb:	8b 50 14             	mov    0x14(%eax),%edx
  181aee:	f6 c2 40             	test   $0x40,%dl
  181af1:	74 f8                	je     181aeb <qm_uart_write+0x14>
	}

	return 0;
}
  181af3:	b8 00 00 00 00       	mov    $0x0,%eax
  181af8:	c3                   	ret    

00181af9 <qm_uart_read>:

int qm_uart_read(const qm_uart_t uart, uint8_t *const data,
		 qm_uart_status_t *status)
{
  181af9:	53                   	push   %ebx
	QM_CHECK(uart < QM_UART_NUM, -EINVAL);
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];
  181afa:	8b 1c 85 1c 00 28 00 	mov    0x28001c(,%eax,4),%ebx

	uint32_t lsr = regs->lsr;
  181b01:	8b 43 14             	mov    0x14(%ebx),%eax
	while (!(lsr & QM_UART_LSR_DR)) {
  181b04:	eb 03                	jmp    181b09 <qm_uart_read+0x10>
		lsr = regs->lsr;
  181b06:	8b 43 14             	mov    0x14(%ebx),%eax
	QM_CHECK(data != NULL, -EINVAL);

	qm_uart_reg_t *const regs = QM_UART[uart];

	uint32_t lsr = regs->lsr;
	while (!(lsr & QM_UART_LSR_DR)) {
  181b09:	a8 01                	test   $0x1,%al
  181b0b:	74 f9                	je     181b06 <qm_uart_read+0xd>
		lsr = regs->lsr;
	}
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
  181b0d:	83 e0 1e             	and    $0x1e,%eax
  181b10:	74 0d                	je     181b1f <qm_uart_read+0x26>
		if (status) {
  181b12:	85 c9                	test   %ecx,%ecx
  181b14:	74 14                	je     181b2a <qm_uart_read+0x31>
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
  181b16:	89 01                	mov    %eax,(%ecx)
		}
		return -EIO;
  181b18:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  181b1d:	eb 10                	jmp    181b2f <qm_uart_read+0x36>
	}
	*data = regs->rbr_thr_dll;
  181b1f:	8b 03                	mov    (%ebx),%eax
  181b21:	88 02                	mov    %al,(%edx)

	return 0;
  181b23:	b8 00 00 00 00       	mov    $0x0,%eax
  181b28:	eb 05                	jmp    181b2f <qm_uart_read+0x36>
	/* Check if there are any errors on the line. */
	if (lsr & QM_UART_LSR_ERROR_BITS) {
		if (status) {
			*status = (lsr & QM_UART_LSR_ERROR_BITS);
		}
		return -EIO;
  181b2a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
	}
	*data = regs->rbr_thr_dll;

	return 0;
}
  181b2f:	5b                   	pop    %ebx
  181b30:	c3                   	ret    

00181b31 <pin_to_register>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The register index of the given pin.
 */
static uint32_t pin_to_register(uint32_t pin, uint32_t width)
{
  181b31:	56                   	push   %esi
  181b32:	53                   	push   %ebx
  181b33:	89 c3                	mov    %eax,%ebx
  181b35:	89 d6                	mov    %edx,%esi
	return (pin / (32 / width));
  181b37:	b8 20 00 00 00       	mov    $0x20,%eax
  181b3c:	ba 00 00 00 00       	mov    $0x0,%edx
  181b41:	f7 f6                	div    %esi
  181b43:	89 c1                	mov    %eax,%ecx
  181b45:	89 d8                	mov    %ebx,%eax
  181b47:	ba 00 00 00 00       	mov    $0x0,%edx
  181b4c:	f7 f1                	div    %ecx
}
  181b4e:	5b                   	pop    %ebx
  181b4f:	5e                   	pop    %esi
  181b50:	c3                   	ret    

00181b51 <pin_to_offset>:
 * @param[in] width The width in bits for each pin in the register.
 *
 * @return The offset for the pin within the register.
 */
static uint32_t pin_to_offset(uint32_t pin, uint32_t width)
{
  181b51:	56                   	push   %esi
  181b52:	53                   	push   %ebx
  181b53:	89 c6                	mov    %eax,%esi
  181b55:	89 d3                	mov    %edx,%ebx
	return ((pin % (32 / width)) * width);
  181b57:	b8 20 00 00 00       	mov    $0x20,%eax
  181b5c:	ba 00 00 00 00       	mov    $0x0,%edx
  181b61:	f7 f3                	div    %ebx
  181b63:	89 c1                	mov    %eax,%ecx
  181b65:	89 f0                	mov    %esi,%eax
  181b67:	ba 00 00 00 00       	mov    $0x0,%edx
  181b6c:	f7 f1                	div    %ecx
  181b6e:	89 d8                	mov    %ebx,%eax
  181b70:	0f af c2             	imul   %edx,%eax
}
  181b73:	5b                   	pop    %ebx
  181b74:	5e                   	pop    %esi
  181b75:	c3                   	ret    

00181b76 <qm_pmux_select>:

int qm_pmux_select(const qm_pin_id_t pin, const qm_pmux_fn_t fn)
{
  181b76:	57                   	push   %edi
  181b77:	56                   	push   %esi
  181b78:	53                   	push   %ebx
  181b79:	89 c7                	mov    %eax,%edi
  181b7b:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);
	QM_CHECK(fn <= QM_PMUX_FN_3, -EINVAL);

	uint32_t reg = pin_to_register(pin, 2);
  181b7d:	ba 02 00 00 00       	mov    $0x2,%edx
  181b82:	e8 aa ff ff ff       	call   181b31 <pin_to_register>
  181b87:	89 c3                	mov    %eax,%ebx
	uint32_t offs = pin_to_offset(pin, 2);
  181b89:	ba 02 00 00 00       	mov    $0x2,%edx
  181b8e:	89 f8                	mov    %edi,%eax
  181b90:	e8 bc ff ff ff       	call   181b51 <pin_to_offset>
  181b95:	89 c1                	mov    %eax,%ecx

	QM_SCSS_PMUX->pmux_sel[reg] &= ~(MASK_2BIT << offs);
  181b97:	83 c3 0c             	add    $0xc,%ebx
  181b9a:	8b 3c 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%edi
  181ba1:	ba 03 00 00 00       	mov    $0x3,%edx
  181ba6:	d3 e2                	shl    %cl,%edx
  181ba8:	f7 d2                	not    %edx
  181baa:	21 fa                	and    %edi,%edx
  181bac:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	QM_SCSS_PMUX->pmux_sel[reg] |= (fn << offs);
  181bb3:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181bba:	d3 e6                	shl    %cl,%esi
  181bbc:	09 c6                	or     %eax,%esi
  181bbe:	89 34 9d 00 09 80 b0 	mov    %esi,-0x4f7ff700(,%ebx,4)

	return 0;
}
  181bc5:	b8 00 00 00 00       	mov    $0x0,%eax
  181bca:	5b                   	pop    %ebx
  181bcb:	5e                   	pop    %esi
  181bcc:	5f                   	pop    %edi
  181bcd:	c3                   	ret    

00181bce <qm_pmux_input_en>:
	}
	return 0;
}

int qm_pmux_input_en(const qm_pin_id_t pin, const bool enable)
{
  181bce:	57                   	push   %edi
  181bcf:	56                   	push   %esi
  181bd0:	53                   	push   %ebx
  181bd1:	89 c7                	mov    %eax,%edi
  181bd3:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  181bd5:	ba 01 00 00 00       	mov    $0x1,%edx
  181bda:	e8 52 ff ff ff       	call   181b31 <pin_to_register>
  181bdf:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  181be1:	ba 01 00 00 00       	mov    $0x1,%edx
  181be6:	89 f8                	mov    %edi,%eax
  181be8:	e8 64 ff ff ff       	call   181b51 <pin_to_offset>
  181bed:	ba 01 00 00 00       	mov    $0x1,%edx
  181bf2:	88 c1                	mov    %al,%cl
  181bf4:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  181bf6:	89 f0                	mov    %esi,%eax
  181bf8:	84 c0                	test   %al,%al
  181bfa:	75 17                	jne    181c13 <qm_pmux_input_en+0x45>
		QM_SCSS_PMUX->pmux_in_en[reg] &= ~mask;
  181bfc:	83 c3 08             	add    $0x8,%ebx
  181bff:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181c06:	f7 d2                	not    %edx
  181c08:	21 c2                	and    %eax,%edx
  181c0a:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  181c11:	eb 13                	jmp    181c26 <qm_pmux_input_en+0x58>
	} else {
		QM_SCSS_PMUX->pmux_in_en[reg] |= mask;
  181c13:	83 c3 08             	add    $0x8,%ebx
  181c16:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181c1d:	09 c2                	or     %eax,%edx
  181c1f:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  181c26:	b8 00 00 00 00       	mov    $0x0,%eax
  181c2b:	5b                   	pop    %ebx
  181c2c:	5e                   	pop    %esi
  181c2d:	5f                   	pop    %edi
  181c2e:	c3                   	ret    

00181c2f <qm_pmux_pullup_en>:

int qm_pmux_pullup_en(const qm_pin_id_t pin, const bool enable)
{
  181c2f:	57                   	push   %edi
  181c30:	56                   	push   %esi
  181c31:	53                   	push   %ebx
  181c32:	89 c7                	mov    %eax,%edi
  181c34:	89 d6                	mov    %edx,%esi
	QM_CHECK(pin < QM_PIN_ID_NUM, -EINVAL);

	uint32_t reg = pin_to_register(pin, 1);
  181c36:	ba 01 00 00 00       	mov    $0x1,%edx
  181c3b:	e8 f1 fe ff ff       	call   181b31 <pin_to_register>
  181c40:	89 c3                	mov    %eax,%ebx
	uint32_t mask = MASK_1BIT << pin_to_offset(pin, 1);
  181c42:	ba 01 00 00 00       	mov    $0x1,%edx
  181c47:	89 f8                	mov    %edi,%eax
  181c49:	e8 03 ff ff ff       	call   181b51 <pin_to_offset>
  181c4e:	ba 01 00 00 00       	mov    $0x1,%edx
  181c53:	88 c1                	mov    %al,%cl
  181c55:	d3 e2                	shl    %cl,%edx

	if (enable == false) {
  181c57:	89 f0                	mov    %esi,%eax
  181c59:	84 c0                	test   %al,%al
  181c5b:	75 14                	jne    181c71 <qm_pmux_pullup_en+0x42>
		QM_SCSS_PMUX->pmux_pullup[reg] &= ~mask;
  181c5d:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181c64:	f7 d2                	not    %edx
  181c66:	21 c2                	and    %eax,%edx
  181c68:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
  181c6f:	eb 10                	jmp    181c81 <qm_pmux_pullup_en+0x52>
	} else {
		QM_SCSS_PMUX->pmux_pullup[reg] |= mask;
  181c71:	8b 04 9d 00 09 80 b0 	mov    -0x4f7ff700(,%ebx,4),%eax
  181c78:	09 c2                	or     %eax,%edx
  181c7a:	89 14 9d 00 09 80 b0 	mov    %edx,-0x4f7ff700(,%ebx,4)
	}
	return 0;
}
  181c81:	b8 00 00 00 00       	mov    $0x0,%eax
  181c86:	5b                   	pop    %ebx
  181c87:	5e                   	pop    %esi
  181c88:	5f                   	pop    %edi
  181c89:	c3                   	ret    

00181c8a <k_cpu_idle>:
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _tsc_read();
#endif

	__asm__ volatile (
  181c8a:	fb                   	sti    
  181c8b:	f4                   	hlt    
  181c8c:	c3                   	ret    

00181c8d <_SysFatalErrorHandler>:
{
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
  181c8d:	e8 df 0c 00 00       	call   182971 <k_is_in_isr>
  181c92:	85 c0                	test   %eax,%eax
  181c94:	75 09                	jne    181c9f <_SysFatalErrorHandler+0x12>
  181c96:	e8 e4 0c 00 00       	call   18297f <_is_thread_essential>
  181c9b:	85 c0                	test   %eax,%eax
  181c9d:	74 25                	je     181cc4 <_SysFatalErrorHandler+0x37>
		printk("Fatal fault in %s! Spinning...\n",
		       k_is_in_isr() ? "ISR" : "essential thread");
  181c9f:	e8 cd 0c 00 00       	call   182971 <k_is_in_isr>
	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

#if !defined(CONFIG_SIMPLE_FATAL_ERROR_HANDLER)
	if (k_is_in_isr() || _is_thread_essential()) {
		printk("Fatal fault in %s! Spinning...\n",
  181ca4:	85 c0                	test   %eax,%eax
  181ca6:	74 07                	je     181caf <_SysFatalErrorHandler+0x22>
  181ca8:	b8 70 32 18 00       	mov    $0x183270,%eax
  181cad:	eb 05                	jmp    181cb4 <_SysFatalErrorHandler+0x27>
  181caf:	b8 74 32 18 00       	mov    $0x183274,%eax
  181cb4:	50                   	push   %eax
  181cb5:	68 c4 32 18 00       	push   $0x1832c4
  181cba:	e8 01 fc ff ff       	call   1818c0 <printk>
  181cbf:	83 c4 08             	add    $0x8,%esp
  181cc2:	eb fe                	jmp    181cc2 <_SysFatalErrorHandler+0x35>
		       k_is_in_isr() ? "ISR" : "essential thread");
		for (;;)
			; /* spin forever */
	}
	printk("Fatal fault in thread %p! Aborting.\n", _current);
  181cc4:	ff 35 e8 02 28 00    	pushl  0x2802e8
  181cca:	68 e4 32 18 00       	push   $0x1832e4
  181ccf:	e8 ec fb ff ff       	call   1818c0 <printk>
  181cd4:	83 c4 08             	add    $0x8,%esp
	k_thread_abort(_current);
  181cd7:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  181cdc:	e8 e8 0e 00 00       	call   182bc9 <k_thread_abort>

00181ce1 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  181ce1:	53                   	push   %ebx
	movl $1, %eax
  181ce2:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  181ce7:	0f a2                	cpuid  
	movl %ebx, %eax
  181ce9:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  181ceb:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  181cf0:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  181cf3:	5b                   	pop    %ebx
	ret
  181cf4:	c3                   	ret    

00181cf5 <init_cache_line_size>:

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  181cf5:	e8 e7 ff ff ff       	call   181ce1 <_cache_line_size_get>
  181cfa:	a3 0c 04 28 00       	mov    %eax,0x28040c
  181cff:	c3                   	ret    

00181d00 <init_cache>:
static int init_cache(struct device *unused)
{
	ARG_UNUSED(unused);

	init_cache_flush();
	init_cache_line_size();
  181d00:	e8 f0 ff ff ff       	call   181cf5 <init_cache_line_size>

	return 0;
}
  181d05:	b8 00 00 00 00       	mov    $0x0,%eax
  181d0a:	c3                   	ret    

00181d0b <_exception_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  181d0b:	fc                   	cld    


	/*
	 * Swap ecx and handler function on the current stack;
	 */
	xchgl	%ecx, (%esp)
  181d0c:	87 0c 24             	xchg   %ecx,(%esp)

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  181d0f:	50                   	push   %eax
	pushl	%edx
  181d10:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  181d11:	57                   	push   %edi
	pushl	%esi
  181d12:	56                   	push   %esi
	pushl	%ebx
  181d13:	53                   	push   %ebx
	pushl	%ebp
  181d14:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  181d15:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  181d19:	50                   	push   %eax

	/* ESP is pointing to the ESF at this point */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %edx
  181d1a:	8b 15 e8 02 28 00    	mov    0x2802e8,%edx

	/* inc exception nest count */
	incl	_thread_offset_to_excNestCount(%edx)
  181d20:	ff 42 44             	incl   0x44(%edx)
     * the current execution context if this is the outermost exception.
     * The ESF pointer is used by debug tools to locate the volatile
     * registers and the stack of the preempted thread.
     */

	testb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  181d23:	f6 42 09 40          	testb  $0x40,0x9(%edx)
	jne	alreadyInException
  181d27:	75 03                	jne    181d2c <alreadyInException>
	movl	%esp, _thread_offset_to_esf(%edx)
  181d29:	89 62 40             	mov    %esp,0x40(%edx)

00181d2c <alreadyInException>:
	 * (where needed) if the exception handler causes a context switch.
	 * It also indicates to debug tools that an exception is being
	 * handled in the event of a context switch.
	 */

	orb	$_EXC_ACTIVE, _thread_offset_to_thread_state(%edx)
  181d2c:	80 4a 09 40          	orb    $0x40,0x9(%edx)
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  181d30:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  181d37:	00 
	je	allDone
  181d38:	74 01                	je     181d3b <allDone>
	sti
  181d3a:	fb                   	sti    

00181d3b <allDone>:

allDone:
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
  181d3b:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	call	*%ecx			/* call exception handler */
  181d3d:	ff d1                	call   *%ecx
	addl	$0x4, %esp
#endif

#if defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO)

	movl	_kernel + _kernel_offset_to_current, %ecx
  181d3f:	8b 0d e8 02 28 00    	mov    0x2802e8,%ecx
	 * Must lock interrupts to prevent outside interference.
	 * (Using "lock" prefix would be nicer, but this won't work
	 * on platforms that don't respect the CPU's bus lock signal.)
	 */

	cli
  181d45:	fa                   	cli    

	/*
	 * Determine whether exiting from a nested interrupt.
	 */

	decl	_thread_offset_to_excNestCount(%ecx)
  181d46:	ff 49 44             	decl   0x44(%ecx)

	cmpl	$0, _thread_offset_to_excNestCount(%ecx)
  181d49:	83 79 44 00          	cmpl   $0x0,0x44(%ecx)
	jne	nestedException
  181d4d:	75 04                	jne    181d53 <nestedException>
	 * Clear the _EXC_ACTIVE bit in the k_thread of the current execution
	 * context if we are not in a nested exception (ie, when we exit the
	 * outermost exception).
	 */

	andb	$~_EXC_ACTIVE, _thread_offset_to_thread_state(%ecx)
  181d4f:	80 61 09 bf          	andb   $0xbf,0x9(%ecx)

00181d53 <nestedException>:
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  181d53:	5d                   	pop    %ebp
	popl	%ebp
  181d54:	5d                   	pop    %ebp
	popl	%ebx
  181d55:	5b                   	pop    %ebx
	popl	%esi
  181d56:	5e                   	pop    %esi
	popl	%edi
  181d57:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  181d58:	5a                   	pop    %edx
	popl	%eax
  181d59:	58                   	pop    %eax
	popl	%ecx
  181d5a:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  181d5b:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181d5e:	cf                   	iret   

00181d5f <_interrupt_enter>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  181d5f:	fc                   	cld    

	/*
	 * Swap EAX with isr_param and EDX with isr.
	 * Push ECX onto the stack
	 */
	xchgl	%eax, 4(%esp)
  181d60:	87 44 24 04          	xchg   %eax,0x4(%esp)
	xchgl	%edx, (%esp)
  181d64:	87 14 24             	xchg   %edx,(%esp)
	pushl	%ecx
  181d67:	51                   	push   %ecx

	/* Push EDI as we will use it for scratch space.
	 * Rest of the callee-saved regs get saved by invocation of C
	 * functions (isr handler, _Swap(), etc)
	 */
	pushl	%edi
  181d68:	57                   	push   %edi
	popl	%eax
#endif

	/* load %ecx with &_kernel */

	movl	$_kernel, %ecx
  181d69:	b9 e0 02 28 00       	mov    $0x2802e0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	_kernel_offset_to_nested(%ecx)
  181d6e:	ff 01                	incl   (%ecx)

	/* use interrupt stack if not nested */
	cmpl	$1, _kernel_offset_to_nested(%ecx)
  181d70:	83 39 01             	cmpl   $0x1,(%ecx)
#ifdef CONFIG_DEBUG_INFO
	jne	nested_save_isf
#else
	jne	alreadyOnIntStack
  181d73:	75 06                	jne    181d7b <alreadyOnIntStack>
	/*
	 * switch to base of the interrupt stack: save esp in edi, then load
	 * irq_stack pointer
	 */

	movl	%esp, %edi
  181d75:	89 e7                	mov    %esp,%edi
	movl	_kernel_offset_to_irq_stack(%ecx), %esp
  181d77:	8b 61 04             	mov    0x4(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edi			/* Save stack pointer */
  181d7a:	57                   	push   %edi

00181d7b <alreadyOnIntStack>:
	 * stack for sys V calling convention
	 */
	push	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  181d7b:	fb                   	sti    
#endif
	/* Now call the interrupt handler */
	call	*%edx
  181d7c:	ff d2                	call   *%edx
#ifndef CONFIG_X86_IAMCU
	/* Discard ISR argument */
	addl	$0x4, %esp
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	cli			/* disable interrupts again */
  181d7e:	fa                   	cli    
#endif

	/* irq_controller.h interface */
	_irq_controller_eoi_macro
  181d7f:	31 c0                	xor    %eax,%eax
  181d81:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */
	movl	$_kernel, %ecx
  181d86:	b9 e0 02 28 00       	mov    $0x2802e0,%ecx
#ifdef CONFIG_DEBUG_INFO
	popl	_kernel_offset_to_isf(%ecx)    /* Restore old ISF */
#endif
	decl	_kernel_offset_to_nested(%ecx)	/* dec interrupt nest count */
  181d8b:	ff 09                	decl   (%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  181d8d:	75 2b                	jne    181dba <nestedInterrupt>


#ifdef CONFIG_PREEMPT_ENABLED
	movl	_kernel_offset_to_current(%ecx), %edx
  181d8f:	8b 51 08             	mov    0x8(%ecx),%edx

	/*
	 * Non-preemptible thread ? Do not schedule (see explanation of
	 * preempt field in kernel_struct.h).
	 */
	cmpw	$_NON_PREEMPT_THRESHOLD, _thread_offset_to_preempt(%edx)
  181d92:	66 81 7a 0a 80 00    	cmpw   $0x80,0xa(%edx)
	jae	noReschedule
  181d98:	73 1f                	jae    181db9 <noReschedule>


	/* reschedule only if the scheduler says that we must do so */
	cmpl	%edx, _kernel_offset_to_ready_q_cache(%ecx)
  181d9a:	39 51 14             	cmp    %edx,0x14(%ecx)
	je	noReschedule
  181d9d:	74 1a                	je     181db9 <noReschedule>
	 * preserved using the lazy save/restore algorithm, or to indicate to
	 * debug tools that a preemptive context switch has occurred.
	 */

#if defined(CONFIG_FP_SHARING) ||  defined(CONFIG_GDB_INFO)
	orb	$_INT_ACTIVE, _thread_offset_to_thread_state(%edx)
  181d9f:	80 4a 09 80          	orb    $0x80,0x9(%edx)
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp	/* switch back to outgoing thread's stack */
  181da3:	5c                   	pop    %esp
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif

	pushfl			/* push KERNEL_LOCK_KEY argument */
  181da4:	9c                   	pushf  
#ifdef CONFIG_X86_IAMCU
	/* IAMCU first argument goes into a register, not the stack.
	 */
	popl	%eax
  181da5:	58                   	pop    %eax
#endif
	call	_Swap
  181da6:	e8 30 00 00 00       	call   181ddb <_Swap>
	 * _Swap() has restored the floating point registers, if needed.
	 * Clear the _INT_ACTIVE bit in the interrupted thread's state
	 * since it has served its purpose.
	 */

	movl	_kernel + _kernel_offset_to_current, %eax
  181dab:	a1 e8 02 28 00       	mov    0x2802e8,%eax
	andb	$~_INT_ACTIVE, _thread_offset_to_thread_state(%eax)
  181db0:	80 60 09 7f          	andb   $0x7f,0x9(%eax)

	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edi
  181db4:	5f                   	pop    %edi
	popl	%ecx
  181db5:	59                   	pop    %ecx
	popl	%edx
  181db6:	5a                   	pop    %edx
	popl	%eax
  181db7:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181db8:	cf                   	iret   

00181db9 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  181db9:	5c                   	pop    %esp

00181dba <nestedInterrupt>:
	popl	%ebp        /* Discard saved ESP */
	popl	%ebp
	popl	%ebx
	popl	%esi
#endif
	popl	%edi
  181dba:	5f                   	pop    %edi
	popl	%ecx		/* pop volatile registers in reverse order */
  181dbb:	59                   	pop    %ecx
	popl	%edx
  181dbc:	5a                   	pop    %edx
	popl	%eax
  181dbd:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  181dbe:	cf                   	iret   

00181dbf <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  181dbf:	6a 00                	push   $0x0

00181dc1 <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  181dc1:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  181dc2:	50                   	push   %eax
	pushl %ecx
  181dc3:	51                   	push   %ecx
	pushl %edx
  181dc4:	52                   	push   %edx
	pushl %edi
  181dc5:	57                   	push   %edi
	pushl %esi
  181dc6:	56                   	push   %esi
	pushl %ebx
  181dc7:	53                   	push   %ebx
	pushl %ebp
  181dc8:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  181dc9:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  181dcd:	51                   	push   %ecx

#ifndef CONFIG_X86_IAMCU
	pushl	%esp			/* push cur stack pointer: pEsf arg */
#else
	mov	%esp, %edx
  181dce:	89 e2                	mov    %esp,%edx
#endif

	/* re-enable interrupts */
	sti
  181dd0:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */
#ifndef CONFIG_X86_IAMCU
	pushl	$_NANO_ERR_SPURIOUS_INT
#else
	movl	$_NANO_ERR_SPURIOUS_INT, %eax
  181dd1:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
	/* call the fatal error handler */
	call	_NanoFatalErrorHandler
  181dd6:	e8 d5 00 00 00       	call   181eb0 <_NanoFatalErrorHandler>

00181ddb <_Swap>:
SECTION_FUNC(TEXT, _Swap)
#ifdef CONFIG_X86_IAMCU
	/* save EFLAGS on stack right before return address, just as SYSV would
	 * have done
	 */
	pushl	0(%esp)
  181ddb:	ff 34 24             	pushl  (%esp)
	movl	%eax, 4(%esp)
  181dde:	89 44 24 04          	mov    %eax,0x4(%esp)
	 * any of these registers into the k_thread.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * k_thread.
	 */

	pushl	%edi
  181de2:	57                   	push   %edi

	movl	$_kernel, %edi
  181de3:	bf e0 02 28 00       	mov    $0x2802e0,%edi

	pushl	%esi
  181de8:	56                   	push   %esi
	pushl	%ebx
  181de9:	53                   	push   %ebx
	pushl	%ebp
  181dea:	55                   	push   %ebp
	 * -EAGAIN eliminates the need for the timeout code to set it.
	 * If another value is ever needed, it can be modified with
	 * _set_thread_return_value().
	 */

	pushl   _k_neg_eagain
  181deb:	ff 35 c4 34 18 00    	pushl  0x1834c4


	/* save esp into k_thread structure */

	movl	_kernel_offset_to_current(%edi), %ecx
  181df1:	8b 4f 08             	mov    0x8(%edi),%ecx
	movl	%esp, _thread_offset_to_esp(%ecx)
  181df4:	89 61 28             	mov    %esp,0x28(%ecx)

#ifdef CONFIG_KERNEL_EVENT_LOGGER_CONTEXT_SWITCH
	/* Register the context switch */
	call	_sys_k_event_logger_context_switch
#endif
	movl	_kernel_offset_to_ready_q_cache(%edi), %eax
  181df7:	8b 47 14             	mov    0x14(%edi),%eax

#endif /* CONFIG_FP_SHARING */

	/* update _kernel.current to reflect incoming thread */

	movl    %eax, _kernel_offset_to_current(%edi)
  181dfa:	89 47 08             	mov    %eax,0x8(%edi)

	/* recover task/fiber stack pointer from k_thread */

	movl	_thread_offset_to_esp(%eax), %esp
  181dfd:	8b 60 28             	mov    0x28(%eax),%esp


	/* load return value from a possible _set_thread_return_value() */

	popl	%eax
  181e00:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  181e01:	5d                   	pop    %ebp
	popl	%ebx
  181e02:	5b                   	pop    %ebx
	popl	%esi
  181e03:	5e                   	pop    %esi
	popl	%edi
  181e04:	5f                   	pop    %edi
	 * - in unified kernel, -EINVAL
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  181e05:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

skipIntLatencyStop:
#endif
	popfl
  181e09:	9d                   	popf   
#if CONFIG_X86_IAMCU
	/* Remember that eflags we stuck into the stack before the return
	 * address? need to get it out of there since the calling convention
	 * will not do that for us.
	 */
	popl	%edx
  181e0a:	5a                   	pop    %edx
	movl	%edx, (%esp)
  181e0b:	89 14 24             	mov    %edx,(%esp)
#endif
	ret
  181e0e:	c3                   	ret    

00181e0f <_new_thread_internal>:
 * @return N/A
 */
static void _new_thread_internal(char *pStackMem, unsigned stackSize,
				 int priority,
				 unsigned options)
{
  181e0f:	56                   	push   %esi
  181e10:	53                   	push   %ebx
  181e11:	89 c3                	mov    %eax,%ebx
  181e13:	89 d6                	mov    %edx,%esi
  181e15:	89 ca                	mov    %ecx,%edx
	unsigned long *pInitialCtx;
	/* ptr to the new task's k_thread */
	struct k_thread *thread = (struct k_thread *)pStackMem;

#if (defined(CONFIG_FP_SHARING) || defined(CONFIG_GDB_INFO))
	thread->arch.excNestCount = 0;
  181e17:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */

	_init_thread_base(&thread->base, priority, _THREAD_PRESTART, options);
  181e1e:	ff 74 24 0c          	pushl  0xc(%esp)
  181e22:	b9 04 00 00 00       	mov    $0x4,%ecx
  181e27:	e8 6d 0d 00 00       	call   182b99 <_init_thread_base>
  181e2c:	83 c4 04             	add    $0x4,%esp

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
  181e2f:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
	thread->fn_abort = NULL;
  181e36:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
	 * the base address of the stack which is past the initial stack frame.
	 * Therefore some of the calculations done in the other routines that
	 * initialize the stack frame need to be repeated.
	 */

	pInitialCtx = (unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  181e3d:	8d 14 33             	lea    (%ebx,%esi,1),%edx
  181e40:	83 e2 fc             	and    $0xfffffffc,%edx
#ifdef CONFIG_THREAD_MONITOR
	/*
	 * In debug mode thread->entry give direct access to the thread entry
	 * and the corresponding parameters.
	 */
	thread->entry = (struct __thread_entry *)(pInitialCtx -
  181e43:	8d 42 c0             	lea    -0x40(%edx),%eax
  181e46:	89 43 34             	mov    %eax,0x34(%ebx)
	 *  - 4 thread entry routine parameters
	 *  - eflags
	 *  - eip (so that _Swap() "returns" to the entry point)
	 *  - edi, esi, ebx, ebp,  eax
	 */
	pInitialCtx -= 11;
  181e49:	83 ea 2c             	sub    $0x2c,%edx

	thread->callee_saved.esp = (unsigned long)pInitialCtx;
  181e4c:	89 53 28             	mov    %edx,0x28(%ebx)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  181e4f:	9c                   	pushf  
  181e50:	fa                   	cli    
  181e51:	58                   	pop    %eax
static ALWAYS_INLINE void thread_monitor_init(struct k_thread *thread)
{
	unsigned int key;

	key = irq_lock();
	thread->next_thread = _kernel.threads;
  181e52:	8b 15 fc 03 28 00    	mov    0x2803fc,%edx
  181e58:	89 53 38             	mov    %edx,0x38(%ebx)
	_kernel.threads = thread;
  181e5b:	89 1d fc 03 28 00    	mov    %ebx,0x2803fc
  181e61:	f6 c4 02             	test   $0x2,%ah
  181e64:	74 01                	je     181e67 <_new_thread_internal+0x58>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  181e66:	fb                   	sti    
	PRINTK("\nInitial context ESP = 0x%x\n", thread->coopReg.esp);

	PRINTK("\nstruct thread * = 0x%x", thread);

	thread_monitor_init(thread);
}
  181e67:	5b                   	pop    %ebx
  181e68:	5e                   	pop    %esi
  181e69:	c3                   	ret    

00181e6a <_new_thread>:
 */
void _new_thread(char *pStackMem, size_t stackSize,
		 _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  181e6a:	56                   	push   %esi
  181e6b:	53                   	push   %ebx
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
		(unsigned long *)STACK_ROUND_DOWN(pStackMem + stackSize);
  181e6c:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
  181e6f:	83 e3 fc             	and    $0xfffffffc,%ebx
	 * primitive.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  181e72:	8b 74 24 14          	mov    0x14(%esp),%esi
  181e76:	89 73 fc             	mov    %esi,-0x4(%ebx)
	*--pInitialThread = (unsigned long)parameter2;
  181e79:	8b 74 24 10          	mov    0x10(%esp),%esi
  181e7d:	89 73 f8             	mov    %esi,-0x8(%ebx)
	*--pInitialThread = (unsigned long)parameter1;
  181e80:	8b 74 24 0c          	mov    0xc(%esp),%esi
  181e84:	89 73 f4             	mov    %esi,-0xc(%ebx)
	*--pInitialThread = (unsigned long)pEntry;
  181e87:	89 4b f0             	mov    %ecx,-0x10(%ebx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  181e8a:	9c                   	pushf  
  181e8b:	59                   	pop    %ecx

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  181e8c:	80 e5 cd             	and    $0xcd,%ch
  181e8f:	80 cd 02             	or     $0x2,%ch
  181e92:	89 4b ec             	mov    %ecx,-0x14(%ebx)
	/*
	 * Arrange for the _thread_entry_wrapper() function to be called
	 * to adjust the stack before _thread_entry() is invoked.
	 */

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;
  181e95:	c7 43 e8 60 00 18 00 	movl   $0x180060,-0x18(%ebx)
	/*
	 * The k_thread structure is located at the "low end" of memory set
	 * aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
  181e9c:	ff 74 24 1c          	pushl  0x1c(%esp)
  181ea0:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  181ea4:	e8 66 ff ff ff       	call   181e0f <_new_thread_internal>
  181ea9:	83 c4 04             	add    $0x4,%esp
}
  181eac:	5b                   	pop    %ebx
  181ead:	5e                   	pop    %esi
  181eae:	c3                   	ret    

00181eaf <_debug_fatal_hook>:
#include <misc/printk.h>
#include <arch/x86/irq_controller.h>
#include <arch/x86/segmentation.h>
#include <exception.h>

__weak void _debug_fatal_hook(const NANO_ESF *esf) { ARG_UNUSED(esf); }
  181eaf:	c3                   	ret    

00181eb0 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  181eb0:	55                   	push   %ebp
  181eb1:	57                   	push   %edi
  181eb2:	56                   	push   %esi
  181eb3:	53                   	push   %ebx
  181eb4:	83 ec 24             	sub    $0x24,%esp
  181eb7:	89 c6                	mov    %eax,%esi
  181eb9:	89 d7                	mov    %edx,%edi
	_debug_fatal_hook(pEsf);
  181ebb:	89 d0                	mov    %edx,%eax
  181ebd:	e8 ed ff ff ff       	call   181eaf <_debug_fatal_hook>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  181ec2:	83 fe 03             	cmp    $0x3,%esi
  181ec5:	74 4c                	je     181f13 <_NanoFatalErrorHandler+0x63>
  181ec7:	83 fe 03             	cmp    $0x3,%esi
  181eca:	77 06                	ja     181ed2 <_NanoFatalErrorHandler+0x22>
  181ecc:	85 f6                	test   %esi,%esi
  181ece:	74 0e                	je     181ede <_NanoFatalErrorHandler+0x2e>
  181ed0:	eb 5f                	jmp    181f31 <_NanoFatalErrorHandler+0x81>
  181ed2:	83 fe 05             	cmp    $0x5,%esi
  181ed5:	74 4b                	je     181f22 <_NanoFatalErrorHandler+0x72>
  181ed7:	83 fe 06             	cmp    $0x6,%esi
  181eda:	74 63                	je     181f3f <_NanoFatalErrorHandler+0x8f>
  181edc:	eb 53                	jmp    181f31 <_NanoFatalErrorHandler+0x81>
 * @return the vector of the interrupt that is currently being processed, or
 * -1 if this can't be determined
 */
static inline int _irq_controller_isr_vector_get(void)
{
	return __irq_controller_isr_vector_get();
  181ede:	e8 22 e7 ff ff       	call   180605 <__irq_controller_isr_vector_get>
  181ee3:	89 c3                	mov    %eax,%ebx
		break;

	case _NANO_ERR_SPURIOUS_INT: {
		int vector = _irq_controller_isr_vector_get();

		printk("***** Unhandled interrupt vector ");
  181ee5:	68 0c 33 18 00       	push   $0x18330c
  181eea:	e8 d1 f9 ff ff       	call   1818c0 <printk>
  181eef:	83 c4 04             	add    $0x4,%esp
		if (vector >= 0) {
  181ef2:	85 db                	test   %ebx,%ebx
  181ef4:	78 0e                	js     181f04 <_NanoFatalErrorHandler+0x54>
			printk("%d ", vector);
  181ef6:	53                   	push   %ebx
  181ef7:	68 85 32 18 00       	push   $0x183285
  181efc:	e8 bf f9 ff ff       	call   1818c0 <printk>
  181f01:	83 c4 08             	add    $0x8,%esp
		}
		printk("*****\n");
  181f04:	68 89 32 18 00       	push   $0x183289
  181f09:	e8 b2 f9 ff ff       	call   1818c0 <printk>
  181f0e:	83 c4 04             	add    $0x4,%esp
		break;
  181f11:	eb 2c                	jmp    181f3f <_NanoFatalErrorHandler+0x8f>
	}
	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  181f13:	68 30 33 18 00       	push   $0x183330
  181f18:	e8 a3 f9 ff ff       	call   1818c0 <printk>
  181f1d:	83 c4 04             	add    $0x4,%esp
		break;
  181f20:	eb 1d                	jmp    181f3f <_NanoFatalErrorHandler+0x8f>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  181f22:	68 5c 33 18 00       	push   $0x18335c
  181f27:	e8 94 f9 ff ff       	call   1818c0 <printk>
  181f2c:	83 c4 04             	add    $0x4,%esp
		break;
  181f2f:	eb 0e                	jmp    181f3f <_NanoFatalErrorHandler+0x8f>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  181f31:	56                   	push   %esi
  181f32:	68 84 33 18 00       	push   $0x183384
  181f37:	e8 84 f9 ff ff       	call   1818c0 <printk>
  181f3c:	83 c4 08             	add    $0x8,%esp
		break;
	}

	printk("Current thread ID = %p\n"
  181f3f:	8b 6f 2c             	mov    0x2c(%edi),%ebp
  181f42:	8b 07                	mov    (%edi),%eax
  181f44:	89 04 24             	mov    %eax,(%esp)
  181f47:	8b 4f 04             	mov    0x4(%edi),%ecx
  181f4a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  181f4e:	8b 5f 10             	mov    0x10(%edi),%ebx
  181f51:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  181f55:	8b 57 0c             	mov    0xc(%edi),%edx
  181f58:	89 54 24 0c          	mov    %edx,0xc(%esp)
  181f5c:	8b 47 14             	mov    0x14(%edi),%eax
  181f5f:	89 44 24 10          	mov    %eax,0x10(%esp)
  181f63:	8b 4f 1c             	mov    0x1c(%edi),%ecx
  181f66:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  181f6a:	8b 5f 08             	mov    0x8(%edi),%ebx
  181f6d:	89 5c 24 18          	mov    %ebx,0x18(%esp)
  181f71:	8b 57 18             	mov    0x18(%edi),%edx
  181f74:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  181f78:	8b 47 24             	mov    0x24(%edi),%eax
  181f7b:	89 44 24 20          	mov    %eax,0x20(%esp)
	       "Faulting segment:address = 0x%x:0x%x\n"
	       "eax: 0x%x, ebx: 0x%x, ecx: 0x%x, edx: 0x%x\n"
	       "esi: 0x%x, edi: 0x%x, ebp: 0%x, esp: 0x%x\n"
	       "eflags: 0x%x\n",
	       k_current_get(),
	       pEsf->cs & 0xFFFF, pEsf->eip,
  181f7f:	8b 5f 28             	mov    0x28(%edi),%ebx
	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
		break;
	}

	printk("Current thread ID = %p\n"
  181f82:	e8 0f 06 00 00       	call   182596 <k_current_get>
  181f87:	55                   	push   %ebp
  181f88:	ff 74 24 04          	pushl  0x4(%esp)
  181f8c:	ff 74 24 0c          	pushl  0xc(%esp)
  181f90:	ff 74 24 14          	pushl  0x14(%esp)
  181f94:	ff 74 24 1c          	pushl  0x1c(%esp)
  181f98:	ff 74 24 24          	pushl  0x24(%esp)
  181f9c:	ff 74 24 2c          	pushl  0x2c(%esp)
  181fa0:	ff 74 24 34          	pushl  0x34(%esp)
  181fa4:	ff 74 24 3c          	pushl  0x3c(%esp)
  181fa8:	ff 74 24 44          	pushl  0x44(%esp)
  181fac:	0f b7 d3             	movzwl %bx,%edx
  181faf:	52                   	push   %edx
  181fb0:	50                   	push   %eax
  181fb1:	68 a8 33 18 00       	push   $0x1833a8
  181fb6:	e8 05 f9 ff ff       	call   1818c0 <printk>
  181fbb:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  181fbe:	89 fa                	mov    %edi,%edx
  181fc0:	89 f0                	mov    %esi,%eax
  181fc2:	e8 c6 fc ff ff       	call   181c8d <_SysFatalErrorHandler>

00181fc7 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  181fc7:	56                   	push   %esi
  181fc8:	53                   	push   %ebx
  181fc9:	89 c3                	mov    %eax,%ebx
  181fcb:	89 d6                	mov    %edx,%esi
	printk("***** CPU exception %d\n", vector);
  181fcd:	50                   	push   %eax
  181fce:	68 90 32 18 00       	push   $0x183290
  181fd3:	e8 e8 f8 ff ff       	call   1818c0 <printk>
  181fd8:	83 c4 08             	add    $0x8,%esp
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  181fdb:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  181fe0:	88 d9                	mov    %bl,%cl
  181fe2:	d3 f8                	sar    %cl,%eax
  181fe4:	a8 01                	test   $0x1,%al
  181fe6:	74 10                	je     181ff8 <generic_exc_handle+0x31>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  181fe8:	ff 76 20             	pushl  0x20(%esi)
  181feb:	68 a8 32 18 00       	push   $0x1832a8
  181ff0:	e8 cb f8 ff ff       	call   1818c0 <printk>
  181ff5:	83 c4 08             	add    $0x8,%esp
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  181ff8:	89 f2                	mov    %esi,%edx
  181ffa:	b8 06 00 00 00       	mov    $0x6,%eax
  181fff:	e8 ac fe ff ff       	call   181eb0 <_NanoFatalErrorHandler>

00182004 <handle_exc_0>:
	_EXC_FUNC_NOCODE(vector)

#define EXC_FUNC_CODE(vector) \
	_EXC_FUNC_CODE(vector)

EXC_FUNC_NOCODE(IV_DIVIDE_ERROR);
  182004:	89 c2                	mov    %eax,%edx
  182006:	b8 00 00 00 00       	mov    $0x0,%eax
  18200b:	e8 b7 ff ff ff       	call   181fc7 <generic_exc_handle>

00182010 <handle_exc_2>:
EXC_FUNC_NOCODE(IV_NON_MASKABLE_INTERRUPT);
  182010:	89 c2                	mov    %eax,%edx
  182012:	b8 02 00 00 00       	mov    $0x2,%eax
  182017:	e8 ab ff ff ff       	call   181fc7 <generic_exc_handle>

0018201c <handle_exc_4>:
EXC_FUNC_NOCODE(IV_OVERFLOW);
  18201c:	89 c2                	mov    %eax,%edx
  18201e:	b8 04 00 00 00       	mov    $0x4,%eax
  182023:	e8 9f ff ff ff       	call   181fc7 <generic_exc_handle>

00182028 <handle_exc_5>:
EXC_FUNC_NOCODE(IV_BOUND_RANGE);
  182028:	89 c2                	mov    %eax,%edx
  18202a:	b8 05 00 00 00       	mov    $0x5,%eax
  18202f:	e8 93 ff ff ff       	call   181fc7 <generic_exc_handle>

00182034 <handle_exc_6>:
EXC_FUNC_NOCODE(IV_INVALID_OPCODE);
  182034:	89 c2                	mov    %eax,%edx
  182036:	b8 06 00 00 00       	mov    $0x6,%eax
  18203b:	e8 87 ff ff ff       	call   181fc7 <generic_exc_handle>

00182040 <handle_exc_7>:
EXC_FUNC_NOCODE(IV_DEVICE_NOT_AVAILABLE);
  182040:	89 c2                	mov    %eax,%edx
  182042:	b8 07 00 00 00       	mov    $0x7,%eax
  182047:	e8 7b ff ff ff       	call   181fc7 <generic_exc_handle>

0018204c <handle_exc_8>:
EXC_FUNC_CODE(IV_DOUBLE_FAULT);
  18204c:	89 c2                	mov    %eax,%edx
  18204e:	b8 08 00 00 00       	mov    $0x8,%eax
  182053:	e8 6f ff ff ff       	call   181fc7 <generic_exc_handle>

00182058 <handle_exc_10>:
EXC_FUNC_CODE(IV_INVALID_TSS);
  182058:	89 c2                	mov    %eax,%edx
  18205a:	b8 0a 00 00 00       	mov    $0xa,%eax
  18205f:	e8 63 ff ff ff       	call   181fc7 <generic_exc_handle>

00182064 <handle_exc_11>:
EXC_FUNC_CODE(IV_SEGMENT_NOT_PRESENT);
  182064:	89 c2                	mov    %eax,%edx
  182066:	b8 0b 00 00 00       	mov    $0xb,%eax
  18206b:	e8 57 ff ff ff       	call   181fc7 <generic_exc_handle>

00182070 <handle_exc_12>:
EXC_FUNC_CODE(IV_STACK_FAULT);
  182070:	89 c2                	mov    %eax,%edx
  182072:	b8 0c 00 00 00       	mov    $0xc,%eax
  182077:	e8 4b ff ff ff       	call   181fc7 <generic_exc_handle>

0018207c <handle_exc_13>:
EXC_FUNC_CODE(IV_GENERAL_PROTECTION);
  18207c:	89 c2                	mov    %eax,%edx
  18207e:	b8 0d 00 00 00       	mov    $0xd,%eax
  182083:	e8 3f ff ff ff       	call   181fc7 <generic_exc_handle>

00182088 <handle_exc_14>:
EXC_FUNC_CODE(IV_PAGE_FAULT);
  182088:	89 c2                	mov    %eax,%edx
  18208a:	b8 0e 00 00 00       	mov    $0xe,%eax
  18208f:	e8 33 ff ff ff       	call   181fc7 <generic_exc_handle>

00182094 <handle_exc_16>:
EXC_FUNC_NOCODE(IV_X87_FPU_FP_ERROR);
  182094:	89 c2                	mov    %eax,%edx
  182096:	b8 10 00 00 00       	mov    $0x10,%eax
  18209b:	e8 27 ff ff ff       	call   181fc7 <generic_exc_handle>

001820a0 <handle_exc_17>:
EXC_FUNC_CODE(IV_ALIGNMENT_CHECK);
  1820a0:	89 c2                	mov    %eax,%edx
  1820a2:	b8 11 00 00 00       	mov    $0x11,%eax
  1820a7:	e8 1b ff ff ff       	call   181fc7 <generic_exc_handle>

001820ac <handle_exc_18>:
EXC_FUNC_NOCODE(IV_MACHINE_CHECK);
  1820ac:	89 c2                	mov    %eax,%edx
  1820ae:	b8 12 00 00 00       	mov    $0x12,%eax
  1820b3:	e8 0f ff ff ff       	call   181fc7 <generic_exc_handle>

001820b8 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  1820b8:	56                   	push   %esi
  1820b9:	53                   	push   %ebx
  1820ba:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  1820bc:	8b 1c 85 a0 34 18 00 	mov    0x1834a0(,%eax,4),%ebx
  1820c3:	eb 0a                	jmp    1820cf <_sys_device_do_config_level+0x17>
		struct device_config *device = info->config;
  1820c5:	8b 13                	mov    (%ebx),%edx

		device->init(info);
  1820c7:	89 d8                	mov    %ebx,%eax
  1820c9:	ff 52 04             	call   *0x4(%edx)
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  1820cc:	83 c3 0c             	add    $0xc,%ebx
  1820cf:	3b 1c b5 a4 34 18 00 	cmp    0x1834a4(,%esi,4),%ebx
  1820d6:	72 ed                	jb     1820c5 <_sys_device_do_config_level+0xd>
		struct device_config *device = info->config;

		device->init(info);
	}
}
  1820d8:	5b                   	pop    %ebx
  1820d9:	5e                   	pop    %esi
  1820da:	c3                   	ret    

001820db <device_get_binding>:

struct device *device_get_binding(const char *name)
{
  1820db:	56                   	push   %esi
  1820dc:	53                   	push   %ebx
  1820dd:	89 c6                	mov    %eax,%esi
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1820df:	bb 2c 00 28 00       	mov    $0x28002c,%ebx
  1820e4:	eb 18                	jmp    1820fe <device_get_binding+0x23>
		if (info->driver_api && !strcmp(name, info->config->name)) {
  1820e6:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  1820ea:	74 0f                	je     1820fb <device_get_binding+0x20>
  1820ec:	8b 03                	mov    (%ebx),%eax
  1820ee:	8b 10                	mov    (%eax),%edx
  1820f0:	89 f0                	mov    %esi,%eax
  1820f2:	e8 e8 f3 ff ff       	call   1814df <strcmp>
  1820f7:	85 c0                	test   %eax,%eax
  1820f9:	74 12                	je     18210d <device_get_binding+0x32>

struct device *device_get_binding(const char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1820fb:	83 c3 0c             	add    $0xc,%ebx
  1820fe:	81 fb 98 00 28 00    	cmp    $0x280098,%ebx
  182104:	75 e0                	jne    1820e6 <device_get_binding+0xb>
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
  182106:	b8 00 00 00 00       	mov    $0x0,%eax
  18210b:	eb 02                	jmp    18210f <device_get_binding+0x34>
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
		if (info->driver_api && !strcmp(name, info->config->name)) {
			return info;
  18210d:	89 d8                	mov    %ebx,%eax
		}
	}

	return NULL;
}
  18210f:	5b                   	pop    %ebx
  182110:	5e                   	pop    %esi
  182111:	c3                   	ret    

00182112 <device_busy_set>:
}

#endif

void device_busy_set(struct device *busy_dev)
{
  182112:	c3                   	ret    

00182113 <device_busy_clear>:
	ARG_UNUSED(busy_dev);
#endif
}

void device_busy_clear(struct device *busy_dev)
{
  182113:	c3                   	ret    

00182114 <prepare_multithreading>:
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */

	_current = dummy_thread;
  182114:	a3 e8 02 28 00       	mov    %eax,0x2802e8

	dummy_thread->base.user_options = K_ESSENTIAL;
  182119:	c6 40 08 01          	movb   $0x1,0x8(%eax)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  18211d:	b8 00 00 00 00       	mov    $0x0,%eax
  182122:	eb 1a                	jmp    18213e <prepare_multithreading+0x2a>
		sys_dlist_init(&_ready_q.q[ii]);
  182124:	8d 50 01             	lea    0x1(%eax),%edx
  182127:	8d 0c d5 f4 02 28 00 	lea    0x2802f4(,%edx,8),%ecx
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  18212e:	89 0c d5 f4 02 28 00 	mov    %ecx,0x2802f4(,%edx,8)
	list->tail = (sys_dnode_t *)list;
  182135:	89 0c c5 00 03 28 00 	mov    %ecx,0x280300(,%eax,8)

	_IntLibInit();

	/* ready the init/main and idle threads */

	for (int ii = 0; ii < K_NUM_PRIORITIES; ii++) {
  18213c:	89 d0                	mov    %edx,%eax
  18213e:	83 f8 1f             	cmp    $0x1f,%eax
  182141:	7e e1                	jle    182124 <prepare_multithreading+0x10>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_ready_q.cache = _main_thread;
  182143:	c7 05 f4 02 28 00 24 	movl   $0x280624,0x2802f4
  18214a:	06 28 00 

	_new_thread(_main_stack, MAIN_STACK_SIZE,
  18214d:	6a 01                	push   $0x1
  18214f:	6a 00                	push   $0x0
  182151:	6a 00                	push   $0x0
  182153:	6a 00                	push   $0x0
  182155:	6a 00                	push   $0x0
  182157:	b9 03 22 18 00       	mov    $0x182203,%ecx
  18215c:	ba 00 02 00 00       	mov    $0x200,%edx
  182161:	b8 24 06 28 00       	mov    $0x280624,%eax
  182166:	e8 ff fc ff ff       	call   181e6a <_new_thread>
  18216b:	83 c4 14             	add    $0x14,%esp
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  18216e:	a0 2d 06 28 00       	mov    0x28062d,%al
  182173:	83 e0 fb             	and    $0xfffffffb,%eax
  182176:	a2 2d 06 28 00       	mov    %al,0x28062d
		    _main, NULL, NULL, NULL,
		    CONFIG_MAIN_THREAD_PRIORITY, K_ESSENTIAL);
	_mark_thread_as_started(_main_thread);
	_add_thread_to_ready_q(_main_thread);
  18217b:	b8 24 06 28 00       	mov    $0x280624,%eax
  182180:	e8 3b 01 00 00       	call   1822c0 <_add_thread_to_ready_q>

#ifdef CONFIG_MULTITHREADING
	_new_thread(_idle_stack, IDLE_STACK_SIZE,
  182185:	6a 01                	push   $0x1
  182187:	6a 0f                	push   $0xf
  182189:	6a 00                	push   $0x0
  18218b:	6a 00                	push   $0x0
  18218d:	6a 00                	push   $0x0
  18218f:	b9 fb 2b 18 00       	mov    $0x182bfb,%ecx
  182194:	ba 00 01 00 00       	mov    $0x100,%edx
  182199:	b8 24 05 28 00       	mov    $0x280524,%eax
  18219e:	e8 c7 fc ff ff       	call   181e6a <_new_thread>
  1821a3:	83 c4 14             	add    $0x14,%esp
  1821a6:	a0 2d 05 28 00       	mov    0x28052d,%al
  1821ab:	83 e0 fb             	and    $0xfffffffb,%eax
  1821ae:	a2 2d 05 28 00       	mov    %al,0x28052d
		    idle, NULL, NULL, NULL,
		    K_LOWEST_THREAD_PRIO, K_ESSENTIAL);
	_mark_thread_as_started(_idle_thread);
	_add_thread_to_ready_q(_idle_thread);
  1821b3:	b8 24 05 28 00       	mov    $0x280524,%eax
  1821b8:	e8 03 01 00 00       	call   1822c0 <_add_thread_to_ready_q>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  1821bd:	c7 05 ec 02 28 00 ec 	movl   $0x2802ec,0x2802ec
  1821c4:	02 28 00 
	list->tail = (sys_dnode_t *)list;
  1821c7:	c7 05 f0 02 28 00 ec 	movl   $0x2802ec,0x2802f0
  1821ce:	02 28 00 
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];

	extern void _exception_enter(void);

	_kernel.nested = 0;
  1821d1:	c7 05 e0 02 28 00 00 	movl   $0x0,0x2802e0
  1821d8:	00 00 00 

	_kernel.irq_stack = _interrupt_stack + CONFIG_ISR_STACK_SIZE;
  1821db:	c7 05 e4 02 28 00 24 	movl   $0x280524,0x2802e4
  1821e2:	05 28 00 
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  1821e5:	c7 05 10 04 28 00 00 	movl   $0x200,0x280410
  1821ec:	02 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_exception_enter;
  1821ef:	c7 05 08 04 28 00 0b 	movl   $0x181d0b,0x280408
  1821f6:	1d 18 00 
  1821f9:	c3                   	ret    

001821fa <switch_to_main_thread>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1821fa:	9c                   	pushf  
  1821fb:	fa                   	cli    
  1821fc:	58                   	pop    %eax
	 * Context switch to main task (entry function is _main()): the
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */

	_Swap(irq_lock());
  1821fd:	e8 d9 fb ff ff       	call   181ddb <_Swap>
  182202:	c3                   	ret    

00182203 <_main>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
  182203:	b8 02 00 00 00       	mov    $0x2,%eax
  182208:	e8 ab fe ff ff       	call   1820b8 <_sys_device_do_config_level>

	/* These 3 are deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  18220d:	b8 05 00 00 00       	mov    $0x5,%eax
  182212:	e8 a1 fe ff ff       	call   1820b8 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  182217:	b8 06 00 00 00       	mov    $0x6,%eax
  18221c:	e8 97 fe ff ff       	call   1820b8 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_MICROKERNEL);
  182221:	b8 07 00 00 00       	mov    $0x7,%eax
  182226:	e8 8d fe ff ff       	call   1820b8 <_sys_device_do_config_level>

	/* Final init level before app starts */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  18222b:	b8 03 00 00 00       	mov    $0x3,%eax
  182230:	e8 83 fe ff ff       	call   1820b8 <_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	_init_static_threads();
  182235:	e8 d6 08 00 00       	call   182b10 <_init_static_threads>
	 */
#if defined(MDEF_MAIN_THREAD_PRIORITY) && \
		(MDEF_MAIN_THREAD_PRIORITY != CONFIG_MAIN_THREAD_PRIORITY)
	k_thread_priority_set(_main_thread, MDEF_MAIN_THREAD_PRIORITY);
#endif
	main();
  18223a:	e8 03 df ff ff       	call   180142 <main>

	/* Terminate thread normally since it has no more work to do */
	_main_thread->base.user_options &= ~K_ESSENTIAL;
  18223f:	a0 2c 06 28 00       	mov    0x28062c,%al
  182244:	83 e0 fe             	and    $0xfffffffe,%eax
  182247:	a2 2c 06 28 00       	mov    %al,0x28062c
  18224c:	c3                   	ret    

0018224d <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  18224d:	83 ec 48             	sub    $0x48,%esp
	 * Initialize kernel data structures. This step includes
	 * initializing the interrupt subsystem, which must be performed
	 * before the hardware initialization phase.
	 */

	prepare_multithreading(dummy_thread);
  182250:	89 e0                	mov    %esp,%eax
  182252:	e8 bd fe ff ff       	call   182114 <prepare_multithreading>

	/* Deprecated */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  182257:	b8 04 00 00 00       	mov    $0x4,%eax
  18225c:	e8 57 fe ff ff       	call   1820b8 <_sys_device_do_config_level>

	/* perform basic hardware initialization */
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
  182261:	b8 00 00 00 00       	mov    $0x0,%eax
  182266:	e8 4d fe ff ff       	call   1820b8 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
  18226b:	b8 01 00 00 00       	mov    $0x1,%eax
  182270:	e8 43 fe ff ff       	call   1820b8 <_sys_device_do_config_level>

	/* display boot banner */

	PRINT_BOOT_BANNER();

	switch_to_main_thread();
  182275:	e8 80 ff ff ff       	call   1821fa <switch_to_main_thread>

0018227a <_set_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  18227a:	8d 48 10             	lea    0x10(%eax),%ecx
  18227d:	89 ca                	mov    %ecx,%edx
  18227f:	c1 fa 05             	sar    $0x5,%edx
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  182282:	b8 01 00 00 00       	mov    $0x1,%eax
  182287:	d3 e0                	shl    %cl,%eax
static void _set_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap |= _get_ready_q_prio_bit(prio);
  182289:	09 04 95 f8 02 28 00 	or     %eax,0x2802f8(,%edx,4)
  182290:	c3                   	ret    

00182291 <_clear_ready_q_prio_bit>:
}

/* find out the prio bitmap index for a given prio */
static inline int _get_ready_q_prio_bmap_index(int prio)
{
	return (prio + _NUM_COOP_PRIO) >> 5;
  182291:	8d 48 10             	lea    0x10(%eax),%ecx
  182294:	89 c8                	mov    %ecx,%eax
  182296:	c1 f8 05             	sar    $0x5,%eax
}

/* find out the prio bit for a given prio */
static inline int _get_ready_q_prio_bit(int prio)
{
	return (1 << ((prio + _NUM_COOP_PRIO) & 0x1f));
  182299:	ba 01 00 00 00       	mov    $0x1,%edx
  18229e:	d3 e2                	shl    %cl,%edx
static void _clear_ready_q_prio_bit(int prio)
{
	int bmap_index = _get_ready_q_prio_bmap_index(prio);
	uint32_t *bmap = &_ready_q.prio_bmap[bmap_index];

	*bmap &= ~_get_ready_q_prio_bit(prio);
  1822a0:	f7 d2                	not    %edx
  1822a2:	21 14 85 f8 02 28 00 	and    %edx,0x2802f8(,%eax,4)
  1822a9:	c3                   	ret    

001822aa <_get_ready_q_head>:

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  1822aa:	0f bc 05 f8 02 28 00 	bsf    0x2802f8,%eax
  1822b1:	75 05                	jne    1822b8 <_get_ready_q_head+0xe>
  1822b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 * @return a pointer to the head element
 */

static inline sys_dnode_t *sys_dlist_peek_head_not_empty(sys_dlist_t *list)
{
	return list->head;
  1822b8:	8b 04 c5 fc 02 28 00 	mov    0x2802fc(,%eax,8),%eax

	struct k_thread *thread =
		(struct k_thread *)sys_dlist_peek_head_not_empty(list);

	return thread;
}
  1822bf:	c3                   	ret    

001822c0 <_add_thread_to_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _add_thread_to_ready_q(struct k_thread *thread)
{
  1822c0:	57                   	push   %edi
  1822c1:	56                   	push   %esi
  1822c2:	53                   	push   %ebx
  1822c3:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  1822c5:	0f be 58 0a          	movsbl 0xa(%eax),%ebx
	sys_dlist_t *q = &_ready_q.q[q_index];
  1822c9:	8d 3c dd 7c 03 28 00 	lea    0x28037c(,%ebx,8),%edi

	_set_ready_q_prio_bit(thread->base.prio);
  1822d0:	89 d8                	mov    %ebx,%eax
  1822d2:	e8 a3 ff ff ff       	call   18227a <_set_ready_q_prio_bit>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1822d7:	89 3e                	mov    %edi,(%esi)
	node->prev = list->tail;
  1822d9:	83 c3 14             	add    $0x14,%ebx
  1822dc:	8b 04 dd e0 02 28 00 	mov    0x2802e0(,%ebx,8),%eax
  1822e3:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  1822e6:	8b 04 dd e0 02 28 00 	mov    0x2802e0(,%ebx,8),%eax
  1822ed:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  1822ef:	89 34 dd e0 02 28 00 	mov    %esi,0x2802e0(,%ebx,8)
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = _is_t1_higher_prio_than_t2(thread, *cache) ? thread : *cache;
  1822f6:	a1 f4 02 28 00       	mov    0x2802f4,%eax
  1822fb:	8a 50 0a             	mov    0xa(%eax),%dl
  1822fe:	38 56 0a             	cmp    %dl,0xa(%esi)
  182301:	7d 02                	jge    182305 <_add_thread_to_ready_q+0x45>
  182303:	89 f0                	mov    %esi,%eax
  182305:	a3 f4 02 28 00       	mov    %eax,0x2802f4
#else
	sys_dlist_append(&_ready_q.q[0], &thread->base.k_q_node);
	_ready_q.prio_bmap[0] = 1;
	_ready_q.cache = thread;
#endif
}
  18230a:	5b                   	pop    %ebx
  18230b:	5e                   	pop    %esi
  18230c:	5f                   	pop    %edi
  18230d:	c3                   	ret    

0018230e <_remove_thread_from_ready_q>:
 *
 * Interrupts must be locked when calling this function.
 */

void _remove_thread_from_ready_q(struct k_thread *thread)
{
  18230e:	56                   	push   %esi
  18230f:	53                   	push   %ebx
  182310:	89 c3                	mov    %eax,%ebx
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  182312:	0f be 40 0a          	movsbl 0xa(%eax),%eax
	sys_dlist_t *q = &_ready_q.q[q_index];
  182316:	83 c0 11             	add    $0x11,%eax
  182319:	8d 14 c5 f4 02 28 00 	lea    0x2802f4(,%eax,8),%edx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182320:	8b 4b 04             	mov    0x4(%ebx),%ecx
  182323:	8b 33                	mov    (%ebx),%esi
  182325:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  182327:	8b 0b                	mov    (%ebx),%ecx
  182329:	8b 73 04             	mov    0x4(%ebx),%esi
  18232c:	89 71 04             	mov    %esi,0x4(%ecx)

	sys_dlist_remove(&thread->base.k_q_node);
	if (sys_dlist_is_empty(q)) {
  18232f:	3b 14 c5 f4 02 28 00 	cmp    0x2802f4(,%eax,8),%edx
  182336:	75 09                	jne    182341 <_remove_thread_from_ready_q+0x33>
		_clear_ready_q_prio_bit(thread->base.prio);
  182338:	0f be 43 0a          	movsbl 0xa(%ebx),%eax
  18233c:	e8 50 ff ff ff       	call   182291 <_clear_ready_q_prio_bit>
	}

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  182341:	a1 f4 02 28 00       	mov    0x2802f4,%eax
  182346:	39 c3                	cmp    %eax,%ebx
  182348:	75 05                	jne    18234f <_remove_thread_from_ready_q+0x41>
  18234a:	e8 5b ff ff ff       	call   1822aa <_get_ready_q_head>
  18234f:	a3 f4 02 28 00       	mov    %eax,0x2802f4
#else
	_ready_q.prio_bmap[0] = 0;
	_ready_q.cache = NULL;
	sys_dlist_remove(&thread->base.k_q_node);
#endif
}
  182354:	5b                   	pop    %ebx
  182355:	5e                   	pop    %esi
  182356:	c3                   	ret    

00182357 <__must_switch_threads>:
		_current->base.prio, _get_highest_ready_prio());

	extern void _dump_ready_q(void);
	_dump_ready_q();

	return _is_prio_higher(_get_highest_ready_prio(), _current->base.prio);
  182357:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  18235c:	0f be 50 0a          	movsbl 0xa(%eax),%edx
  182360:	0f bc 05 f8 02 28 00 	bsf    0x2802f8,%eax
  182367:	75 05                	jne    18236e <__must_switch_threads+0x17>
  182369:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

	int abs_prio = (find_lsb_set(ready_range) - 1) + (bitmap << 5);

	__ASSERT(abs_prio < K_NUM_PRIORITIES, "prio out-of-range\n");

	return abs_prio - _NUM_COOP_PRIO;
  18236e:	83 e8 10             	sub    $0x10,%eax
	return _is_prio1_higher_than_or_equal_to_prio2(prio1, prio2);
}

static inline int _is_prio1_higher_than_prio2(int prio1, int prio2)
{
	return prio1 < prio2;
  182371:	39 c2                	cmp    %eax,%edx
  182373:	0f 9f c0             	setg   %al
  182376:	0f b6 c0             	movzbl %al,%eax
#else
	return 0;
#endif
}
  182379:	c3                   	ret    

0018237a <_reschedule_threads>:

/* reschedule threads if the scheduler is not locked */
/* not callable from ISR */
/* must be called with interrupts locked */
void _reschedule_threads(int key)
{
  18237a:	53                   	push   %ebx
  18237b:	89 c3                	mov    %eax,%ebx
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  18237d:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  182382:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  182387:	77 10                	ja     182399 <_reschedule_threads+0x1f>
  182389:	e8 c9 ff ff ff       	call   182357 <__must_switch_threads>
  18238e:	85 c0                	test   %eax,%eax
  182390:	74 0c                	je     18239e <_reschedule_threads+0x24>
  182392:	b8 01 00 00 00       	mov    $0x1,%eax
  182397:	eb 05                	jmp    18239e <_reschedule_threads+0x24>
  182399:	b8 00 00 00 00       	mov    $0x0,%eax
#ifdef CONFIG_PREEMPT_ENABLED
	K_DEBUG("rescheduling threads\n");

	if (_must_switch_threads()) {
  18239e:	85 c0                	test   %eax,%eax
  1823a0:	74 09                	je     1823ab <_reschedule_threads+0x31>
		K_DEBUG("context-switching out %p\n", _current);
		_Swap(key);
  1823a2:	89 d8                	mov    %ebx,%eax
  1823a4:	e8 32 fa ff ff       	call   181ddb <_Swap>
  1823a9:	eb 06                	jmp    1823b1 <_reschedule_threads+0x37>
  1823ab:	f6 c7 02             	test   $0x2,%bh
  1823ae:	74 01                	je     1823b1 <_reschedule_threads+0x37>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1823b0:	fb                   	sti    
		irq_unlock(key);
	}
#else
	irq_unlock(key);
#endif
}
  1823b1:	5b                   	pop    %ebx
  1823b2:	c3                   	ret    

001823b3 <k_sched_unlock>:

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1823b3:	9c                   	pushf  
  1823b4:	fa                   	cli    
  1823b5:	58                   	pop    %eax

	int key = irq_lock();

	/* compiler_barrier() not needed, comes from irq_lock() */

	++_current->base.sched_locked;
  1823b6:	8b 0d e8 02 28 00    	mov    0x2802e8,%ecx
  1823bc:	8a 51 0b             	mov    0xb(%ecx),%dl
  1823bf:	42                   	inc    %edx
  1823c0:	88 51 0b             	mov    %dl,0xb(%ecx)

	K_DEBUG("scheduler unlocked (%p:%d)\n",
		_current, _current->base.sched_locked);

	_reschedule_threads(key);
  1823c3:	e8 b2 ff ff ff       	call   18237a <_reschedule_threads>
  1823c8:	c3                   	ret    

001823c9 <_move_thread_to_end_of_prio_q>:
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
#ifdef CONFIG_MULTITHREADING
	int q_index = _get_ready_q_q_index(thread->base.prio);
  1823c9:	0f be 48 0a          	movsbl 0xa(%eax),%ecx
	sys_dlist_t *q = &_ready_q.q[q_index];

	if (sys_dlist_is_tail(q, &thread->base.k_q_node)) {
  1823cd:	3b 04 cd 80 03 28 00 	cmp    0x280380(,%ecx,8),%eax
  1823d4:	74 53                	je     182429 <_move_thread_to_end_of_prio_q+0x60>
 * This function, along with _add_thread_to_ready_q() and
 * _remove_thread_from_ready_q(), are the _only_ places where a thread is
 * taken off or put on the ready queue.
 */
void _move_thread_to_end_of_prio_q(struct k_thread *thread)
{
  1823d6:	56                   	push   %esi
  1823d7:	53                   	push   %ebx
  1823d8:	8d 51 10             	lea    0x10(%ecx),%edx
  1823db:	8d 1c cd 7c 03 28 00 	lea    0x28037c(,%ecx,8),%ebx
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1823e2:	8b 48 04             	mov    0x4(%eax),%ecx
  1823e5:	8b 30                	mov    (%eax),%esi
  1823e7:	89 31                	mov    %esi,(%ecx)
	node->next->prev = node->prev;
  1823e9:	8b 08                	mov    (%eax),%ecx
  1823eb:	8b 70 04             	mov    0x4(%eax),%esi
  1823ee:	89 71 04             	mov    %esi,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1823f1:	89 18                	mov    %ebx,(%eax)
	node->prev = list->tail;
  1823f3:	83 c2 04             	add    $0x4,%edx
  1823f6:	8b 0c d5 e0 02 28 00 	mov    0x2802e0(,%edx,8),%ecx
  1823fd:	89 48 04             	mov    %ecx,0x4(%eax)

	list->tail->next = node;
  182400:	8b 0c d5 e0 02 28 00 	mov    0x2802e0(,%edx,8),%ecx
  182407:	89 01                	mov    %eax,(%ecx)
	list->tail = node;
  182409:	89 04 d5 e0 02 28 00 	mov    %eax,0x2802e0(,%edx,8)
	sys_dlist_remove(&thread->base.k_q_node);
	sys_dlist_append(q, &thread->base.k_q_node);

	struct k_thread **cache = &_ready_q.cache;

	*cache = *cache == thread ? _get_ready_q_head() : *cache;
  182410:	8b 15 f4 02 28 00    	mov    0x2802f4,%edx
  182416:	39 d0                	cmp    %edx,%eax
  182418:	75 07                	jne    182421 <_move_thread_to_end_of_prio_q+0x58>
  18241a:	e8 8b fe ff ff       	call   1822aa <_get_ready_q_head>
  18241f:	89 c2                	mov    %eax,%edx
  182421:	89 15 f4 02 28 00    	mov    %edx,0x2802f4
#endif
}
  182427:	5b                   	pop    %ebx
  182428:	5e                   	pop    %esi
  182429:	c3                   	ret    

0018242a <k_yield>:

void k_yield(void)
{
  18242a:	53                   	push   %ebx
  18242b:	9c                   	pushf  
  18242c:	fa                   	cli    
  18242d:	5b                   	pop    %ebx
	__ASSERT(!_is_in_isr(), "");

	int key = irq_lock();

	_move_thread_to_end_of_prio_q(_current);
  18242e:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  182433:	e8 91 ff ff ff       	call   1823c9 <_move_thread_to_end_of_prio_q>

	if (_current == _get_next_ready_thread()) {
  182438:	a1 f4 02 28 00       	mov    0x2802f4,%eax
  18243d:	39 05 e8 02 28 00    	cmp    %eax,0x2802e8
  182443:	75 08                	jne    18244d <k_yield+0x23>
  182445:	f6 c7 02             	test   $0x2,%bh
  182448:	74 0a                	je     182454 <k_yield+0x2a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18244a:	fb                   	sti    
  18244b:	eb 07                	jmp    182454 <k_yield+0x2a>
		irq_unlock(key);
	} else {
		_Swap(key);
  18244d:	89 d8                	mov    %ebx,%eax
  18244f:	e8 87 f9 ff ff       	call   181ddb <_Swap>
	}
}
  182454:	5b                   	pop    %ebx
  182455:	c3                   	ret    

00182456 <k_sleep>:

void k_sleep(int32_t duration)
{
  182456:	57                   	push   %edi
  182457:	56                   	push   %esi
  182458:	53                   	push   %ebx
  182459:	83 ec 04             	sub    $0x4,%esp
	__ASSERT(duration != K_FOREVER, "");

	K_DEBUG("thread %p for %d ns\n", _current, duration);

	/* wait of 0 ms is treated as a 'yield' */
	if (duration == 0) {
  18245c:	85 c0                	test   %eax,%eax
  18245e:	75 0a                	jne    18246a <k_sleep+0x14>
		k_yield();
  182460:	e8 c5 ff ff ff       	call   18242a <k_yield>
		return;
  182465:	e9 25 01 00 00       	jmp    18258f <k_sleep+0x139>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  18246a:	83 c0 09             	add    $0x9,%eax
  18246d:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  182472:	f7 e2                	mul    %edx
  182474:	c1 ea 03             	shr    $0x3,%edx
	}

	ticks = _TICK_ALIGN + _ms_to_ticks(duration);
  182477:	42                   	inc    %edx
  182478:	89 14 24             	mov    %edx,(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18247b:	9c                   	pushf  
  18247c:	fa                   	cli    
  18247d:	5b                   	pop    %ebx
	key = irq_lock();

	_remove_thread_from_ready_q(_current);
  18247e:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  182483:	e8 86 fe ff ff       	call   18230e <_remove_thread_from_ready_q>
	_add_thread_timeout(_current, NULL, ticks);
  182488:	8b 04 24             	mov    (%esp),%eax
  18248b:	8b 3d e8 02 28 00    	mov    0x2802e8,%edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  182491:	8d 77 10             	lea    0x10(%edi),%esi
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  182494:	89 46 10             	mov    %eax,0x10(%esi)
	timeout->thread = thread;
  182497:	89 7e 08             	mov    %edi,0x8(%esi)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  18249a:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1824a1:	a1 ec 02 28 00       	mov    0x2802ec,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1824a6:	3d ec 02 28 00       	cmp    $0x2802ec,%eax
  1824ab:	75 07                	jne    1824b4 <k_sleep+0x5e>
  1824ad:	ba 00 00 00 00       	mov    $0x0,%edx
  1824b2:	eb 02                	jmp    1824b6 <k_sleep+0x60>
  1824b4:	89 c2                	mov    %eax,%edx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1824b6:	85 d2                	test   %edx,%edx
  1824b8:	74 15                	je     1824cf <k_sleep+0x79>
  1824ba:	3d ec 02 28 00       	cmp    $0x2802ec,%eax
  1824bf:	0f 85 9f 00 00 00    	jne    182564 <k_sleep+0x10e>
  1824c5:	b8 00 00 00 00       	mov    $0x0,%eax
  1824ca:	e9 95 00 00 00       	jmp    182564 <k_sleep+0x10e>
  1824cf:	b8 00 00 00 00       	mov    $0x0,%eax
  1824d4:	e9 8b 00 00 00       	jmp    182564 <k_sleep+0x10e>
		if (*delta <= in_q->delta_ticks_from_prev) {
  1824d9:	8b 56 10             	mov    0x10(%esi),%edx
  1824dc:	8b 48 10             	mov    0x10(%eax),%ecx
  1824df:	39 ca                	cmp    %ecx,%edx
  1824e1:	7f 3a                	jg     18251d <k_sleep+0xc7>
			in_q->delta_ticks_from_prev -= *delta;
  1824e3:	29 d1                	sub    %edx,%ecx
  1824e5:	89 48 10             	mov    %ecx,0x10(%eax)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  1824e8:	85 c0                	test   %eax,%eax
  1824ea:	75 1e                	jne    18250a <k_sleep+0xb4>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1824ec:	c7 47 10 ec 02 28 00 	movl   $0x2802ec,0x10(%edi)
	node->prev = list->tail;
  1824f3:	a1 f0 02 28 00       	mov    0x2802f0,%eax
  1824f8:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  1824fb:	a1 f0 02 28 00       	mov    0x2802f0,%eax
  182500:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  182502:	89 35 f0 02 28 00    	mov    %esi,0x2802f0
  182508:	eb 7e                	jmp    182588 <k_sleep+0x132>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  18250a:	8b 50 04             	mov    0x4(%eax),%edx
  18250d:	89 56 04             	mov    %edx,0x4(%esi)
		node->next = insert_point;
  182510:	89 47 10             	mov    %eax,0x10(%edi)
		insert_point->prev->next = node;
  182513:	8b 50 04             	mov    0x4(%eax),%edx
  182516:	89 32                	mov    %esi,(%edx)
		insert_point->prev = node;
  182518:	89 70 04             	mov    %esi,0x4(%eax)
  18251b:	eb 6b                	jmp    182588 <k_sleep+0x132>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  18251d:	29 ca                	sub    %ecx,%edx
  18251f:	89 56 10             	mov    %edx,0x10(%esi)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  182522:	89 c2                	mov    %eax,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182524:	85 c0                	test   %eax,%eax
  182526:	74 0c                	je     182534 <k_sleep+0xde>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182528:	3b 05 f0 02 28 00    	cmp    0x2802f0,%eax
  18252e:	74 08                	je     182538 <k_sleep+0xe2>
  182530:	8b 08                	mov    (%eax),%ecx
  182532:	eb 09                	jmp    18253d <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182534:	89 c1                	mov    %eax,%ecx
  182536:	eb 05                	jmp    18253d <k_sleep+0xe7>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182538:	b9 00 00 00 00       	mov    $0x0,%ecx
  18253d:	85 c9                	test   %ecx,%ecx
  18253f:	74 1e                	je     18255f <k_sleep+0x109>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182541:	85 d2                	test   %edx,%edx
  182543:	74 0c                	je     182551 <k_sleep+0xfb>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182545:	3b 15 f0 02 28 00    	cmp    0x2802f0,%edx
  18254b:	74 0b                	je     182558 <k_sleep+0x102>
  18254d:	8b 00                	mov    (%eax),%eax
  18254f:	eb 13                	jmp    182564 <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182551:	b8 00 00 00 00       	mov    $0x0,%eax
  182556:	eb 0c                	jmp    182564 <k_sleep+0x10e>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182558:	b8 00 00 00 00       	mov    $0x0,%eax
  18255d:	eb 05                	jmp    182564 <k_sleep+0x10e>
  18255f:	b8 00 00 00 00       	mov    $0x0,%eax
  182564:	85 c0                	test   %eax,%eax
  182566:	0f 85 6d ff ff ff    	jne    1824d9 <k_sleep+0x83>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  18256c:	c7 47 10 ec 02 28 00 	movl   $0x2802ec,0x10(%edi)
	node->prev = list->tail;
  182573:	a1 f0 02 28 00       	mov    0x2802f0,%eax
  182578:	89 46 04             	mov    %eax,0x4(%esi)

	list->tail->next = node;
  18257b:	a1 f0 02 28 00       	mov    0x2802f0,%eax
  182580:	89 30                	mov    %esi,(%eax)
	list->tail = node;
  182582:	89 35 f0 02 28 00    	mov    %esi,0x2802f0

	_Swap(key);
  182588:	89 d8                	mov    %ebx,%eax
  18258a:	e8 4c f8 ff ff       	call   181ddb <_Swap>
#endif
}
  18258f:	83 c4 04             	add    $0x4,%esp
  182592:	5b                   	pop    %ebx
  182593:	5e                   	pop    %esi
  182594:	5f                   	pop    %edi
  182595:	c3                   	ret    

00182596 <k_current_get>:
}

k_tid_t k_current_get(void)
{
	return _current;
}
  182596:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  18259b:	c3                   	ret    

0018259c <handle_time_slicing>:
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
	if (_time_slice_duration == 0) {
  18259c:	8b 15 04 04 28 00    	mov    0x280404,%edx
  1825a2:	85 d2                	test   %edx,%edx
  1825a4:	74 50                	je     1825f6 <handle_time_slicing+0x5a>
		return;
	}

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
  1825a6:	8b 0d e8 02 28 00    	mov    0x2802e8,%ecx
  1825ac:	0f be 49 0a          	movsbl 0xa(%ecx),%ecx
  1825b0:	39 0d 00 04 28 00    	cmp    %ecx,0x280400
  1825b6:	7f 3e                	jg     1825f6 <handle_time_slicing+0x5a>
 *   in this function and at thread level
 * - _time_slice_duration does not have to be protected, since it can only
 *   change at thread level
 */
static void handle_time_slicing(int32_t ticks)
{
  1825b8:	57                   	push   %edi
  1825b9:	56                   	push   %esi
  1825ba:	53                   	push   %ebx
#ifdef CONFIG_SYS_CLOCK_EXISTS

#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
	return (MSEC_PER_SEC * (uint64_t)ticks) / sys_clock_ticks_per_sec;
#else
	return (uint64_t)ticks * _ms_per_tick;
  1825bb:	89 c1                	mov    %eax,%ecx
  1825bd:	89 c6                	mov    %eax,%esi
  1825bf:	01 c6                	add    %eax,%esi
  1825c1:	c1 e1 03             	shl    $0x3,%ecx
  1825c4:	01 f1                	add    %esi,%ecx

	if (_is_prio_higher(_current->base.prio, _time_slice_prio_ceiling)) {
		return;
	}

	_time_slice_elapsed += __ticks_to_ms(ticks);
  1825c6:	03 0d 18 04 28 00    	add    0x280418,%ecx
  1825cc:	89 0d 18 04 28 00    	mov    %ecx,0x280418
	if (_time_slice_elapsed >= _time_slice_duration) {
  1825d2:	39 ca                	cmp    %ecx,%edx
  1825d4:	7f 1d                	jg     1825f3 <handle_time_slicing+0x57>

		unsigned int key;

		_time_slice_elapsed = 0;
  1825d6:	c7 05 18 04 28 00 00 	movl   $0x0,0x280418
  1825dd:	00 00 00 
  1825e0:	9c                   	pushf  
  1825e1:	fa                   	cli    
  1825e2:	5b                   	pop    %ebx

		key = irq_lock();
		_move_thread_to_end_of_prio_q(_current);
  1825e3:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  1825e8:	e8 dc fd ff ff       	call   1823c9 <_move_thread_to_end_of_prio_q>
  1825ed:	f6 c7 02             	test   $0x2,%bh
  1825f0:	74 01                	je     1825f3 <handle_time_slicing+0x57>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1825f2:	fb                   	sti    
		irq_unlock(key);
	}
}
  1825f3:	5b                   	pop    %ebx
  1825f4:	5e                   	pop    %esi
  1825f5:	5f                   	pop    %edi
  1825f6:	c3                   	ret    

001825f7 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the threads pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  1825f7:	57                   	push   %edi
  1825f8:	56                   	push   %esi
  1825f9:	53                   	push   %ebx
  1825fa:	83 ec 08             	sub    $0x8,%esp
  1825fd:	89 c6                	mov    %eax,%esi

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1825ff:	9c                   	pushf  
  182600:	fa                   	cli    
  182601:	58                   	pop    %eax

	K_DEBUG("ticks: %d\n", ticks);

	/* 64-bit value, ensure atomic access with irq lock */
	key = irq_lock();
	_sys_clock_tick_count += ticks;
  182602:	89 f3                	mov    %esi,%ebx
  182604:	c1 fb 1f             	sar    $0x1f,%ebx
  182607:	01 35 1c 04 28 00    	add    %esi,0x28041c
  18260d:	11 1d 20 04 28 00    	adc    %ebx,0x280420
  182613:	f6 c4 02             	test   $0x2,%ah
  182616:	74 01                	je     182619 <_nano_sys_clock_tick_announce+0x22>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182618:	fb                   	sti    
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  182619:	89 24 24             	mov    %esp,(%esp)
	list->tail = (sys_dnode_t *)list;
  18261c:	89 64 24 04          	mov    %esp,0x4(%esp)

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182620:	9c                   	pushf  
  182621:	fa                   	cli    
  182622:	59                   	pop    %ecx
  182623:	89 ca                	mov    %ecx,%edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182625:	a1 ec 02 28 00       	mov    0x2802ec,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  18262a:	3d ec 02 28 00       	cmp    $0x2802ec,%eax
  18262f:	75 05                	jne    182636 <_nano_sys_clock_tick_announce+0x3f>
  182631:	b8 00 00 00 00       	mov    $0x0,%eax
		(struct _timeout *)sys_dlist_peek_head(&_timeout_q);

	K_DEBUG("head: %p, delta: %d\n",
		head, head ? head->delta_ticks_from_prev : -2112);

	if (!head) {
  182636:	85 c0                	test   %eax,%eax
  182638:	75 0f                	jne    182649 <_nano_sys_clock_tick_announce+0x52>
  18263a:	f6 c5 02             	test   $0x2,%ch
  18263d:	0f 84 52 01 00 00    	je     182795 <_nano_sys_clock_tick_announce+0x19e>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182643:	fb                   	sti    
  182644:	e9 4c 01 00 00       	jmp    182795 <_nano_sys_clock_tick_announce+0x19e>
		irq_unlock(key);
		return;
	}

	head->delta_ticks_from_prev -= ticks;
  182649:	29 70 10             	sub    %esi,0x10(%eax)
	 * prohibited.
	 */
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;
  18264c:	c7 05 14 04 28 00 01 	movl   $0x1,0x280414
  182653:	00 00 00 
  182656:	eb 41                	jmp    182699 <_nano_sys_clock_tick_announce+0xa2>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182658:	8b 48 04             	mov    0x4(%eax),%ecx
  18265b:	8b 18                	mov    (%eax),%ebx
  18265d:	89 19                	mov    %ebx,(%ecx)
	node->next->prev = node->prev;
  18265f:	8b 08                	mov    (%eax),%ecx
  182661:	8b 58 04             	mov    0x4(%eax),%ebx
  182664:	89 59 04             	mov    %ebx,0x4(%ecx)
 * @return N/A
 */

static inline void sys_dlist_prepend(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list->head;
  182667:	8b 0c 24             	mov    (%esp),%ecx
  18266a:	89 08                	mov    %ecx,(%eax)
	node->prev = list;
  18266c:	89 60 04             	mov    %esp,0x4(%eax)

	list->head->prev = node;
  18266f:	8b 0c 24             	mov    (%esp),%ecx
  182672:	89 41 04             	mov    %eax,0x4(%ecx)
	list->head = node;
  182675:	89 04 24             	mov    %eax,(%esp)
		 * expired queue, they end up being processed in the same order
		 * they were added, time-wise.
		 */
		sys_dlist_prepend(&expired, next);

		timeout->delta_ticks_from_prev = _EXPIRED;
  182678:	c7 40 10 fe ff ff ff 	movl   $0xfffffffe,0x10(%eax)
  18267f:	f6 c6 02             	test   $0x2,%dh
  182682:	74 01                	je     182685 <_nano_sys_clock_tick_announce+0x8e>
  182684:	fb                   	sti    

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182685:	9c                   	pushf  
  182686:	fa                   	cli    
  182687:	5a                   	pop    %edx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182688:	a1 ec 02 28 00       	mov    0x2802ec,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  18268d:	3d ec 02 28 00       	cmp    $0x2802ec,%eax
  182692:	75 05                	jne    182699 <_nano_sys_clock_tick_announce+0xa2>
  182694:	b8 00 00 00 00       	mov    $0x0,%eax
	sys_dnode_t *next = &head->node;
	struct _timeout *timeout = (struct _timeout *)next;

	_handling_timeouts = 1;

	while (timeout && timeout->delta_ticks_from_prev == 0) {
  182699:	85 c0                	test   %eax,%eax
  18269b:	74 06                	je     1826a3 <_nano_sys_clock_tick_announce+0xac>
  18269d:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  1826a1:	74 b5                	je     182658 <_nano_sys_clock_tick_announce+0x61>
  1826a3:	f6 c6 02             	test   $0x2,%dh
  1826a6:	74 01                	je     1826a9 <_nano_sys_clock_tick_announce+0xb2>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1826a8:	fb                   	sti    
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1826a9:	8b 14 24             	mov    (%esp),%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1826ac:	39 e2                	cmp    %esp,%edx
  1826ae:	75 05                	jne    1826b5 <_nano_sys_clock_tick_announce+0xbe>
  1826b0:	ba 00 00 00 00       	mov    $0x0,%edx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1826b5:	85 d2                	test   %edx,%edx
  1826b7:	74 0d                	je     1826c6 <_nano_sys_clock_tick_announce+0xcf>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1826b9:	3b 54 24 04          	cmp    0x4(%esp),%edx
  1826bd:	74 0e                	je     1826cd <_nano_sys_clock_tick_announce+0xd6>
  1826bf:	8b 1a                	mov    (%edx),%ebx
  1826c1:	e9 bd 00 00 00       	jmp    182783 <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1826c6:	89 d3                	mov    %edx,%ebx
  1826c8:	e9 b6 00 00 00       	jmp    182783 <_nano_sys_clock_tick_announce+0x18c>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  1826cd:	bb 00 00 00 00       	mov    $0x0,%ebx
  1826d2:	e9 ac 00 00 00       	jmp    182783 <_nano_sys_clock_tick_announce+0x18c>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1826d7:	8b 42 04             	mov    0x4(%edx),%eax
  1826da:	8b 0a                	mov    (%edx),%ecx
  1826dc:	89 08                	mov    %ecx,(%eax)
	node->next->prev = node->prev;
  1826de:	8b 02                	mov    (%edx),%eax
  1826e0:	8b 4a 04             	mov    0x4(%edx),%ecx
  1826e3:	89 48 04             	mov    %ecx,0x4(%eax)
 * kept as -EAGAIN, set previously in _Swap().
 */

static inline void _handle_one_expired_timeout(struct _timeout *timeout)
{
	struct k_thread *thread = timeout->thread;
  1826e6:	8b 42 08             	mov    0x8(%edx),%eax

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1826e9:	9c                   	pushf  
  1826ea:	fa                   	cli    
  1826eb:	5f                   	pop    %edi
	unsigned int key = irq_lock();

	timeout->delta_ticks_from_prev = _INACTIVE;
  1826ec:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%edx)

	K_DEBUG("timeout %p\n", timeout);
	if (thread) {
  1826f3:	85 c0                	test   %eax,%eax
  1826f5:	74 5d                	je     182754 <_nano_sys_clock_tick_announce+0x15d>
/* remove a thread timing out from kernel object's wait queue */

static inline void _unpend_thread_timing_out(struct k_thread *thread,
					     struct _timeout *timeout_obj)
{
	if (timeout_obj->wait_q) {
  1826f7:	83 7a 0c 00          	cmpl   $0x0,0xc(%edx)
  1826fb:	74 1a                	je     182717 <_nano_sys_clock_tick_announce+0x120>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1826fd:	8b 50 04             	mov    0x4(%eax),%edx
  182700:	8b 08                	mov    (%eax),%ecx
  182702:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  182704:	8b 10                	mov    (%eax),%edx
  182706:	8b 48 04             	mov    0x4(%eax),%ecx
  182709:	89 4a 04             	mov    %ecx,0x4(%edx)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  18270c:	80 60 09 fd          	andb   $0xfd,0x9(%eax)
		_unpend_thread(thread);
		thread->base.timeout.wait_q = NULL;
  182710:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  182717:	8a 50 09             	mov    0x9(%eax),%dl
  18271a:	88 d1                	mov    %dl,%cl
  18271c:	83 e1 fb             	and    $0xfffffffb,%ecx
  18271f:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182722:	f6 c2 1b             	test   $0x1b,%dl
  182725:	75 0d                	jne    182734 <_nano_sys_clock_tick_announce+0x13d>
  182727:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  18272b:	75 0e                	jne    18273b <_nano_sys_clock_tick_announce+0x144>
  18272d:	ba 01 00 00 00       	mov    $0x1,%edx
  182732:	eb 0c                	jmp    182740 <_nano_sys_clock_tick_announce+0x149>
  182734:	ba 00 00 00 00       	mov    $0x0,%edx
  182739:	eb 05                	jmp    182740 <_nano_sys_clock_tick_announce+0x149>
  18273b:	ba 00 00 00 00       	mov    $0x0,%edx
		 thread, thread->base.prio, K_HIGHEST_THREAD_PRIO);

	/* needed to handle the start-with-delay case */
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182740:	85 d2                	test   %edx,%edx
  182742:	74 05                	je     182749 <_nano_sys_clock_tick_announce+0x152>
		_add_thread_to_ready_q(thread);
  182744:	e8 77 fb ff ff       	call   1822c0 <_add_thread_to_ready_q>
  182749:	f7 c7 00 02 00 00    	test   $0x200,%edi
  18274f:	74 17                	je     182768 <_nano_sys_clock_tick_announce+0x171>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182751:	fb                   	sti    
  182752:	eb 14                	jmp    182768 <_nano_sys_clock_tick_announce+0x171>
  182754:	f7 c7 00 02 00 00    	test   $0x200,%edi
  18275a:	74 01                	je     18275d <_nano_sys_clock_tick_announce+0x166>
  18275c:	fb                   	sti    
		_unpend_thread_timing_out(thread, timeout);
		_ready_thread(thread);
		irq_unlock(key);
	} else {
		irq_unlock(key);
		if (timeout->func) {
  18275d:	8b 4a 14             	mov    0x14(%edx),%ecx
  182760:	85 c9                	test   %ecx,%ecx
  182762:	74 04                	je     182768 <_nano_sys_clock_tick_announce+0x171>
			timeout->func(timeout);
  182764:	89 d0                	mov    %edx,%eax
  182766:	ff d1                	call   *%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182768:	85 db                	test   %ebx,%ebx
  18276a:	74 0a                	je     182776 <_nano_sys_clock_tick_announce+0x17f>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18276c:	3b 5c 24 04          	cmp    0x4(%esp),%ebx
  182770:	74 08                	je     18277a <_nano_sys_clock_tick_announce+0x183>
  182772:	8b 03                	mov    (%ebx),%eax
  182774:	eb 09                	jmp    18277f <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182776:	89 d8                	mov    %ebx,%eax
  182778:	eb 05                	jmp    18277f <_nano_sys_clock_tick_announce+0x188>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  18277a:	b8 00 00 00 00       	mov    $0x0,%eax

static inline void _handle_expired_timeouts(sys_dlist_t *expired)
{
	sys_dnode_t *timeout, *next;

	SYS_DLIST_FOR_EACH_NODE_SAFE(expired, timeout, next) {
  18277f:	89 da                	mov    %ebx,%edx
  182781:	89 c3                	mov    %eax,%ebx
  182783:	85 d2                	test   %edx,%edx
  182785:	0f 85 4c ff ff ff    	jne    1826d7 <_nano_sys_clock_tick_announce+0xe0>

	irq_unlock(key);

	_handle_expired_timeouts(&expired);

	_handling_timeouts = 0;
  18278b:	c7 05 14 04 28 00 00 	movl   $0x0,0x280414
  182792:	00 00 00 
	irq_unlock(key);

	handle_timeouts(ticks);

	/* time slicing is basically handled like just yet another timeout */
	handle_time_slicing(ticks);
  182795:	89 f0                	mov    %esi,%eax
  182797:	e8 00 fe ff ff       	call   18259c <handle_time_slicing>
}
  18279c:	83 c4 08             	add    $0x8,%esp
  18279f:	5b                   	pop    %ebx
  1827a0:	5e                   	pop    %esi
  1827a1:	5f                   	pop    %edi
  1827a2:	c3                   	ret    

001827a3 <_k_thread_single_start>:
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1827a3:	8a 50 09             	mov    0x9(%eax),%dl
  1827a6:	88 d1                	mov    %dl,%cl
  1827a8:	83 e1 fb             	and    $0xfffffffb,%ecx
  1827ab:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1827ae:	f6 c2 1b             	test   $0x1b,%dl
  1827b1:	75 0d                	jne    1827c0 <_k_thread_single_start+0x1d>
  1827b3:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1827b7:	75 0e                	jne    1827c7 <_k_thread_single_start+0x24>
  1827b9:	ba 01 00 00 00       	mov    $0x1,%edx
  1827be:	eb 0c                	jmp    1827cc <_k_thread_single_start+0x29>
  1827c0:	ba 00 00 00 00       	mov    $0x0,%edx
  1827c5:	eb 05                	jmp    1827cc <_k_thread_single_start+0x29>
  1827c7:	ba 00 00 00 00       	mov    $0x0,%edx

void _k_thread_single_start(struct k_thread *thread)
{
	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  1827cc:	85 d2                	test   %edx,%edx
  1827ce:	74 05                	je     1827d5 <_k_thread_single_start+0x32>
		_add_thread_to_ready_q(thread);
  1827d0:	e8 eb fa ff ff       	call   1822c0 <_add_thread_to_ready_q>
  1827d5:	c3                   	ret    

001827d6 <start_thread>:
	CODE_UNREACHABLE;
}

#ifdef CONFIG_MULTITHREADING
static void start_thread(struct k_thread *thread)
{
  1827d6:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1827d7:	9c                   	pushf  
  1827d8:	fa                   	cli    
  1827d9:	5b                   	pop    %ebx
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
  1827da:	8a 50 09             	mov    0x9(%eax),%dl
  1827dd:	88 d1                	mov    %dl,%cl
  1827df:	83 e1 fb             	and    $0xfffffffb,%ecx
  1827e2:	88 48 09             	mov    %cl,0x9(%eax)
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  1827e5:	f6 c2 1b             	test   $0x1b,%dl
  1827e8:	75 0d                	jne    1827f7 <start_thread+0x21>
  1827ea:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  1827ee:	75 0e                	jne    1827fe <start_thread+0x28>
  1827f0:	ba 01 00 00 00       	mov    $0x1,%edx
  1827f5:	eb 0c                	jmp    182803 <start_thread+0x2d>
  1827f7:	ba 00 00 00 00       	mov    $0x0,%edx
  1827fc:	eb 05                	jmp    182803 <start_thread+0x2d>
  1827fe:	ba 00 00 00 00       	mov    $0x0,%edx
	int key = irq_lock(); /* protect kernel queues */

	_mark_thread_as_started(thread);

	if (_is_thread_ready(thread)) {
  182803:	85 d2                	test   %edx,%edx
  182805:	74 33                	je     18283a <start_thread+0x64>
		_add_thread_to_ready_q(thread);
  182807:	e8 b4 fa ff ff       	call   1822c0 <_add_thread_to_ready_q>
 * Checks if current thread must be context-switched out. The caller must
 * already know that the execution context is a thread.
 */
static inline int _must_switch_threads(void)
{
	return _is_preempt(_current) && __must_switch_threads();
  18280c:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  182811:	66 83 78 0a 7f       	cmpw   $0x7f,0xa(%eax)
  182816:	77 10                	ja     182828 <start_thread+0x52>
  182818:	e8 3a fb ff ff       	call   182357 <__must_switch_threads>
  18281d:	85 c0                	test   %eax,%eax
  18281f:	74 0c                	je     18282d <start_thread+0x57>
  182821:	b8 01 00 00 00       	mov    $0x1,%eax
  182826:	eb 05                	jmp    18282d <start_thread+0x57>
  182828:	b8 00 00 00 00       	mov    $0x0,%eax
		if (_must_switch_threads()) {
  18282d:	85 c0                	test   %eax,%eax
  18282f:	74 09                	je     18283a <start_thread+0x64>
			_Swap(key);
  182831:	89 d8                	mov    %ebx,%eax
  182833:	e8 a3 f5 ff ff       	call   181ddb <_Swap>
			return;
  182838:	eb 06                	jmp    182840 <start_thread+0x6a>
  18283a:	f6 c7 02             	test   $0x2,%bh
  18283d:	74 01                	je     182840 <start_thread+0x6a>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18283f:	fb                   	sti    
		}
	}

	irq_unlock(key);
}
  182840:	5b                   	pop    %ebx
  182841:	c3                   	ret    

00182842 <schedule_new_thread>:
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, int32_t delay)
{
  182842:	57                   	push   %edi
  182843:	56                   	push   %esi
  182844:	53                   	push   %ebx
  182845:	89 c6                	mov    %eax,%esi
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
  182847:	85 d2                	test   %edx,%edx
  182849:	75 0a                	jne    182855 <schedule_new_thread+0x13>
		start_thread(thread);
  18284b:	e8 86 ff ff ff       	call   1827d6 <start_thread>
  182850:	e9 18 01 00 00       	jmp    18296d <schedule_new_thread+0x12b>
#ifdef _NON_OPTIMIZED_TICKS_PER_SEC
extern int32_t _ms_to_ticks(int32_t ms);
#else
static ALWAYS_INLINE int32_t _ms_to_ticks(int32_t ms)
{
	return (int32_t)ceiling_fraction((uint32_t)ms, _ms_per_tick);
  182855:	83 c2 09             	add    $0x9,%edx
  182858:	b9 cd cc cc cc       	mov    $0xcccccccd,%ecx
  18285d:	89 d0                	mov    %edx,%eax
  18285f:	f7 e1                	mul    %ecx
  182861:	c1 ea 03             	shr    $0x3,%edx
	} else {
		int32_t ticks = _TICK_ALIGN + _ms_to_ticks(delay);
  182864:	42                   	inc    %edx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182865:	9c                   	pushf  
  182866:	fa                   	cli    
  182867:	5f                   	pop    %edi

static inline void _add_thread_timeout(struct k_thread *thread,
				       _wait_q_t *wait_q,
				       int32_t timeout_in_ticks)
{
	_add_timeout(thread, &thread->base.timeout, wait_q, timeout_in_ticks);
  182868:	8d 46 10             	lea    0x10(%esi),%eax
				_wait_q_t *wait_q,
				int32_t timeout_in_ticks)
{
	__ASSERT(timeout_in_ticks > 0, "");

	timeout->delta_ticks_from_prev = timeout_in_ticks;
  18286b:	89 50 10             	mov    %edx,0x10(%eax)
	timeout->thread = thread;
  18286e:	89 70 08             	mov    %esi,0x8(%eax)
	timeout->wait_q = (sys_dlist_t *)wait_q;
  182871:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182878:	8b 15 ec 02 28 00    	mov    0x2802ec,%edx
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  18287e:	81 fa ec 02 28 00    	cmp    $0x2802ec,%edx
  182884:	75 07                	jne    18288d <schedule_new_thread+0x4b>
  182886:	b9 00 00 00 00       	mov    $0x0,%ecx
  18288b:	eb 02                	jmp    18288f <schedule_new_thread+0x4d>
  18288d:	89 d1                	mov    %edx,%ecx
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  18288f:	85 c9                	test   %ecx,%ecx
  182891:	74 16                	je     1828a9 <schedule_new_thread+0x67>
  182893:	81 fa ec 02 28 00    	cmp    $0x2802ec,%edx
  182899:	0f 85 a0 00 00 00    	jne    18293f <schedule_new_thread+0xfd>
  18289f:	ba 00 00 00 00       	mov    $0x0,%edx
  1828a4:	e9 96 00 00 00       	jmp    18293f <schedule_new_thread+0xfd>
  1828a9:	ba 00 00 00 00       	mov    $0x0,%edx
  1828ae:	e9 8c 00 00 00       	jmp    18293f <schedule_new_thread+0xfd>
		if (*delta <= in_q->delta_ticks_from_prev) {
  1828b3:	8b 48 10             	mov    0x10(%eax),%ecx
  1828b6:	8b 5a 10             	mov    0x10(%edx),%ebx
  1828b9:	39 d9                	cmp    %ebx,%ecx
  1828bb:	7f 3b                	jg     1828f8 <schedule_new_thread+0xb6>
			in_q->delta_ticks_from_prev -= *delta;
  1828bd:	29 cb                	sub    %ecx,%ebx
  1828bf:	89 5a 10             	mov    %ebx,0x10(%edx)
 */

static inline void sys_dlist_insert_before(sys_dlist_t *list,
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
  1828c2:	85 d2                	test   %edx,%edx
  1828c4:	75 1f                	jne    1828e5 <schedule_new_thread+0xa3>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  1828c6:	c7 46 10 ec 02 28 00 	movl   $0x2802ec,0x10(%esi)
	node->prev = list->tail;
  1828cd:	8b 15 f0 02 28 00    	mov    0x2802f0,%edx
  1828d3:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  1828d6:	8b 15 f0 02 28 00    	mov    0x2802f0,%edx
  1828dc:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  1828de:	a3 f0 02 28 00       	mov    %eax,0x2802f0
  1828e3:	eb 7f                	jmp    182964 <schedule_new_thread+0x122>
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  1828e5:	8b 4a 04             	mov    0x4(%edx),%ecx
  1828e8:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
  1828eb:	89 56 10             	mov    %edx,0x10(%esi)
		insert_point->prev->next = node;
  1828ee:	8b 4a 04             	mov    0x4(%edx),%ecx
  1828f1:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
  1828f3:	89 42 04             	mov    %eax,0x4(%edx)
  1828f6:	eb 6c                	jmp    182964 <schedule_new_thread+0x122>
			sys_dlist_insert_before(&_timeout_q, &in_q->node,
						&timeout->node);
			goto inserted;
		}

		*delta -= in_q->delta_ticks_from_prev;
  1828f8:	29 d9                	sub    %ebx,%ecx
  1828fa:	89 48 10             	mov    %ecx,0x10(%eax)
	_dump_timeout_q();

	int32_t *delta = &timeout->delta_ticks_from_prev;
	struct _timeout *in_q;

	SYS_DLIST_FOR_EACH_CONTAINER(&_timeout_q, in_q, node) {
  1828fd:	89 d1                	mov    %edx,%ecx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  1828ff:	85 d2                	test   %edx,%edx
  182901:	74 0c                	je     18290f <schedule_new_thread+0xcd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182903:	3b 15 f0 02 28 00    	cmp    0x2802f0,%edx
  182909:	74 08                	je     182913 <schedule_new_thread+0xd1>
  18290b:	8b 1a                	mov    (%edx),%ebx
  18290d:	eb 09                	jmp    182918 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18290f:	89 d3                	mov    %edx,%ebx
  182911:	eb 05                	jmp    182918 <schedule_new_thread+0xd6>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182913:	bb 00 00 00 00       	mov    $0x0,%ebx
  182918:	85 db                	test   %ebx,%ebx
  18291a:	74 1e                	je     18293a <schedule_new_thread+0xf8>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18291c:	85 c9                	test   %ecx,%ecx
  18291e:	74 0c                	je     18292c <schedule_new_thread+0xea>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182920:	3b 0d f0 02 28 00    	cmp    0x2802f0,%ecx
  182926:	74 0b                	je     182933 <schedule_new_thread+0xf1>
  182928:	8b 12                	mov    (%edx),%edx
  18292a:	eb 13                	jmp    18293f <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  18292c:	ba 00 00 00 00       	mov    $0x0,%edx
  182931:	eb 0c                	jmp    18293f <schedule_new_thread+0xfd>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182933:	ba 00 00 00 00       	mov    $0x0,%edx
  182938:	eb 05                	jmp    18293f <schedule_new_thread+0xfd>
  18293a:	ba 00 00 00 00       	mov    $0x0,%edx
  18293f:	85 d2                	test   %edx,%edx
  182941:	0f 85 6c ff ff ff    	jne    1828b3 <schedule_new_thread+0x71>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  182947:	c7 46 10 ec 02 28 00 	movl   $0x2802ec,0x10(%esi)
	node->prev = list->tail;
  18294e:	8b 15 f0 02 28 00    	mov    0x2802f0,%edx
  182954:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  182957:	8b 15 f0 02 28 00    	mov    0x2802f0,%edx
  18295d:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  18295f:	a3 f0 02 28 00       	mov    %eax,0x2802f0
  182964:	f7 c7 00 02 00 00    	test   $0x200,%edi
  18296a:	74 01                	je     18296d <schedule_new_thread+0x12b>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  18296c:	fb                   	sti    
	}
#else
	ARG_UNUSED(delay);
	start_thread(thread);
#endif
}
  18296d:	5b                   	pop    %ebx
  18296e:	5e                   	pop    %esi
  18296f:	5f                   	pop    %edi
  182970:	c3                   	ret    

00182971 <k_is_in_isr>:
}
#endif

int k_is_in_isr(void)
{
	return _is_in_isr();
  182971:	83 3d e0 02 28 00 00 	cmpl   $0x0,0x2802e0
  182978:	0f 95 c0             	setne  %al
  18297b:	0f b6 c0             	movzbl %al,%eax
}
  18297e:	c3                   	ret    

0018297f <_is_thread_essential>:
 *
 * Returns non-zero if current thread is essential, zero if it is not.
 */
int _is_thread_essential(void)
{
	return _current->base.user_options & K_ESSENTIAL;
  18297f:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  182984:	8a 40 08             	mov    0x8(%eax),%al
  182987:	83 e0 01             	and    $0x1,%eax
}
  18298a:	c3                   	ret    

0018298b <_thread_monitor_exit>:
#if defined(CONFIG_THREAD_MONITOR)
/*
 * Remove a thread from the kernel's list of active threads.
 */
void _thread_monitor_exit(struct k_thread *thread)
{
  18298b:	53                   	push   %ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  18298c:	9c                   	pushf  
  18298d:	fa                   	cli    
  18298e:	5b                   	pop    %ebx
	unsigned int key = irq_lock();

	if (thread == _kernel.threads) {
  18298f:	8b 0d fc 03 28 00    	mov    0x2803fc,%ecx
  182995:	39 c1                	cmp    %eax,%ecx
  182997:	75 0c                	jne    1829a5 <_thread_monitor_exit+0x1a>
		_kernel.threads = _kernel.threads->next_thread;
  182999:	8b 41 38             	mov    0x38(%ecx),%eax
  18299c:	a3 fc 03 28 00       	mov    %eax,0x2803fc
  1829a1:	eb 0f                	jmp    1829b2 <_thread_monitor_exit+0x27>
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
			prev_thread = prev_thread->next_thread;
  1829a3:	89 d1                	mov    %edx,%ecx
		_kernel.threads = _kernel.threads->next_thread;
	} else {
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while (thread != prev_thread->next_thread) {
  1829a5:	8b 51 38             	mov    0x38(%ecx),%edx
  1829a8:	39 d0                	cmp    %edx,%eax
  1829aa:	75 f7                	jne    1829a3 <_thread_monitor_exit+0x18>
			prev_thread = prev_thread->next_thread;
		}
		prev_thread->next_thread = thread->next_thread;
  1829ac:	8b 40 38             	mov    0x38(%eax),%eax
  1829af:	89 41 38             	mov    %eax,0x38(%ecx)
  1829b2:	f6 c7 02             	test   $0x2,%bh
  1829b5:	74 01                	je     1829b8 <_thread_monitor_exit+0x2d>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  1829b7:	fb                   	sti    
	}

	irq_unlock(key);
}
  1829b8:	5b                   	pop    %ebx
  1829b9:	c3                   	ret    

001829ba <_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void _thread_entry(void (*entry)(void *, void *, void *),
				 void *p1, void *p2, void *p3)
{
  1829ba:	53                   	push   %ebx
  1829bb:	89 c3                	mov    %eax,%ebx
  1829bd:	89 d0                	mov    %edx,%eax
  1829bf:	89 ca                	mov    %ecx,%edx
	entry(p1, p2, p3);
  1829c1:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1829c5:	ff d3                	call   *%ebx

#ifdef CONFIG_MULTITHREADING
	if (_is_thread_essential()) {
  1829c7:	e8 b3 ff ff ff       	call   18297f <_is_thread_essential>
  1829cc:	85 c0                	test   %eax,%eax
  1829ce:	74 0f                	je     1829df <_thread_entry+0x25>
		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  1829d0:	ba 60 34 18 00       	mov    $0x183460,%edx
  1829d5:	b8 03 00 00 00       	mov    $0x3,%eax
  1829da:	e8 d1 f4 ff ff       	call   181eb0 <_NanoFatalErrorHandler>
				       &_default_esf);
	}

	k_thread_abort(_current);
  1829df:	a1 e8 02 28 00       	mov    0x2802e8,%eax
  1829e4:	e8 e0 01 00 00       	call   182bc9 <k_thread_abort>

001829e9 <_k_thread_group_op>:
{
	return !!(thread_data->init_groups & groups);
}

void _k_thread_group_op(uint32_t groups, void (*func)(struct k_thread *))
{
  1829e9:	55                   	push   %ebp
  1829ea:	57                   	push   %edi
  1829eb:	56                   	push   %esi
  1829ec:	53                   	push   %ebx
  1829ed:	89 c6                	mov    %eax,%esi
  1829ef:	89 d5                	mov    %edx,%ebp
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  1829f1:	8b 15 e8 02 28 00    	mov    0x2802e8,%edx
  1829f7:	8a 42 0b             	mov    0xb(%edx),%al
  1829fa:	48                   	dec    %eax
  1829fb:	88 42 0b             	mov    %al,0xb(%edx)

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  1829fe:	bb 98 00 28 00       	mov    $0x280098,%ebx
  182a03:	eb 18                	jmp    182a1d <_k_thread_group_op+0x34>
		if (is_in_any_group(thread_data, groups)) {
  182a05:	85 73 28             	test   %esi,0x28(%ebx)
  182a08:	74 10                	je     182a1a <_k_thread_group_op+0x31>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182a0a:	9c                   	pushf  
  182a0b:	fa                   	cli    
  182a0c:	5f                   	pop    %edi
			key = irq_lock();
			func(thread_data->thread);
  182a0d:	8b 03                	mov    (%ebx),%eax
  182a0f:	ff d5                	call   *%ebp
  182a11:	f7 c7 00 02 00 00    	test   $0x200,%edi
  182a17:	74 01                	je     182a1a <_k_thread_group_op+0x31>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182a19:	fb                   	sti    

	_sched_lock();

	/* Invoke func() on each static thread in the specified group set. */

	_FOREACH_STATIC_THREAD(thread_data) {
  182a1a:	83 c3 2c             	add    $0x2c,%ebx
  182a1d:	81 fb 98 00 28 00    	cmp    $0x280098,%ebx
  182a23:	72 e0                	jb     182a05 <_k_thread_group_op+0x1c>

	/*
	 * If the current thread is still in a ready state, then let the
	 * "unlock scheduler" code determine if any rescheduling is needed.
	 */
	if (_is_thread_ready(_current)) {
  182a25:	a1 e8 02 28 00       	mov    0x2802e8,%eax
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182a2a:	f6 40 09 1f          	testb  $0x1f,0x9(%eax)
  182a2e:	75 0d                	jne    182a3d <_k_thread_group_op+0x54>
  182a30:	83 78 20 ff          	cmpl   $0xffffffff,0x20(%eax)
  182a34:	75 0e                	jne    182a44 <_k_thread_group_op+0x5b>
  182a36:	b8 01 00 00 00       	mov    $0x1,%eax
  182a3b:	eb 0c                	jmp    182a49 <_k_thread_group_op+0x60>
  182a3d:	b8 00 00 00 00       	mov    $0x0,%eax
  182a42:	eb 05                	jmp    182a49 <_k_thread_group_op+0x60>
  182a44:	b8 00 00 00 00       	mov    $0x0,%eax
  182a49:	85 c0                	test   %eax,%eax
  182a4b:	74 07                	je     182a54 <_k_thread_group_op+0x6b>
		k_sched_unlock();
  182a4d:	e8 61 f9 ff ff       	call   1823b3 <k_sched_unlock>
		return;
  182a52:	eb 15                	jmp    182a69 <_k_thread_group_op+0x80>

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182a54:	9c                   	pushf  
  182a55:	fa                   	cli    
  182a56:	58                   	pop    %eax
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 0, "");

	compiler_barrier();

	++_current->base.sched_locked;
  182a57:	8b 0d e8 02 28 00    	mov    0x2802e8,%ecx
  182a5d:	8a 51 0b             	mov    0xb(%ecx),%dl
  182a60:	42                   	inc    %edx
  182a61:	88 51 0b             	mov    %dl,0xb(%ecx)
	}

	/* The current thread is no longer in a ready state--reschedule. */
	key = irq_lock();
	_sched_unlock_no_reschedule();
	_Swap(key);
  182a64:	e8 72 f3 ff ff       	call   181ddb <_Swap>
}
  182a69:	5b                   	pop    %ebx
  182a6a:	5e                   	pop    %esi
  182a6b:	5f                   	pop    %edi
  182a6c:	5d                   	pop    %ebp
  182a6d:	c3                   	ret    

00182a6e <_k_thread_single_abort>:

	_reschedule_threads(key);
}

void _k_thread_single_abort(struct k_thread *thread)
{
  182a6e:	56                   	push   %esi
  182a6f:	53                   	push   %ebx
  182a70:	89 c3                	mov    %eax,%ebx
	if (thread->fn_abort != NULL) {
  182a72:	8b 40 30             	mov    0x30(%eax),%eax
  182a75:	85 c0                	test   %eax,%eax
  182a77:	74 02                	je     182a7b <_k_thread_single_abort+0xd>
		thread->fn_abort();
  182a79:	ff d0                	call   *%eax
	return !(thread->base.thread_state & _THREAD_PRESTART);
}

static inline int _is_thread_prevented_from_running(struct k_thread *thread)
{
	uint8_t state = thread->base.thread_state;
  182a7b:	8a 43 09             	mov    0x9(%ebx),%al
}

/* check if a thread is ready */
static inline int _is_thread_ready(struct k_thread *thread)
{
	return !(_is_thread_prevented_from_running(thread) ||
  182a7e:	a8 1f                	test   $0x1f,%al
  182a80:	75 0d                	jne    182a8f <_k_thread_single_abort+0x21>
  182a82:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  182a86:	75 0e                	jne    182a96 <_k_thread_single_abort+0x28>
  182a88:	ba 01 00 00 00       	mov    $0x1,%edx
  182a8d:	eb 0c                	jmp    182a9b <_k_thread_single_abort+0x2d>
  182a8f:	ba 00 00 00 00       	mov    $0x0,%edx
  182a94:	eb 05                	jmp    182a9b <_k_thread_single_abort+0x2d>
  182a96:	ba 00 00 00 00       	mov    $0x0,%edx
	}

	if (_is_thread_ready(thread)) {
  182a9b:	85 d2                	test   %edx,%edx
  182a9d:	74 09                	je     182aa8 <_k_thread_single_abort+0x3a>
		_remove_thread_from_ready_q(thread);
  182a9f:	89 d8                	mov    %ebx,%eax
  182aa1:	e8 68 f8 ff ff       	call   18230e <_remove_thread_from_ready_q>
  182aa6:	eb 61                	jmp    182b09 <_k_thread_single_abort+0x9b>
	} else {
		if (_is_thread_pending(thread)) {
  182aa8:	a8 02                	test   $0x2,%al
  182aaa:	74 13                	je     182abf <_k_thread_single_abort+0x51>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182aac:	8b 43 04             	mov    0x4(%ebx),%eax
  182aaf:	8b 13                	mov    (%ebx),%edx
  182ab1:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  182ab3:	8b 03                	mov    (%ebx),%eax
  182ab5:	8b 53 04             	mov    0x4(%ebx),%edx
  182ab8:	89 50 04             	mov    %edx,0x4(%eax)
}

/* mark a thread as not pending in its TCS */
static inline void _mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
  182abb:	80 63 09 fd          	andb   $0xfd,0x9(%ebx)
			_unpend_thread(thread);
		}
		if (_is_thread_timeout_active(thread)) {
  182abf:	83 7b 20 ff          	cmpl   $0xffffffff,0x20(%ebx)
  182ac3:	74 44                	je     182b09 <_k_thread_single_abort+0x9b>
}

/* returns _INACTIVE if the timer has already expired */
static inline int _abort_thread_timeout(struct k_thread *thread)
{
	return _abort_timeout(&thread->base.timeout);
  182ac5:	8d 43 10             	lea    0x10(%ebx),%eax
}

/* returns _INACTIVE if the timer is not active */
static inline int _abort_timeout(struct _timeout *timeout)
{
	if (timeout->delta_ticks_from_prev == _INACTIVE) {
  182ac8:	8b 48 10             	mov    0x10(%eax),%ecx
  182acb:	83 f9 ff             	cmp    $0xffffffff,%ecx
  182ace:	74 39                	je     182b09 <_k_thread_single_abort+0x9b>
		return _INACTIVE;
	}

	if (!sys_dlist_is_tail(&_timeout_q, &timeout->node)) {
  182ad0:	89 c2                	mov    %eax,%edx
 * @return 1 if node is the tail, 0 otherwise
 */

static inline int sys_dlist_is_tail(sys_dlist_t *list, sys_dnode_t *node)
{
	return list->tail == node;
  182ad2:	8b 35 f0 02 28 00    	mov    0x2802f0,%esi
  182ad8:	39 f0                	cmp    %esi,%eax
  182ada:	74 15                	je     182af1 <_k_thread_single_abort+0x83>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node ? sys_dlist_peek_next_no_check(list, node) : NULL;
  182adc:	85 c0                	test   %eax,%eax
  182ade:	74 0e                	je     182aee <_k_thread_single_abort+0x80>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
  182ae0:	39 f0                	cmp    %esi,%eax
  182ae2:	74 05                	je     182ae9 <_k_thread_single_abort+0x7b>
  182ae4:	8b 53 10             	mov    0x10(%ebx),%edx
  182ae7:	eb 05                	jmp    182aee <_k_thread_single_abort+0x80>
  182ae9:	ba 00 00 00 00       	mov    $0x0,%edx
		sys_dnode_t *next_node =
			sys_dlist_peek_next(&_timeout_q, &timeout->node);
		struct _timeout *next = (struct _timeout *)next_node;

		next->delta_ticks_from_prev += timeout->delta_ticks_from_prev;
  182aee:	01 4a 10             	add    %ecx,0x10(%edx)
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  182af1:	8b 50 04             	mov    0x4(%eax),%edx
  182af4:	8b 4b 10             	mov    0x10(%ebx),%ecx
  182af7:	89 0a                	mov    %ecx,(%edx)
	node->next->prev = node->prev;
  182af9:	8b 53 10             	mov    0x10(%ebx),%edx
  182afc:	8b 48 04             	mov    0x4(%eax),%ecx
  182aff:	89 4a 04             	mov    %ecx,0x4(%edx)
	}
	sys_dlist_remove(&timeout->node);
	timeout->delta_ticks_from_prev = _INACTIVE;
  182b02:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)
 *
 * This routine must be called with interrupts locked.
 */
static inline void _mark_thread_as_dead(struct k_thread *thread)
{
	thread->base.thread_state |= _THREAD_DEAD;
  182b09:	80 4b 09 08          	orb    $0x8,0x9(%ebx)
			_abort_thread_timeout(thread);
		}
	}
	_mark_thread_as_dead(thread);
}
  182b0d:	5b                   	pop    %ebx
  182b0e:	5e                   	pop    %esi
  182b0f:	c3                   	ret    

00182b10 <_init_static_threads>:

#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
  182b10:	56                   	push   %esi
  182b11:	53                   	push   %ebx
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  182b12:	bb 98 00 28 00       	mov    $0x280098,%ebx
  182b17:	eb 27                	jmp    182b40 <_init_static_threads+0x30>
		_task_group_adjust(thread_data);
		_new_thread(
  182b19:	8b 4b 08             	mov    0x8(%ebx),%ecx
  182b1c:	8b 53 04             	mov    0x4(%ebx),%edx
  182b1f:	ff 73 1c             	pushl  0x1c(%ebx)
  182b22:	ff 73 18             	pushl  0x18(%ebx)
  182b25:	ff 73 14             	pushl  0x14(%ebx)
  182b28:	ff 73 10             	pushl  0x10(%ebx)
  182b2b:	ff 73 0c             	pushl  0xc(%ebx)
  182b2e:	8b 03                	mov    (%ebx),%eax
  182b30:	e8 35 f3 ff ff       	call   181e6a <_new_thread>
  182b35:	83 c4 14             	add    $0x14,%esp
			thread_data->init_p2,
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options);

		thread_data->thread->init_data = thread_data;
  182b38:	8b 03                	mov    (%ebx),%eax
  182b3a:	89 58 2c             	mov    %ebx,0x2c(%eax)
#ifdef CONFIG_MULTITHREADING
void _init_static_threads(void)
{
	unsigned int  key;

	_FOREACH_STATIC_THREAD(thread_data) {
  182b3d:	83 c3 2c             	add    $0x2c,%ebx
  182b40:	81 fb 98 00 28 00    	cmp    $0x280098,%ebx
  182b46:	72 d1                	jb     182b19 <_init_static_threads+0x9>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
  182b48:	8b 15 e8 02 28 00    	mov    0x2802e8,%edx
  182b4e:	8a 42 0b             	mov    0xb(%edx),%al
  182b51:	48                   	dec    %eax
  182b52:	88 42 0b             	mov    %al,0xb(%edx)
	}

	_sched_lock();
#if defined(CONFIG_LEGACY_KERNEL)
	/* Start all (legacy) threads that are part of the EXE task group */
	_k_thread_group_op(K_TASK_GROUP_EXE, _k_thread_single_start);
  182b55:	ba a3 27 18 00       	mov    $0x1827a3,%edx
  182b5a:	b8 01 00 00 00       	mov    $0x1,%eax
  182b5f:	e8 85 fe ff ff       	call   1829e9 <_k_thread_group_op>
  182b64:	9c                   	pushf  
  182b65:	fa                   	cli    
  182b66:	5e                   	pop    %esi
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  182b67:	bb 98 00 28 00       	mov    $0x280098,%ebx
  182b6c:	eb 12                	jmp    182b80 <_init_static_threads+0x70>
		if (thread_data->init_delay != K_FOREVER) {
  182b6e:	8b 53 20             	mov    0x20(%ebx),%edx
  182b71:	83 fa ff             	cmp    $0xffffffff,%edx
  182b74:	74 07                	je     182b7d <_init_static_threads+0x6d>
			schedule_new_thread(thread_data->thread,
  182b76:	8b 03                	mov    (%ebx),%eax
  182b78:	e8 c5 fc ff ff       	call   182842 <schedule_new_thread>
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	key = irq_lock();
	_FOREACH_STATIC_THREAD(thread_data) {
  182b7d:	83 c3 2c             	add    $0x2c,%ebx
  182b80:	81 fb 98 00 28 00    	cmp    $0x280098,%ebx
  182b86:	72 e6                	jb     182b6e <_init_static_threads+0x5e>
  182b88:	f7 c6 00 02 00 00    	test   $0x200,%esi
  182b8e:	74 01                	je     182b91 <_init_static_threads+0x81>
 * @return N/A
 */

static ALWAYS_INLINE void _do_irq_unlock(void)
{
	__asm__ volatile (
  182b90:	fb                   	sti    
			schedule_new_thread(thread_data->thread,
					    thread_data->init_delay);
		}
	}
	irq_unlock(key);
	k_sched_unlock();
  182b91:	e8 1d f8 ff ff       	call   1823b3 <k_sched_unlock>
}
  182b96:	5b                   	pop    %ebx
  182b97:	5e                   	pop    %esi
  182b98:	c3                   	ret    

00182b99 <_init_thread_base>:
#endif

void _init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
  182b99:	53                   	push   %ebx
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
  182b9a:	8a 5c 24 08          	mov    0x8(%esp),%bl
  182b9e:	88 58 08             	mov    %bl,0x8(%eax)
	thread_base->thread_state = (uint8_t)initial_state;
  182ba1:	88 48 09             	mov    %cl,0x9(%eax)

	thread_base->prio = priority;
  182ba4:	88 50 0a             	mov    %dl,0xa(%eax)

	thread_base->sched_locked = 0;
  182ba7:	c6 40 0b 00          	movb   $0x0,0xb(%eax)
	/*
	 * Must be initialized here and when dequeueing a timeout so that code
	 * not dealing with timeouts does not have to handle this, such as when
	 * waiting forever on a semaphore.
	 */
	t->delta_ticks_from_prev = _INACTIVE;
  182bab:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)

	/*
	 * Must be initialized here so that the _fiber_wakeup family of APIs can
	 * verify the fiber is not on a wait queue before aborting a timeout.
	 */
	t->wait_q = NULL;
  182bb2:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)

	/*
	 * Must be initialized here, so the _handle_one_timeout()
	 * routine can check if there is a fiber waiting on this timeout
	 */
	t->thread = NULL;
  182bb9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)

	/*
	 * Function must be initialized before being potentially called.
	 */
	t->func = func;
  182bc0:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)

	/* swap_data does not need to be initialized */

	_init_thread_timeout(thread_base);
}
  182bc7:	5b                   	pop    %ebx
  182bc8:	c3                   	ret    

00182bc9 <k_thread_abort>:

extern void _k_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void k_thread_abort(k_tid_t thread)
{
  182bc9:	56                   	push   %esi
  182bca:	53                   	push   %ebx
  182bcb:	89 c3                	mov    %eax,%ebx

static ALWAYS_INLINE unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  182bcd:	9c                   	pushf  
  182bce:	fa                   	cli    
  182bcf:	5e                   	pop    %esi
	unsigned int key;

	key = irq_lock();

	_k_thread_single_abort(thread);
  182bd0:	e8 99 fe ff ff       	call   182a6e <_k_thread_single_abort>
	_thread_monitor_exit(thread);
  182bd5:	89 d8                	mov    %ebx,%eax
  182bd7:	e8 af fd ff ff       	call   18298b <_thread_monitor_exit>

	if (_current == thread) {
  182bdc:	3b 1d e8 02 28 00    	cmp    0x2802e8,%ebx
  182be2:	75 07                	jne    182beb <k_thread_abort+0x22>
		_Swap(key);
  182be4:	89 f0                	mov    %esi,%eax
  182be6:	e8 f0 f1 ff ff       	call   181ddb <_Swap>
		CODE_UNREACHABLE;
	}

	/* The abort handler might have altered the ready queue. */
	_reschedule_threads(key);
  182beb:	89 f0                	mov    %esi,%eax
  182bed:	e8 88 f7 ff ff       	call   18237a <_reschedule_threads>
}
  182bf2:	5b                   	pop    %ebx
  182bf3:	5e                   	pop    %esi
  182bf4:	c3                   	ret    

00182bf5 <_sys_power_save_idle>:
	if (_sys_soc_suspend(ticks) == SYS_PM_NOT_HANDLED) {
		_sys_pm_idle_exit_notify = 0;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
  182bf5:	e8 90 f0 ff ff       	call   181c8a <k_cpu_idle>
  182bfa:	c3                   	ret    

00182bfb <idle>:
  182bfb:	9c                   	pushf  
  182bfc:	fa                   	cli    
  182bfd:	58                   	pop    %eax
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  182bfe:	a1 ec 02 28 00       	mov    0x2802ec,%eax
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  182c03:	3d ec 02 28 00       	cmp    $0x2802ec,%eax
  182c08:	75 05                	jne    182c0f <idle+0x14>
  182c0a:	b8 00 00 00 00       	mov    $0x0,%eax
static inline int32_t _get_next_timeout_expiry(void)
{
	struct _timeout *t = (struct _timeout *)
			     sys_dlist_peek_head(&_timeout_q);

	return t ? t->delta_ticks_from_prev : K_FOREVER;
  182c0f:	85 c0                	test   %eax,%eax
  182c11:	74 05                	je     182c18 <idle+0x1d>
  182c13:	8b 40 10             	mov    0x10(%eax),%eax
  182c16:	eb 05                	jmp    182c1d <idle+0x22>
  182c18:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	__idle_tsc = _tsc_read();
#endif

	for (;;) {
		(void)irq_lock();
		_sys_power_save_idle(_get_next_timeout_expiry());
  182c1d:	e8 d3 ff ff ff       	call   182bf5 <_sys_power_save_idle>

		IDLE_YIELD_IF_COOP();
	}
  182c22:	eb d7                	jmp    182bfb <idle>

00182c24 <_OffsetAbsSyms>:
/* tTaskStateSegment structure member offsets */


/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));
  182c24:	c3                   	ret    

00182c25 <_handle_exc_0_vector_0_stub>:
  182c25:	6a 00                	push   $0x0
  182c27:	68 04 20 18 00       	push   $0x182004
  182c2c:	e9 da f0 ff ff       	jmp    181d0b <_exception_enter>

00182c31 <_handle_exc_2_vector_2_stub>:
  182c31:	6a 00                	push   $0x0
  182c33:	68 10 20 18 00       	push   $0x182010
  182c38:	e9 ce f0 ff ff       	jmp    181d0b <_exception_enter>

00182c3d <_handle_exc_4_vector_4_stub>:
  182c3d:	6a 00                	push   $0x0
  182c3f:	68 1c 20 18 00       	push   $0x18201c
  182c44:	e9 c2 f0 ff ff       	jmp    181d0b <_exception_enter>

00182c49 <_handle_exc_5_vector_5_stub>:
  182c49:	6a 00                	push   $0x0
  182c4b:	68 28 20 18 00       	push   $0x182028
  182c50:	e9 b6 f0 ff ff       	jmp    181d0b <_exception_enter>

00182c55 <_handle_exc_6_vector_6_stub>:
  182c55:	6a 00                	push   $0x0
  182c57:	68 34 20 18 00       	push   $0x182034
  182c5c:	e9 aa f0 ff ff       	jmp    181d0b <_exception_enter>

00182c61 <_handle_exc_7_vector_7_stub>:
  182c61:	6a 00                	push   $0x0
  182c63:	68 40 20 18 00       	push   $0x182040
  182c68:	e9 9e f0 ff ff       	jmp    181d0b <_exception_enter>

00182c6d <_handle_exc_8_vector_8_stub>:
  182c6d:	68 4c 20 18 00       	push   $0x18204c
  182c72:	e9 94 f0 ff ff       	jmp    181d0b <_exception_enter>

00182c77 <_handle_exc_10_vector_10_stub>:
  182c77:	68 58 20 18 00       	push   $0x182058
  182c7c:	e9 8a f0 ff ff       	jmp    181d0b <_exception_enter>

00182c81 <_handle_exc_11_vector_11_stub>:
  182c81:	68 64 20 18 00       	push   $0x182064
  182c86:	e9 80 f0 ff ff       	jmp    181d0b <_exception_enter>

00182c8b <_handle_exc_12_vector_12_stub>:
  182c8b:	68 70 20 18 00       	push   $0x182070
  182c90:	e9 76 f0 ff ff       	jmp    181d0b <_exception_enter>

00182c95 <_handle_exc_13_vector_13_stub>:
  182c95:	68 7c 20 18 00       	push   $0x18207c
  182c9a:	e9 6c f0 ff ff       	jmp    181d0b <_exception_enter>

00182c9f <_handle_exc_14_vector_14_stub>:
  182c9f:	68 88 20 18 00       	push   $0x182088
  182ca4:	e9 62 f0 ff ff       	jmp    181d0b <_exception_enter>

00182ca9 <_handle_exc_16_vector_16_stub>:
  182ca9:	6a 00                	push   $0x0
  182cab:	68 94 20 18 00       	push   $0x182094
  182cb0:	e9 56 f0 ff ff       	jmp    181d0b <_exception_enter>

00182cb5 <_handle_exc_17_vector_17_stub>:
  182cb5:	68 a0 20 18 00       	push   $0x1820a0
  182cba:	e9 4c f0 ff ff       	jmp    181d0b <_exception_enter>

00182cbf <_handle_exc_18_vector_18_stub>:
  182cbf:	6a 00                	push   $0x0
  182cc1:	68 ac 20 18 00       	push   $0x1820ac
  182cc6:	e9 40 f0 ff ff       	jmp    181d0b <_exception_enter>
